
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Service
 * 
 */
export type Service = $Result.DefaultSelection<Prisma.$ServicePayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Customer
 * 
 */
export type Customer = $Result.DefaultSelection<Prisma.$CustomerPayload>
/**
 * Model CustomerAddress
 * 
 */
export type CustomerAddress = $Result.DefaultSelection<Prisma.$CustomerAddressPayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model ProductPrice
 * 
 */
export type ProductPrice = $Result.DefaultSelection<Prisma.$ProductPricePayload>
/**
 * Model Quote
 * 
 */
export type Quote = $Result.DefaultSelection<Prisma.$QuotePayload>
/**
 * Model QuoteItem
 * 
 */
export type QuoteItem = $Result.DefaultSelection<Prisma.$QuoteItemPayload>
/**
 * Model QuoteApproval
 * 
 */
export type QuoteApproval = $Result.DefaultSelection<Prisma.$QuoteApprovalPayload>
/**
 * Model Invoice
 * 
 */
export type Invoice = $Result.DefaultSelection<Prisma.$InvoicePayload>
/**
 * Model InvoiceItem
 * 
 */
export type InvoiceItem = $Result.DefaultSelection<Prisma.$InvoiceItemPayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model PaymentAllocation
 * 
 */
export type PaymentAllocation = $Result.DefaultSelection<Prisma.$PaymentAllocationPayload>
/**
 * Model RecurringInvoice
 * 
 */
export type RecurringInvoice = $Result.DefaultSelection<Prisma.$RecurringInvoicePayload>
/**
 * Model RecurringInvoiceItem
 * 
 */
export type RecurringInvoiceItem = $Result.DefaultSelection<Prisma.$RecurringInvoiceItemPayload>
/**
 * Model Reminder
 * 
 */
export type Reminder = $Result.DefaultSelection<Prisma.$ReminderPayload>
/**
 * Model Document
 * 
 */
export type Document = $Result.DefaultSelection<Prisma.$DocumentPayload>
/**
 * Model Expense
 * 
 */
export type Expense = $Result.DefaultSelection<Prisma.$ExpensePayload>
/**
 * Model Supplier
 * 
 */
export type Supplier = $Result.DefaultSelection<Prisma.$SupplierPayload>
/**
 * Model AccountingEntry
 * 
 */
export type AccountingEntry = $Result.DefaultSelection<Prisma.$AccountingEntryPayload>
/**
 * Model CashFlow
 * 
 */
export type CashFlow = $Result.DefaultSelection<Prisma.$CashFlowPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model Employee
 * 
 */
export type Employee = $Result.DefaultSelection<Prisma.$EmployeePayload>
/**
 * Model Contract
 * 
 */
export type Contract = $Result.DefaultSelection<Prisma.$ContractPayload>
/**
 * Model Salary
 * 
 */
export type Salary = $Result.DefaultSelection<Prisma.$SalaryPayload>
/**
 * Model LoanPayment
 * 
 */
export type LoanPayment = $Result.DefaultSelection<Prisma.$LoanPaymentPayload>
/**
 * Model LeaveRequest
 * 
 */
export type LeaveRequest = $Result.DefaultSelection<Prisma.$LeaveRequestPayload>
/**
 * Model Prospect
 * 
 */
export type Prospect = $Result.DefaultSelection<Prisma.$ProspectPayload>
/**
 * Model ProspectActivity
 * 
 */
export type ProspectActivity = $Result.DefaultSelection<Prisma.$ProspectActivityPayload>
/**
 * Model Loan
 * 
 */
export type Loan = $Result.DefaultSelection<Prisma.$LoanPayload>
/**
 * Model Specialite
 * 
 */
export type Specialite = $Result.DefaultSelection<Prisma.$SpecialitePayload>
/**
 * Model Technicien
 * 
 */
export type Technicien = $Result.DefaultSelection<Prisma.$TechnicienPayload>
/**
 * Model Mission
 * 
 */
export type Mission = $Result.DefaultSelection<Prisma.$MissionPayload>
/**
 * Model Intervention
 * 
 */
export type Intervention = $Result.DefaultSelection<Prisma.$InterventionPayload>
/**
 * Model TechnicienIntervention
 * 
 */
export type TechnicienIntervention = $Result.DefaultSelection<Prisma.$TechnicienInterventionPayload>
/**
 * Model RapportMission
 * 
 */
export type RapportMission = $Result.DefaultSelection<Prisma.$RapportMissionPayload>
/**
 * Model RapportImage
 * 
 */
export type RapportImage = $Result.DefaultSelection<Prisma.$RapportImagePayload>
/**
 * Model Materiel
 * 
 */
export type Materiel = $Result.DefaultSelection<Prisma.$MaterielPayload>
/**
 * Model SortieMateriel
 * 
 */
export type SortieMateriel = $Result.DefaultSelection<Prisma.$SortieMaterielPayload>
/**
 * Model EntreeMateriel
 * 
 */
export type EntreeMateriel = $Result.DefaultSelection<Prisma.$EntreeMaterielPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  ADMIN: 'ADMIN',
  GENERAL_DIRECTOR: 'GENERAL_DIRECTOR',
  SERVICE_MANAGER: 'SERVICE_MANAGER',
  EMPLOYEE: 'EMPLOYEE',
  ACCOUNTANT: 'ACCOUNTANT'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const CustomerType: {
  INDIVIDUAL: 'INDIVIDUAL',
  COMPANY: 'COMPANY'
};

export type CustomerType = (typeof CustomerType)[keyof typeof CustomerType]


export const PaymentMethod: {
  TRANSFER: 'TRANSFER',
  CHECK: 'CHECK',
  CARD: 'CARD',
  CASH: 'CASH',
  OTHER: 'OTHER'
};

export type PaymentMethod = (typeof PaymentMethod)[keyof typeof PaymentMethod]


export const AddressType: {
  BILLING: 'BILLING',
  SHIPPING: 'SHIPPING',
  OTHER: 'OTHER'
};

export type AddressType = (typeof AddressType)[keyof typeof AddressType]


export const ProductType: {
  PRODUCT: 'PRODUCT',
  SERVICE: 'SERVICE',
  SUBSCRIPTION: 'SUBSCRIPTION'
};

export type ProductType = (typeof ProductType)[keyof typeof ProductType]


export const QuoteStatus: {
  DRAFT: 'DRAFT',
  SUBMITTED_FOR_SERVICE_APPROVAL: 'SUBMITTED_FOR_SERVICE_APPROVAL',
  APPROVED_BY_SERVICE_MANAGER: 'APPROVED_BY_SERVICE_MANAGER',
  REJECTED_BY_SERVICE_MANAGER: 'REJECTED_BY_SERVICE_MANAGER',
  SUBMITTED_FOR_DG_APPROVAL: 'SUBMITTED_FOR_DG_APPROVAL',
  APPROVED_BY_DG: 'APPROVED_BY_DG',
  REJECTED_BY_DG: 'REJECTED_BY_DG',
  ACCEPTED_BY_CLIENT: 'ACCEPTED_BY_CLIENT',
  REJECTED_BY_CLIENT: 'REJECTED_BY_CLIENT',
  EXPIRED: 'EXPIRED'
};

export type QuoteStatus = (typeof QuoteStatus)[keyof typeof QuoteStatus]


export const ApprovalLevel: {
  SERVICE_MANAGER: 'SERVICE_MANAGER',
  GENERAL_DIRECTOR: 'GENERAL_DIRECTOR'
};

export type ApprovalLevel = (typeof ApprovalLevel)[keyof typeof ApprovalLevel]


export const ApprovalStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED'
};

export type ApprovalStatus = (typeof ApprovalStatus)[keyof typeof ApprovalStatus]


export const InvoiceType: {
  INVOICE: 'INVOICE',
  CREDIT_NOTE: 'CREDIT_NOTE',
  PROFORMA: 'PROFORMA'
};

export type InvoiceType = (typeof InvoiceType)[keyof typeof InvoiceType]


export const InvoiceStatus: {
  DRAFT: 'DRAFT',
  SENT: 'SENT',
  PAID: 'PAID',
  PARTIAL: 'PARTIAL',
  OVERDUE: 'OVERDUE',
  CANCELLED: 'CANCELLED'
};

export type InvoiceStatus = (typeof InvoiceStatus)[keyof typeof InvoiceStatus]


export const RecurringFrequency: {
  MONTHLY: 'MONTHLY',
  QUARTERLY: 'QUARTERLY',
  YEARLY: 'YEARLY'
};

export type RecurringFrequency = (typeof RecurringFrequency)[keyof typeof RecurringFrequency]


export const ReminderType: {
  FRIENDLY: 'FRIENDLY',
  FORMAL: 'FORMAL',
  FINAL: 'FINAL',
  LEGAL: 'LEGAL'
};

export type ReminderType = (typeof ReminderType)[keyof typeof ReminderType]


export const ReminderStatus: {
  SENT: 'SENT',
  READ: 'READ',
  PAID: 'PAID',
  IGNORED: 'IGNORED'
};

export type ReminderStatus = (typeof ReminderStatus)[keyof typeof ReminderStatus]


export const DocumentType: {
  QUOTE: 'QUOTE',
  INVOICE: 'INVOICE',
  CREDIT_NOTE: 'CREDIT_NOTE',
  REMinder: 'REMinder',
  REPORT: 'REPORT'
};

export type DocumentType = (typeof DocumentType)[keyof typeof DocumentType]


export const ExpenseStatus: {
  PENDING: 'PENDING',
  PAID: 'PAID',
  REIMBURSED: 'REIMBURSED'
};

export type ExpenseStatus = (typeof ExpenseStatus)[keyof typeof ExpenseStatus]


export const SourceDocumentType: {
  INVOICE: 'INVOICE',
  QUOTE: 'QUOTE',
  PAYMENT: 'PAYMENT',
  EXPENSE: 'EXPENSE',
  SALARY: 'SALARY',
  OTHER: 'OTHER'
};

export type SourceDocumentType = (typeof SourceDocumentType)[keyof typeof SourceDocumentType]


export const CashFlowType: {
  INFLOW: 'INFLOW',
  OUTFLOW: 'OUTFLOW'
};

export type CashFlowType = (typeof CashFlowType)[keyof typeof CashFlowType]


export const ContractType: {
  CDI: 'CDI',
  CDD: 'CDD',
  STAGE: 'STAGE',
  FREELANCE: 'FREELANCE'
};

export type ContractType = (typeof ContractType)[keyof typeof ContractType]


export const SalaryStatus: {
  PENDING: 'PENDING',
  PAID: 'PAID'
};

export type SalaryStatus = (typeof SalaryStatus)[keyof typeof SalaryStatus]


export const LeaveType: {
  ANNUAL: 'ANNUAL',
  SICK: 'SICK',
  PERSONAL: 'PERSONAL',
  MATERNITY: 'MATERNITY',
  PATERNITY: 'PATERNITY',
  OTHER: 'OTHER'
};

export type LeaveType = (typeof LeaveType)[keyof typeof LeaveType]


export const LeaveStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED'
};

export type LeaveStatus = (typeof LeaveStatus)[keyof typeof LeaveStatus]


export const LoanStatus: {
  ACTIVE: 'ACTIVE',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type LoanStatus = (typeof LoanStatus)[keyof typeof LoanStatus]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type CustomerType = $Enums.CustomerType

export const CustomerType: typeof $Enums.CustomerType

export type PaymentMethod = $Enums.PaymentMethod

export const PaymentMethod: typeof $Enums.PaymentMethod

export type AddressType = $Enums.AddressType

export const AddressType: typeof $Enums.AddressType

export type ProductType = $Enums.ProductType

export const ProductType: typeof $Enums.ProductType

export type QuoteStatus = $Enums.QuoteStatus

export const QuoteStatus: typeof $Enums.QuoteStatus

export type ApprovalLevel = $Enums.ApprovalLevel

export const ApprovalLevel: typeof $Enums.ApprovalLevel

export type ApprovalStatus = $Enums.ApprovalStatus

export const ApprovalStatus: typeof $Enums.ApprovalStatus

export type InvoiceType = $Enums.InvoiceType

export const InvoiceType: typeof $Enums.InvoiceType

export type InvoiceStatus = $Enums.InvoiceStatus

export const InvoiceStatus: typeof $Enums.InvoiceStatus

export type RecurringFrequency = $Enums.RecurringFrequency

export const RecurringFrequency: typeof $Enums.RecurringFrequency

export type ReminderType = $Enums.ReminderType

export const ReminderType: typeof $Enums.ReminderType

export type ReminderStatus = $Enums.ReminderStatus

export const ReminderStatus: typeof $Enums.ReminderStatus

export type DocumentType = $Enums.DocumentType

export const DocumentType: typeof $Enums.DocumentType

export type ExpenseStatus = $Enums.ExpenseStatus

export const ExpenseStatus: typeof $Enums.ExpenseStatus

export type SourceDocumentType = $Enums.SourceDocumentType

export const SourceDocumentType: typeof $Enums.SourceDocumentType

export type CashFlowType = $Enums.CashFlowType

export const CashFlowType: typeof $Enums.CashFlowType

export type ContractType = $Enums.ContractType

export const ContractType: typeof $Enums.ContractType

export type SalaryStatus = $Enums.SalaryStatus

export const SalaryStatus: typeof $Enums.SalaryStatus

export type LeaveType = $Enums.LeaveType

export const LeaveType: typeof $Enums.LeaveType

export type LeaveStatus = $Enums.LeaveStatus

export const LeaveStatus: typeof $Enums.LeaveStatus

export type LoanStatus = $Enums.LoanStatus

export const LoanStatus: typeof $Enums.LoanStatus

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Services
 * const services = await prisma.service.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Services
   * const services = await prisma.service.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.service`: Exposes CRUD operations for the **Service** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Services
    * const services = await prisma.service.findMany()
    * ```
    */
  get service(): Prisma.ServiceDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.customer`: Exposes CRUD operations for the **Customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.CustomerDelegate<ExtArgs>;

  /**
   * `prisma.customerAddress`: Exposes CRUD operations for the **CustomerAddress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomerAddresses
    * const customerAddresses = await prisma.customerAddress.findMany()
    * ```
    */
  get customerAddress(): Prisma.CustomerAddressDelegate<ExtArgs>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs>;

  /**
   * `prisma.productPrice`: Exposes CRUD operations for the **ProductPrice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductPrices
    * const productPrices = await prisma.productPrice.findMany()
    * ```
    */
  get productPrice(): Prisma.ProductPriceDelegate<ExtArgs>;

  /**
   * `prisma.quote`: Exposes CRUD operations for the **Quote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Quotes
    * const quotes = await prisma.quote.findMany()
    * ```
    */
  get quote(): Prisma.QuoteDelegate<ExtArgs>;

  /**
   * `prisma.quoteItem`: Exposes CRUD operations for the **QuoteItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuoteItems
    * const quoteItems = await prisma.quoteItem.findMany()
    * ```
    */
  get quoteItem(): Prisma.QuoteItemDelegate<ExtArgs>;

  /**
   * `prisma.quoteApproval`: Exposes CRUD operations for the **QuoteApproval** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuoteApprovals
    * const quoteApprovals = await prisma.quoteApproval.findMany()
    * ```
    */
  get quoteApproval(): Prisma.QuoteApprovalDelegate<ExtArgs>;

  /**
   * `prisma.invoice`: Exposes CRUD operations for the **Invoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoice.findMany()
    * ```
    */
  get invoice(): Prisma.InvoiceDelegate<ExtArgs>;

  /**
   * `prisma.invoiceItem`: Exposes CRUD operations for the **InvoiceItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvoiceItems
    * const invoiceItems = await prisma.invoiceItem.findMany()
    * ```
    */
  get invoiceItem(): Prisma.InvoiceItemDelegate<ExtArgs>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs>;

  /**
   * `prisma.paymentAllocation`: Exposes CRUD operations for the **PaymentAllocation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentAllocations
    * const paymentAllocations = await prisma.paymentAllocation.findMany()
    * ```
    */
  get paymentAllocation(): Prisma.PaymentAllocationDelegate<ExtArgs>;

  /**
   * `prisma.recurringInvoice`: Exposes CRUD operations for the **RecurringInvoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RecurringInvoices
    * const recurringInvoices = await prisma.recurringInvoice.findMany()
    * ```
    */
  get recurringInvoice(): Prisma.RecurringInvoiceDelegate<ExtArgs>;

  /**
   * `prisma.recurringInvoiceItem`: Exposes CRUD operations for the **RecurringInvoiceItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RecurringInvoiceItems
    * const recurringInvoiceItems = await prisma.recurringInvoiceItem.findMany()
    * ```
    */
  get recurringInvoiceItem(): Prisma.RecurringInvoiceItemDelegate<ExtArgs>;

  /**
   * `prisma.reminder`: Exposes CRUD operations for the **Reminder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reminders
    * const reminders = await prisma.reminder.findMany()
    * ```
    */
  get reminder(): Prisma.ReminderDelegate<ExtArgs>;

  /**
   * `prisma.document`: Exposes CRUD operations for the **Document** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Documents
    * const documents = await prisma.document.findMany()
    * ```
    */
  get document(): Prisma.DocumentDelegate<ExtArgs>;

  /**
   * `prisma.expense`: Exposes CRUD operations for the **Expense** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Expenses
    * const expenses = await prisma.expense.findMany()
    * ```
    */
  get expense(): Prisma.ExpenseDelegate<ExtArgs>;

  /**
   * `prisma.supplier`: Exposes CRUD operations for the **Supplier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Suppliers
    * const suppliers = await prisma.supplier.findMany()
    * ```
    */
  get supplier(): Prisma.SupplierDelegate<ExtArgs>;

  /**
   * `prisma.accountingEntry`: Exposes CRUD operations for the **AccountingEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AccountingEntries
    * const accountingEntries = await prisma.accountingEntry.findMany()
    * ```
    */
  get accountingEntry(): Prisma.AccountingEntryDelegate<ExtArgs>;

  /**
   * `prisma.cashFlow`: Exposes CRUD operations for the **CashFlow** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CashFlows
    * const cashFlows = await prisma.cashFlow.findMany()
    * ```
    */
  get cashFlow(): Prisma.CashFlowDelegate<ExtArgs>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs>;

  /**
   * `prisma.employee`: Exposes CRUD operations for the **Employee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Employees
    * const employees = await prisma.employee.findMany()
    * ```
    */
  get employee(): Prisma.EmployeeDelegate<ExtArgs>;

  /**
   * `prisma.contract`: Exposes CRUD operations for the **Contract** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contracts
    * const contracts = await prisma.contract.findMany()
    * ```
    */
  get contract(): Prisma.ContractDelegate<ExtArgs>;

  /**
   * `prisma.salary`: Exposes CRUD operations for the **Salary** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Salaries
    * const salaries = await prisma.salary.findMany()
    * ```
    */
  get salary(): Prisma.SalaryDelegate<ExtArgs>;

  /**
   * `prisma.loanPayment`: Exposes CRUD operations for the **LoanPayment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LoanPayments
    * const loanPayments = await prisma.loanPayment.findMany()
    * ```
    */
  get loanPayment(): Prisma.LoanPaymentDelegate<ExtArgs>;

  /**
   * `prisma.leaveRequest`: Exposes CRUD operations for the **LeaveRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LeaveRequests
    * const leaveRequests = await prisma.leaveRequest.findMany()
    * ```
    */
  get leaveRequest(): Prisma.LeaveRequestDelegate<ExtArgs>;

  /**
   * `prisma.prospect`: Exposes CRUD operations for the **Prospect** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Prospects
    * const prospects = await prisma.prospect.findMany()
    * ```
    */
  get prospect(): Prisma.ProspectDelegate<ExtArgs>;

  /**
   * `prisma.prospectActivity`: Exposes CRUD operations for the **ProspectActivity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProspectActivities
    * const prospectActivities = await prisma.prospectActivity.findMany()
    * ```
    */
  get prospectActivity(): Prisma.ProspectActivityDelegate<ExtArgs>;

  /**
   * `prisma.loan`: Exposes CRUD operations for the **Loan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Loans
    * const loans = await prisma.loan.findMany()
    * ```
    */
  get loan(): Prisma.LoanDelegate<ExtArgs>;

  /**
   * `prisma.specialite`: Exposes CRUD operations for the **Specialite** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Specialites
    * const specialites = await prisma.specialite.findMany()
    * ```
    */
  get specialite(): Prisma.SpecialiteDelegate<ExtArgs>;

  /**
   * `prisma.technicien`: Exposes CRUD operations for the **Technicien** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Techniciens
    * const techniciens = await prisma.technicien.findMany()
    * ```
    */
  get technicien(): Prisma.TechnicienDelegate<ExtArgs>;

  /**
   * `prisma.mission`: Exposes CRUD operations for the **Mission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Missions
    * const missions = await prisma.mission.findMany()
    * ```
    */
  get mission(): Prisma.MissionDelegate<ExtArgs>;

  /**
   * `prisma.intervention`: Exposes CRUD operations for the **Intervention** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Interventions
    * const interventions = await prisma.intervention.findMany()
    * ```
    */
  get intervention(): Prisma.InterventionDelegate<ExtArgs>;

  /**
   * `prisma.technicienIntervention`: Exposes CRUD operations for the **TechnicienIntervention** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TechnicienInterventions
    * const technicienInterventions = await prisma.technicienIntervention.findMany()
    * ```
    */
  get technicienIntervention(): Prisma.TechnicienInterventionDelegate<ExtArgs>;

  /**
   * `prisma.rapportMission`: Exposes CRUD operations for the **RapportMission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RapportMissions
    * const rapportMissions = await prisma.rapportMission.findMany()
    * ```
    */
  get rapportMission(): Prisma.RapportMissionDelegate<ExtArgs>;

  /**
   * `prisma.rapportImage`: Exposes CRUD operations for the **RapportImage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RapportImages
    * const rapportImages = await prisma.rapportImage.findMany()
    * ```
    */
  get rapportImage(): Prisma.RapportImageDelegate<ExtArgs>;

  /**
   * `prisma.materiel`: Exposes CRUD operations for the **Materiel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Materiels
    * const materiels = await prisma.materiel.findMany()
    * ```
    */
  get materiel(): Prisma.MaterielDelegate<ExtArgs>;

  /**
   * `prisma.sortieMateriel`: Exposes CRUD operations for the **SortieMateriel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SortieMateriels
    * const sortieMateriels = await prisma.sortieMateriel.findMany()
    * ```
    */
  get sortieMateriel(): Prisma.SortieMaterielDelegate<ExtArgs>;

  /**
   * `prisma.entreeMateriel`: Exposes CRUD operations for the **EntreeMateriel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EntreeMateriels
    * const entreeMateriels = await prisma.entreeMateriel.findMany()
    * ```
    */
  get entreeMateriel(): Prisma.EntreeMaterielDelegate<ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Service: 'Service',
    User: 'User',
    Customer: 'Customer',
    CustomerAddress: 'CustomerAddress',
    Product: 'Product',
    ProductPrice: 'ProductPrice',
    Quote: 'Quote',
    QuoteItem: 'QuoteItem',
    QuoteApproval: 'QuoteApproval',
    Invoice: 'Invoice',
    InvoiceItem: 'InvoiceItem',
    Payment: 'Payment',
    PaymentAllocation: 'PaymentAllocation',
    RecurringInvoice: 'RecurringInvoice',
    RecurringInvoiceItem: 'RecurringInvoiceItem',
    Reminder: 'Reminder',
    Document: 'Document',
    Expense: 'Expense',
    Supplier: 'Supplier',
    AccountingEntry: 'AccountingEntry',
    CashFlow: 'CashFlow',
    AuditLog: 'AuditLog',
    Employee: 'Employee',
    Contract: 'Contract',
    Salary: 'Salary',
    LoanPayment: 'LoanPayment',
    LeaveRequest: 'LeaveRequest',
    Prospect: 'Prospect',
    ProspectActivity: 'ProspectActivity',
    Loan: 'Loan',
    Specialite: 'Specialite',
    Technicien: 'Technicien',
    Mission: 'Mission',
    Intervention: 'Intervention',
    TechnicienIntervention: 'TechnicienIntervention',
    RapportMission: 'RapportMission',
    RapportImage: 'RapportImage',
    Materiel: 'Materiel',
    SortieMateriel: 'SortieMateriel',
    EntreeMateriel: 'EntreeMateriel',
    Notification: 'Notification'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "service" | "user" | "customer" | "customerAddress" | "product" | "productPrice" | "quote" | "quoteItem" | "quoteApproval" | "invoice" | "invoiceItem" | "payment" | "paymentAllocation" | "recurringInvoice" | "recurringInvoiceItem" | "reminder" | "document" | "expense" | "supplier" | "accountingEntry" | "cashFlow" | "auditLog" | "employee" | "contract" | "salary" | "loanPayment" | "leaveRequest" | "prospect" | "prospectActivity" | "loan" | "specialite" | "technicien" | "mission" | "intervention" | "technicienIntervention" | "rapportMission" | "rapportImage" | "materiel" | "sortieMateriel" | "entreeMateriel" | "notification"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Service: {
        payload: Prisma.$ServicePayload<ExtArgs>
        fields: Prisma.ServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findFirst: {
            args: Prisma.ServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findMany: {
            args: Prisma.ServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          create: {
            args: Prisma.ServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          createMany: {
            args: Prisma.ServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          delete: {
            args: Prisma.ServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          update: {
            args: Prisma.ServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          deleteMany: {
            args: Prisma.ServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          aggregate: {
            args: Prisma.ServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateService>
          }
          groupBy: {
            args: Prisma.ServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Customer: {
        payload: Prisma.$CustomerPayload<ExtArgs>
        fields: Prisma.CustomerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findFirst: {
            args: Prisma.CustomerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findMany: {
            args: Prisma.CustomerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          create: {
            args: Prisma.CustomerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          createMany: {
            args: Prisma.CustomerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          delete: {
            args: Prisma.CustomerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          update: {
            args: Prisma.CustomerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          deleteMany: {
            args: Prisma.CustomerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CustomerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          aggregate: {
            args: Prisma.CustomerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomer>
          }
          groupBy: {
            args: Prisma.CustomerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerCountAggregateOutputType> | number
          }
        }
      }
      CustomerAddress: {
        payload: Prisma.$CustomerAddressPayload<ExtArgs>
        fields: Prisma.CustomerAddressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerAddressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerAddressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerAddressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerAddressPayload>
          }
          findFirst: {
            args: Prisma.CustomerAddressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerAddressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerAddressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerAddressPayload>
          }
          findMany: {
            args: Prisma.CustomerAddressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerAddressPayload>[]
          }
          create: {
            args: Prisma.CustomerAddressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerAddressPayload>
          }
          createMany: {
            args: Prisma.CustomerAddressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerAddressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerAddressPayload>[]
          }
          delete: {
            args: Prisma.CustomerAddressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerAddressPayload>
          }
          update: {
            args: Prisma.CustomerAddressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerAddressPayload>
          }
          deleteMany: {
            args: Prisma.CustomerAddressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerAddressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CustomerAddressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerAddressPayload>
          }
          aggregate: {
            args: Prisma.CustomerAddressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomerAddress>
          }
          groupBy: {
            args: Prisma.CustomerAddressGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerAddressGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerAddressCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerAddressCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      ProductPrice: {
        payload: Prisma.$ProductPricePayload<ExtArgs>
        fields: Prisma.ProductPriceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductPriceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPricePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductPriceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPricePayload>
          }
          findFirst: {
            args: Prisma.ProductPriceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPricePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductPriceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPricePayload>
          }
          findMany: {
            args: Prisma.ProductPriceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPricePayload>[]
          }
          create: {
            args: Prisma.ProductPriceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPricePayload>
          }
          createMany: {
            args: Prisma.ProductPriceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductPriceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPricePayload>[]
          }
          delete: {
            args: Prisma.ProductPriceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPricePayload>
          }
          update: {
            args: Prisma.ProductPriceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPricePayload>
          }
          deleteMany: {
            args: Prisma.ProductPriceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductPriceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductPriceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPricePayload>
          }
          aggregate: {
            args: Prisma.ProductPriceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductPrice>
          }
          groupBy: {
            args: Prisma.ProductPriceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductPriceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductPriceCountArgs<ExtArgs>
            result: $Utils.Optional<ProductPriceCountAggregateOutputType> | number
          }
        }
      }
      Quote: {
        payload: Prisma.$QuotePayload<ExtArgs>
        fields: Prisma.QuoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload>
          }
          findFirst: {
            args: Prisma.QuoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload>
          }
          findMany: {
            args: Prisma.QuoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload>[]
          }
          create: {
            args: Prisma.QuoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload>
          }
          createMany: {
            args: Prisma.QuoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuoteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload>[]
          }
          delete: {
            args: Prisma.QuoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload>
          }
          update: {
            args: Prisma.QuoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload>
          }
          deleteMany: {
            args: Prisma.QuoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.QuoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload>
          }
          aggregate: {
            args: Prisma.QuoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuote>
          }
          groupBy: {
            args: Prisma.QuoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuoteCountArgs<ExtArgs>
            result: $Utils.Optional<QuoteCountAggregateOutputType> | number
          }
        }
      }
      QuoteItem: {
        payload: Prisma.$QuoteItemPayload<ExtArgs>
        fields: Prisma.QuoteItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuoteItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuoteItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteItemPayload>
          }
          findFirst: {
            args: Prisma.QuoteItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuoteItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteItemPayload>
          }
          findMany: {
            args: Prisma.QuoteItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteItemPayload>[]
          }
          create: {
            args: Prisma.QuoteItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteItemPayload>
          }
          createMany: {
            args: Prisma.QuoteItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuoteItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteItemPayload>[]
          }
          delete: {
            args: Prisma.QuoteItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteItemPayload>
          }
          update: {
            args: Prisma.QuoteItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteItemPayload>
          }
          deleteMany: {
            args: Prisma.QuoteItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuoteItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.QuoteItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteItemPayload>
          }
          aggregate: {
            args: Prisma.QuoteItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuoteItem>
          }
          groupBy: {
            args: Prisma.QuoteItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuoteItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuoteItemCountArgs<ExtArgs>
            result: $Utils.Optional<QuoteItemCountAggregateOutputType> | number
          }
        }
      }
      QuoteApproval: {
        payload: Prisma.$QuoteApprovalPayload<ExtArgs>
        fields: Prisma.QuoteApprovalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuoteApprovalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteApprovalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuoteApprovalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteApprovalPayload>
          }
          findFirst: {
            args: Prisma.QuoteApprovalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteApprovalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuoteApprovalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteApprovalPayload>
          }
          findMany: {
            args: Prisma.QuoteApprovalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteApprovalPayload>[]
          }
          create: {
            args: Prisma.QuoteApprovalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteApprovalPayload>
          }
          createMany: {
            args: Prisma.QuoteApprovalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuoteApprovalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteApprovalPayload>[]
          }
          delete: {
            args: Prisma.QuoteApprovalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteApprovalPayload>
          }
          update: {
            args: Prisma.QuoteApprovalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteApprovalPayload>
          }
          deleteMany: {
            args: Prisma.QuoteApprovalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuoteApprovalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.QuoteApprovalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteApprovalPayload>
          }
          aggregate: {
            args: Prisma.QuoteApprovalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuoteApproval>
          }
          groupBy: {
            args: Prisma.QuoteApprovalGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuoteApprovalGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuoteApprovalCountArgs<ExtArgs>
            result: $Utils.Optional<QuoteApprovalCountAggregateOutputType> | number
          }
        }
      }
      Invoice: {
        payload: Prisma.$InvoicePayload<ExtArgs>
        fields: Prisma.InvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findFirst: {
            args: Prisma.InvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findMany: {
            args: Prisma.InvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          create: {
            args: Prisma.InvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          createMany: {
            args: Prisma.InvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          delete: {
            args: Prisma.InvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          update: {
            args: Prisma.InvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          deleteMany: {
            args: Prisma.InvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          aggregate: {
            args: Prisma.InvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoice>
          }
          groupBy: {
            args: Prisma.InvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceCountAggregateOutputType> | number
          }
        }
      }
      InvoiceItem: {
        payload: Prisma.$InvoiceItemPayload<ExtArgs>
        fields: Prisma.InvoiceItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          findFirst: {
            args: Prisma.InvoiceItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          findMany: {
            args: Prisma.InvoiceItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>[]
          }
          create: {
            args: Prisma.InvoiceItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          createMany: {
            args: Prisma.InvoiceItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>[]
          }
          delete: {
            args: Prisma.InvoiceItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          update: {
            args: Prisma.InvoiceItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          deleteMany: {
            args: Prisma.InvoiceItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InvoiceItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          aggregate: {
            args: Prisma.InvoiceItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoiceItem>
          }
          groupBy: {
            args: Prisma.InvoiceItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceItemCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceItemCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      PaymentAllocation: {
        payload: Prisma.$PaymentAllocationPayload<ExtArgs>
        fields: Prisma.PaymentAllocationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentAllocationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentAllocationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentAllocationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentAllocationPayload>
          }
          findFirst: {
            args: Prisma.PaymentAllocationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentAllocationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentAllocationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentAllocationPayload>
          }
          findMany: {
            args: Prisma.PaymentAllocationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentAllocationPayload>[]
          }
          create: {
            args: Prisma.PaymentAllocationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentAllocationPayload>
          }
          createMany: {
            args: Prisma.PaymentAllocationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentAllocationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentAllocationPayload>[]
          }
          delete: {
            args: Prisma.PaymentAllocationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentAllocationPayload>
          }
          update: {
            args: Prisma.PaymentAllocationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentAllocationPayload>
          }
          deleteMany: {
            args: Prisma.PaymentAllocationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentAllocationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PaymentAllocationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentAllocationPayload>
          }
          aggregate: {
            args: Prisma.PaymentAllocationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaymentAllocation>
          }
          groupBy: {
            args: Prisma.PaymentAllocationGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentAllocationGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentAllocationCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentAllocationCountAggregateOutputType> | number
          }
        }
      }
      RecurringInvoice: {
        payload: Prisma.$RecurringInvoicePayload<ExtArgs>
        fields: Prisma.RecurringInvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RecurringInvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringInvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RecurringInvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringInvoicePayload>
          }
          findFirst: {
            args: Prisma.RecurringInvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringInvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RecurringInvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringInvoicePayload>
          }
          findMany: {
            args: Prisma.RecurringInvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringInvoicePayload>[]
          }
          create: {
            args: Prisma.RecurringInvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringInvoicePayload>
          }
          createMany: {
            args: Prisma.RecurringInvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RecurringInvoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringInvoicePayload>[]
          }
          delete: {
            args: Prisma.RecurringInvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringInvoicePayload>
          }
          update: {
            args: Prisma.RecurringInvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringInvoicePayload>
          }
          deleteMany: {
            args: Prisma.RecurringInvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RecurringInvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RecurringInvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringInvoicePayload>
          }
          aggregate: {
            args: Prisma.RecurringInvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRecurringInvoice>
          }
          groupBy: {
            args: Prisma.RecurringInvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<RecurringInvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.RecurringInvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<RecurringInvoiceCountAggregateOutputType> | number
          }
        }
      }
      RecurringInvoiceItem: {
        payload: Prisma.$RecurringInvoiceItemPayload<ExtArgs>
        fields: Prisma.RecurringInvoiceItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RecurringInvoiceItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringInvoiceItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RecurringInvoiceItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringInvoiceItemPayload>
          }
          findFirst: {
            args: Prisma.RecurringInvoiceItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringInvoiceItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RecurringInvoiceItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringInvoiceItemPayload>
          }
          findMany: {
            args: Prisma.RecurringInvoiceItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringInvoiceItemPayload>[]
          }
          create: {
            args: Prisma.RecurringInvoiceItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringInvoiceItemPayload>
          }
          createMany: {
            args: Prisma.RecurringInvoiceItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RecurringInvoiceItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringInvoiceItemPayload>[]
          }
          delete: {
            args: Prisma.RecurringInvoiceItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringInvoiceItemPayload>
          }
          update: {
            args: Prisma.RecurringInvoiceItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringInvoiceItemPayload>
          }
          deleteMany: {
            args: Prisma.RecurringInvoiceItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RecurringInvoiceItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RecurringInvoiceItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringInvoiceItemPayload>
          }
          aggregate: {
            args: Prisma.RecurringInvoiceItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRecurringInvoiceItem>
          }
          groupBy: {
            args: Prisma.RecurringInvoiceItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<RecurringInvoiceItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.RecurringInvoiceItemCountArgs<ExtArgs>
            result: $Utils.Optional<RecurringInvoiceItemCountAggregateOutputType> | number
          }
        }
      }
      Reminder: {
        payload: Prisma.$ReminderPayload<ExtArgs>
        fields: Prisma.ReminderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReminderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReminderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReminderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReminderPayload>
          }
          findFirst: {
            args: Prisma.ReminderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReminderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReminderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReminderPayload>
          }
          findMany: {
            args: Prisma.ReminderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReminderPayload>[]
          }
          create: {
            args: Prisma.ReminderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReminderPayload>
          }
          createMany: {
            args: Prisma.ReminderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReminderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReminderPayload>[]
          }
          delete: {
            args: Prisma.ReminderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReminderPayload>
          }
          update: {
            args: Prisma.ReminderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReminderPayload>
          }
          deleteMany: {
            args: Prisma.ReminderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReminderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReminderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReminderPayload>
          }
          aggregate: {
            args: Prisma.ReminderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReminder>
          }
          groupBy: {
            args: Prisma.ReminderGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReminderGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReminderCountArgs<ExtArgs>
            result: $Utils.Optional<ReminderCountAggregateOutputType> | number
          }
        }
      }
      Document: {
        payload: Prisma.$DocumentPayload<ExtArgs>
        fields: Prisma.DocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findFirst: {
            args: Prisma.DocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findMany: {
            args: Prisma.DocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          create: {
            args: Prisma.DocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          createMany: {
            args: Prisma.DocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          delete: {
            args: Prisma.DocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          update: {
            args: Prisma.DocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          deleteMany: {
            args: Prisma.DocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          aggregate: {
            args: Prisma.DocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocument>
          }
          groupBy: {
            args: Prisma.DocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentCountAggregateOutputType> | number
          }
        }
      }
      Expense: {
        payload: Prisma.$ExpensePayload<ExtArgs>
        fields: Prisma.ExpenseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExpenseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExpenseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          findFirst: {
            args: Prisma.ExpenseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExpenseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          findMany: {
            args: Prisma.ExpenseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>[]
          }
          create: {
            args: Prisma.ExpenseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          createMany: {
            args: Prisma.ExpenseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExpenseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>[]
          }
          delete: {
            args: Prisma.ExpenseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          update: {
            args: Prisma.ExpenseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          deleteMany: {
            args: Prisma.ExpenseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExpenseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ExpenseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          aggregate: {
            args: Prisma.ExpenseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExpense>
          }
          groupBy: {
            args: Prisma.ExpenseGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExpenseGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExpenseCountArgs<ExtArgs>
            result: $Utils.Optional<ExpenseCountAggregateOutputType> | number
          }
        }
      }
      Supplier: {
        payload: Prisma.$SupplierPayload<ExtArgs>
        fields: Prisma.SupplierFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SupplierFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SupplierFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          findFirst: {
            args: Prisma.SupplierFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SupplierFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          findMany: {
            args: Prisma.SupplierFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>[]
          }
          create: {
            args: Prisma.SupplierCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          createMany: {
            args: Prisma.SupplierCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SupplierCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>[]
          }
          delete: {
            args: Prisma.SupplierDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          update: {
            args: Prisma.SupplierUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          deleteMany: {
            args: Prisma.SupplierDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SupplierUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SupplierUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          aggregate: {
            args: Prisma.SupplierAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupplier>
          }
          groupBy: {
            args: Prisma.SupplierGroupByArgs<ExtArgs>
            result: $Utils.Optional<SupplierGroupByOutputType>[]
          }
          count: {
            args: Prisma.SupplierCountArgs<ExtArgs>
            result: $Utils.Optional<SupplierCountAggregateOutputType> | number
          }
        }
      }
      AccountingEntry: {
        payload: Prisma.$AccountingEntryPayload<ExtArgs>
        fields: Prisma.AccountingEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountingEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountingEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountingEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountingEntryPayload>
          }
          findFirst: {
            args: Prisma.AccountingEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountingEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountingEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountingEntryPayload>
          }
          findMany: {
            args: Prisma.AccountingEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountingEntryPayload>[]
          }
          create: {
            args: Prisma.AccountingEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountingEntryPayload>
          }
          createMany: {
            args: Prisma.AccountingEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountingEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountingEntryPayload>[]
          }
          delete: {
            args: Prisma.AccountingEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountingEntryPayload>
          }
          update: {
            args: Prisma.AccountingEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountingEntryPayload>
          }
          deleteMany: {
            args: Prisma.AccountingEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountingEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AccountingEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountingEntryPayload>
          }
          aggregate: {
            args: Prisma.AccountingEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccountingEntry>
          }
          groupBy: {
            args: Prisma.AccountingEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountingEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountingEntryCountArgs<ExtArgs>
            result: $Utils.Optional<AccountingEntryCountAggregateOutputType> | number
          }
        }
      }
      CashFlow: {
        payload: Prisma.$CashFlowPayload<ExtArgs>
        fields: Prisma.CashFlowFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CashFlowFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashFlowPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CashFlowFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashFlowPayload>
          }
          findFirst: {
            args: Prisma.CashFlowFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashFlowPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CashFlowFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashFlowPayload>
          }
          findMany: {
            args: Prisma.CashFlowFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashFlowPayload>[]
          }
          create: {
            args: Prisma.CashFlowCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashFlowPayload>
          }
          createMany: {
            args: Prisma.CashFlowCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CashFlowCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashFlowPayload>[]
          }
          delete: {
            args: Prisma.CashFlowDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashFlowPayload>
          }
          update: {
            args: Prisma.CashFlowUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashFlowPayload>
          }
          deleteMany: {
            args: Prisma.CashFlowDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CashFlowUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CashFlowUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashFlowPayload>
          }
          aggregate: {
            args: Prisma.CashFlowAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCashFlow>
          }
          groupBy: {
            args: Prisma.CashFlowGroupByArgs<ExtArgs>
            result: $Utils.Optional<CashFlowGroupByOutputType>[]
          }
          count: {
            args: Prisma.CashFlowCountArgs<ExtArgs>
            result: $Utils.Optional<CashFlowCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      Employee: {
        payload: Prisma.$EmployeePayload<ExtArgs>
        fields: Prisma.EmployeeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          findFirst: {
            args: Prisma.EmployeeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          findMany: {
            args: Prisma.EmployeeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          create: {
            args: Prisma.EmployeeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          createMany: {
            args: Prisma.EmployeeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmployeeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          delete: {
            args: Prisma.EmployeeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          update: {
            args: Prisma.EmployeeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          deleteMany: {
            args: Prisma.EmployeeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmployeeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          aggregate: {
            args: Prisma.EmployeeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployee>
          }
          groupBy: {
            args: Prisma.EmployeeGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeeCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeCountAggregateOutputType> | number
          }
        }
      }
      Contract: {
        payload: Prisma.$ContractPayload<ExtArgs>
        fields: Prisma.ContractFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContractFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContractFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          findFirst: {
            args: Prisma.ContractFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContractFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          findMany: {
            args: Prisma.ContractFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>[]
          }
          create: {
            args: Prisma.ContractCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          createMany: {
            args: Prisma.ContractCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContractCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>[]
          }
          delete: {
            args: Prisma.ContractDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          update: {
            args: Prisma.ContractUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          deleteMany: {
            args: Prisma.ContractDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContractUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContractUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          aggregate: {
            args: Prisma.ContractAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContract>
          }
          groupBy: {
            args: Prisma.ContractGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContractGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContractCountArgs<ExtArgs>
            result: $Utils.Optional<ContractCountAggregateOutputType> | number
          }
        }
      }
      Salary: {
        payload: Prisma.$SalaryPayload<ExtArgs>
        fields: Prisma.SalaryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SalaryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SalaryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPayload>
          }
          findFirst: {
            args: Prisma.SalaryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SalaryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPayload>
          }
          findMany: {
            args: Prisma.SalaryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPayload>[]
          }
          create: {
            args: Prisma.SalaryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPayload>
          }
          createMany: {
            args: Prisma.SalaryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SalaryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPayload>[]
          }
          delete: {
            args: Prisma.SalaryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPayload>
          }
          update: {
            args: Prisma.SalaryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPayload>
          }
          deleteMany: {
            args: Prisma.SalaryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SalaryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SalaryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPayload>
          }
          aggregate: {
            args: Prisma.SalaryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSalary>
          }
          groupBy: {
            args: Prisma.SalaryGroupByArgs<ExtArgs>
            result: $Utils.Optional<SalaryGroupByOutputType>[]
          }
          count: {
            args: Prisma.SalaryCountArgs<ExtArgs>
            result: $Utils.Optional<SalaryCountAggregateOutputType> | number
          }
        }
      }
      LoanPayment: {
        payload: Prisma.$LoanPaymentPayload<ExtArgs>
        fields: Prisma.LoanPaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LoanPaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanPaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LoanPaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanPaymentPayload>
          }
          findFirst: {
            args: Prisma.LoanPaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanPaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LoanPaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanPaymentPayload>
          }
          findMany: {
            args: Prisma.LoanPaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanPaymentPayload>[]
          }
          create: {
            args: Prisma.LoanPaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanPaymentPayload>
          }
          createMany: {
            args: Prisma.LoanPaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LoanPaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanPaymentPayload>[]
          }
          delete: {
            args: Prisma.LoanPaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanPaymentPayload>
          }
          update: {
            args: Prisma.LoanPaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanPaymentPayload>
          }
          deleteMany: {
            args: Prisma.LoanPaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LoanPaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LoanPaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanPaymentPayload>
          }
          aggregate: {
            args: Prisma.LoanPaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLoanPayment>
          }
          groupBy: {
            args: Prisma.LoanPaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<LoanPaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.LoanPaymentCountArgs<ExtArgs>
            result: $Utils.Optional<LoanPaymentCountAggregateOutputType> | number
          }
        }
      }
      LeaveRequest: {
        payload: Prisma.$LeaveRequestPayload<ExtArgs>
        fields: Prisma.LeaveRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeaveRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeaveRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload>
          }
          findFirst: {
            args: Prisma.LeaveRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeaveRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload>
          }
          findMany: {
            args: Prisma.LeaveRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload>[]
          }
          create: {
            args: Prisma.LeaveRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload>
          }
          createMany: {
            args: Prisma.LeaveRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LeaveRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload>[]
          }
          delete: {
            args: Prisma.LeaveRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload>
          }
          update: {
            args: Prisma.LeaveRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload>
          }
          deleteMany: {
            args: Prisma.LeaveRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeaveRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LeaveRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload>
          }
          aggregate: {
            args: Prisma.LeaveRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLeaveRequest>
          }
          groupBy: {
            args: Prisma.LeaveRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeaveRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeaveRequestCountArgs<ExtArgs>
            result: $Utils.Optional<LeaveRequestCountAggregateOutputType> | number
          }
        }
      }
      Prospect: {
        payload: Prisma.$ProspectPayload<ExtArgs>
        fields: Prisma.ProspectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProspectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProspectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProspectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProspectPayload>
          }
          findFirst: {
            args: Prisma.ProspectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProspectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProspectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProspectPayload>
          }
          findMany: {
            args: Prisma.ProspectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProspectPayload>[]
          }
          create: {
            args: Prisma.ProspectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProspectPayload>
          }
          createMany: {
            args: Prisma.ProspectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProspectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProspectPayload>[]
          }
          delete: {
            args: Prisma.ProspectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProspectPayload>
          }
          update: {
            args: Prisma.ProspectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProspectPayload>
          }
          deleteMany: {
            args: Prisma.ProspectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProspectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProspectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProspectPayload>
          }
          aggregate: {
            args: Prisma.ProspectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProspect>
          }
          groupBy: {
            args: Prisma.ProspectGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProspectGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProspectCountArgs<ExtArgs>
            result: $Utils.Optional<ProspectCountAggregateOutputType> | number
          }
        }
      }
      ProspectActivity: {
        payload: Prisma.$ProspectActivityPayload<ExtArgs>
        fields: Prisma.ProspectActivityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProspectActivityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProspectActivityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProspectActivityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProspectActivityPayload>
          }
          findFirst: {
            args: Prisma.ProspectActivityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProspectActivityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProspectActivityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProspectActivityPayload>
          }
          findMany: {
            args: Prisma.ProspectActivityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProspectActivityPayload>[]
          }
          create: {
            args: Prisma.ProspectActivityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProspectActivityPayload>
          }
          createMany: {
            args: Prisma.ProspectActivityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProspectActivityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProspectActivityPayload>[]
          }
          delete: {
            args: Prisma.ProspectActivityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProspectActivityPayload>
          }
          update: {
            args: Prisma.ProspectActivityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProspectActivityPayload>
          }
          deleteMany: {
            args: Prisma.ProspectActivityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProspectActivityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProspectActivityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProspectActivityPayload>
          }
          aggregate: {
            args: Prisma.ProspectActivityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProspectActivity>
          }
          groupBy: {
            args: Prisma.ProspectActivityGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProspectActivityGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProspectActivityCountArgs<ExtArgs>
            result: $Utils.Optional<ProspectActivityCountAggregateOutputType> | number
          }
        }
      }
      Loan: {
        payload: Prisma.$LoanPayload<ExtArgs>
        fields: Prisma.LoanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LoanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LoanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanPayload>
          }
          findFirst: {
            args: Prisma.LoanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LoanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanPayload>
          }
          findMany: {
            args: Prisma.LoanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanPayload>[]
          }
          create: {
            args: Prisma.LoanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanPayload>
          }
          createMany: {
            args: Prisma.LoanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LoanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanPayload>[]
          }
          delete: {
            args: Prisma.LoanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanPayload>
          }
          update: {
            args: Prisma.LoanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanPayload>
          }
          deleteMany: {
            args: Prisma.LoanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LoanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LoanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanPayload>
          }
          aggregate: {
            args: Prisma.LoanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLoan>
          }
          groupBy: {
            args: Prisma.LoanGroupByArgs<ExtArgs>
            result: $Utils.Optional<LoanGroupByOutputType>[]
          }
          count: {
            args: Prisma.LoanCountArgs<ExtArgs>
            result: $Utils.Optional<LoanCountAggregateOutputType> | number
          }
        }
      }
      Specialite: {
        payload: Prisma.$SpecialitePayload<ExtArgs>
        fields: Prisma.SpecialiteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SpecialiteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialitePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SpecialiteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialitePayload>
          }
          findFirst: {
            args: Prisma.SpecialiteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialitePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SpecialiteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialitePayload>
          }
          findMany: {
            args: Prisma.SpecialiteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialitePayload>[]
          }
          create: {
            args: Prisma.SpecialiteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialitePayload>
          }
          createMany: {
            args: Prisma.SpecialiteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SpecialiteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialitePayload>[]
          }
          delete: {
            args: Prisma.SpecialiteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialitePayload>
          }
          update: {
            args: Prisma.SpecialiteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialitePayload>
          }
          deleteMany: {
            args: Prisma.SpecialiteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SpecialiteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SpecialiteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialitePayload>
          }
          aggregate: {
            args: Prisma.SpecialiteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSpecialite>
          }
          groupBy: {
            args: Prisma.SpecialiteGroupByArgs<ExtArgs>
            result: $Utils.Optional<SpecialiteGroupByOutputType>[]
          }
          count: {
            args: Prisma.SpecialiteCountArgs<ExtArgs>
            result: $Utils.Optional<SpecialiteCountAggregateOutputType> | number
          }
        }
      }
      Technicien: {
        payload: Prisma.$TechnicienPayload<ExtArgs>
        fields: Prisma.TechnicienFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TechnicienFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicienPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TechnicienFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicienPayload>
          }
          findFirst: {
            args: Prisma.TechnicienFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicienPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TechnicienFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicienPayload>
          }
          findMany: {
            args: Prisma.TechnicienFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicienPayload>[]
          }
          create: {
            args: Prisma.TechnicienCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicienPayload>
          }
          createMany: {
            args: Prisma.TechnicienCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TechnicienCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicienPayload>[]
          }
          delete: {
            args: Prisma.TechnicienDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicienPayload>
          }
          update: {
            args: Prisma.TechnicienUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicienPayload>
          }
          deleteMany: {
            args: Prisma.TechnicienDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TechnicienUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TechnicienUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicienPayload>
          }
          aggregate: {
            args: Prisma.TechnicienAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTechnicien>
          }
          groupBy: {
            args: Prisma.TechnicienGroupByArgs<ExtArgs>
            result: $Utils.Optional<TechnicienGroupByOutputType>[]
          }
          count: {
            args: Prisma.TechnicienCountArgs<ExtArgs>
            result: $Utils.Optional<TechnicienCountAggregateOutputType> | number
          }
        }
      }
      Mission: {
        payload: Prisma.$MissionPayload<ExtArgs>
        fields: Prisma.MissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionPayload>
          }
          findFirst: {
            args: Prisma.MissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionPayload>
          }
          findMany: {
            args: Prisma.MissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionPayload>[]
          }
          create: {
            args: Prisma.MissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionPayload>
          }
          createMany: {
            args: Prisma.MissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionPayload>[]
          }
          delete: {
            args: Prisma.MissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionPayload>
          }
          update: {
            args: Prisma.MissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionPayload>
          }
          deleteMany: {
            args: Prisma.MissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionPayload>
          }
          aggregate: {
            args: Prisma.MissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMission>
          }
          groupBy: {
            args: Prisma.MissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<MissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.MissionCountArgs<ExtArgs>
            result: $Utils.Optional<MissionCountAggregateOutputType> | number
          }
        }
      }
      Intervention: {
        payload: Prisma.$InterventionPayload<ExtArgs>
        fields: Prisma.InterventionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InterventionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterventionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InterventionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterventionPayload>
          }
          findFirst: {
            args: Prisma.InterventionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterventionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InterventionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterventionPayload>
          }
          findMany: {
            args: Prisma.InterventionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterventionPayload>[]
          }
          create: {
            args: Prisma.InterventionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterventionPayload>
          }
          createMany: {
            args: Prisma.InterventionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InterventionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterventionPayload>[]
          }
          delete: {
            args: Prisma.InterventionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterventionPayload>
          }
          update: {
            args: Prisma.InterventionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterventionPayload>
          }
          deleteMany: {
            args: Prisma.InterventionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InterventionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InterventionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterventionPayload>
          }
          aggregate: {
            args: Prisma.InterventionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIntervention>
          }
          groupBy: {
            args: Prisma.InterventionGroupByArgs<ExtArgs>
            result: $Utils.Optional<InterventionGroupByOutputType>[]
          }
          count: {
            args: Prisma.InterventionCountArgs<ExtArgs>
            result: $Utils.Optional<InterventionCountAggregateOutputType> | number
          }
        }
      }
      TechnicienIntervention: {
        payload: Prisma.$TechnicienInterventionPayload<ExtArgs>
        fields: Prisma.TechnicienInterventionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TechnicienInterventionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicienInterventionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TechnicienInterventionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicienInterventionPayload>
          }
          findFirst: {
            args: Prisma.TechnicienInterventionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicienInterventionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TechnicienInterventionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicienInterventionPayload>
          }
          findMany: {
            args: Prisma.TechnicienInterventionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicienInterventionPayload>[]
          }
          create: {
            args: Prisma.TechnicienInterventionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicienInterventionPayload>
          }
          createMany: {
            args: Prisma.TechnicienInterventionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TechnicienInterventionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicienInterventionPayload>[]
          }
          delete: {
            args: Prisma.TechnicienInterventionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicienInterventionPayload>
          }
          update: {
            args: Prisma.TechnicienInterventionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicienInterventionPayload>
          }
          deleteMany: {
            args: Prisma.TechnicienInterventionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TechnicienInterventionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TechnicienInterventionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicienInterventionPayload>
          }
          aggregate: {
            args: Prisma.TechnicienInterventionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTechnicienIntervention>
          }
          groupBy: {
            args: Prisma.TechnicienInterventionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TechnicienInterventionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TechnicienInterventionCountArgs<ExtArgs>
            result: $Utils.Optional<TechnicienInterventionCountAggregateOutputType> | number
          }
        }
      }
      RapportMission: {
        payload: Prisma.$RapportMissionPayload<ExtArgs>
        fields: Prisma.RapportMissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RapportMissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RapportMissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RapportMissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RapportMissionPayload>
          }
          findFirst: {
            args: Prisma.RapportMissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RapportMissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RapportMissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RapportMissionPayload>
          }
          findMany: {
            args: Prisma.RapportMissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RapportMissionPayload>[]
          }
          create: {
            args: Prisma.RapportMissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RapportMissionPayload>
          }
          createMany: {
            args: Prisma.RapportMissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RapportMissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RapportMissionPayload>[]
          }
          delete: {
            args: Prisma.RapportMissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RapportMissionPayload>
          }
          update: {
            args: Prisma.RapportMissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RapportMissionPayload>
          }
          deleteMany: {
            args: Prisma.RapportMissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RapportMissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RapportMissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RapportMissionPayload>
          }
          aggregate: {
            args: Prisma.RapportMissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRapportMission>
          }
          groupBy: {
            args: Prisma.RapportMissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<RapportMissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.RapportMissionCountArgs<ExtArgs>
            result: $Utils.Optional<RapportMissionCountAggregateOutputType> | number
          }
        }
      }
      RapportImage: {
        payload: Prisma.$RapportImagePayload<ExtArgs>
        fields: Prisma.RapportImageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RapportImageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RapportImagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RapportImageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RapportImagePayload>
          }
          findFirst: {
            args: Prisma.RapportImageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RapportImagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RapportImageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RapportImagePayload>
          }
          findMany: {
            args: Prisma.RapportImageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RapportImagePayload>[]
          }
          create: {
            args: Prisma.RapportImageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RapportImagePayload>
          }
          createMany: {
            args: Prisma.RapportImageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RapportImageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RapportImagePayload>[]
          }
          delete: {
            args: Prisma.RapportImageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RapportImagePayload>
          }
          update: {
            args: Prisma.RapportImageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RapportImagePayload>
          }
          deleteMany: {
            args: Prisma.RapportImageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RapportImageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RapportImageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RapportImagePayload>
          }
          aggregate: {
            args: Prisma.RapportImageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRapportImage>
          }
          groupBy: {
            args: Prisma.RapportImageGroupByArgs<ExtArgs>
            result: $Utils.Optional<RapportImageGroupByOutputType>[]
          }
          count: {
            args: Prisma.RapportImageCountArgs<ExtArgs>
            result: $Utils.Optional<RapportImageCountAggregateOutputType> | number
          }
        }
      }
      Materiel: {
        payload: Prisma.$MaterielPayload<ExtArgs>
        fields: Prisma.MaterielFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MaterielFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterielPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MaterielFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterielPayload>
          }
          findFirst: {
            args: Prisma.MaterielFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterielPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MaterielFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterielPayload>
          }
          findMany: {
            args: Prisma.MaterielFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterielPayload>[]
          }
          create: {
            args: Prisma.MaterielCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterielPayload>
          }
          createMany: {
            args: Prisma.MaterielCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MaterielCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterielPayload>[]
          }
          delete: {
            args: Prisma.MaterielDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterielPayload>
          }
          update: {
            args: Prisma.MaterielUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterielPayload>
          }
          deleteMany: {
            args: Prisma.MaterielDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MaterielUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MaterielUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterielPayload>
          }
          aggregate: {
            args: Prisma.MaterielAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMateriel>
          }
          groupBy: {
            args: Prisma.MaterielGroupByArgs<ExtArgs>
            result: $Utils.Optional<MaterielGroupByOutputType>[]
          }
          count: {
            args: Prisma.MaterielCountArgs<ExtArgs>
            result: $Utils.Optional<MaterielCountAggregateOutputType> | number
          }
        }
      }
      SortieMateriel: {
        payload: Prisma.$SortieMaterielPayload<ExtArgs>
        fields: Prisma.SortieMaterielFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SortieMaterielFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SortieMaterielPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SortieMaterielFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SortieMaterielPayload>
          }
          findFirst: {
            args: Prisma.SortieMaterielFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SortieMaterielPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SortieMaterielFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SortieMaterielPayload>
          }
          findMany: {
            args: Prisma.SortieMaterielFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SortieMaterielPayload>[]
          }
          create: {
            args: Prisma.SortieMaterielCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SortieMaterielPayload>
          }
          createMany: {
            args: Prisma.SortieMaterielCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SortieMaterielCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SortieMaterielPayload>[]
          }
          delete: {
            args: Prisma.SortieMaterielDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SortieMaterielPayload>
          }
          update: {
            args: Prisma.SortieMaterielUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SortieMaterielPayload>
          }
          deleteMany: {
            args: Prisma.SortieMaterielDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SortieMaterielUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SortieMaterielUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SortieMaterielPayload>
          }
          aggregate: {
            args: Prisma.SortieMaterielAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSortieMateriel>
          }
          groupBy: {
            args: Prisma.SortieMaterielGroupByArgs<ExtArgs>
            result: $Utils.Optional<SortieMaterielGroupByOutputType>[]
          }
          count: {
            args: Prisma.SortieMaterielCountArgs<ExtArgs>
            result: $Utils.Optional<SortieMaterielCountAggregateOutputType> | number
          }
        }
      }
      EntreeMateriel: {
        payload: Prisma.$EntreeMaterielPayload<ExtArgs>
        fields: Prisma.EntreeMaterielFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EntreeMaterielFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntreeMaterielPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EntreeMaterielFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntreeMaterielPayload>
          }
          findFirst: {
            args: Prisma.EntreeMaterielFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntreeMaterielPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EntreeMaterielFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntreeMaterielPayload>
          }
          findMany: {
            args: Prisma.EntreeMaterielFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntreeMaterielPayload>[]
          }
          create: {
            args: Prisma.EntreeMaterielCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntreeMaterielPayload>
          }
          createMany: {
            args: Prisma.EntreeMaterielCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EntreeMaterielCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntreeMaterielPayload>[]
          }
          delete: {
            args: Prisma.EntreeMaterielDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntreeMaterielPayload>
          }
          update: {
            args: Prisma.EntreeMaterielUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntreeMaterielPayload>
          }
          deleteMany: {
            args: Prisma.EntreeMaterielDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EntreeMaterielUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EntreeMaterielUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntreeMaterielPayload>
          }
          aggregate: {
            args: Prisma.EntreeMaterielAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEntreeMateriel>
          }
          groupBy: {
            args: Prisma.EntreeMaterielGroupByArgs<ExtArgs>
            result: $Utils.Optional<EntreeMaterielGroupByOutputType>[]
          }
          count: {
            args: Prisma.EntreeMaterielCountArgs<ExtArgs>
            result: $Utils.Optional<EntreeMaterielCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ServiceCountOutputType
   */

  export type ServiceCountOutputType = {
    users: number
    customers: number
    employees: number
  }

  export type ServiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | ServiceCountOutputTypeCountUsersArgs
    customers?: boolean | ServiceCountOutputTypeCountCustomersArgs
    employees?: boolean | ServiceCountOutputTypeCountEmployeesArgs
  }

  // Custom InputTypes
  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCountOutputType
     */
    select?: ServiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountCustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountEmployeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    createdCustomers: number
    createdQuotes: number
    createdInvoices: number
    createdPayments: number
    serviceApprovals: number
    dgApprovals: number
    auditLogs: number
    quoteApprovals: number
    createdExpenses: number
    accountingEntries: number
    cashFlowEntries: number
    createdReminders: number
    createdRecurringInvoices: number
    leaveApprovals: number
    assignedProspects: number
    createdProspects: number
    createdProspectActivities: number
    notifications: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdCustomers?: boolean | UserCountOutputTypeCountCreatedCustomersArgs
    createdQuotes?: boolean | UserCountOutputTypeCountCreatedQuotesArgs
    createdInvoices?: boolean | UserCountOutputTypeCountCreatedInvoicesArgs
    createdPayments?: boolean | UserCountOutputTypeCountCreatedPaymentsArgs
    serviceApprovals?: boolean | UserCountOutputTypeCountServiceApprovalsArgs
    dgApprovals?: boolean | UserCountOutputTypeCountDgApprovalsArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
    quoteApprovals?: boolean | UserCountOutputTypeCountQuoteApprovalsArgs
    createdExpenses?: boolean | UserCountOutputTypeCountCreatedExpensesArgs
    accountingEntries?: boolean | UserCountOutputTypeCountAccountingEntriesArgs
    cashFlowEntries?: boolean | UserCountOutputTypeCountCashFlowEntriesArgs
    createdReminders?: boolean | UserCountOutputTypeCountCreatedRemindersArgs
    createdRecurringInvoices?: boolean | UserCountOutputTypeCountCreatedRecurringInvoicesArgs
    leaveApprovals?: boolean | UserCountOutputTypeCountLeaveApprovalsArgs
    assignedProspects?: boolean | UserCountOutputTypeCountAssignedProspectsArgs
    createdProspects?: boolean | UserCountOutputTypeCountCreatedProspectsArgs
    createdProspectActivities?: boolean | UserCountOutputTypeCountCreatedProspectActivitiesArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedCustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedQuotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuoteWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountServiceApprovalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuoteWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDgApprovalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuoteWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountQuoteApprovalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuoteApprovalWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedExpensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountingEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountingEntryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCashFlowEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CashFlowWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedRemindersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReminderWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedRecurringInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecurringInvoiceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLeaveApprovalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveRequestWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssignedProspectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProspectWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedProspectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProspectWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedProspectActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProspectActivityWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Count Type CustomerCountOutputType
   */

  export type CustomerCountOutputType = {
    addresses: number
    quotes: number
    invoices: number
    payments: number
    recurringInvoices: number
    missions: number
  }

  export type CustomerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    addresses?: boolean | CustomerCountOutputTypeCountAddressesArgs
    quotes?: boolean | CustomerCountOutputTypeCountQuotesArgs
    invoices?: boolean | CustomerCountOutputTypeCountInvoicesArgs
    payments?: boolean | CustomerCountOutputTypeCountPaymentsArgs
    recurringInvoices?: boolean | CustomerCountOutputTypeCountRecurringInvoicesArgs
    missions?: boolean | CustomerCountOutputTypeCountMissionsArgs
  }

  // Custom InputTypes
  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerCountOutputType
     */
    select?: CustomerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountAddressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerAddressWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountQuotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuoteWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountRecurringInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecurringInvoiceWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountMissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MissionWhereInput
  }


  /**
   * Count Type CustomerAddressCountOutputType
   */

  export type CustomerAddressCountOutputType = {
    quotes: number
    invoices: number
  }

  export type CustomerAddressCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quotes?: boolean | CustomerAddressCountOutputTypeCountQuotesArgs
    invoices?: boolean | CustomerAddressCountOutputTypeCountInvoicesArgs
  }

  // Custom InputTypes
  /**
   * CustomerAddressCountOutputType without action
   */
  export type CustomerAddressCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddressCountOutputType
     */
    select?: CustomerAddressCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerAddressCountOutputType without action
   */
  export type CustomerAddressCountOutputTypeCountQuotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuoteWhereInput
  }

  /**
   * CustomerAddressCountOutputType without action
   */
  export type CustomerAddressCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    prices: number
    quoteItems: number
    invoiceItems: number
    recurringInvoiceItems: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prices?: boolean | ProductCountOutputTypeCountPricesArgs
    quoteItems?: boolean | ProductCountOutputTypeCountQuoteItemsArgs
    invoiceItems?: boolean | ProductCountOutputTypeCountInvoiceItemsArgs
    recurringInvoiceItems?: boolean | ProductCountOutputTypeCountRecurringInvoiceItemsArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountPricesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductPriceWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountQuoteItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuoteItemWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountInvoiceItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceItemWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountRecurringInvoiceItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecurringInvoiceItemWhereInput
  }


  /**
   * Count Type QuoteCountOutputType
   */

  export type QuoteCountOutputType = {
    items: number
    invoices: number
    approvals: number
    missions: number
  }

  export type QuoteCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | QuoteCountOutputTypeCountItemsArgs
    invoices?: boolean | QuoteCountOutputTypeCountInvoicesArgs
    approvals?: boolean | QuoteCountOutputTypeCountApprovalsArgs
    missions?: boolean | QuoteCountOutputTypeCountMissionsArgs
  }

  // Custom InputTypes
  /**
   * QuoteCountOutputType without action
   */
  export type QuoteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteCountOutputType
     */
    select?: QuoteCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuoteCountOutputType without action
   */
  export type QuoteCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuoteItemWhereInput
  }

  /**
   * QuoteCountOutputType without action
   */
  export type QuoteCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * QuoteCountOutputType without action
   */
  export type QuoteCountOutputTypeCountApprovalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuoteApprovalWhereInput
  }

  /**
   * QuoteCountOutputType without action
   */
  export type QuoteCountOutputTypeCountMissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MissionWhereInput
  }


  /**
   * Count Type InvoiceCountOutputType
   */

  export type InvoiceCountOutputType = {
    items: number
    paymentAllocations: number
    reminders: number
  }

  export type InvoiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | InvoiceCountOutputTypeCountItemsArgs
    paymentAllocations?: boolean | InvoiceCountOutputTypeCountPaymentAllocationsArgs
    reminders?: boolean | InvoiceCountOutputTypeCountRemindersArgs
  }

  // Custom InputTypes
  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceCountOutputType
     */
    select?: InvoiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceItemWhereInput
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountPaymentAllocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentAllocationWhereInput
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountRemindersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReminderWhereInput
  }


  /**
   * Count Type PaymentCountOutputType
   */

  export type PaymentCountOutputType = {
    allocations: number
  }

  export type PaymentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    allocations?: boolean | PaymentCountOutputTypeCountAllocationsArgs
  }

  // Custom InputTypes
  /**
   * PaymentCountOutputType without action
   */
  export type PaymentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentCountOutputType
     */
    select?: PaymentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PaymentCountOutputType without action
   */
  export type PaymentCountOutputTypeCountAllocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentAllocationWhereInput
  }


  /**
   * Count Type RecurringInvoiceCountOutputType
   */

  export type RecurringInvoiceCountOutputType = {
    items: number
  }

  export type RecurringInvoiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | RecurringInvoiceCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * RecurringInvoiceCountOutputType without action
   */
  export type RecurringInvoiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringInvoiceCountOutputType
     */
    select?: RecurringInvoiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RecurringInvoiceCountOutputType without action
   */
  export type RecurringInvoiceCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecurringInvoiceItemWhereInput
  }


  /**
   * Count Type SupplierCountOutputType
   */

  export type SupplierCountOutputType = {
    expenses: number
  }

  export type SupplierCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    expenses?: boolean | SupplierCountOutputTypeCountExpensesArgs
  }

  // Custom InputTypes
  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierCountOutputType
     */
    select?: SupplierCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeCountExpensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseWhereInput
  }


  /**
   * Count Type EmployeeCountOutputType
   */

  export type EmployeeCountOutputType = {
    contracts: number
    salaries: number
    leaveRequests: number
    loans: number
  }

  export type EmployeeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contracts?: boolean | EmployeeCountOutputTypeCountContractsArgs
    salaries?: boolean | EmployeeCountOutputTypeCountSalariesArgs
    leaveRequests?: boolean | EmployeeCountOutputTypeCountLeaveRequestsArgs
    loans?: boolean | EmployeeCountOutputTypeCountLoansArgs
  }

  // Custom InputTypes
  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeCountOutputType
     */
    select?: EmployeeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountContractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContractWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountSalariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalaryWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountLeaveRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveRequestWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountLoansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LoanWhereInput
  }


  /**
   * Count Type SalaryCountOutputType
   */

  export type SalaryCountOutputType = {
    loanPayments: number
  }

  export type SalaryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    loanPayments?: boolean | SalaryCountOutputTypeCountLoanPaymentsArgs
  }

  // Custom InputTypes
  /**
   * SalaryCountOutputType without action
   */
  export type SalaryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryCountOutputType
     */
    select?: SalaryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SalaryCountOutputType without action
   */
  export type SalaryCountOutputTypeCountLoanPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LoanPaymentWhereInput
  }


  /**
   * Count Type ProspectCountOutputType
   */

  export type ProspectCountOutputType = {
    activities: number
  }

  export type ProspectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activities?: boolean | ProspectCountOutputTypeCountActivitiesArgs
  }

  // Custom InputTypes
  /**
   * ProspectCountOutputType without action
   */
  export type ProspectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProspectCountOutputType
     */
    select?: ProspectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProspectCountOutputType without action
   */
  export type ProspectCountOutputTypeCountActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProspectActivityWhereInput
  }


  /**
   * Count Type LoanCountOutputType
   */

  export type LoanCountOutputType = {
    payments: number
  }

  export type LoanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | LoanCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * LoanCountOutputType without action
   */
  export type LoanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanCountOutputType
     */
    select?: LoanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LoanCountOutputType without action
   */
  export type LoanCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LoanPaymentWhereInput
  }


  /**
   * Count Type SpecialiteCountOutputType
   */

  export type SpecialiteCountOutputType = {
    techniciens: number
  }

  export type SpecialiteCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    techniciens?: boolean | SpecialiteCountOutputTypeCountTechniciensArgs
  }

  // Custom InputTypes
  /**
   * SpecialiteCountOutputType without action
   */
  export type SpecialiteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecialiteCountOutputType
     */
    select?: SpecialiteCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SpecialiteCountOutputType without action
   */
  export type SpecialiteCountOutputTypeCountTechniciensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TechnicienWhereInput
  }


  /**
   * Count Type TechnicienCountOutputType
   */

  export type TechnicienCountOutputType = {
    interventions: number
    rapports: number
    sortiesMateriels: number
  }

  export type TechnicienCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interventions?: boolean | TechnicienCountOutputTypeCountInterventionsArgs
    rapports?: boolean | TechnicienCountOutputTypeCountRapportsArgs
    sortiesMateriels?: boolean | TechnicienCountOutputTypeCountSortiesMaterielsArgs
  }

  // Custom InputTypes
  /**
   * TechnicienCountOutputType without action
   */
  export type TechnicienCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicienCountOutputType
     */
    select?: TechnicienCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TechnicienCountOutputType without action
   */
  export type TechnicienCountOutputTypeCountInterventionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TechnicienInterventionWhereInput
  }

  /**
   * TechnicienCountOutputType without action
   */
  export type TechnicienCountOutputTypeCountRapportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RapportMissionWhereInput
  }

  /**
   * TechnicienCountOutputType without action
   */
  export type TechnicienCountOutputTypeCountSortiesMaterielsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SortieMaterielWhereInput
  }


  /**
   * Count Type MissionCountOutputType
   */

  export type MissionCountOutputType = {
    interventions: number
    rapports: number
    devis: number
  }

  export type MissionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interventions?: boolean | MissionCountOutputTypeCountInterventionsArgs
    rapports?: boolean | MissionCountOutputTypeCountRapportsArgs
    devis?: boolean | MissionCountOutputTypeCountDevisArgs
  }

  // Custom InputTypes
  /**
   * MissionCountOutputType without action
   */
  export type MissionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MissionCountOutputType
     */
    select?: MissionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MissionCountOutputType without action
   */
  export type MissionCountOutputTypeCountInterventionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InterventionWhereInput
  }

  /**
   * MissionCountOutputType without action
   */
  export type MissionCountOutputTypeCountRapportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RapportMissionWhereInput
  }

  /**
   * MissionCountOutputType without action
   */
  export type MissionCountOutputTypeCountDevisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuoteWhereInput
  }


  /**
   * Count Type InterventionCountOutputType
   */

  export type InterventionCountOutputType = {
    techniciens: number
    rapports: number
    sortiesMateriels: number
  }

  export type InterventionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    techniciens?: boolean | InterventionCountOutputTypeCountTechniciensArgs
    rapports?: boolean | InterventionCountOutputTypeCountRapportsArgs
    sortiesMateriels?: boolean | InterventionCountOutputTypeCountSortiesMaterielsArgs
  }

  // Custom InputTypes
  /**
   * InterventionCountOutputType without action
   */
  export type InterventionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterventionCountOutputType
     */
    select?: InterventionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InterventionCountOutputType without action
   */
  export type InterventionCountOutputTypeCountTechniciensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TechnicienInterventionWhereInput
  }

  /**
   * InterventionCountOutputType without action
   */
  export type InterventionCountOutputTypeCountRapportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RapportMissionWhereInput
  }

  /**
   * InterventionCountOutputType without action
   */
  export type InterventionCountOutputTypeCountSortiesMaterielsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SortieMaterielWhereInput
  }


  /**
   * Count Type RapportMissionCountOutputType
   */

  export type RapportMissionCountOutputType = {
    images: number
  }

  export type RapportMissionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    images?: boolean | RapportMissionCountOutputTypeCountImagesArgs
  }

  // Custom InputTypes
  /**
   * RapportMissionCountOutputType without action
   */
  export type RapportMissionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RapportMissionCountOutputType
     */
    select?: RapportMissionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RapportMissionCountOutputType without action
   */
  export type RapportMissionCountOutputTypeCountImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RapportImageWhereInput
  }


  /**
   * Count Type MaterielCountOutputType
   */

  export type MaterielCountOutputType = {
    sorties: number
    entrees: number
  }

  export type MaterielCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sorties?: boolean | MaterielCountOutputTypeCountSortiesArgs
    entrees?: boolean | MaterielCountOutputTypeCountEntreesArgs
  }

  // Custom InputTypes
  /**
   * MaterielCountOutputType without action
   */
  export type MaterielCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterielCountOutputType
     */
    select?: MaterielCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MaterielCountOutputType without action
   */
  export type MaterielCountOutputTypeCountSortiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SortieMaterielWhereInput
  }

  /**
   * MaterielCountOutputType without action
   */
  export type MaterielCountOutputTypeCountEntreesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EntreeMaterielWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Service
   */

  export type AggregateService = {
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  export type ServiceAvgAggregateOutputType = {
    id: number | null
  }

  export type ServiceSumAggregateOutputType = {
    id: number | null
  }

  export type ServiceMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ServiceAvgAggregateInputType = {
    id?: true
  }

  export type ServiceSumAggregateInputType = {
    id?: true
  }

  export type ServiceMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Service to aggregate.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Services
    **/
    _count?: true | ServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceMaxAggregateInputType
  }

  export type GetServiceAggregateType<T extends ServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateService[P]>
      : GetScalarType<T[P], AggregateService[P]>
  }




  export type ServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithAggregationInput | ServiceOrderByWithAggregationInput[]
    by: ServiceScalarFieldEnum[] | ServiceScalarFieldEnum
    having?: ServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceCountAggregateInputType | true
    _avg?: ServiceAvgAggregateInputType
    _sum?: ServiceSumAggregateInputType
    _min?: ServiceMinAggregateInputType
    _max?: ServiceMaxAggregateInputType
  }

  export type ServiceGroupByOutputType = {
    id: number
    name: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  type GetServiceGroupByPayload<T extends ServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceGroupByOutputType[P]>
        }
      >
    >


  export type ServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | Service$usersArgs<ExtArgs>
    customers?: boolean | Service$customersArgs<ExtArgs>
    employees?: boolean | Service$employeesArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Service$usersArgs<ExtArgs>
    customers?: boolean | Service$customersArgs<ExtArgs>
    employees?: boolean | Service$employeesArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ServiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Service"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
      customers: Prisma.$CustomerPayload<ExtArgs>[]
      employees: Prisma.$EmployeePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["service"]>
    composites: {}
  }

  type ServiceGetPayload<S extends boolean | null | undefined | ServiceDefaultArgs> = $Result.GetResult<Prisma.$ServicePayload, S>

  type ServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ServiceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ServiceCountAggregateInputType | true
    }

  export interface ServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Service'], meta: { name: 'Service' } }
    /**
     * Find zero or one Service that matches the filter.
     * @param {ServiceFindUniqueArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceFindUniqueArgs>(args: SelectSubset<T, ServiceFindUniqueArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Service that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ServiceFindUniqueOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Service that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceFindFirstArgs>(args?: SelectSubset<T, ServiceFindFirstArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Service that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Services
     * const services = await prisma.service.findMany()
     * 
     * // Get first 10 Services
     * const services = await prisma.service.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceWithIdOnly = await prisma.service.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceFindManyArgs>(args?: SelectSubset<T, ServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Service.
     * @param {ServiceCreateArgs} args - Arguments to create a Service.
     * @example
     * // Create one Service
     * const Service = await prisma.service.create({
     *   data: {
     *     // ... data to create a Service
     *   }
     * })
     * 
     */
    create<T extends ServiceCreateArgs>(args: SelectSubset<T, ServiceCreateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Services.
     * @param {ServiceCreateManyArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceCreateManyArgs>(args?: SelectSubset<T, ServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Services and returns the data saved in the database.
     * @param {ServiceCreateManyAndReturnArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Services and only return the `id`
     * const serviceWithIdOnly = await prisma.service.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Service.
     * @param {ServiceDeleteArgs} args - Arguments to delete one Service.
     * @example
     * // Delete one Service
     * const Service = await prisma.service.delete({
     *   where: {
     *     // ... filter to delete one Service
     *   }
     * })
     * 
     */
    delete<T extends ServiceDeleteArgs>(args: SelectSubset<T, ServiceDeleteArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Service.
     * @param {ServiceUpdateArgs} args - Arguments to update one Service.
     * @example
     * // Update one Service
     * const service = await prisma.service.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceUpdateArgs>(args: SelectSubset<T, ServiceUpdateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Services.
     * @param {ServiceDeleteManyArgs} args - Arguments to filter Services to delete.
     * @example
     * // Delete a few Services
     * const { count } = await prisma.service.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceDeleteManyArgs>(args?: SelectSubset<T, ServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceUpdateManyArgs>(args: SelectSubset<T, ServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Service.
     * @param {ServiceUpsertArgs} args - Arguments to update or create a Service.
     * @example
     * // Update or create a Service
     * const service = await prisma.service.upsert({
     *   create: {
     *     // ... data to create a Service
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Service we want to update
     *   }
     * })
     */
    upsert<T extends ServiceUpsertArgs>(args: SelectSubset<T, ServiceUpsertArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCountArgs} args - Arguments to filter Services to count.
     * @example
     * // Count the number of Services
     * const count = await prisma.service.count({
     *   where: {
     *     // ... the filter for the Services we want to count
     *   }
     * })
    **/
    count<T extends ServiceCountArgs>(
      args?: Subset<T, ServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceAggregateArgs>(args: Subset<T, ServiceAggregateArgs>): Prisma.PrismaPromise<GetServiceAggregateType<T>>

    /**
     * Group by Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceGroupByArgs['orderBy'] }
        : { orderBy?: ServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Service model
   */
  readonly fields: ServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Service.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Service$usersArgs<ExtArgs> = {}>(args?: Subset<T, Service$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    customers<T extends Service$customersArgs<ExtArgs> = {}>(args?: Subset<T, Service$customersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany"> | Null>
    employees<T extends Service$employeesArgs<ExtArgs> = {}>(args?: Subset<T, Service$employeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Service model
   */ 
  interface ServiceFieldRefs {
    readonly id: FieldRef<"Service", 'Int'>
    readonly name: FieldRef<"Service", 'String'>
    readonly description: FieldRef<"Service", 'String'>
    readonly createdAt: FieldRef<"Service", 'DateTime'>
    readonly updatedAt: FieldRef<"Service", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Service findUnique
   */
  export type ServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findUniqueOrThrow
   */
  export type ServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findFirst
   */
  export type ServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findFirstOrThrow
   */
  export type ServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findMany
   */
  export type ServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Services to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service create
   */
  export type ServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Service.
     */
    data: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
  }

  /**
   * Service createMany
   */
  export type ServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Service createManyAndReturn
   */
  export type ServiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Service update
   */
  export type ServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Service.
     */
    data: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
    /**
     * Choose, which Service to update.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service updateMany
   */
  export type ServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput
  }

  /**
   * Service upsert
   */
  export type ServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Service to update in case it exists.
     */
    where: ServiceWhereUniqueInput
    /**
     * In case the Service found by the `where` argument doesn't exist, create a new Service with this data.
     */
    create: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
    /**
     * In case the Service was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
  }

  /**
   * Service delete
   */
  export type ServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter which Service to delete.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service deleteMany
   */
  export type ServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Services to delete
     */
    where?: ServiceWhereInput
  }

  /**
   * Service.users
   */
  export type Service$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Service.customers
   */
  export type Service$customersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    cursor?: CustomerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Service.employees
   */
  export type Service$employeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    cursor?: EmployeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Service without action
   */
  export type ServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    serviceId: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    serviceId: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    email: string | null
    passwordHash: string | null
    firstName: string | null
    lastName: string | null
    role: $Enums.UserRole | null
    serviceId: number | null
    isActive: boolean | null
    lastLogin: Date | null
    preferences: string | null
    permissions: string | null
    avatarUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    email: string | null
    passwordHash: string | null
    firstName: string | null
    lastName: string | null
    role: $Enums.UserRole | null
    serviceId: number | null
    isActive: boolean | null
    lastLogin: Date | null
    preferences: string | null
    permissions: string | null
    avatarUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    passwordHash: number
    firstName: number
    lastName: number
    role: number
    serviceId: number
    isActive: number
    lastLogin: number
    preferences: number
    permissions: number
    avatarUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    serviceId?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    serviceId?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    firstName?: true
    lastName?: true
    role?: true
    serviceId?: true
    isActive?: true
    lastLogin?: true
    preferences?: true
    permissions?: true
    avatarUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    firstName?: true
    lastName?: true
    role?: true
    serviceId?: true
    isActive?: true
    lastLogin?: true
    preferences?: true
    permissions?: true
    avatarUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    firstName?: true
    lastName?: true
    role?: true
    serviceId?: true
    isActive?: true
    lastLogin?: true
    preferences?: true
    permissions?: true
    avatarUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    serviceId: number | null
    isActive: boolean
    lastLogin: Date | null
    preferences: string | null
    permissions: string | null
    avatarUrl: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    role?: boolean
    serviceId?: boolean
    isActive?: boolean
    lastLogin?: boolean
    preferences?: boolean
    permissions?: boolean
    avatarUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    service?: boolean | User$serviceArgs<ExtArgs>
    createdCustomers?: boolean | User$createdCustomersArgs<ExtArgs>
    createdQuotes?: boolean | User$createdQuotesArgs<ExtArgs>
    createdInvoices?: boolean | User$createdInvoicesArgs<ExtArgs>
    createdPayments?: boolean | User$createdPaymentsArgs<ExtArgs>
    serviceApprovals?: boolean | User$serviceApprovalsArgs<ExtArgs>
    dgApprovals?: boolean | User$dgApprovalsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    quoteApprovals?: boolean | User$quoteApprovalsArgs<ExtArgs>
    createdExpenses?: boolean | User$createdExpensesArgs<ExtArgs>
    accountingEntries?: boolean | User$accountingEntriesArgs<ExtArgs>
    cashFlowEntries?: boolean | User$cashFlowEntriesArgs<ExtArgs>
    createdReminders?: boolean | User$createdRemindersArgs<ExtArgs>
    createdRecurringInvoices?: boolean | User$createdRecurringInvoicesArgs<ExtArgs>
    employee?: boolean | User$employeeArgs<ExtArgs>
    leaveApprovals?: boolean | User$leaveApprovalsArgs<ExtArgs>
    assignedProspects?: boolean | User$assignedProspectsArgs<ExtArgs>
    createdProspects?: boolean | User$createdProspectsArgs<ExtArgs>
    createdProspectActivities?: boolean | User$createdProspectActivitiesArgs<ExtArgs>
    technicien?: boolean | User$technicienArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    role?: boolean
    serviceId?: boolean
    isActive?: boolean
    lastLogin?: boolean
    preferences?: boolean
    permissions?: boolean
    avatarUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    service?: boolean | User$serviceArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    role?: boolean
    serviceId?: boolean
    isActive?: boolean
    lastLogin?: boolean
    preferences?: boolean
    permissions?: boolean
    avatarUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | User$serviceArgs<ExtArgs>
    createdCustomers?: boolean | User$createdCustomersArgs<ExtArgs>
    createdQuotes?: boolean | User$createdQuotesArgs<ExtArgs>
    createdInvoices?: boolean | User$createdInvoicesArgs<ExtArgs>
    createdPayments?: boolean | User$createdPaymentsArgs<ExtArgs>
    serviceApprovals?: boolean | User$serviceApprovalsArgs<ExtArgs>
    dgApprovals?: boolean | User$dgApprovalsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    quoteApprovals?: boolean | User$quoteApprovalsArgs<ExtArgs>
    createdExpenses?: boolean | User$createdExpensesArgs<ExtArgs>
    accountingEntries?: boolean | User$accountingEntriesArgs<ExtArgs>
    cashFlowEntries?: boolean | User$cashFlowEntriesArgs<ExtArgs>
    createdReminders?: boolean | User$createdRemindersArgs<ExtArgs>
    createdRecurringInvoices?: boolean | User$createdRecurringInvoicesArgs<ExtArgs>
    employee?: boolean | User$employeeArgs<ExtArgs>
    leaveApprovals?: boolean | User$leaveApprovalsArgs<ExtArgs>
    assignedProspects?: boolean | User$assignedProspectsArgs<ExtArgs>
    createdProspects?: boolean | User$createdProspectsArgs<ExtArgs>
    createdProspectActivities?: boolean | User$createdProspectActivitiesArgs<ExtArgs>
    technicien?: boolean | User$technicienArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | User$serviceArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      service: Prisma.$ServicePayload<ExtArgs> | null
      createdCustomers: Prisma.$CustomerPayload<ExtArgs>[]
      createdQuotes: Prisma.$QuotePayload<ExtArgs>[]
      createdInvoices: Prisma.$InvoicePayload<ExtArgs>[]
      createdPayments: Prisma.$PaymentPayload<ExtArgs>[]
      serviceApprovals: Prisma.$QuotePayload<ExtArgs>[]
      dgApprovals: Prisma.$QuotePayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      quoteApprovals: Prisma.$QuoteApprovalPayload<ExtArgs>[]
      createdExpenses: Prisma.$ExpensePayload<ExtArgs>[]
      accountingEntries: Prisma.$AccountingEntryPayload<ExtArgs>[]
      cashFlowEntries: Prisma.$CashFlowPayload<ExtArgs>[]
      createdReminders: Prisma.$ReminderPayload<ExtArgs>[]
      createdRecurringInvoices: Prisma.$RecurringInvoicePayload<ExtArgs>[]
      employee: Prisma.$EmployeePayload<ExtArgs> | null
      leaveApprovals: Prisma.$LeaveRequestPayload<ExtArgs>[]
      assignedProspects: Prisma.$ProspectPayload<ExtArgs>[]
      createdProspects: Prisma.$ProspectPayload<ExtArgs>[]
      createdProspectActivities: Prisma.$ProspectActivityPayload<ExtArgs>[]
      technicien: Prisma.$TechnicienPayload<ExtArgs> | null
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      passwordHash: string
      firstName: string
      lastName: string
      role: $Enums.UserRole
      serviceId: number | null
      isActive: boolean
      lastLogin: Date | null
      preferences: string | null
      permissions: string | null
      avatarUrl: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    service<T extends User$serviceArgs<ExtArgs> = {}>(args?: Subset<T, User$serviceArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    createdCustomers<T extends User$createdCustomersArgs<ExtArgs> = {}>(args?: Subset<T, User$createdCustomersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany"> | Null>
    createdQuotes<T extends User$createdQuotesArgs<ExtArgs> = {}>(args?: Subset<T, User$createdQuotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "findMany"> | Null>
    createdInvoices<T extends User$createdInvoicesArgs<ExtArgs> = {}>(args?: Subset<T, User$createdInvoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany"> | Null>
    createdPayments<T extends User$createdPaymentsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdPaymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany"> | Null>
    serviceApprovals<T extends User$serviceApprovalsArgs<ExtArgs> = {}>(args?: Subset<T, User$serviceApprovalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "findMany"> | Null>
    dgApprovals<T extends User$dgApprovalsArgs<ExtArgs> = {}>(args?: Subset<T, User$dgApprovalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "findMany"> | Null>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany"> | Null>
    quoteApprovals<T extends User$quoteApprovalsArgs<ExtArgs> = {}>(args?: Subset<T, User$quoteApprovalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuoteApprovalPayload<ExtArgs>, T, "findMany"> | Null>
    createdExpenses<T extends User$createdExpensesArgs<ExtArgs> = {}>(args?: Subset<T, User$createdExpensesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findMany"> | Null>
    accountingEntries<T extends User$accountingEntriesArgs<ExtArgs> = {}>(args?: Subset<T, User$accountingEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountingEntryPayload<ExtArgs>, T, "findMany"> | Null>
    cashFlowEntries<T extends User$cashFlowEntriesArgs<ExtArgs> = {}>(args?: Subset<T, User$cashFlowEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashFlowPayload<ExtArgs>, T, "findMany"> | Null>
    createdReminders<T extends User$createdRemindersArgs<ExtArgs> = {}>(args?: Subset<T, User$createdRemindersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReminderPayload<ExtArgs>, T, "findMany"> | Null>
    createdRecurringInvoices<T extends User$createdRecurringInvoicesArgs<ExtArgs> = {}>(args?: Subset<T, User$createdRecurringInvoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecurringInvoicePayload<ExtArgs>, T, "findMany"> | Null>
    employee<T extends User$employeeArgs<ExtArgs> = {}>(args?: Subset<T, User$employeeArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    leaveApprovals<T extends User$leaveApprovalsArgs<ExtArgs> = {}>(args?: Subset<T, User$leaveApprovalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "findMany"> | Null>
    assignedProspects<T extends User$assignedProspectsArgs<ExtArgs> = {}>(args?: Subset<T, User$assignedProspectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProspectPayload<ExtArgs>, T, "findMany"> | Null>
    createdProspects<T extends User$createdProspectsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdProspectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProspectPayload<ExtArgs>, T, "findMany"> | Null>
    createdProspectActivities<T extends User$createdProspectActivitiesArgs<ExtArgs> = {}>(args?: Subset<T, User$createdProspectActivitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProspectActivityPayload<ExtArgs>, T, "findMany"> | Null>
    technicien<T extends User$technicienArgs<ExtArgs> = {}>(args?: Subset<T, User$technicienArgs<ExtArgs>>): Prisma__TechnicienClient<$Result.GetResult<Prisma.$TechnicienPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly email: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly serviceId: FieldRef<"User", 'Int'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly lastLogin: FieldRef<"User", 'DateTime'>
    readonly preferences: FieldRef<"User", 'String'>
    readonly permissions: FieldRef<"User", 'String'>
    readonly avatarUrl: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.service
   */
  export type User$serviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    where?: ServiceWhereInput
  }

  /**
   * User.createdCustomers
   */
  export type User$createdCustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    cursor?: CustomerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * User.createdQuotes
   */
  export type User$createdQuotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    where?: QuoteWhereInput
    orderBy?: QuoteOrderByWithRelationInput | QuoteOrderByWithRelationInput[]
    cursor?: QuoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuoteScalarFieldEnum | QuoteScalarFieldEnum[]
  }

  /**
   * User.createdInvoices
   */
  export type User$createdInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * User.createdPayments
   */
  export type User$createdPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * User.serviceApprovals
   */
  export type User$serviceApprovalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    where?: QuoteWhereInput
    orderBy?: QuoteOrderByWithRelationInput | QuoteOrderByWithRelationInput[]
    cursor?: QuoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuoteScalarFieldEnum | QuoteScalarFieldEnum[]
  }

  /**
   * User.dgApprovals
   */
  export type User$dgApprovalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    where?: QuoteWhereInput
    orderBy?: QuoteOrderByWithRelationInput | QuoteOrderByWithRelationInput[]
    cursor?: QuoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuoteScalarFieldEnum | QuoteScalarFieldEnum[]
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User.quoteApprovals
   */
  export type User$quoteApprovalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteApproval
     */
    select?: QuoteApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteApprovalInclude<ExtArgs> | null
    where?: QuoteApprovalWhereInput
    orderBy?: QuoteApprovalOrderByWithRelationInput | QuoteApprovalOrderByWithRelationInput[]
    cursor?: QuoteApprovalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuoteApprovalScalarFieldEnum | QuoteApprovalScalarFieldEnum[]
  }

  /**
   * User.createdExpenses
   */
  export type User$createdExpensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    where?: ExpenseWhereInput
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    cursor?: ExpenseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * User.accountingEntries
   */
  export type User$accountingEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountingEntry
     */
    select?: AccountingEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountingEntryInclude<ExtArgs> | null
    where?: AccountingEntryWhereInput
    orderBy?: AccountingEntryOrderByWithRelationInput | AccountingEntryOrderByWithRelationInput[]
    cursor?: AccountingEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountingEntryScalarFieldEnum | AccountingEntryScalarFieldEnum[]
  }

  /**
   * User.cashFlowEntries
   */
  export type User$cashFlowEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashFlow
     */
    select?: CashFlowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashFlowInclude<ExtArgs> | null
    where?: CashFlowWhereInput
    orderBy?: CashFlowOrderByWithRelationInput | CashFlowOrderByWithRelationInput[]
    cursor?: CashFlowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CashFlowScalarFieldEnum | CashFlowScalarFieldEnum[]
  }

  /**
   * User.createdReminders
   */
  export type User$createdRemindersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reminder
     */
    select?: ReminderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReminderInclude<ExtArgs> | null
    where?: ReminderWhereInput
    orderBy?: ReminderOrderByWithRelationInput | ReminderOrderByWithRelationInput[]
    cursor?: ReminderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReminderScalarFieldEnum | ReminderScalarFieldEnum[]
  }

  /**
   * User.createdRecurringInvoices
   */
  export type User$createdRecurringInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringInvoice
     */
    select?: RecurringInvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringInvoiceInclude<ExtArgs> | null
    where?: RecurringInvoiceWhereInput
    orderBy?: RecurringInvoiceOrderByWithRelationInput | RecurringInvoiceOrderByWithRelationInput[]
    cursor?: RecurringInvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecurringInvoiceScalarFieldEnum | RecurringInvoiceScalarFieldEnum[]
  }

  /**
   * User.employee
   */
  export type User$employeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
  }

  /**
   * User.leaveApprovals
   */
  export type User$leaveApprovalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    where?: LeaveRequestWhereInput
    orderBy?: LeaveRequestOrderByWithRelationInput | LeaveRequestOrderByWithRelationInput[]
    cursor?: LeaveRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeaveRequestScalarFieldEnum | LeaveRequestScalarFieldEnum[]
  }

  /**
   * User.assignedProspects
   */
  export type User$assignedProspectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prospect
     */
    select?: ProspectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProspectInclude<ExtArgs> | null
    where?: ProspectWhereInput
    orderBy?: ProspectOrderByWithRelationInput | ProspectOrderByWithRelationInput[]
    cursor?: ProspectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProspectScalarFieldEnum | ProspectScalarFieldEnum[]
  }

  /**
   * User.createdProspects
   */
  export type User$createdProspectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prospect
     */
    select?: ProspectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProspectInclude<ExtArgs> | null
    where?: ProspectWhereInput
    orderBy?: ProspectOrderByWithRelationInput | ProspectOrderByWithRelationInput[]
    cursor?: ProspectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProspectScalarFieldEnum | ProspectScalarFieldEnum[]
  }

  /**
   * User.createdProspectActivities
   */
  export type User$createdProspectActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProspectActivity
     */
    select?: ProspectActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProspectActivityInclude<ExtArgs> | null
    where?: ProspectActivityWhereInput
    orderBy?: ProspectActivityOrderByWithRelationInput | ProspectActivityOrderByWithRelationInput[]
    cursor?: ProspectActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProspectActivityScalarFieldEnum | ProspectActivityScalarFieldEnum[]
  }

  /**
   * User.technicien
   */
  export type User$technicienArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Technicien
     */
    select?: TechnicienSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicienInclude<ExtArgs> | null
    where?: TechnicienWhereInput
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Customer
   */

  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerAvgAggregateOutputType = {
    id: number | null
    paymentTerms: number | null
    creditLimit: number | null
    discountRate: number | null
    serviceId: number | null
    createdBy: number | null
  }

  export type CustomerSumAggregateOutputType = {
    id: number | null
    paymentTerms: number | null
    creditLimit: number | null
    discountRate: number | null
    serviceId: number | null
    createdBy: number | null
  }

  export type CustomerMinAggregateOutputType = {
    id: number | null
    customerNumber: string | null
    type: $Enums.CustomerType | null
    name: string | null
    legalName: string | null
    siret: string | null
    vatNumber: string | null
    email: string | null
    phone: string | null
    mobile: string | null
    website: string | null
    paymentTerms: number | null
    paymentMethod: $Enums.PaymentMethod | null
    creditLimit: number | null
    discountRate: number | null
    category: string | null
    tags: string | null
    notes: string | null
    isActive: boolean | null
    serviceId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: number | null
  }

  export type CustomerMaxAggregateOutputType = {
    id: number | null
    customerNumber: string | null
    type: $Enums.CustomerType | null
    name: string | null
    legalName: string | null
    siret: string | null
    vatNumber: string | null
    email: string | null
    phone: string | null
    mobile: string | null
    website: string | null
    paymentTerms: number | null
    paymentMethod: $Enums.PaymentMethod | null
    creditLimit: number | null
    discountRate: number | null
    category: string | null
    tags: string | null
    notes: string | null
    isActive: boolean | null
    serviceId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: number | null
  }

  export type CustomerCountAggregateOutputType = {
    id: number
    customerNumber: number
    type: number
    name: number
    legalName: number
    siret: number
    vatNumber: number
    email: number
    phone: number
    mobile: number
    website: number
    paymentTerms: number
    paymentMethod: number
    creditLimit: number
    discountRate: number
    category: number
    tags: number
    notes: number
    isActive: number
    serviceId: number
    createdAt: number
    updatedAt: number
    createdBy: number
    _all: number
  }


  export type CustomerAvgAggregateInputType = {
    id?: true
    paymentTerms?: true
    creditLimit?: true
    discountRate?: true
    serviceId?: true
    createdBy?: true
  }

  export type CustomerSumAggregateInputType = {
    id?: true
    paymentTerms?: true
    creditLimit?: true
    discountRate?: true
    serviceId?: true
    createdBy?: true
  }

  export type CustomerMinAggregateInputType = {
    id?: true
    customerNumber?: true
    type?: true
    name?: true
    legalName?: true
    siret?: true
    vatNumber?: true
    email?: true
    phone?: true
    mobile?: true
    website?: true
    paymentTerms?: true
    paymentMethod?: true
    creditLimit?: true
    discountRate?: true
    category?: true
    tags?: true
    notes?: true
    isActive?: true
    serviceId?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
  }

  export type CustomerMaxAggregateInputType = {
    id?: true
    customerNumber?: true
    type?: true
    name?: true
    legalName?: true
    siret?: true
    vatNumber?: true
    email?: true
    phone?: true
    mobile?: true
    website?: true
    paymentTerms?: true
    paymentMethod?: true
    creditLimit?: true
    discountRate?: true
    category?: true
    tags?: true
    notes?: true
    isActive?: true
    serviceId?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
  }

  export type CustomerCountAggregateInputType = {
    id?: true
    customerNumber?: true
    type?: true
    name?: true
    legalName?: true
    siret?: true
    vatNumber?: true
    email?: true
    phone?: true
    mobile?: true
    website?: true
    paymentTerms?: true
    paymentMethod?: true
    creditLimit?: true
    discountRate?: true
    category?: true
    tags?: true
    notes?: true
    isActive?: true
    serviceId?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    _all?: true
  }

  export type CustomerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customer to aggregate.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type CustomerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithAggregationInput | CustomerOrderByWithAggregationInput[]
    by: CustomerScalarFieldEnum[] | CustomerScalarFieldEnum
    having?: CustomerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _avg?: CustomerAvgAggregateInputType
    _sum?: CustomerSumAggregateInputType
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }

  export type CustomerGroupByOutputType = {
    id: number
    customerNumber: string
    type: $Enums.CustomerType
    name: string
    legalName: string | null
    siret: string | null
    vatNumber: string | null
    email: string | null
    phone: string | null
    mobile: string | null
    website: string | null
    paymentTerms: number
    paymentMethod: $Enums.PaymentMethod
    creditLimit: number
    discountRate: number
    category: string | null
    tags: string | null
    notes: string | null
    isActive: boolean
    serviceId: number | null
    createdAt: Date
    updatedAt: Date
    createdBy: number
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends CustomerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type CustomerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerNumber?: boolean
    type?: boolean
    name?: boolean
    legalName?: boolean
    siret?: boolean
    vatNumber?: boolean
    email?: boolean
    phone?: boolean
    mobile?: boolean
    website?: boolean
    paymentTerms?: boolean
    paymentMethod?: boolean
    creditLimit?: boolean
    discountRate?: boolean
    category?: boolean
    tags?: boolean
    notes?: boolean
    isActive?: boolean
    serviceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    service?: boolean | Customer$serviceArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    addresses?: boolean | Customer$addressesArgs<ExtArgs>
    quotes?: boolean | Customer$quotesArgs<ExtArgs>
    invoices?: boolean | Customer$invoicesArgs<ExtArgs>
    payments?: boolean | Customer$paymentsArgs<ExtArgs>
    recurringInvoices?: boolean | Customer$recurringInvoicesArgs<ExtArgs>
    missions?: boolean | Customer$missionsArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerNumber?: boolean
    type?: boolean
    name?: boolean
    legalName?: boolean
    siret?: boolean
    vatNumber?: boolean
    email?: boolean
    phone?: boolean
    mobile?: boolean
    website?: boolean
    paymentTerms?: boolean
    paymentMethod?: boolean
    creditLimit?: boolean
    discountRate?: boolean
    category?: boolean
    tags?: boolean
    notes?: boolean
    isActive?: boolean
    serviceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    service?: boolean | Customer$serviceArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectScalar = {
    id?: boolean
    customerNumber?: boolean
    type?: boolean
    name?: boolean
    legalName?: boolean
    siret?: boolean
    vatNumber?: boolean
    email?: boolean
    phone?: boolean
    mobile?: boolean
    website?: boolean
    paymentTerms?: boolean
    paymentMethod?: boolean
    creditLimit?: boolean
    discountRate?: boolean
    category?: boolean
    tags?: boolean
    notes?: boolean
    isActive?: boolean
    serviceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
  }

  export type CustomerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | Customer$serviceArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    addresses?: boolean | Customer$addressesArgs<ExtArgs>
    quotes?: boolean | Customer$quotesArgs<ExtArgs>
    invoices?: boolean | Customer$invoicesArgs<ExtArgs>
    payments?: boolean | Customer$paymentsArgs<ExtArgs>
    recurringInvoices?: boolean | Customer$recurringInvoicesArgs<ExtArgs>
    missions?: boolean | Customer$missionsArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CustomerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | Customer$serviceArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CustomerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Customer"
    objects: {
      service: Prisma.$ServicePayload<ExtArgs> | null
      creator: Prisma.$UserPayload<ExtArgs>
      addresses: Prisma.$CustomerAddressPayload<ExtArgs>[]
      quotes: Prisma.$QuotePayload<ExtArgs>[]
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      recurringInvoices: Prisma.$RecurringInvoicePayload<ExtArgs>[]
      missions: Prisma.$MissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      customerNumber: string
      type: $Enums.CustomerType
      name: string
      legalName: string | null
      siret: string | null
      vatNumber: string | null
      email: string | null
      phone: string | null
      mobile: string | null
      website: string | null
      paymentTerms: number
      paymentMethod: $Enums.PaymentMethod
      creditLimit: number
      discountRate: number
      category: string | null
      tags: string | null
      notes: string | null
      isActive: boolean
      serviceId: number | null
      createdAt: Date
      updatedAt: Date
      createdBy: number
    }, ExtArgs["result"]["customer"]>
    composites: {}
  }

  type CustomerGetPayload<S extends boolean | null | undefined | CustomerDefaultArgs> = $Result.GetResult<Prisma.$CustomerPayload, S>

  type CustomerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CustomerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CustomerCountAggregateInputType | true
    }

  export interface CustomerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Customer'], meta: { name: 'Customer' } }
    /**
     * Find zero or one Customer that matches the filter.
     * @param {CustomerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerFindUniqueArgs>(args: SelectSubset<T, CustomerFindUniqueArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Customer that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CustomerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerFindFirstArgs>(args?: SelectSubset<T, CustomerFindFirstArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Customer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerWithIdOnly = await prisma.customer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerFindManyArgs>(args?: SelectSubset<T, CustomerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Customer.
     * @param {CustomerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
     */
    create<T extends CustomerCreateArgs>(args: SelectSubset<T, CustomerCreateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Customers.
     * @param {CustomerCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerCreateManyArgs>(args?: SelectSubset<T, CustomerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Customers and returns the data saved in the database.
     * @param {CustomerCreateManyAndReturnArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Customer.
     * @param {CustomerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
     */
    delete<T extends CustomerDeleteArgs>(args: SelectSubset<T, CustomerDeleteArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Customer.
     * @param {CustomerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerUpdateArgs>(args: SelectSubset<T, CustomerUpdateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Customers.
     * @param {CustomerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerDeleteManyArgs>(args?: SelectSubset<T, CustomerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerUpdateManyArgs>(args: SelectSubset<T, CustomerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Customer.
     * @param {CustomerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
     */
    upsert<T extends CustomerUpsertArgs>(args: SelectSubset<T, CustomerUpsertArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomerCountArgs>(
      args?: Subset<T, CustomerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): Prisma.PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerGroupByArgs['orderBy'] }
        : { orderBy?: CustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Customer model
   */
  readonly fields: CustomerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    service<T extends Customer$serviceArgs<ExtArgs> = {}>(args?: Subset<T, Customer$serviceArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    addresses<T extends Customer$addressesArgs<ExtArgs> = {}>(args?: Subset<T, Customer$addressesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerAddressPayload<ExtArgs>, T, "findMany"> | Null>
    quotes<T extends Customer$quotesArgs<ExtArgs> = {}>(args?: Subset<T, Customer$quotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "findMany"> | Null>
    invoices<T extends Customer$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, Customer$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany"> | Null>
    payments<T extends Customer$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany"> | Null>
    recurringInvoices<T extends Customer$recurringInvoicesArgs<ExtArgs> = {}>(args?: Subset<T, Customer$recurringInvoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecurringInvoicePayload<ExtArgs>, T, "findMany"> | Null>
    missions<T extends Customer$missionsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$missionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MissionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Customer model
   */ 
  interface CustomerFieldRefs {
    readonly id: FieldRef<"Customer", 'Int'>
    readonly customerNumber: FieldRef<"Customer", 'String'>
    readonly type: FieldRef<"Customer", 'CustomerType'>
    readonly name: FieldRef<"Customer", 'String'>
    readonly legalName: FieldRef<"Customer", 'String'>
    readonly siret: FieldRef<"Customer", 'String'>
    readonly vatNumber: FieldRef<"Customer", 'String'>
    readonly email: FieldRef<"Customer", 'String'>
    readonly phone: FieldRef<"Customer", 'String'>
    readonly mobile: FieldRef<"Customer", 'String'>
    readonly website: FieldRef<"Customer", 'String'>
    readonly paymentTerms: FieldRef<"Customer", 'Int'>
    readonly paymentMethod: FieldRef<"Customer", 'PaymentMethod'>
    readonly creditLimit: FieldRef<"Customer", 'Float'>
    readonly discountRate: FieldRef<"Customer", 'Float'>
    readonly category: FieldRef<"Customer", 'String'>
    readonly tags: FieldRef<"Customer", 'String'>
    readonly notes: FieldRef<"Customer", 'String'>
    readonly isActive: FieldRef<"Customer", 'Boolean'>
    readonly serviceId: FieldRef<"Customer", 'Int'>
    readonly createdAt: FieldRef<"Customer", 'DateTime'>
    readonly updatedAt: FieldRef<"Customer", 'DateTime'>
    readonly createdBy: FieldRef<"Customer", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Customer findUnique
   */
  export type CustomerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findUniqueOrThrow
   */
  export type CustomerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findFirst
   */
  export type CustomerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findFirstOrThrow
   */
  export type CustomerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findMany
   */
  export type CustomerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer create
   */
  export type CustomerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to create a Customer.
     */
    data: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
  }

  /**
   * Customer createMany
   */
  export type CustomerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Customer createManyAndReturn
   */
  export type CustomerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Customer update
   */
  export type CustomerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to update a Customer.
     */
    data: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
    /**
     * Choose, which Customer to update.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer updateMany
   */
  export type CustomerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
  }

  /**
   * Customer upsert
   */
  export type CustomerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The filter to search for the Customer to update in case it exists.
     */
    where: CustomerWhereUniqueInput
    /**
     * In case the Customer found by the `where` argument doesn't exist, create a new Customer with this data.
     */
    create: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
    /**
     * In case the Customer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
  }

  /**
   * Customer delete
   */
  export type CustomerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter which Customer to delete.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer deleteMany
   */
  export type CustomerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customers to delete
     */
    where?: CustomerWhereInput
  }

  /**
   * Customer.service
   */
  export type Customer$serviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    where?: ServiceWhereInput
  }

  /**
   * Customer.addresses
   */
  export type Customer$addressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressInclude<ExtArgs> | null
    where?: CustomerAddressWhereInput
    orderBy?: CustomerAddressOrderByWithRelationInput | CustomerAddressOrderByWithRelationInput[]
    cursor?: CustomerAddressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerAddressScalarFieldEnum | CustomerAddressScalarFieldEnum[]
  }

  /**
   * Customer.quotes
   */
  export type Customer$quotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    where?: QuoteWhereInput
    orderBy?: QuoteOrderByWithRelationInput | QuoteOrderByWithRelationInput[]
    cursor?: QuoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuoteScalarFieldEnum | QuoteScalarFieldEnum[]
  }

  /**
   * Customer.invoices
   */
  export type Customer$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Customer.payments
   */
  export type Customer$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Customer.recurringInvoices
   */
  export type Customer$recurringInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringInvoice
     */
    select?: RecurringInvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringInvoiceInclude<ExtArgs> | null
    where?: RecurringInvoiceWhereInput
    orderBy?: RecurringInvoiceOrderByWithRelationInput | RecurringInvoiceOrderByWithRelationInput[]
    cursor?: RecurringInvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecurringInvoiceScalarFieldEnum | RecurringInvoiceScalarFieldEnum[]
  }

  /**
   * Customer.missions
   */
  export type Customer$missionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mission
     */
    select?: MissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionInclude<ExtArgs> | null
    where?: MissionWhereInput
    orderBy?: MissionOrderByWithRelationInput | MissionOrderByWithRelationInput[]
    cursor?: MissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MissionScalarFieldEnum | MissionScalarFieldEnum[]
  }

  /**
   * Customer without action
   */
  export type CustomerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
  }


  /**
   * Model CustomerAddress
   */

  export type AggregateCustomerAddress = {
    _count: CustomerAddressCountAggregateOutputType | null
    _avg: CustomerAddressAvgAggregateOutputType | null
    _sum: CustomerAddressSumAggregateOutputType | null
    _min: CustomerAddressMinAggregateOutputType | null
    _max: CustomerAddressMaxAggregateOutputType | null
  }

  export type CustomerAddressAvgAggregateOutputType = {
    id: number | null
    customerId: number | null
  }

  export type CustomerAddressSumAggregateOutputType = {
    id: number | null
    customerId: number | null
  }

  export type CustomerAddressMinAggregateOutputType = {
    id: number | null
    customerId: number | null
    type: $Enums.AddressType | null
    name: string | null
    addressLine1: string | null
    addressLine2: string | null
    postalCode: string | null
    city: string | null
    country: string | null
    isDefault: boolean | null
    createdAt: Date | null
  }

  export type CustomerAddressMaxAggregateOutputType = {
    id: number | null
    customerId: number | null
    type: $Enums.AddressType | null
    name: string | null
    addressLine1: string | null
    addressLine2: string | null
    postalCode: string | null
    city: string | null
    country: string | null
    isDefault: boolean | null
    createdAt: Date | null
  }

  export type CustomerAddressCountAggregateOutputType = {
    id: number
    customerId: number
    type: number
    name: number
    addressLine1: number
    addressLine2: number
    postalCode: number
    city: number
    country: number
    isDefault: number
    createdAt: number
    _all: number
  }


  export type CustomerAddressAvgAggregateInputType = {
    id?: true
    customerId?: true
  }

  export type CustomerAddressSumAggregateInputType = {
    id?: true
    customerId?: true
  }

  export type CustomerAddressMinAggregateInputType = {
    id?: true
    customerId?: true
    type?: true
    name?: true
    addressLine1?: true
    addressLine2?: true
    postalCode?: true
    city?: true
    country?: true
    isDefault?: true
    createdAt?: true
  }

  export type CustomerAddressMaxAggregateInputType = {
    id?: true
    customerId?: true
    type?: true
    name?: true
    addressLine1?: true
    addressLine2?: true
    postalCode?: true
    city?: true
    country?: true
    isDefault?: true
    createdAt?: true
  }

  export type CustomerAddressCountAggregateInputType = {
    id?: true
    customerId?: true
    type?: true
    name?: true
    addressLine1?: true
    addressLine2?: true
    postalCode?: true
    city?: true
    country?: true
    isDefault?: true
    createdAt?: true
    _all?: true
  }

  export type CustomerAddressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerAddress to aggregate.
     */
    where?: CustomerAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerAddresses to fetch.
     */
    orderBy?: CustomerAddressOrderByWithRelationInput | CustomerAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomerAddresses
    **/
    _count?: true | CustomerAddressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerAddressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerAddressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerAddressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerAddressMaxAggregateInputType
  }

  export type GetCustomerAddressAggregateType<T extends CustomerAddressAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerAddress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerAddress[P]>
      : GetScalarType<T[P], AggregateCustomerAddress[P]>
  }




  export type CustomerAddressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerAddressWhereInput
    orderBy?: CustomerAddressOrderByWithAggregationInput | CustomerAddressOrderByWithAggregationInput[]
    by: CustomerAddressScalarFieldEnum[] | CustomerAddressScalarFieldEnum
    having?: CustomerAddressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerAddressCountAggregateInputType | true
    _avg?: CustomerAddressAvgAggregateInputType
    _sum?: CustomerAddressSumAggregateInputType
    _min?: CustomerAddressMinAggregateInputType
    _max?: CustomerAddressMaxAggregateInputType
  }

  export type CustomerAddressGroupByOutputType = {
    id: number
    customerId: number
    type: $Enums.AddressType
    name: string | null
    addressLine1: string
    addressLine2: string | null
    postalCode: string
    city: string
    country: string
    isDefault: boolean
    createdAt: Date
    _count: CustomerAddressCountAggregateOutputType | null
    _avg: CustomerAddressAvgAggregateOutputType | null
    _sum: CustomerAddressSumAggregateOutputType | null
    _min: CustomerAddressMinAggregateOutputType | null
    _max: CustomerAddressMaxAggregateOutputType | null
  }

  type GetCustomerAddressGroupByPayload<T extends CustomerAddressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerAddressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerAddressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerAddressGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerAddressGroupByOutputType[P]>
        }
      >
    >


  export type CustomerAddressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    type?: boolean
    name?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    postalCode?: boolean
    city?: boolean
    country?: boolean
    isDefault?: boolean
    createdAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    quotes?: boolean | CustomerAddress$quotesArgs<ExtArgs>
    invoices?: boolean | CustomerAddress$invoicesArgs<ExtArgs>
    _count?: boolean | CustomerAddressCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerAddress"]>

  export type CustomerAddressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    type?: boolean
    name?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    postalCode?: boolean
    city?: boolean
    country?: boolean
    isDefault?: boolean
    createdAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerAddress"]>

  export type CustomerAddressSelectScalar = {
    id?: boolean
    customerId?: boolean
    type?: boolean
    name?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    postalCode?: boolean
    city?: boolean
    country?: boolean
    isDefault?: boolean
    createdAt?: boolean
  }

  export type CustomerAddressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    quotes?: boolean | CustomerAddress$quotesArgs<ExtArgs>
    invoices?: boolean | CustomerAddress$invoicesArgs<ExtArgs>
    _count?: boolean | CustomerAddressCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CustomerAddressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }

  export type $CustomerAddressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomerAddress"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
      quotes: Prisma.$QuotePayload<ExtArgs>[]
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      customerId: number
      type: $Enums.AddressType
      name: string | null
      addressLine1: string
      addressLine2: string | null
      postalCode: string
      city: string
      country: string
      isDefault: boolean
      createdAt: Date
    }, ExtArgs["result"]["customerAddress"]>
    composites: {}
  }

  type CustomerAddressGetPayload<S extends boolean | null | undefined | CustomerAddressDefaultArgs> = $Result.GetResult<Prisma.$CustomerAddressPayload, S>

  type CustomerAddressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CustomerAddressFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CustomerAddressCountAggregateInputType | true
    }

  export interface CustomerAddressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomerAddress'], meta: { name: 'CustomerAddress' } }
    /**
     * Find zero or one CustomerAddress that matches the filter.
     * @param {CustomerAddressFindUniqueArgs} args - Arguments to find a CustomerAddress
     * @example
     * // Get one CustomerAddress
     * const customerAddress = await prisma.customerAddress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerAddressFindUniqueArgs>(args: SelectSubset<T, CustomerAddressFindUniqueArgs<ExtArgs>>): Prisma__CustomerAddressClient<$Result.GetResult<Prisma.$CustomerAddressPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CustomerAddress that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CustomerAddressFindUniqueOrThrowArgs} args - Arguments to find a CustomerAddress
     * @example
     * // Get one CustomerAddress
     * const customerAddress = await prisma.customerAddress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerAddressFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerAddressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerAddressClient<$Result.GetResult<Prisma.$CustomerAddressPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CustomerAddress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAddressFindFirstArgs} args - Arguments to find a CustomerAddress
     * @example
     * // Get one CustomerAddress
     * const customerAddress = await prisma.customerAddress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerAddressFindFirstArgs>(args?: SelectSubset<T, CustomerAddressFindFirstArgs<ExtArgs>>): Prisma__CustomerAddressClient<$Result.GetResult<Prisma.$CustomerAddressPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CustomerAddress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAddressFindFirstOrThrowArgs} args - Arguments to find a CustomerAddress
     * @example
     * // Get one CustomerAddress
     * const customerAddress = await prisma.customerAddress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerAddressFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerAddressFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerAddressClient<$Result.GetResult<Prisma.$CustomerAddressPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CustomerAddresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAddressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomerAddresses
     * const customerAddresses = await prisma.customerAddress.findMany()
     * 
     * // Get first 10 CustomerAddresses
     * const customerAddresses = await prisma.customerAddress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerAddressWithIdOnly = await prisma.customerAddress.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerAddressFindManyArgs>(args?: SelectSubset<T, CustomerAddressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerAddressPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CustomerAddress.
     * @param {CustomerAddressCreateArgs} args - Arguments to create a CustomerAddress.
     * @example
     * // Create one CustomerAddress
     * const CustomerAddress = await prisma.customerAddress.create({
     *   data: {
     *     // ... data to create a CustomerAddress
     *   }
     * })
     * 
     */
    create<T extends CustomerAddressCreateArgs>(args: SelectSubset<T, CustomerAddressCreateArgs<ExtArgs>>): Prisma__CustomerAddressClient<$Result.GetResult<Prisma.$CustomerAddressPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CustomerAddresses.
     * @param {CustomerAddressCreateManyArgs} args - Arguments to create many CustomerAddresses.
     * @example
     * // Create many CustomerAddresses
     * const customerAddress = await prisma.customerAddress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerAddressCreateManyArgs>(args?: SelectSubset<T, CustomerAddressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CustomerAddresses and returns the data saved in the database.
     * @param {CustomerAddressCreateManyAndReturnArgs} args - Arguments to create many CustomerAddresses.
     * @example
     * // Create many CustomerAddresses
     * const customerAddress = await prisma.customerAddress.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CustomerAddresses and only return the `id`
     * const customerAddressWithIdOnly = await prisma.customerAddress.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerAddressCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerAddressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerAddressPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CustomerAddress.
     * @param {CustomerAddressDeleteArgs} args - Arguments to delete one CustomerAddress.
     * @example
     * // Delete one CustomerAddress
     * const CustomerAddress = await prisma.customerAddress.delete({
     *   where: {
     *     // ... filter to delete one CustomerAddress
     *   }
     * })
     * 
     */
    delete<T extends CustomerAddressDeleteArgs>(args: SelectSubset<T, CustomerAddressDeleteArgs<ExtArgs>>): Prisma__CustomerAddressClient<$Result.GetResult<Prisma.$CustomerAddressPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CustomerAddress.
     * @param {CustomerAddressUpdateArgs} args - Arguments to update one CustomerAddress.
     * @example
     * // Update one CustomerAddress
     * const customerAddress = await prisma.customerAddress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerAddressUpdateArgs>(args: SelectSubset<T, CustomerAddressUpdateArgs<ExtArgs>>): Prisma__CustomerAddressClient<$Result.GetResult<Prisma.$CustomerAddressPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CustomerAddresses.
     * @param {CustomerAddressDeleteManyArgs} args - Arguments to filter CustomerAddresses to delete.
     * @example
     * // Delete a few CustomerAddresses
     * const { count } = await prisma.customerAddress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerAddressDeleteManyArgs>(args?: SelectSubset<T, CustomerAddressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerAddresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAddressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomerAddresses
     * const customerAddress = await prisma.customerAddress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerAddressUpdateManyArgs>(args: SelectSubset<T, CustomerAddressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CustomerAddress.
     * @param {CustomerAddressUpsertArgs} args - Arguments to update or create a CustomerAddress.
     * @example
     * // Update or create a CustomerAddress
     * const customerAddress = await prisma.customerAddress.upsert({
     *   create: {
     *     // ... data to create a CustomerAddress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomerAddress we want to update
     *   }
     * })
     */
    upsert<T extends CustomerAddressUpsertArgs>(args: SelectSubset<T, CustomerAddressUpsertArgs<ExtArgs>>): Prisma__CustomerAddressClient<$Result.GetResult<Prisma.$CustomerAddressPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CustomerAddresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAddressCountArgs} args - Arguments to filter CustomerAddresses to count.
     * @example
     * // Count the number of CustomerAddresses
     * const count = await prisma.customerAddress.count({
     *   where: {
     *     // ... the filter for the CustomerAddresses we want to count
     *   }
     * })
    **/
    count<T extends CustomerAddressCountArgs>(
      args?: Subset<T, CustomerAddressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerAddressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomerAddress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAddressAggregateArgs>(args: Subset<T, CustomerAddressAggregateArgs>): Prisma.PrismaPromise<GetCustomerAddressAggregateType<T>>

    /**
     * Group by CustomerAddress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAddressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerAddressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerAddressGroupByArgs['orderBy'] }
        : { orderBy?: CustomerAddressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerAddressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerAddressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomerAddress model
   */
  readonly fields: CustomerAddressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomerAddress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerAddressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    quotes<T extends CustomerAddress$quotesArgs<ExtArgs> = {}>(args?: Subset<T, CustomerAddress$quotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "findMany"> | Null>
    invoices<T extends CustomerAddress$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, CustomerAddress$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomerAddress model
   */ 
  interface CustomerAddressFieldRefs {
    readonly id: FieldRef<"CustomerAddress", 'Int'>
    readonly customerId: FieldRef<"CustomerAddress", 'Int'>
    readonly type: FieldRef<"CustomerAddress", 'AddressType'>
    readonly name: FieldRef<"CustomerAddress", 'String'>
    readonly addressLine1: FieldRef<"CustomerAddress", 'String'>
    readonly addressLine2: FieldRef<"CustomerAddress", 'String'>
    readonly postalCode: FieldRef<"CustomerAddress", 'String'>
    readonly city: FieldRef<"CustomerAddress", 'String'>
    readonly country: FieldRef<"CustomerAddress", 'String'>
    readonly isDefault: FieldRef<"CustomerAddress", 'Boolean'>
    readonly createdAt: FieldRef<"CustomerAddress", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CustomerAddress findUnique
   */
  export type CustomerAddressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressInclude<ExtArgs> | null
    /**
     * Filter, which CustomerAddress to fetch.
     */
    where: CustomerAddressWhereUniqueInput
  }

  /**
   * CustomerAddress findUniqueOrThrow
   */
  export type CustomerAddressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressInclude<ExtArgs> | null
    /**
     * Filter, which CustomerAddress to fetch.
     */
    where: CustomerAddressWhereUniqueInput
  }

  /**
   * CustomerAddress findFirst
   */
  export type CustomerAddressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressInclude<ExtArgs> | null
    /**
     * Filter, which CustomerAddress to fetch.
     */
    where?: CustomerAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerAddresses to fetch.
     */
    orderBy?: CustomerAddressOrderByWithRelationInput | CustomerAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerAddresses.
     */
    cursor?: CustomerAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerAddresses.
     */
    distinct?: CustomerAddressScalarFieldEnum | CustomerAddressScalarFieldEnum[]
  }

  /**
   * CustomerAddress findFirstOrThrow
   */
  export type CustomerAddressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressInclude<ExtArgs> | null
    /**
     * Filter, which CustomerAddress to fetch.
     */
    where?: CustomerAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerAddresses to fetch.
     */
    orderBy?: CustomerAddressOrderByWithRelationInput | CustomerAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerAddresses.
     */
    cursor?: CustomerAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerAddresses.
     */
    distinct?: CustomerAddressScalarFieldEnum | CustomerAddressScalarFieldEnum[]
  }

  /**
   * CustomerAddress findMany
   */
  export type CustomerAddressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressInclude<ExtArgs> | null
    /**
     * Filter, which CustomerAddresses to fetch.
     */
    where?: CustomerAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerAddresses to fetch.
     */
    orderBy?: CustomerAddressOrderByWithRelationInput | CustomerAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomerAddresses.
     */
    cursor?: CustomerAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerAddresses.
     */
    skip?: number
    distinct?: CustomerAddressScalarFieldEnum | CustomerAddressScalarFieldEnum[]
  }

  /**
   * CustomerAddress create
   */
  export type CustomerAddressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomerAddress.
     */
    data: XOR<CustomerAddressCreateInput, CustomerAddressUncheckedCreateInput>
  }

  /**
   * CustomerAddress createMany
   */
  export type CustomerAddressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomerAddresses.
     */
    data: CustomerAddressCreateManyInput | CustomerAddressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomerAddress createManyAndReturn
   */
  export type CustomerAddressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CustomerAddresses.
     */
    data: CustomerAddressCreateManyInput | CustomerAddressCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomerAddress update
   */
  export type CustomerAddressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomerAddress.
     */
    data: XOR<CustomerAddressUpdateInput, CustomerAddressUncheckedUpdateInput>
    /**
     * Choose, which CustomerAddress to update.
     */
    where: CustomerAddressWhereUniqueInput
  }

  /**
   * CustomerAddress updateMany
   */
  export type CustomerAddressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomerAddresses.
     */
    data: XOR<CustomerAddressUpdateManyMutationInput, CustomerAddressUncheckedUpdateManyInput>
    /**
     * Filter which CustomerAddresses to update
     */
    where?: CustomerAddressWhereInput
  }

  /**
   * CustomerAddress upsert
   */
  export type CustomerAddressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomerAddress to update in case it exists.
     */
    where: CustomerAddressWhereUniqueInput
    /**
     * In case the CustomerAddress found by the `where` argument doesn't exist, create a new CustomerAddress with this data.
     */
    create: XOR<CustomerAddressCreateInput, CustomerAddressUncheckedCreateInput>
    /**
     * In case the CustomerAddress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerAddressUpdateInput, CustomerAddressUncheckedUpdateInput>
  }

  /**
   * CustomerAddress delete
   */
  export type CustomerAddressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressInclude<ExtArgs> | null
    /**
     * Filter which CustomerAddress to delete.
     */
    where: CustomerAddressWhereUniqueInput
  }

  /**
   * CustomerAddress deleteMany
   */
  export type CustomerAddressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerAddresses to delete
     */
    where?: CustomerAddressWhereInput
  }

  /**
   * CustomerAddress.quotes
   */
  export type CustomerAddress$quotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    where?: QuoteWhereInput
    orderBy?: QuoteOrderByWithRelationInput | QuoteOrderByWithRelationInput[]
    cursor?: QuoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuoteScalarFieldEnum | QuoteScalarFieldEnum[]
  }

  /**
   * CustomerAddress.invoices
   */
  export type CustomerAddress$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * CustomerAddress without action
   */
  export type CustomerAddressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressInclude<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    id: number | null
    priceHt: number | null
    vatRate: number | null
    costPrice: number | null
    stockQuantity: number | null
    stockAlertThreshold: number | null
    weight: number | null
  }

  export type ProductSumAggregateOutputType = {
    id: number | null
    priceHt: number | null
    vatRate: number | null
    costPrice: number | null
    stockQuantity: number | null
    stockAlertThreshold: number | null
    weight: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: number | null
    sku: string | null
    name: string | null
    description: string | null
    type: $Enums.ProductType | null
    category: string | null
    unit: string | null
    priceHt: number | null
    vatRate: number | null
    costPrice: number | null
    stockQuantity: number | null
    stockAlertThreshold: number | null
    isActive: boolean | null
    weight: number | null
    dimensions: string | null
    imageUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductMaxAggregateOutputType = {
    id: number | null
    sku: string | null
    name: string | null
    description: string | null
    type: $Enums.ProductType | null
    category: string | null
    unit: string | null
    priceHt: number | null
    vatRate: number | null
    costPrice: number | null
    stockQuantity: number | null
    stockAlertThreshold: number | null
    isActive: boolean | null
    weight: number | null
    dimensions: string | null
    imageUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    sku: number
    name: number
    description: number
    type: number
    category: number
    unit: number
    priceHt: number
    vatRate: number
    costPrice: number
    stockQuantity: number
    stockAlertThreshold: number
    isActive: number
    weight: number
    dimensions: number
    imageUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    id?: true
    priceHt?: true
    vatRate?: true
    costPrice?: true
    stockQuantity?: true
    stockAlertThreshold?: true
    weight?: true
  }

  export type ProductSumAggregateInputType = {
    id?: true
    priceHt?: true
    vatRate?: true
    costPrice?: true
    stockQuantity?: true
    stockAlertThreshold?: true
    weight?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    sku?: true
    name?: true
    description?: true
    type?: true
    category?: true
    unit?: true
    priceHt?: true
    vatRate?: true
    costPrice?: true
    stockQuantity?: true
    stockAlertThreshold?: true
    isActive?: true
    weight?: true
    dimensions?: true
    imageUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    sku?: true
    name?: true
    description?: true
    type?: true
    category?: true
    unit?: true
    priceHt?: true
    vatRate?: true
    costPrice?: true
    stockQuantity?: true
    stockAlertThreshold?: true
    isActive?: true
    weight?: true
    dimensions?: true
    imageUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    sku?: true
    name?: true
    description?: true
    type?: true
    category?: true
    unit?: true
    priceHt?: true
    vatRate?: true
    costPrice?: true
    stockQuantity?: true
    stockAlertThreshold?: true
    isActive?: true
    weight?: true
    dimensions?: true
    imageUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: number
    sku: string
    name: string
    description: string | null
    type: $Enums.ProductType
    category: string | null
    unit: string
    priceHt: number
    vatRate: number
    costPrice: number | null
    stockQuantity: number
    stockAlertThreshold: number
    isActive: boolean
    weight: number | null
    dimensions: string | null
    imageUrl: string | null
    createdAt: Date
    updatedAt: Date
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sku?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    category?: boolean
    unit?: boolean
    priceHt?: boolean
    vatRate?: boolean
    costPrice?: boolean
    stockQuantity?: boolean
    stockAlertThreshold?: boolean
    isActive?: boolean
    weight?: boolean
    dimensions?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    prices?: boolean | Product$pricesArgs<ExtArgs>
    quoteItems?: boolean | Product$quoteItemsArgs<ExtArgs>
    invoiceItems?: boolean | Product$invoiceItemsArgs<ExtArgs>
    recurringInvoiceItems?: boolean | Product$recurringInvoiceItemsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sku?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    category?: boolean
    unit?: boolean
    priceHt?: boolean
    vatRate?: boolean
    costPrice?: boolean
    stockQuantity?: boolean
    stockAlertThreshold?: boolean
    isActive?: boolean
    weight?: boolean
    dimensions?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    id?: boolean
    sku?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    category?: boolean
    unit?: boolean
    priceHt?: boolean
    vatRate?: boolean
    costPrice?: boolean
    stockQuantity?: boolean
    stockAlertThreshold?: boolean
    isActive?: boolean
    weight?: boolean
    dimensions?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prices?: boolean | Product$pricesArgs<ExtArgs>
    quoteItems?: boolean | Product$quoteItemsArgs<ExtArgs>
    invoiceItems?: boolean | Product$invoiceItemsArgs<ExtArgs>
    recurringInvoiceItems?: boolean | Product$recurringInvoiceItemsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      prices: Prisma.$ProductPricePayload<ExtArgs>[]
      quoteItems: Prisma.$QuoteItemPayload<ExtArgs>[]
      invoiceItems: Prisma.$InvoiceItemPayload<ExtArgs>[]
      recurringInvoiceItems: Prisma.$RecurringInvoiceItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      sku: string
      name: string
      description: string | null
      type: $Enums.ProductType
      category: string | null
      unit: string
      priceHt: number
      vatRate: number
      costPrice: number | null
      stockQuantity: number
      stockAlertThreshold: number
      isActive: boolean
      weight: number | null
      dimensions: string | null
      imageUrl: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {ProductCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `id`
     * const productWithIdOnly = await prisma.product.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    prices<T extends Product$pricesArgs<ExtArgs> = {}>(args?: Subset<T, Product$pricesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPricePayload<ExtArgs>, T, "findMany"> | Null>
    quoteItems<T extends Product$quoteItemsArgs<ExtArgs> = {}>(args?: Subset<T, Product$quoteItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuoteItemPayload<ExtArgs>, T, "findMany"> | Null>
    invoiceItems<T extends Product$invoiceItemsArgs<ExtArgs> = {}>(args?: Subset<T, Product$invoiceItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findMany"> | Null>
    recurringInvoiceItems<T extends Product$recurringInvoiceItemsArgs<ExtArgs> = {}>(args?: Subset<T, Product$recurringInvoiceItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecurringInvoiceItemPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */ 
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'Int'>
    readonly sku: FieldRef<"Product", 'String'>
    readonly name: FieldRef<"Product", 'String'>
    readonly description: FieldRef<"Product", 'String'>
    readonly type: FieldRef<"Product", 'ProductType'>
    readonly category: FieldRef<"Product", 'String'>
    readonly unit: FieldRef<"Product", 'String'>
    readonly priceHt: FieldRef<"Product", 'Float'>
    readonly vatRate: FieldRef<"Product", 'Float'>
    readonly costPrice: FieldRef<"Product", 'Float'>
    readonly stockQuantity: FieldRef<"Product", 'Int'>
    readonly stockAlertThreshold: FieldRef<"Product", 'Int'>
    readonly isActive: FieldRef<"Product", 'Boolean'>
    readonly weight: FieldRef<"Product", 'Float'>
    readonly dimensions: FieldRef<"Product", 'String'>
    readonly imageUrl: FieldRef<"Product", 'String'>
    readonly createdAt: FieldRef<"Product", 'DateTime'>
    readonly updatedAt: FieldRef<"Product", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product createManyAndReturn
   */
  export type ProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
  }

  /**
   * Product.prices
   */
  export type Product$pricesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductPrice
     */
    select?: ProductPriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductPriceInclude<ExtArgs> | null
    where?: ProductPriceWhereInput
    orderBy?: ProductPriceOrderByWithRelationInput | ProductPriceOrderByWithRelationInput[]
    cursor?: ProductPriceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductPriceScalarFieldEnum | ProductPriceScalarFieldEnum[]
  }

  /**
   * Product.quoteItems
   */
  export type Product$quoteItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteItem
     */
    select?: QuoteItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteItemInclude<ExtArgs> | null
    where?: QuoteItemWhereInput
    orderBy?: QuoteItemOrderByWithRelationInput | QuoteItemOrderByWithRelationInput[]
    cursor?: QuoteItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuoteItemScalarFieldEnum | QuoteItemScalarFieldEnum[]
  }

  /**
   * Product.invoiceItems
   */
  export type Product$invoiceItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    where?: InvoiceItemWhereInput
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    cursor?: InvoiceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * Product.recurringInvoiceItems
   */
  export type Product$recurringInvoiceItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringInvoiceItem
     */
    select?: RecurringInvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringInvoiceItemInclude<ExtArgs> | null
    where?: RecurringInvoiceItemWhereInput
    orderBy?: RecurringInvoiceItemOrderByWithRelationInput | RecurringInvoiceItemOrderByWithRelationInput[]
    cursor?: RecurringInvoiceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecurringInvoiceItemScalarFieldEnum | RecurringInvoiceItemScalarFieldEnum[]
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model ProductPrice
   */

  export type AggregateProductPrice = {
    _count: ProductPriceCountAggregateOutputType | null
    _avg: ProductPriceAvgAggregateOutputType | null
    _sum: ProductPriceSumAggregateOutputType | null
    _min: ProductPriceMinAggregateOutputType | null
    _max: ProductPriceMaxAggregateOutputType | null
  }

  export type ProductPriceAvgAggregateOutputType = {
    id: number | null
    productId: number | null
    minQuantity: number | null
    priceHt: number | null
  }

  export type ProductPriceSumAggregateOutputType = {
    id: number | null
    productId: number | null
    minQuantity: number | null
    priceHt: number | null
  }

  export type ProductPriceMinAggregateOutputType = {
    id: number | null
    productId: number | null
    customerCategory: string | null
    minQuantity: number | null
    priceHt: number | null
    validFrom: Date | null
    validUntil: Date | null
    createdAt: Date | null
  }

  export type ProductPriceMaxAggregateOutputType = {
    id: number | null
    productId: number | null
    customerCategory: string | null
    minQuantity: number | null
    priceHt: number | null
    validFrom: Date | null
    validUntil: Date | null
    createdAt: Date | null
  }

  export type ProductPriceCountAggregateOutputType = {
    id: number
    productId: number
    customerCategory: number
    minQuantity: number
    priceHt: number
    validFrom: number
    validUntil: number
    createdAt: number
    _all: number
  }


  export type ProductPriceAvgAggregateInputType = {
    id?: true
    productId?: true
    minQuantity?: true
    priceHt?: true
  }

  export type ProductPriceSumAggregateInputType = {
    id?: true
    productId?: true
    minQuantity?: true
    priceHt?: true
  }

  export type ProductPriceMinAggregateInputType = {
    id?: true
    productId?: true
    customerCategory?: true
    minQuantity?: true
    priceHt?: true
    validFrom?: true
    validUntil?: true
    createdAt?: true
  }

  export type ProductPriceMaxAggregateInputType = {
    id?: true
    productId?: true
    customerCategory?: true
    minQuantity?: true
    priceHt?: true
    validFrom?: true
    validUntil?: true
    createdAt?: true
  }

  export type ProductPriceCountAggregateInputType = {
    id?: true
    productId?: true
    customerCategory?: true
    minQuantity?: true
    priceHt?: true
    validFrom?: true
    validUntil?: true
    createdAt?: true
    _all?: true
  }

  export type ProductPriceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductPrice to aggregate.
     */
    where?: ProductPriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductPrices to fetch.
     */
    orderBy?: ProductPriceOrderByWithRelationInput | ProductPriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductPriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductPrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductPrices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductPrices
    **/
    _count?: true | ProductPriceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductPriceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductPriceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductPriceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductPriceMaxAggregateInputType
  }

  export type GetProductPriceAggregateType<T extends ProductPriceAggregateArgs> = {
        [P in keyof T & keyof AggregateProductPrice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductPrice[P]>
      : GetScalarType<T[P], AggregateProductPrice[P]>
  }




  export type ProductPriceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductPriceWhereInput
    orderBy?: ProductPriceOrderByWithAggregationInput | ProductPriceOrderByWithAggregationInput[]
    by: ProductPriceScalarFieldEnum[] | ProductPriceScalarFieldEnum
    having?: ProductPriceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductPriceCountAggregateInputType | true
    _avg?: ProductPriceAvgAggregateInputType
    _sum?: ProductPriceSumAggregateInputType
    _min?: ProductPriceMinAggregateInputType
    _max?: ProductPriceMaxAggregateInputType
  }

  export type ProductPriceGroupByOutputType = {
    id: number
    productId: number
    customerCategory: string | null
    minQuantity: number
    priceHt: number
    validFrom: Date | null
    validUntil: Date | null
    createdAt: Date
    _count: ProductPriceCountAggregateOutputType | null
    _avg: ProductPriceAvgAggregateOutputType | null
    _sum: ProductPriceSumAggregateOutputType | null
    _min: ProductPriceMinAggregateOutputType | null
    _max: ProductPriceMaxAggregateOutputType | null
  }

  type GetProductPriceGroupByPayload<T extends ProductPriceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductPriceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductPriceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductPriceGroupByOutputType[P]>
            : GetScalarType<T[P], ProductPriceGroupByOutputType[P]>
        }
      >
    >


  export type ProductPriceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    customerCategory?: boolean
    minQuantity?: boolean
    priceHt?: boolean
    validFrom?: boolean
    validUntil?: boolean
    createdAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productPrice"]>

  export type ProductPriceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    customerCategory?: boolean
    minQuantity?: boolean
    priceHt?: boolean
    validFrom?: boolean
    validUntil?: boolean
    createdAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productPrice"]>

  export type ProductPriceSelectScalar = {
    id?: boolean
    productId?: boolean
    customerCategory?: boolean
    minQuantity?: boolean
    priceHt?: boolean
    validFrom?: boolean
    validUntil?: boolean
    createdAt?: boolean
  }

  export type ProductPriceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ProductPriceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $ProductPricePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductPrice"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      productId: number
      customerCategory: string | null
      minQuantity: number
      priceHt: number
      validFrom: Date | null
      validUntil: Date | null
      createdAt: Date
    }, ExtArgs["result"]["productPrice"]>
    composites: {}
  }

  type ProductPriceGetPayload<S extends boolean | null | undefined | ProductPriceDefaultArgs> = $Result.GetResult<Prisma.$ProductPricePayload, S>

  type ProductPriceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProductPriceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProductPriceCountAggregateInputType | true
    }

  export interface ProductPriceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductPrice'], meta: { name: 'ProductPrice' } }
    /**
     * Find zero or one ProductPrice that matches the filter.
     * @param {ProductPriceFindUniqueArgs} args - Arguments to find a ProductPrice
     * @example
     * // Get one ProductPrice
     * const productPrice = await prisma.productPrice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductPriceFindUniqueArgs>(args: SelectSubset<T, ProductPriceFindUniqueArgs<ExtArgs>>): Prisma__ProductPriceClient<$Result.GetResult<Prisma.$ProductPricePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProductPrice that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProductPriceFindUniqueOrThrowArgs} args - Arguments to find a ProductPrice
     * @example
     * // Get one ProductPrice
     * const productPrice = await prisma.productPrice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductPriceFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductPriceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductPriceClient<$Result.GetResult<Prisma.$ProductPricePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProductPrice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductPriceFindFirstArgs} args - Arguments to find a ProductPrice
     * @example
     * // Get one ProductPrice
     * const productPrice = await prisma.productPrice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductPriceFindFirstArgs>(args?: SelectSubset<T, ProductPriceFindFirstArgs<ExtArgs>>): Prisma__ProductPriceClient<$Result.GetResult<Prisma.$ProductPricePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProductPrice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductPriceFindFirstOrThrowArgs} args - Arguments to find a ProductPrice
     * @example
     * // Get one ProductPrice
     * const productPrice = await prisma.productPrice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductPriceFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductPriceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductPriceClient<$Result.GetResult<Prisma.$ProductPricePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProductPrices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductPriceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductPrices
     * const productPrices = await prisma.productPrice.findMany()
     * 
     * // Get first 10 ProductPrices
     * const productPrices = await prisma.productPrice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productPriceWithIdOnly = await prisma.productPrice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductPriceFindManyArgs>(args?: SelectSubset<T, ProductPriceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPricePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProductPrice.
     * @param {ProductPriceCreateArgs} args - Arguments to create a ProductPrice.
     * @example
     * // Create one ProductPrice
     * const ProductPrice = await prisma.productPrice.create({
     *   data: {
     *     // ... data to create a ProductPrice
     *   }
     * })
     * 
     */
    create<T extends ProductPriceCreateArgs>(args: SelectSubset<T, ProductPriceCreateArgs<ExtArgs>>): Prisma__ProductPriceClient<$Result.GetResult<Prisma.$ProductPricePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProductPrices.
     * @param {ProductPriceCreateManyArgs} args - Arguments to create many ProductPrices.
     * @example
     * // Create many ProductPrices
     * const productPrice = await prisma.productPrice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductPriceCreateManyArgs>(args?: SelectSubset<T, ProductPriceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductPrices and returns the data saved in the database.
     * @param {ProductPriceCreateManyAndReturnArgs} args - Arguments to create many ProductPrices.
     * @example
     * // Create many ProductPrices
     * const productPrice = await prisma.productPrice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductPrices and only return the `id`
     * const productPriceWithIdOnly = await prisma.productPrice.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductPriceCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductPriceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPricePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProductPrice.
     * @param {ProductPriceDeleteArgs} args - Arguments to delete one ProductPrice.
     * @example
     * // Delete one ProductPrice
     * const ProductPrice = await prisma.productPrice.delete({
     *   where: {
     *     // ... filter to delete one ProductPrice
     *   }
     * })
     * 
     */
    delete<T extends ProductPriceDeleteArgs>(args: SelectSubset<T, ProductPriceDeleteArgs<ExtArgs>>): Prisma__ProductPriceClient<$Result.GetResult<Prisma.$ProductPricePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProductPrice.
     * @param {ProductPriceUpdateArgs} args - Arguments to update one ProductPrice.
     * @example
     * // Update one ProductPrice
     * const productPrice = await prisma.productPrice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductPriceUpdateArgs>(args: SelectSubset<T, ProductPriceUpdateArgs<ExtArgs>>): Prisma__ProductPriceClient<$Result.GetResult<Prisma.$ProductPricePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProductPrices.
     * @param {ProductPriceDeleteManyArgs} args - Arguments to filter ProductPrices to delete.
     * @example
     * // Delete a few ProductPrices
     * const { count } = await prisma.productPrice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductPriceDeleteManyArgs>(args?: SelectSubset<T, ProductPriceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductPrices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductPriceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductPrices
     * const productPrice = await prisma.productPrice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductPriceUpdateManyArgs>(args: SelectSubset<T, ProductPriceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductPrice.
     * @param {ProductPriceUpsertArgs} args - Arguments to update or create a ProductPrice.
     * @example
     * // Update or create a ProductPrice
     * const productPrice = await prisma.productPrice.upsert({
     *   create: {
     *     // ... data to create a ProductPrice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductPrice we want to update
     *   }
     * })
     */
    upsert<T extends ProductPriceUpsertArgs>(args: SelectSubset<T, ProductPriceUpsertArgs<ExtArgs>>): Prisma__ProductPriceClient<$Result.GetResult<Prisma.$ProductPricePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProductPrices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductPriceCountArgs} args - Arguments to filter ProductPrices to count.
     * @example
     * // Count the number of ProductPrices
     * const count = await prisma.productPrice.count({
     *   where: {
     *     // ... the filter for the ProductPrices we want to count
     *   }
     * })
    **/
    count<T extends ProductPriceCountArgs>(
      args?: Subset<T, ProductPriceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductPriceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductPrice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductPriceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductPriceAggregateArgs>(args: Subset<T, ProductPriceAggregateArgs>): Prisma.PrismaPromise<GetProductPriceAggregateType<T>>

    /**
     * Group by ProductPrice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductPriceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductPriceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductPriceGroupByArgs['orderBy'] }
        : { orderBy?: ProductPriceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductPriceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductPriceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductPrice model
   */
  readonly fields: ProductPriceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductPrice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductPriceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductPrice model
   */ 
  interface ProductPriceFieldRefs {
    readonly id: FieldRef<"ProductPrice", 'Int'>
    readonly productId: FieldRef<"ProductPrice", 'Int'>
    readonly customerCategory: FieldRef<"ProductPrice", 'String'>
    readonly minQuantity: FieldRef<"ProductPrice", 'Int'>
    readonly priceHt: FieldRef<"ProductPrice", 'Float'>
    readonly validFrom: FieldRef<"ProductPrice", 'DateTime'>
    readonly validUntil: FieldRef<"ProductPrice", 'DateTime'>
    readonly createdAt: FieldRef<"ProductPrice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductPrice findUnique
   */
  export type ProductPriceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductPrice
     */
    select?: ProductPriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductPriceInclude<ExtArgs> | null
    /**
     * Filter, which ProductPrice to fetch.
     */
    where: ProductPriceWhereUniqueInput
  }

  /**
   * ProductPrice findUniqueOrThrow
   */
  export type ProductPriceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductPrice
     */
    select?: ProductPriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductPriceInclude<ExtArgs> | null
    /**
     * Filter, which ProductPrice to fetch.
     */
    where: ProductPriceWhereUniqueInput
  }

  /**
   * ProductPrice findFirst
   */
  export type ProductPriceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductPrice
     */
    select?: ProductPriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductPriceInclude<ExtArgs> | null
    /**
     * Filter, which ProductPrice to fetch.
     */
    where?: ProductPriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductPrices to fetch.
     */
    orderBy?: ProductPriceOrderByWithRelationInput | ProductPriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductPrices.
     */
    cursor?: ProductPriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductPrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductPrices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductPrices.
     */
    distinct?: ProductPriceScalarFieldEnum | ProductPriceScalarFieldEnum[]
  }

  /**
   * ProductPrice findFirstOrThrow
   */
  export type ProductPriceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductPrice
     */
    select?: ProductPriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductPriceInclude<ExtArgs> | null
    /**
     * Filter, which ProductPrice to fetch.
     */
    where?: ProductPriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductPrices to fetch.
     */
    orderBy?: ProductPriceOrderByWithRelationInput | ProductPriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductPrices.
     */
    cursor?: ProductPriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductPrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductPrices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductPrices.
     */
    distinct?: ProductPriceScalarFieldEnum | ProductPriceScalarFieldEnum[]
  }

  /**
   * ProductPrice findMany
   */
  export type ProductPriceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductPrice
     */
    select?: ProductPriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductPriceInclude<ExtArgs> | null
    /**
     * Filter, which ProductPrices to fetch.
     */
    where?: ProductPriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductPrices to fetch.
     */
    orderBy?: ProductPriceOrderByWithRelationInput | ProductPriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductPrices.
     */
    cursor?: ProductPriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductPrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductPrices.
     */
    skip?: number
    distinct?: ProductPriceScalarFieldEnum | ProductPriceScalarFieldEnum[]
  }

  /**
   * ProductPrice create
   */
  export type ProductPriceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductPrice
     */
    select?: ProductPriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductPriceInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductPrice.
     */
    data: XOR<ProductPriceCreateInput, ProductPriceUncheckedCreateInput>
  }

  /**
   * ProductPrice createMany
   */
  export type ProductPriceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductPrices.
     */
    data: ProductPriceCreateManyInput | ProductPriceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductPrice createManyAndReturn
   */
  export type ProductPriceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductPrice
     */
    select?: ProductPriceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProductPrices.
     */
    data: ProductPriceCreateManyInput | ProductPriceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductPriceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductPrice update
   */
  export type ProductPriceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductPrice
     */
    select?: ProductPriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductPriceInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductPrice.
     */
    data: XOR<ProductPriceUpdateInput, ProductPriceUncheckedUpdateInput>
    /**
     * Choose, which ProductPrice to update.
     */
    where: ProductPriceWhereUniqueInput
  }

  /**
   * ProductPrice updateMany
   */
  export type ProductPriceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductPrices.
     */
    data: XOR<ProductPriceUpdateManyMutationInput, ProductPriceUncheckedUpdateManyInput>
    /**
     * Filter which ProductPrices to update
     */
    where?: ProductPriceWhereInput
  }

  /**
   * ProductPrice upsert
   */
  export type ProductPriceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductPrice
     */
    select?: ProductPriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductPriceInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductPrice to update in case it exists.
     */
    where: ProductPriceWhereUniqueInput
    /**
     * In case the ProductPrice found by the `where` argument doesn't exist, create a new ProductPrice with this data.
     */
    create: XOR<ProductPriceCreateInput, ProductPriceUncheckedCreateInput>
    /**
     * In case the ProductPrice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductPriceUpdateInput, ProductPriceUncheckedUpdateInput>
  }

  /**
   * ProductPrice delete
   */
  export type ProductPriceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductPrice
     */
    select?: ProductPriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductPriceInclude<ExtArgs> | null
    /**
     * Filter which ProductPrice to delete.
     */
    where: ProductPriceWhereUniqueInput
  }

  /**
   * ProductPrice deleteMany
   */
  export type ProductPriceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductPrices to delete
     */
    where?: ProductPriceWhereInput
  }

  /**
   * ProductPrice without action
   */
  export type ProductPriceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductPrice
     */
    select?: ProductPriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductPriceInclude<ExtArgs> | null
  }


  /**
   * Model Quote
   */

  export type AggregateQuote = {
    _count: QuoteCountAggregateOutputType | null
    _avg: QuoteAvgAggregateOutputType | null
    _sum: QuoteSumAggregateOutputType | null
    _min: QuoteMinAggregateOutputType | null
    _max: QuoteMaxAggregateOutputType | null
  }

  export type QuoteAvgAggregateOutputType = {
    id: number | null
    customerId: number | null
    customerAddressId: number | null
    subtotalHt: number | null
    discountAmount: number | null
    totalVat: number | null
    totalTtc: number | null
    createdBy: number | null
    serviceManagerApprovedBy: number | null
    dgApprovedBy: number | null
  }

  export type QuoteSumAggregateOutputType = {
    id: number | null
    customerId: number | null
    customerAddressId: number | null
    subtotalHt: number | null
    discountAmount: number | null
    totalVat: number | null
    totalTtc: number | null
    createdBy: number | null
    serviceManagerApprovedBy: number | null
    dgApprovedBy: number | null
  }

  export type QuoteMinAggregateOutputType = {
    id: number | null
    quoteNumber: string | null
    customerId: number | null
    customerAddressId: number | null
    status: $Enums.QuoteStatus | null
    quoteDate: Date | null
    validUntil: Date | null
    subtotalHt: number | null
    discountAmount: number | null
    totalVat: number | null
    totalTtc: number | null
    terms: string | null
    notes: string | null
    createdBy: number | null
    createdAt: Date | null
    updatedAt: Date | null
    sentAt: Date | null
    submittedForServiceApprovalAt: Date | null
    serviceManagerApprovedBy: number | null
    serviceManagerApprovalDate: Date | null
    serviceManagerComments: string | null
    dgApprovedBy: number | null
    dgApprovalDate: Date | null
    dgComments: string | null
    acceptedAt: Date | null
  }

  export type QuoteMaxAggregateOutputType = {
    id: number | null
    quoteNumber: string | null
    customerId: number | null
    customerAddressId: number | null
    status: $Enums.QuoteStatus | null
    quoteDate: Date | null
    validUntil: Date | null
    subtotalHt: number | null
    discountAmount: number | null
    totalVat: number | null
    totalTtc: number | null
    terms: string | null
    notes: string | null
    createdBy: number | null
    createdAt: Date | null
    updatedAt: Date | null
    sentAt: Date | null
    submittedForServiceApprovalAt: Date | null
    serviceManagerApprovedBy: number | null
    serviceManagerApprovalDate: Date | null
    serviceManagerComments: string | null
    dgApprovedBy: number | null
    dgApprovalDate: Date | null
    dgComments: string | null
    acceptedAt: Date | null
  }

  export type QuoteCountAggregateOutputType = {
    id: number
    quoteNumber: number
    customerId: number
    customerAddressId: number
    status: number
    quoteDate: number
    validUntil: number
    subtotalHt: number
    discountAmount: number
    totalVat: number
    totalTtc: number
    terms: number
    notes: number
    createdBy: number
    createdAt: number
    updatedAt: number
    sentAt: number
    submittedForServiceApprovalAt: number
    serviceManagerApprovedBy: number
    serviceManagerApprovalDate: number
    serviceManagerComments: number
    dgApprovedBy: number
    dgApprovalDate: number
    dgComments: number
    acceptedAt: number
    _all: number
  }


  export type QuoteAvgAggregateInputType = {
    id?: true
    customerId?: true
    customerAddressId?: true
    subtotalHt?: true
    discountAmount?: true
    totalVat?: true
    totalTtc?: true
    createdBy?: true
    serviceManagerApprovedBy?: true
    dgApprovedBy?: true
  }

  export type QuoteSumAggregateInputType = {
    id?: true
    customerId?: true
    customerAddressId?: true
    subtotalHt?: true
    discountAmount?: true
    totalVat?: true
    totalTtc?: true
    createdBy?: true
    serviceManagerApprovedBy?: true
    dgApprovedBy?: true
  }

  export type QuoteMinAggregateInputType = {
    id?: true
    quoteNumber?: true
    customerId?: true
    customerAddressId?: true
    status?: true
    quoteDate?: true
    validUntil?: true
    subtotalHt?: true
    discountAmount?: true
    totalVat?: true
    totalTtc?: true
    terms?: true
    notes?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    sentAt?: true
    submittedForServiceApprovalAt?: true
    serviceManagerApprovedBy?: true
    serviceManagerApprovalDate?: true
    serviceManagerComments?: true
    dgApprovedBy?: true
    dgApprovalDate?: true
    dgComments?: true
    acceptedAt?: true
  }

  export type QuoteMaxAggregateInputType = {
    id?: true
    quoteNumber?: true
    customerId?: true
    customerAddressId?: true
    status?: true
    quoteDate?: true
    validUntil?: true
    subtotalHt?: true
    discountAmount?: true
    totalVat?: true
    totalTtc?: true
    terms?: true
    notes?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    sentAt?: true
    submittedForServiceApprovalAt?: true
    serviceManagerApprovedBy?: true
    serviceManagerApprovalDate?: true
    serviceManagerComments?: true
    dgApprovedBy?: true
    dgApprovalDate?: true
    dgComments?: true
    acceptedAt?: true
  }

  export type QuoteCountAggregateInputType = {
    id?: true
    quoteNumber?: true
    customerId?: true
    customerAddressId?: true
    status?: true
    quoteDate?: true
    validUntil?: true
    subtotalHt?: true
    discountAmount?: true
    totalVat?: true
    totalTtc?: true
    terms?: true
    notes?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    sentAt?: true
    submittedForServiceApprovalAt?: true
    serviceManagerApprovedBy?: true
    serviceManagerApprovalDate?: true
    serviceManagerComments?: true
    dgApprovedBy?: true
    dgApprovalDate?: true
    dgComments?: true
    acceptedAt?: true
    _all?: true
  }

  export type QuoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Quote to aggregate.
     */
    where?: QuoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quotes to fetch.
     */
    orderBy?: QuoteOrderByWithRelationInput | QuoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Quotes
    **/
    _count?: true | QuoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuoteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuoteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuoteMaxAggregateInputType
  }

  export type GetQuoteAggregateType<T extends QuoteAggregateArgs> = {
        [P in keyof T & keyof AggregateQuote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuote[P]>
      : GetScalarType<T[P], AggregateQuote[P]>
  }




  export type QuoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuoteWhereInput
    orderBy?: QuoteOrderByWithAggregationInput | QuoteOrderByWithAggregationInput[]
    by: QuoteScalarFieldEnum[] | QuoteScalarFieldEnum
    having?: QuoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuoteCountAggregateInputType | true
    _avg?: QuoteAvgAggregateInputType
    _sum?: QuoteSumAggregateInputType
    _min?: QuoteMinAggregateInputType
    _max?: QuoteMaxAggregateInputType
  }

  export type QuoteGroupByOutputType = {
    id: number
    quoteNumber: string
    customerId: number
    customerAddressId: number | null
    status: $Enums.QuoteStatus
    quoteDate: Date
    validUntil: Date
    subtotalHt: number
    discountAmount: number
    totalVat: number
    totalTtc: number
    terms: string | null
    notes: string | null
    createdBy: number
    createdAt: Date
    updatedAt: Date
    sentAt: Date | null
    submittedForServiceApprovalAt: Date | null
    serviceManagerApprovedBy: number | null
    serviceManagerApprovalDate: Date | null
    serviceManagerComments: string | null
    dgApprovedBy: number | null
    dgApprovalDate: Date | null
    dgComments: string | null
    acceptedAt: Date | null
    _count: QuoteCountAggregateOutputType | null
    _avg: QuoteAvgAggregateOutputType | null
    _sum: QuoteSumAggregateOutputType | null
    _min: QuoteMinAggregateOutputType | null
    _max: QuoteMaxAggregateOutputType | null
  }

  type GetQuoteGroupByPayload<T extends QuoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuoteGroupByOutputType[P]>
            : GetScalarType<T[P], QuoteGroupByOutputType[P]>
        }
      >
    >


  export type QuoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quoteNumber?: boolean
    customerId?: boolean
    customerAddressId?: boolean
    status?: boolean
    quoteDate?: boolean
    validUntil?: boolean
    subtotalHt?: boolean
    discountAmount?: boolean
    totalVat?: boolean
    totalTtc?: boolean
    terms?: boolean
    notes?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sentAt?: boolean
    submittedForServiceApprovalAt?: boolean
    serviceManagerApprovedBy?: boolean
    serviceManagerApprovalDate?: boolean
    serviceManagerComments?: boolean
    dgApprovedBy?: boolean
    dgApprovalDate?: boolean
    dgComments?: boolean
    acceptedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    customerAddress?: boolean | Quote$customerAddressArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    serviceManager?: boolean | Quote$serviceManagerArgs<ExtArgs>
    dgApprover?: boolean | Quote$dgApproverArgs<ExtArgs>
    items?: boolean | Quote$itemsArgs<ExtArgs>
    invoices?: boolean | Quote$invoicesArgs<ExtArgs>
    approvals?: boolean | Quote$approvalsArgs<ExtArgs>
    missions?: boolean | Quote$missionsArgs<ExtArgs>
    _count?: boolean | QuoteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quote"]>

  export type QuoteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quoteNumber?: boolean
    customerId?: boolean
    customerAddressId?: boolean
    status?: boolean
    quoteDate?: boolean
    validUntil?: boolean
    subtotalHt?: boolean
    discountAmount?: boolean
    totalVat?: boolean
    totalTtc?: boolean
    terms?: boolean
    notes?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sentAt?: boolean
    submittedForServiceApprovalAt?: boolean
    serviceManagerApprovedBy?: boolean
    serviceManagerApprovalDate?: boolean
    serviceManagerComments?: boolean
    dgApprovedBy?: boolean
    dgApprovalDate?: boolean
    dgComments?: boolean
    acceptedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    customerAddress?: boolean | Quote$customerAddressArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    serviceManager?: boolean | Quote$serviceManagerArgs<ExtArgs>
    dgApprover?: boolean | Quote$dgApproverArgs<ExtArgs>
  }, ExtArgs["result"]["quote"]>

  export type QuoteSelectScalar = {
    id?: boolean
    quoteNumber?: boolean
    customerId?: boolean
    customerAddressId?: boolean
    status?: boolean
    quoteDate?: boolean
    validUntil?: boolean
    subtotalHt?: boolean
    discountAmount?: boolean
    totalVat?: boolean
    totalTtc?: boolean
    terms?: boolean
    notes?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sentAt?: boolean
    submittedForServiceApprovalAt?: boolean
    serviceManagerApprovedBy?: boolean
    serviceManagerApprovalDate?: boolean
    serviceManagerComments?: boolean
    dgApprovedBy?: boolean
    dgApprovalDate?: boolean
    dgComments?: boolean
    acceptedAt?: boolean
  }

  export type QuoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    customerAddress?: boolean | Quote$customerAddressArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    serviceManager?: boolean | Quote$serviceManagerArgs<ExtArgs>
    dgApprover?: boolean | Quote$dgApproverArgs<ExtArgs>
    items?: boolean | Quote$itemsArgs<ExtArgs>
    invoices?: boolean | Quote$invoicesArgs<ExtArgs>
    approvals?: boolean | Quote$approvalsArgs<ExtArgs>
    missions?: boolean | Quote$missionsArgs<ExtArgs>
    _count?: boolean | QuoteCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type QuoteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    customerAddress?: boolean | Quote$customerAddressArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    serviceManager?: boolean | Quote$serviceManagerArgs<ExtArgs>
    dgApprover?: boolean | Quote$dgApproverArgs<ExtArgs>
  }

  export type $QuotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Quote"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
      customerAddress: Prisma.$CustomerAddressPayload<ExtArgs> | null
      creator: Prisma.$UserPayload<ExtArgs>
      serviceManager: Prisma.$UserPayload<ExtArgs> | null
      dgApprover: Prisma.$UserPayload<ExtArgs> | null
      items: Prisma.$QuoteItemPayload<ExtArgs>[]
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
      approvals: Prisma.$QuoteApprovalPayload<ExtArgs>[]
      missions: Prisma.$MissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      quoteNumber: string
      customerId: number
      customerAddressId: number | null
      status: $Enums.QuoteStatus
      quoteDate: Date
      validUntil: Date
      subtotalHt: number
      discountAmount: number
      totalVat: number
      totalTtc: number
      terms: string | null
      notes: string | null
      createdBy: number
      createdAt: Date
      updatedAt: Date
      sentAt: Date | null
      submittedForServiceApprovalAt: Date | null
      serviceManagerApprovedBy: number | null
      serviceManagerApprovalDate: Date | null
      serviceManagerComments: string | null
      dgApprovedBy: number | null
      dgApprovalDate: Date | null
      dgComments: string | null
      acceptedAt: Date | null
    }, ExtArgs["result"]["quote"]>
    composites: {}
  }

  type QuoteGetPayload<S extends boolean | null | undefined | QuoteDefaultArgs> = $Result.GetResult<Prisma.$QuotePayload, S>

  type QuoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<QuoteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: QuoteCountAggregateInputType | true
    }

  export interface QuoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Quote'], meta: { name: 'Quote' } }
    /**
     * Find zero or one Quote that matches the filter.
     * @param {QuoteFindUniqueArgs} args - Arguments to find a Quote
     * @example
     * // Get one Quote
     * const quote = await prisma.quote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuoteFindUniqueArgs>(args: SelectSubset<T, QuoteFindUniqueArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Quote that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {QuoteFindUniqueOrThrowArgs} args - Arguments to find a Quote
     * @example
     * // Get one Quote
     * const quote = await prisma.quote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuoteFindUniqueOrThrowArgs>(args: SelectSubset<T, QuoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Quote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteFindFirstArgs} args - Arguments to find a Quote
     * @example
     * // Get one Quote
     * const quote = await prisma.quote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuoteFindFirstArgs>(args?: SelectSubset<T, QuoteFindFirstArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Quote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteFindFirstOrThrowArgs} args - Arguments to find a Quote
     * @example
     * // Get one Quote
     * const quote = await prisma.quote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuoteFindFirstOrThrowArgs>(args?: SelectSubset<T, QuoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Quotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Quotes
     * const quotes = await prisma.quote.findMany()
     * 
     * // Get first 10 Quotes
     * const quotes = await prisma.quote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quoteWithIdOnly = await prisma.quote.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuoteFindManyArgs>(args?: SelectSubset<T, QuoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Quote.
     * @param {QuoteCreateArgs} args - Arguments to create a Quote.
     * @example
     * // Create one Quote
     * const Quote = await prisma.quote.create({
     *   data: {
     *     // ... data to create a Quote
     *   }
     * })
     * 
     */
    create<T extends QuoteCreateArgs>(args: SelectSubset<T, QuoteCreateArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Quotes.
     * @param {QuoteCreateManyArgs} args - Arguments to create many Quotes.
     * @example
     * // Create many Quotes
     * const quote = await prisma.quote.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuoteCreateManyArgs>(args?: SelectSubset<T, QuoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Quotes and returns the data saved in the database.
     * @param {QuoteCreateManyAndReturnArgs} args - Arguments to create many Quotes.
     * @example
     * // Create many Quotes
     * const quote = await prisma.quote.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Quotes and only return the `id`
     * const quoteWithIdOnly = await prisma.quote.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuoteCreateManyAndReturnArgs>(args?: SelectSubset<T, QuoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Quote.
     * @param {QuoteDeleteArgs} args - Arguments to delete one Quote.
     * @example
     * // Delete one Quote
     * const Quote = await prisma.quote.delete({
     *   where: {
     *     // ... filter to delete one Quote
     *   }
     * })
     * 
     */
    delete<T extends QuoteDeleteArgs>(args: SelectSubset<T, QuoteDeleteArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Quote.
     * @param {QuoteUpdateArgs} args - Arguments to update one Quote.
     * @example
     * // Update one Quote
     * const quote = await prisma.quote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuoteUpdateArgs>(args: SelectSubset<T, QuoteUpdateArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Quotes.
     * @param {QuoteDeleteManyArgs} args - Arguments to filter Quotes to delete.
     * @example
     * // Delete a few Quotes
     * const { count } = await prisma.quote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuoteDeleteManyArgs>(args?: SelectSubset<T, QuoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Quotes
     * const quote = await prisma.quote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuoteUpdateManyArgs>(args: SelectSubset<T, QuoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Quote.
     * @param {QuoteUpsertArgs} args - Arguments to update or create a Quote.
     * @example
     * // Update or create a Quote
     * const quote = await prisma.quote.upsert({
     *   create: {
     *     // ... data to create a Quote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Quote we want to update
     *   }
     * })
     */
    upsert<T extends QuoteUpsertArgs>(args: SelectSubset<T, QuoteUpsertArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Quotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteCountArgs} args - Arguments to filter Quotes to count.
     * @example
     * // Count the number of Quotes
     * const count = await prisma.quote.count({
     *   where: {
     *     // ... the filter for the Quotes we want to count
     *   }
     * })
    **/
    count<T extends QuoteCountArgs>(
      args?: Subset<T, QuoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Quote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuoteAggregateArgs>(args: Subset<T, QuoteAggregateArgs>): Prisma.PrismaPromise<GetQuoteAggregateType<T>>

    /**
     * Group by Quote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuoteGroupByArgs['orderBy'] }
        : { orderBy?: QuoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Quote model
   */
  readonly fields: QuoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Quote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    customerAddress<T extends Quote$customerAddressArgs<ExtArgs> = {}>(args?: Subset<T, Quote$customerAddressArgs<ExtArgs>>): Prisma__CustomerAddressClient<$Result.GetResult<Prisma.$CustomerAddressPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    serviceManager<T extends Quote$serviceManagerArgs<ExtArgs> = {}>(args?: Subset<T, Quote$serviceManagerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    dgApprover<T extends Quote$dgApproverArgs<ExtArgs> = {}>(args?: Subset<T, Quote$dgApproverArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    items<T extends Quote$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Quote$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuoteItemPayload<ExtArgs>, T, "findMany"> | Null>
    invoices<T extends Quote$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, Quote$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany"> | Null>
    approvals<T extends Quote$approvalsArgs<ExtArgs> = {}>(args?: Subset<T, Quote$approvalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuoteApprovalPayload<ExtArgs>, T, "findMany"> | Null>
    missions<T extends Quote$missionsArgs<ExtArgs> = {}>(args?: Subset<T, Quote$missionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MissionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Quote model
   */ 
  interface QuoteFieldRefs {
    readonly id: FieldRef<"Quote", 'Int'>
    readonly quoteNumber: FieldRef<"Quote", 'String'>
    readonly customerId: FieldRef<"Quote", 'Int'>
    readonly customerAddressId: FieldRef<"Quote", 'Int'>
    readonly status: FieldRef<"Quote", 'QuoteStatus'>
    readonly quoteDate: FieldRef<"Quote", 'DateTime'>
    readonly validUntil: FieldRef<"Quote", 'DateTime'>
    readonly subtotalHt: FieldRef<"Quote", 'Float'>
    readonly discountAmount: FieldRef<"Quote", 'Float'>
    readonly totalVat: FieldRef<"Quote", 'Float'>
    readonly totalTtc: FieldRef<"Quote", 'Float'>
    readonly terms: FieldRef<"Quote", 'String'>
    readonly notes: FieldRef<"Quote", 'String'>
    readonly createdBy: FieldRef<"Quote", 'Int'>
    readonly createdAt: FieldRef<"Quote", 'DateTime'>
    readonly updatedAt: FieldRef<"Quote", 'DateTime'>
    readonly sentAt: FieldRef<"Quote", 'DateTime'>
    readonly submittedForServiceApprovalAt: FieldRef<"Quote", 'DateTime'>
    readonly serviceManagerApprovedBy: FieldRef<"Quote", 'Int'>
    readonly serviceManagerApprovalDate: FieldRef<"Quote", 'DateTime'>
    readonly serviceManagerComments: FieldRef<"Quote", 'String'>
    readonly dgApprovedBy: FieldRef<"Quote", 'Int'>
    readonly dgApprovalDate: FieldRef<"Quote", 'DateTime'>
    readonly dgComments: FieldRef<"Quote", 'String'>
    readonly acceptedAt: FieldRef<"Quote", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Quote findUnique
   */
  export type QuoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    /**
     * Filter, which Quote to fetch.
     */
    where: QuoteWhereUniqueInput
  }

  /**
   * Quote findUniqueOrThrow
   */
  export type QuoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    /**
     * Filter, which Quote to fetch.
     */
    where: QuoteWhereUniqueInput
  }

  /**
   * Quote findFirst
   */
  export type QuoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    /**
     * Filter, which Quote to fetch.
     */
    where?: QuoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quotes to fetch.
     */
    orderBy?: QuoteOrderByWithRelationInput | QuoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Quotes.
     */
    cursor?: QuoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Quotes.
     */
    distinct?: QuoteScalarFieldEnum | QuoteScalarFieldEnum[]
  }

  /**
   * Quote findFirstOrThrow
   */
  export type QuoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    /**
     * Filter, which Quote to fetch.
     */
    where?: QuoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quotes to fetch.
     */
    orderBy?: QuoteOrderByWithRelationInput | QuoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Quotes.
     */
    cursor?: QuoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Quotes.
     */
    distinct?: QuoteScalarFieldEnum | QuoteScalarFieldEnum[]
  }

  /**
   * Quote findMany
   */
  export type QuoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    /**
     * Filter, which Quotes to fetch.
     */
    where?: QuoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quotes to fetch.
     */
    orderBy?: QuoteOrderByWithRelationInput | QuoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Quotes.
     */
    cursor?: QuoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quotes.
     */
    skip?: number
    distinct?: QuoteScalarFieldEnum | QuoteScalarFieldEnum[]
  }

  /**
   * Quote create
   */
  export type QuoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    /**
     * The data needed to create a Quote.
     */
    data: XOR<QuoteCreateInput, QuoteUncheckedCreateInput>
  }

  /**
   * Quote createMany
   */
  export type QuoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Quotes.
     */
    data: QuoteCreateManyInput | QuoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Quote createManyAndReturn
   */
  export type QuoteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Quotes.
     */
    data: QuoteCreateManyInput | QuoteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Quote update
   */
  export type QuoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    /**
     * The data needed to update a Quote.
     */
    data: XOR<QuoteUpdateInput, QuoteUncheckedUpdateInput>
    /**
     * Choose, which Quote to update.
     */
    where: QuoteWhereUniqueInput
  }

  /**
   * Quote updateMany
   */
  export type QuoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Quotes.
     */
    data: XOR<QuoteUpdateManyMutationInput, QuoteUncheckedUpdateManyInput>
    /**
     * Filter which Quotes to update
     */
    where?: QuoteWhereInput
  }

  /**
   * Quote upsert
   */
  export type QuoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    /**
     * The filter to search for the Quote to update in case it exists.
     */
    where: QuoteWhereUniqueInput
    /**
     * In case the Quote found by the `where` argument doesn't exist, create a new Quote with this data.
     */
    create: XOR<QuoteCreateInput, QuoteUncheckedCreateInput>
    /**
     * In case the Quote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuoteUpdateInput, QuoteUncheckedUpdateInput>
  }

  /**
   * Quote delete
   */
  export type QuoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    /**
     * Filter which Quote to delete.
     */
    where: QuoteWhereUniqueInput
  }

  /**
   * Quote deleteMany
   */
  export type QuoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Quotes to delete
     */
    where?: QuoteWhereInput
  }

  /**
   * Quote.customerAddress
   */
  export type Quote$customerAddressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressInclude<ExtArgs> | null
    where?: CustomerAddressWhereInput
  }

  /**
   * Quote.serviceManager
   */
  export type Quote$serviceManagerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Quote.dgApprover
   */
  export type Quote$dgApproverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Quote.items
   */
  export type Quote$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteItem
     */
    select?: QuoteItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteItemInclude<ExtArgs> | null
    where?: QuoteItemWhereInput
    orderBy?: QuoteItemOrderByWithRelationInput | QuoteItemOrderByWithRelationInput[]
    cursor?: QuoteItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuoteItemScalarFieldEnum | QuoteItemScalarFieldEnum[]
  }

  /**
   * Quote.invoices
   */
  export type Quote$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Quote.approvals
   */
  export type Quote$approvalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteApproval
     */
    select?: QuoteApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteApprovalInclude<ExtArgs> | null
    where?: QuoteApprovalWhereInput
    orderBy?: QuoteApprovalOrderByWithRelationInput | QuoteApprovalOrderByWithRelationInput[]
    cursor?: QuoteApprovalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuoteApprovalScalarFieldEnum | QuoteApprovalScalarFieldEnum[]
  }

  /**
   * Quote.missions
   */
  export type Quote$missionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mission
     */
    select?: MissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionInclude<ExtArgs> | null
    where?: MissionWhereInput
    orderBy?: MissionOrderByWithRelationInput | MissionOrderByWithRelationInput[]
    cursor?: MissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MissionScalarFieldEnum | MissionScalarFieldEnum[]
  }

  /**
   * Quote without action
   */
  export type QuoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
  }


  /**
   * Model QuoteItem
   */

  export type AggregateQuoteItem = {
    _count: QuoteItemCountAggregateOutputType | null
    _avg: QuoteItemAvgAggregateOutputType | null
    _sum: QuoteItemSumAggregateOutputType | null
    _min: QuoteItemMinAggregateOutputType | null
    _max: QuoteItemMaxAggregateOutputType | null
  }

  export type QuoteItemAvgAggregateOutputType = {
    id: number | null
    quoteId: number | null
    productId: number | null
    quantity: number | null
    unitPriceHt: number | null
    discountRate: number | null
    vatRate: number | null
    totalHt: number | null
    sortOrder: number | null
  }

  export type QuoteItemSumAggregateOutputType = {
    id: number | null
    quoteId: number | null
    productId: number | null
    quantity: number | null
    unitPriceHt: number | null
    discountRate: number | null
    vatRate: number | null
    totalHt: number | null
    sortOrder: number | null
  }

  export type QuoteItemMinAggregateOutputType = {
    id: number | null
    quoteId: number | null
    productId: number | null
    description: string | null
    quantity: number | null
    unitPriceHt: number | null
    discountRate: number | null
    vatRate: number | null
    totalHt: number | null
    sortOrder: number | null
  }

  export type QuoteItemMaxAggregateOutputType = {
    id: number | null
    quoteId: number | null
    productId: number | null
    description: string | null
    quantity: number | null
    unitPriceHt: number | null
    discountRate: number | null
    vatRate: number | null
    totalHt: number | null
    sortOrder: number | null
  }

  export type QuoteItemCountAggregateOutputType = {
    id: number
    quoteId: number
    productId: number
    description: number
    quantity: number
    unitPriceHt: number
    discountRate: number
    vatRate: number
    totalHt: number
    sortOrder: number
    _all: number
  }


  export type QuoteItemAvgAggregateInputType = {
    id?: true
    quoteId?: true
    productId?: true
    quantity?: true
    unitPriceHt?: true
    discountRate?: true
    vatRate?: true
    totalHt?: true
    sortOrder?: true
  }

  export type QuoteItemSumAggregateInputType = {
    id?: true
    quoteId?: true
    productId?: true
    quantity?: true
    unitPriceHt?: true
    discountRate?: true
    vatRate?: true
    totalHt?: true
    sortOrder?: true
  }

  export type QuoteItemMinAggregateInputType = {
    id?: true
    quoteId?: true
    productId?: true
    description?: true
    quantity?: true
    unitPriceHt?: true
    discountRate?: true
    vatRate?: true
    totalHt?: true
    sortOrder?: true
  }

  export type QuoteItemMaxAggregateInputType = {
    id?: true
    quoteId?: true
    productId?: true
    description?: true
    quantity?: true
    unitPriceHt?: true
    discountRate?: true
    vatRate?: true
    totalHt?: true
    sortOrder?: true
  }

  export type QuoteItemCountAggregateInputType = {
    id?: true
    quoteId?: true
    productId?: true
    description?: true
    quantity?: true
    unitPriceHt?: true
    discountRate?: true
    vatRate?: true
    totalHt?: true
    sortOrder?: true
    _all?: true
  }

  export type QuoteItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuoteItem to aggregate.
     */
    where?: QuoteItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuoteItems to fetch.
     */
    orderBy?: QuoteItemOrderByWithRelationInput | QuoteItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuoteItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuoteItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuoteItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuoteItems
    **/
    _count?: true | QuoteItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuoteItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuoteItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuoteItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuoteItemMaxAggregateInputType
  }

  export type GetQuoteItemAggregateType<T extends QuoteItemAggregateArgs> = {
        [P in keyof T & keyof AggregateQuoteItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuoteItem[P]>
      : GetScalarType<T[P], AggregateQuoteItem[P]>
  }




  export type QuoteItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuoteItemWhereInput
    orderBy?: QuoteItemOrderByWithAggregationInput | QuoteItemOrderByWithAggregationInput[]
    by: QuoteItemScalarFieldEnum[] | QuoteItemScalarFieldEnum
    having?: QuoteItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuoteItemCountAggregateInputType | true
    _avg?: QuoteItemAvgAggregateInputType
    _sum?: QuoteItemSumAggregateInputType
    _min?: QuoteItemMinAggregateInputType
    _max?: QuoteItemMaxAggregateInputType
  }

  export type QuoteItemGroupByOutputType = {
    id: number
    quoteId: number
    productId: number | null
    description: string
    quantity: number
    unitPriceHt: number
    discountRate: number
    vatRate: number
    totalHt: number
    sortOrder: number
    _count: QuoteItemCountAggregateOutputType | null
    _avg: QuoteItemAvgAggregateOutputType | null
    _sum: QuoteItemSumAggregateOutputType | null
    _min: QuoteItemMinAggregateOutputType | null
    _max: QuoteItemMaxAggregateOutputType | null
  }

  type GetQuoteItemGroupByPayload<T extends QuoteItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuoteItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuoteItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuoteItemGroupByOutputType[P]>
            : GetScalarType<T[P], QuoteItemGroupByOutputType[P]>
        }
      >
    >


  export type QuoteItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quoteId?: boolean
    productId?: boolean
    description?: boolean
    quantity?: boolean
    unitPriceHt?: boolean
    discountRate?: boolean
    vatRate?: boolean
    totalHt?: boolean
    sortOrder?: boolean
    quote?: boolean | QuoteDefaultArgs<ExtArgs>
    product?: boolean | QuoteItem$productArgs<ExtArgs>
  }, ExtArgs["result"]["quoteItem"]>

  export type QuoteItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quoteId?: boolean
    productId?: boolean
    description?: boolean
    quantity?: boolean
    unitPriceHt?: boolean
    discountRate?: boolean
    vatRate?: boolean
    totalHt?: boolean
    sortOrder?: boolean
    quote?: boolean | QuoteDefaultArgs<ExtArgs>
    product?: boolean | QuoteItem$productArgs<ExtArgs>
  }, ExtArgs["result"]["quoteItem"]>

  export type QuoteItemSelectScalar = {
    id?: boolean
    quoteId?: boolean
    productId?: boolean
    description?: boolean
    quantity?: boolean
    unitPriceHt?: boolean
    discountRate?: boolean
    vatRate?: boolean
    totalHt?: boolean
    sortOrder?: boolean
  }

  export type QuoteItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quote?: boolean | QuoteDefaultArgs<ExtArgs>
    product?: boolean | QuoteItem$productArgs<ExtArgs>
  }
  export type QuoteItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quote?: boolean | QuoteDefaultArgs<ExtArgs>
    product?: boolean | QuoteItem$productArgs<ExtArgs>
  }

  export type $QuoteItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuoteItem"
    objects: {
      quote: Prisma.$QuotePayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      quoteId: number
      productId: number | null
      description: string
      quantity: number
      unitPriceHt: number
      discountRate: number
      vatRate: number
      totalHt: number
      sortOrder: number
    }, ExtArgs["result"]["quoteItem"]>
    composites: {}
  }

  type QuoteItemGetPayload<S extends boolean | null | undefined | QuoteItemDefaultArgs> = $Result.GetResult<Prisma.$QuoteItemPayload, S>

  type QuoteItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<QuoteItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: QuoteItemCountAggregateInputType | true
    }

  export interface QuoteItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuoteItem'], meta: { name: 'QuoteItem' } }
    /**
     * Find zero or one QuoteItem that matches the filter.
     * @param {QuoteItemFindUniqueArgs} args - Arguments to find a QuoteItem
     * @example
     * // Get one QuoteItem
     * const quoteItem = await prisma.quoteItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuoteItemFindUniqueArgs>(args: SelectSubset<T, QuoteItemFindUniqueArgs<ExtArgs>>): Prisma__QuoteItemClient<$Result.GetResult<Prisma.$QuoteItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one QuoteItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {QuoteItemFindUniqueOrThrowArgs} args - Arguments to find a QuoteItem
     * @example
     * // Get one QuoteItem
     * const quoteItem = await prisma.quoteItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuoteItemFindUniqueOrThrowArgs>(args: SelectSubset<T, QuoteItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuoteItemClient<$Result.GetResult<Prisma.$QuoteItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first QuoteItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteItemFindFirstArgs} args - Arguments to find a QuoteItem
     * @example
     * // Get one QuoteItem
     * const quoteItem = await prisma.quoteItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuoteItemFindFirstArgs>(args?: SelectSubset<T, QuoteItemFindFirstArgs<ExtArgs>>): Prisma__QuoteItemClient<$Result.GetResult<Prisma.$QuoteItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first QuoteItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteItemFindFirstOrThrowArgs} args - Arguments to find a QuoteItem
     * @example
     * // Get one QuoteItem
     * const quoteItem = await prisma.quoteItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuoteItemFindFirstOrThrowArgs>(args?: SelectSubset<T, QuoteItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuoteItemClient<$Result.GetResult<Prisma.$QuoteItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more QuoteItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuoteItems
     * const quoteItems = await prisma.quoteItem.findMany()
     * 
     * // Get first 10 QuoteItems
     * const quoteItems = await prisma.quoteItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quoteItemWithIdOnly = await prisma.quoteItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuoteItemFindManyArgs>(args?: SelectSubset<T, QuoteItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuoteItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a QuoteItem.
     * @param {QuoteItemCreateArgs} args - Arguments to create a QuoteItem.
     * @example
     * // Create one QuoteItem
     * const QuoteItem = await prisma.quoteItem.create({
     *   data: {
     *     // ... data to create a QuoteItem
     *   }
     * })
     * 
     */
    create<T extends QuoteItemCreateArgs>(args: SelectSubset<T, QuoteItemCreateArgs<ExtArgs>>): Prisma__QuoteItemClient<$Result.GetResult<Prisma.$QuoteItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many QuoteItems.
     * @param {QuoteItemCreateManyArgs} args - Arguments to create many QuoteItems.
     * @example
     * // Create many QuoteItems
     * const quoteItem = await prisma.quoteItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuoteItemCreateManyArgs>(args?: SelectSubset<T, QuoteItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuoteItems and returns the data saved in the database.
     * @param {QuoteItemCreateManyAndReturnArgs} args - Arguments to create many QuoteItems.
     * @example
     * // Create many QuoteItems
     * const quoteItem = await prisma.quoteItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuoteItems and only return the `id`
     * const quoteItemWithIdOnly = await prisma.quoteItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuoteItemCreateManyAndReturnArgs>(args?: SelectSubset<T, QuoteItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuoteItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a QuoteItem.
     * @param {QuoteItemDeleteArgs} args - Arguments to delete one QuoteItem.
     * @example
     * // Delete one QuoteItem
     * const QuoteItem = await prisma.quoteItem.delete({
     *   where: {
     *     // ... filter to delete one QuoteItem
     *   }
     * })
     * 
     */
    delete<T extends QuoteItemDeleteArgs>(args: SelectSubset<T, QuoteItemDeleteArgs<ExtArgs>>): Prisma__QuoteItemClient<$Result.GetResult<Prisma.$QuoteItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one QuoteItem.
     * @param {QuoteItemUpdateArgs} args - Arguments to update one QuoteItem.
     * @example
     * // Update one QuoteItem
     * const quoteItem = await prisma.quoteItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuoteItemUpdateArgs>(args: SelectSubset<T, QuoteItemUpdateArgs<ExtArgs>>): Prisma__QuoteItemClient<$Result.GetResult<Prisma.$QuoteItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more QuoteItems.
     * @param {QuoteItemDeleteManyArgs} args - Arguments to filter QuoteItems to delete.
     * @example
     * // Delete a few QuoteItems
     * const { count } = await prisma.quoteItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuoteItemDeleteManyArgs>(args?: SelectSubset<T, QuoteItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuoteItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuoteItems
     * const quoteItem = await prisma.quoteItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuoteItemUpdateManyArgs>(args: SelectSubset<T, QuoteItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one QuoteItem.
     * @param {QuoteItemUpsertArgs} args - Arguments to update or create a QuoteItem.
     * @example
     * // Update or create a QuoteItem
     * const quoteItem = await prisma.quoteItem.upsert({
     *   create: {
     *     // ... data to create a QuoteItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuoteItem we want to update
     *   }
     * })
     */
    upsert<T extends QuoteItemUpsertArgs>(args: SelectSubset<T, QuoteItemUpsertArgs<ExtArgs>>): Prisma__QuoteItemClient<$Result.GetResult<Prisma.$QuoteItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of QuoteItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteItemCountArgs} args - Arguments to filter QuoteItems to count.
     * @example
     * // Count the number of QuoteItems
     * const count = await prisma.quoteItem.count({
     *   where: {
     *     // ... the filter for the QuoteItems we want to count
     *   }
     * })
    **/
    count<T extends QuoteItemCountArgs>(
      args?: Subset<T, QuoteItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuoteItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuoteItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuoteItemAggregateArgs>(args: Subset<T, QuoteItemAggregateArgs>): Prisma.PrismaPromise<GetQuoteItemAggregateType<T>>

    /**
     * Group by QuoteItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuoteItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuoteItemGroupByArgs['orderBy'] }
        : { orderBy?: QuoteItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuoteItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuoteItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuoteItem model
   */
  readonly fields: QuoteItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuoteItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuoteItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    quote<T extends QuoteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuoteDefaultArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    product<T extends QuoteItem$productArgs<ExtArgs> = {}>(args?: Subset<T, QuoteItem$productArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuoteItem model
   */ 
  interface QuoteItemFieldRefs {
    readonly id: FieldRef<"QuoteItem", 'Int'>
    readonly quoteId: FieldRef<"QuoteItem", 'Int'>
    readonly productId: FieldRef<"QuoteItem", 'Int'>
    readonly description: FieldRef<"QuoteItem", 'String'>
    readonly quantity: FieldRef<"QuoteItem", 'Float'>
    readonly unitPriceHt: FieldRef<"QuoteItem", 'Float'>
    readonly discountRate: FieldRef<"QuoteItem", 'Float'>
    readonly vatRate: FieldRef<"QuoteItem", 'Float'>
    readonly totalHt: FieldRef<"QuoteItem", 'Float'>
    readonly sortOrder: FieldRef<"QuoteItem", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * QuoteItem findUnique
   */
  export type QuoteItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteItem
     */
    select?: QuoteItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteItemInclude<ExtArgs> | null
    /**
     * Filter, which QuoteItem to fetch.
     */
    where: QuoteItemWhereUniqueInput
  }

  /**
   * QuoteItem findUniqueOrThrow
   */
  export type QuoteItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteItem
     */
    select?: QuoteItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteItemInclude<ExtArgs> | null
    /**
     * Filter, which QuoteItem to fetch.
     */
    where: QuoteItemWhereUniqueInput
  }

  /**
   * QuoteItem findFirst
   */
  export type QuoteItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteItem
     */
    select?: QuoteItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteItemInclude<ExtArgs> | null
    /**
     * Filter, which QuoteItem to fetch.
     */
    where?: QuoteItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuoteItems to fetch.
     */
    orderBy?: QuoteItemOrderByWithRelationInput | QuoteItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuoteItems.
     */
    cursor?: QuoteItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuoteItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuoteItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuoteItems.
     */
    distinct?: QuoteItemScalarFieldEnum | QuoteItemScalarFieldEnum[]
  }

  /**
   * QuoteItem findFirstOrThrow
   */
  export type QuoteItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteItem
     */
    select?: QuoteItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteItemInclude<ExtArgs> | null
    /**
     * Filter, which QuoteItem to fetch.
     */
    where?: QuoteItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuoteItems to fetch.
     */
    orderBy?: QuoteItemOrderByWithRelationInput | QuoteItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuoteItems.
     */
    cursor?: QuoteItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuoteItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuoteItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuoteItems.
     */
    distinct?: QuoteItemScalarFieldEnum | QuoteItemScalarFieldEnum[]
  }

  /**
   * QuoteItem findMany
   */
  export type QuoteItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteItem
     */
    select?: QuoteItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteItemInclude<ExtArgs> | null
    /**
     * Filter, which QuoteItems to fetch.
     */
    where?: QuoteItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuoteItems to fetch.
     */
    orderBy?: QuoteItemOrderByWithRelationInput | QuoteItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuoteItems.
     */
    cursor?: QuoteItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuoteItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuoteItems.
     */
    skip?: number
    distinct?: QuoteItemScalarFieldEnum | QuoteItemScalarFieldEnum[]
  }

  /**
   * QuoteItem create
   */
  export type QuoteItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteItem
     */
    select?: QuoteItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteItemInclude<ExtArgs> | null
    /**
     * The data needed to create a QuoteItem.
     */
    data: XOR<QuoteItemCreateInput, QuoteItemUncheckedCreateInput>
  }

  /**
   * QuoteItem createMany
   */
  export type QuoteItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuoteItems.
     */
    data: QuoteItemCreateManyInput | QuoteItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuoteItem createManyAndReturn
   */
  export type QuoteItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteItem
     */
    select?: QuoteItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many QuoteItems.
     */
    data: QuoteItemCreateManyInput | QuoteItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuoteItem update
   */
  export type QuoteItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteItem
     */
    select?: QuoteItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteItemInclude<ExtArgs> | null
    /**
     * The data needed to update a QuoteItem.
     */
    data: XOR<QuoteItemUpdateInput, QuoteItemUncheckedUpdateInput>
    /**
     * Choose, which QuoteItem to update.
     */
    where: QuoteItemWhereUniqueInput
  }

  /**
   * QuoteItem updateMany
   */
  export type QuoteItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuoteItems.
     */
    data: XOR<QuoteItemUpdateManyMutationInput, QuoteItemUncheckedUpdateManyInput>
    /**
     * Filter which QuoteItems to update
     */
    where?: QuoteItemWhereInput
  }

  /**
   * QuoteItem upsert
   */
  export type QuoteItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteItem
     */
    select?: QuoteItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteItemInclude<ExtArgs> | null
    /**
     * The filter to search for the QuoteItem to update in case it exists.
     */
    where: QuoteItemWhereUniqueInput
    /**
     * In case the QuoteItem found by the `where` argument doesn't exist, create a new QuoteItem with this data.
     */
    create: XOR<QuoteItemCreateInput, QuoteItemUncheckedCreateInput>
    /**
     * In case the QuoteItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuoteItemUpdateInput, QuoteItemUncheckedUpdateInput>
  }

  /**
   * QuoteItem delete
   */
  export type QuoteItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteItem
     */
    select?: QuoteItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteItemInclude<ExtArgs> | null
    /**
     * Filter which QuoteItem to delete.
     */
    where: QuoteItemWhereUniqueInput
  }

  /**
   * QuoteItem deleteMany
   */
  export type QuoteItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuoteItems to delete
     */
    where?: QuoteItemWhereInput
  }

  /**
   * QuoteItem.product
   */
  export type QuoteItem$productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
  }

  /**
   * QuoteItem without action
   */
  export type QuoteItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteItem
     */
    select?: QuoteItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteItemInclude<ExtArgs> | null
  }


  /**
   * Model QuoteApproval
   */

  export type AggregateQuoteApproval = {
    _count: QuoteApprovalCountAggregateOutputType | null
    _avg: QuoteApprovalAvgAggregateOutputType | null
    _sum: QuoteApprovalSumAggregateOutputType | null
    _min: QuoteApprovalMinAggregateOutputType | null
    _max: QuoteApprovalMaxAggregateOutputType | null
  }

  export type QuoteApprovalAvgAggregateOutputType = {
    id: number | null
    quoteId: number | null
    approverId: number | null
  }

  export type QuoteApprovalSumAggregateOutputType = {
    id: number | null
    quoteId: number | null
    approverId: number | null
  }

  export type QuoteApprovalMinAggregateOutputType = {
    id: number | null
    quoteId: number | null
    approverId: number | null
    approvalLevel: $Enums.ApprovalLevel | null
    status: $Enums.ApprovalStatus | null
    approvalDate: Date | null
    comments: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuoteApprovalMaxAggregateOutputType = {
    id: number | null
    quoteId: number | null
    approverId: number | null
    approvalLevel: $Enums.ApprovalLevel | null
    status: $Enums.ApprovalStatus | null
    approvalDate: Date | null
    comments: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuoteApprovalCountAggregateOutputType = {
    id: number
    quoteId: number
    approverId: number
    approvalLevel: number
    status: number
    approvalDate: number
    comments: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QuoteApprovalAvgAggregateInputType = {
    id?: true
    quoteId?: true
    approverId?: true
  }

  export type QuoteApprovalSumAggregateInputType = {
    id?: true
    quoteId?: true
    approverId?: true
  }

  export type QuoteApprovalMinAggregateInputType = {
    id?: true
    quoteId?: true
    approverId?: true
    approvalLevel?: true
    status?: true
    approvalDate?: true
    comments?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuoteApprovalMaxAggregateInputType = {
    id?: true
    quoteId?: true
    approverId?: true
    approvalLevel?: true
    status?: true
    approvalDate?: true
    comments?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuoteApprovalCountAggregateInputType = {
    id?: true
    quoteId?: true
    approverId?: true
    approvalLevel?: true
    status?: true
    approvalDate?: true
    comments?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QuoteApprovalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuoteApproval to aggregate.
     */
    where?: QuoteApprovalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuoteApprovals to fetch.
     */
    orderBy?: QuoteApprovalOrderByWithRelationInput | QuoteApprovalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuoteApprovalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuoteApprovals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuoteApprovals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuoteApprovals
    **/
    _count?: true | QuoteApprovalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuoteApprovalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuoteApprovalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuoteApprovalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuoteApprovalMaxAggregateInputType
  }

  export type GetQuoteApprovalAggregateType<T extends QuoteApprovalAggregateArgs> = {
        [P in keyof T & keyof AggregateQuoteApproval]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuoteApproval[P]>
      : GetScalarType<T[P], AggregateQuoteApproval[P]>
  }




  export type QuoteApprovalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuoteApprovalWhereInput
    orderBy?: QuoteApprovalOrderByWithAggregationInput | QuoteApprovalOrderByWithAggregationInput[]
    by: QuoteApprovalScalarFieldEnum[] | QuoteApprovalScalarFieldEnum
    having?: QuoteApprovalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuoteApprovalCountAggregateInputType | true
    _avg?: QuoteApprovalAvgAggregateInputType
    _sum?: QuoteApprovalSumAggregateInputType
    _min?: QuoteApprovalMinAggregateInputType
    _max?: QuoteApprovalMaxAggregateInputType
  }

  export type QuoteApprovalGroupByOutputType = {
    id: number
    quoteId: number
    approverId: number
    approvalLevel: $Enums.ApprovalLevel
    status: $Enums.ApprovalStatus
    approvalDate: Date | null
    comments: string | null
    createdAt: Date
    updatedAt: Date
    _count: QuoteApprovalCountAggregateOutputType | null
    _avg: QuoteApprovalAvgAggregateOutputType | null
    _sum: QuoteApprovalSumAggregateOutputType | null
    _min: QuoteApprovalMinAggregateOutputType | null
    _max: QuoteApprovalMaxAggregateOutputType | null
  }

  type GetQuoteApprovalGroupByPayload<T extends QuoteApprovalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuoteApprovalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuoteApprovalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuoteApprovalGroupByOutputType[P]>
            : GetScalarType<T[P], QuoteApprovalGroupByOutputType[P]>
        }
      >
    >


  export type QuoteApprovalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quoteId?: boolean
    approverId?: boolean
    approvalLevel?: boolean
    status?: boolean
    approvalDate?: boolean
    comments?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    quote?: boolean | QuoteDefaultArgs<ExtArgs>
    approver?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quoteApproval"]>

  export type QuoteApprovalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quoteId?: boolean
    approverId?: boolean
    approvalLevel?: boolean
    status?: boolean
    approvalDate?: boolean
    comments?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    quote?: boolean | QuoteDefaultArgs<ExtArgs>
    approver?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quoteApproval"]>

  export type QuoteApprovalSelectScalar = {
    id?: boolean
    quoteId?: boolean
    approverId?: boolean
    approvalLevel?: boolean
    status?: boolean
    approvalDate?: boolean
    comments?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type QuoteApprovalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quote?: boolean | QuoteDefaultArgs<ExtArgs>
    approver?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type QuoteApprovalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quote?: boolean | QuoteDefaultArgs<ExtArgs>
    approver?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $QuoteApprovalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuoteApproval"
    objects: {
      quote: Prisma.$QuotePayload<ExtArgs>
      approver: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      quoteId: number
      approverId: number
      approvalLevel: $Enums.ApprovalLevel
      status: $Enums.ApprovalStatus
      approvalDate: Date | null
      comments: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["quoteApproval"]>
    composites: {}
  }

  type QuoteApprovalGetPayload<S extends boolean | null | undefined | QuoteApprovalDefaultArgs> = $Result.GetResult<Prisma.$QuoteApprovalPayload, S>

  type QuoteApprovalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<QuoteApprovalFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: QuoteApprovalCountAggregateInputType | true
    }

  export interface QuoteApprovalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuoteApproval'], meta: { name: 'QuoteApproval' } }
    /**
     * Find zero or one QuoteApproval that matches the filter.
     * @param {QuoteApprovalFindUniqueArgs} args - Arguments to find a QuoteApproval
     * @example
     * // Get one QuoteApproval
     * const quoteApproval = await prisma.quoteApproval.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuoteApprovalFindUniqueArgs>(args: SelectSubset<T, QuoteApprovalFindUniqueArgs<ExtArgs>>): Prisma__QuoteApprovalClient<$Result.GetResult<Prisma.$QuoteApprovalPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one QuoteApproval that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {QuoteApprovalFindUniqueOrThrowArgs} args - Arguments to find a QuoteApproval
     * @example
     * // Get one QuoteApproval
     * const quoteApproval = await prisma.quoteApproval.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuoteApprovalFindUniqueOrThrowArgs>(args: SelectSubset<T, QuoteApprovalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuoteApprovalClient<$Result.GetResult<Prisma.$QuoteApprovalPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first QuoteApproval that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteApprovalFindFirstArgs} args - Arguments to find a QuoteApproval
     * @example
     * // Get one QuoteApproval
     * const quoteApproval = await prisma.quoteApproval.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuoteApprovalFindFirstArgs>(args?: SelectSubset<T, QuoteApprovalFindFirstArgs<ExtArgs>>): Prisma__QuoteApprovalClient<$Result.GetResult<Prisma.$QuoteApprovalPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first QuoteApproval that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteApprovalFindFirstOrThrowArgs} args - Arguments to find a QuoteApproval
     * @example
     * // Get one QuoteApproval
     * const quoteApproval = await prisma.quoteApproval.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuoteApprovalFindFirstOrThrowArgs>(args?: SelectSubset<T, QuoteApprovalFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuoteApprovalClient<$Result.GetResult<Prisma.$QuoteApprovalPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more QuoteApprovals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteApprovalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuoteApprovals
     * const quoteApprovals = await prisma.quoteApproval.findMany()
     * 
     * // Get first 10 QuoteApprovals
     * const quoteApprovals = await prisma.quoteApproval.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quoteApprovalWithIdOnly = await prisma.quoteApproval.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuoteApprovalFindManyArgs>(args?: SelectSubset<T, QuoteApprovalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuoteApprovalPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a QuoteApproval.
     * @param {QuoteApprovalCreateArgs} args - Arguments to create a QuoteApproval.
     * @example
     * // Create one QuoteApproval
     * const QuoteApproval = await prisma.quoteApproval.create({
     *   data: {
     *     // ... data to create a QuoteApproval
     *   }
     * })
     * 
     */
    create<T extends QuoteApprovalCreateArgs>(args: SelectSubset<T, QuoteApprovalCreateArgs<ExtArgs>>): Prisma__QuoteApprovalClient<$Result.GetResult<Prisma.$QuoteApprovalPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many QuoteApprovals.
     * @param {QuoteApprovalCreateManyArgs} args - Arguments to create many QuoteApprovals.
     * @example
     * // Create many QuoteApprovals
     * const quoteApproval = await prisma.quoteApproval.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuoteApprovalCreateManyArgs>(args?: SelectSubset<T, QuoteApprovalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuoteApprovals and returns the data saved in the database.
     * @param {QuoteApprovalCreateManyAndReturnArgs} args - Arguments to create many QuoteApprovals.
     * @example
     * // Create many QuoteApprovals
     * const quoteApproval = await prisma.quoteApproval.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuoteApprovals and only return the `id`
     * const quoteApprovalWithIdOnly = await prisma.quoteApproval.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuoteApprovalCreateManyAndReturnArgs>(args?: SelectSubset<T, QuoteApprovalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuoteApprovalPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a QuoteApproval.
     * @param {QuoteApprovalDeleteArgs} args - Arguments to delete one QuoteApproval.
     * @example
     * // Delete one QuoteApproval
     * const QuoteApproval = await prisma.quoteApproval.delete({
     *   where: {
     *     // ... filter to delete one QuoteApproval
     *   }
     * })
     * 
     */
    delete<T extends QuoteApprovalDeleteArgs>(args: SelectSubset<T, QuoteApprovalDeleteArgs<ExtArgs>>): Prisma__QuoteApprovalClient<$Result.GetResult<Prisma.$QuoteApprovalPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one QuoteApproval.
     * @param {QuoteApprovalUpdateArgs} args - Arguments to update one QuoteApproval.
     * @example
     * // Update one QuoteApproval
     * const quoteApproval = await prisma.quoteApproval.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuoteApprovalUpdateArgs>(args: SelectSubset<T, QuoteApprovalUpdateArgs<ExtArgs>>): Prisma__QuoteApprovalClient<$Result.GetResult<Prisma.$QuoteApprovalPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more QuoteApprovals.
     * @param {QuoteApprovalDeleteManyArgs} args - Arguments to filter QuoteApprovals to delete.
     * @example
     * // Delete a few QuoteApprovals
     * const { count } = await prisma.quoteApproval.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuoteApprovalDeleteManyArgs>(args?: SelectSubset<T, QuoteApprovalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuoteApprovals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteApprovalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuoteApprovals
     * const quoteApproval = await prisma.quoteApproval.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuoteApprovalUpdateManyArgs>(args: SelectSubset<T, QuoteApprovalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one QuoteApproval.
     * @param {QuoteApprovalUpsertArgs} args - Arguments to update or create a QuoteApproval.
     * @example
     * // Update or create a QuoteApproval
     * const quoteApproval = await prisma.quoteApproval.upsert({
     *   create: {
     *     // ... data to create a QuoteApproval
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuoteApproval we want to update
     *   }
     * })
     */
    upsert<T extends QuoteApprovalUpsertArgs>(args: SelectSubset<T, QuoteApprovalUpsertArgs<ExtArgs>>): Prisma__QuoteApprovalClient<$Result.GetResult<Prisma.$QuoteApprovalPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of QuoteApprovals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteApprovalCountArgs} args - Arguments to filter QuoteApprovals to count.
     * @example
     * // Count the number of QuoteApprovals
     * const count = await prisma.quoteApproval.count({
     *   where: {
     *     // ... the filter for the QuoteApprovals we want to count
     *   }
     * })
    **/
    count<T extends QuoteApprovalCountArgs>(
      args?: Subset<T, QuoteApprovalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuoteApprovalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuoteApproval.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteApprovalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuoteApprovalAggregateArgs>(args: Subset<T, QuoteApprovalAggregateArgs>): Prisma.PrismaPromise<GetQuoteApprovalAggregateType<T>>

    /**
     * Group by QuoteApproval.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteApprovalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuoteApprovalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuoteApprovalGroupByArgs['orderBy'] }
        : { orderBy?: QuoteApprovalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuoteApprovalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuoteApprovalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuoteApproval model
   */
  readonly fields: QuoteApprovalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuoteApproval.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuoteApprovalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    quote<T extends QuoteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuoteDefaultArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    approver<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuoteApproval model
   */ 
  interface QuoteApprovalFieldRefs {
    readonly id: FieldRef<"QuoteApproval", 'Int'>
    readonly quoteId: FieldRef<"QuoteApproval", 'Int'>
    readonly approverId: FieldRef<"QuoteApproval", 'Int'>
    readonly approvalLevel: FieldRef<"QuoteApproval", 'ApprovalLevel'>
    readonly status: FieldRef<"QuoteApproval", 'ApprovalStatus'>
    readonly approvalDate: FieldRef<"QuoteApproval", 'DateTime'>
    readonly comments: FieldRef<"QuoteApproval", 'String'>
    readonly createdAt: FieldRef<"QuoteApproval", 'DateTime'>
    readonly updatedAt: FieldRef<"QuoteApproval", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QuoteApproval findUnique
   */
  export type QuoteApprovalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteApproval
     */
    select?: QuoteApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteApprovalInclude<ExtArgs> | null
    /**
     * Filter, which QuoteApproval to fetch.
     */
    where: QuoteApprovalWhereUniqueInput
  }

  /**
   * QuoteApproval findUniqueOrThrow
   */
  export type QuoteApprovalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteApproval
     */
    select?: QuoteApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteApprovalInclude<ExtArgs> | null
    /**
     * Filter, which QuoteApproval to fetch.
     */
    where: QuoteApprovalWhereUniqueInput
  }

  /**
   * QuoteApproval findFirst
   */
  export type QuoteApprovalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteApproval
     */
    select?: QuoteApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteApprovalInclude<ExtArgs> | null
    /**
     * Filter, which QuoteApproval to fetch.
     */
    where?: QuoteApprovalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuoteApprovals to fetch.
     */
    orderBy?: QuoteApprovalOrderByWithRelationInput | QuoteApprovalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuoteApprovals.
     */
    cursor?: QuoteApprovalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuoteApprovals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuoteApprovals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuoteApprovals.
     */
    distinct?: QuoteApprovalScalarFieldEnum | QuoteApprovalScalarFieldEnum[]
  }

  /**
   * QuoteApproval findFirstOrThrow
   */
  export type QuoteApprovalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteApproval
     */
    select?: QuoteApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteApprovalInclude<ExtArgs> | null
    /**
     * Filter, which QuoteApproval to fetch.
     */
    where?: QuoteApprovalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuoteApprovals to fetch.
     */
    orderBy?: QuoteApprovalOrderByWithRelationInput | QuoteApprovalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuoteApprovals.
     */
    cursor?: QuoteApprovalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuoteApprovals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuoteApprovals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuoteApprovals.
     */
    distinct?: QuoteApprovalScalarFieldEnum | QuoteApprovalScalarFieldEnum[]
  }

  /**
   * QuoteApproval findMany
   */
  export type QuoteApprovalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteApproval
     */
    select?: QuoteApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteApprovalInclude<ExtArgs> | null
    /**
     * Filter, which QuoteApprovals to fetch.
     */
    where?: QuoteApprovalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuoteApprovals to fetch.
     */
    orderBy?: QuoteApprovalOrderByWithRelationInput | QuoteApprovalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuoteApprovals.
     */
    cursor?: QuoteApprovalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuoteApprovals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuoteApprovals.
     */
    skip?: number
    distinct?: QuoteApprovalScalarFieldEnum | QuoteApprovalScalarFieldEnum[]
  }

  /**
   * QuoteApproval create
   */
  export type QuoteApprovalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteApproval
     */
    select?: QuoteApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteApprovalInclude<ExtArgs> | null
    /**
     * The data needed to create a QuoteApproval.
     */
    data: XOR<QuoteApprovalCreateInput, QuoteApprovalUncheckedCreateInput>
  }

  /**
   * QuoteApproval createMany
   */
  export type QuoteApprovalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuoteApprovals.
     */
    data: QuoteApprovalCreateManyInput | QuoteApprovalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuoteApproval createManyAndReturn
   */
  export type QuoteApprovalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteApproval
     */
    select?: QuoteApprovalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many QuoteApprovals.
     */
    data: QuoteApprovalCreateManyInput | QuoteApprovalCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteApprovalIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuoteApproval update
   */
  export type QuoteApprovalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteApproval
     */
    select?: QuoteApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteApprovalInclude<ExtArgs> | null
    /**
     * The data needed to update a QuoteApproval.
     */
    data: XOR<QuoteApprovalUpdateInput, QuoteApprovalUncheckedUpdateInput>
    /**
     * Choose, which QuoteApproval to update.
     */
    where: QuoteApprovalWhereUniqueInput
  }

  /**
   * QuoteApproval updateMany
   */
  export type QuoteApprovalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuoteApprovals.
     */
    data: XOR<QuoteApprovalUpdateManyMutationInput, QuoteApprovalUncheckedUpdateManyInput>
    /**
     * Filter which QuoteApprovals to update
     */
    where?: QuoteApprovalWhereInput
  }

  /**
   * QuoteApproval upsert
   */
  export type QuoteApprovalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteApproval
     */
    select?: QuoteApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteApprovalInclude<ExtArgs> | null
    /**
     * The filter to search for the QuoteApproval to update in case it exists.
     */
    where: QuoteApprovalWhereUniqueInput
    /**
     * In case the QuoteApproval found by the `where` argument doesn't exist, create a new QuoteApproval with this data.
     */
    create: XOR<QuoteApprovalCreateInput, QuoteApprovalUncheckedCreateInput>
    /**
     * In case the QuoteApproval was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuoteApprovalUpdateInput, QuoteApprovalUncheckedUpdateInput>
  }

  /**
   * QuoteApproval delete
   */
  export type QuoteApprovalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteApproval
     */
    select?: QuoteApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteApprovalInclude<ExtArgs> | null
    /**
     * Filter which QuoteApproval to delete.
     */
    where: QuoteApprovalWhereUniqueInput
  }

  /**
   * QuoteApproval deleteMany
   */
  export type QuoteApprovalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuoteApprovals to delete
     */
    where?: QuoteApprovalWhereInput
  }

  /**
   * QuoteApproval without action
   */
  export type QuoteApprovalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteApproval
     */
    select?: QuoteApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteApprovalInclude<ExtArgs> | null
  }


  /**
   * Model Invoice
   */

  export type AggregateInvoice = {
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  export type InvoiceAvgAggregateOutputType = {
    id: number | null
    customerId: number | null
    customerAddressId: number | null
    quoteId: number | null
    subtotalHt: number | null
    discountAmount: number | null
    totalVat: number | null
    totalTtc: number | null
    paidAmount: number | null
    balanceDue: number | null
    paymentTerms: number | null
    lateFeeRate: number | null
    createdBy: number | null
  }

  export type InvoiceSumAggregateOutputType = {
    id: number | null
    customerId: number | null
    customerAddressId: number | null
    quoteId: number | null
    subtotalHt: number | null
    discountAmount: number | null
    totalVat: number | null
    totalTtc: number | null
    paidAmount: number | null
    balanceDue: number | null
    paymentTerms: number | null
    lateFeeRate: number | null
    createdBy: number | null
  }

  export type InvoiceMinAggregateOutputType = {
    id: number | null
    invoiceNumber: string | null
    customerId: number | null
    customerAddressId: number | null
    quoteId: number | null
    type: $Enums.InvoiceType | null
    status: $Enums.InvoiceStatus | null
    invoiceDate: Date | null
    dueDate: Date | null
    subtotalHt: number | null
    discountAmount: number | null
    totalVat: number | null
    totalTtc: number | null
    paidAmount: number | null
    balanceDue: number | null
    paymentTerms: number | null
    lateFeeRate: number | null
    terms: string | null
    notes: string | null
    createdBy: number | null
    createdAt: Date | null
    updatedAt: Date | null
    sentAt: Date | null
  }

  export type InvoiceMaxAggregateOutputType = {
    id: number | null
    invoiceNumber: string | null
    customerId: number | null
    customerAddressId: number | null
    quoteId: number | null
    type: $Enums.InvoiceType | null
    status: $Enums.InvoiceStatus | null
    invoiceDate: Date | null
    dueDate: Date | null
    subtotalHt: number | null
    discountAmount: number | null
    totalVat: number | null
    totalTtc: number | null
    paidAmount: number | null
    balanceDue: number | null
    paymentTerms: number | null
    lateFeeRate: number | null
    terms: string | null
    notes: string | null
    createdBy: number | null
    createdAt: Date | null
    updatedAt: Date | null
    sentAt: Date | null
  }

  export type InvoiceCountAggregateOutputType = {
    id: number
    invoiceNumber: number
    customerId: number
    customerAddressId: number
    quoteId: number
    type: number
    status: number
    invoiceDate: number
    dueDate: number
    subtotalHt: number
    discountAmount: number
    totalVat: number
    totalTtc: number
    paidAmount: number
    balanceDue: number
    paymentTerms: number
    lateFeeRate: number
    terms: number
    notes: number
    createdBy: number
    createdAt: number
    updatedAt: number
    sentAt: number
    _all: number
  }


  export type InvoiceAvgAggregateInputType = {
    id?: true
    customerId?: true
    customerAddressId?: true
    quoteId?: true
    subtotalHt?: true
    discountAmount?: true
    totalVat?: true
    totalTtc?: true
    paidAmount?: true
    balanceDue?: true
    paymentTerms?: true
    lateFeeRate?: true
    createdBy?: true
  }

  export type InvoiceSumAggregateInputType = {
    id?: true
    customerId?: true
    customerAddressId?: true
    quoteId?: true
    subtotalHt?: true
    discountAmount?: true
    totalVat?: true
    totalTtc?: true
    paidAmount?: true
    balanceDue?: true
    paymentTerms?: true
    lateFeeRate?: true
    createdBy?: true
  }

  export type InvoiceMinAggregateInputType = {
    id?: true
    invoiceNumber?: true
    customerId?: true
    customerAddressId?: true
    quoteId?: true
    type?: true
    status?: true
    invoiceDate?: true
    dueDate?: true
    subtotalHt?: true
    discountAmount?: true
    totalVat?: true
    totalTtc?: true
    paidAmount?: true
    balanceDue?: true
    paymentTerms?: true
    lateFeeRate?: true
    terms?: true
    notes?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    sentAt?: true
  }

  export type InvoiceMaxAggregateInputType = {
    id?: true
    invoiceNumber?: true
    customerId?: true
    customerAddressId?: true
    quoteId?: true
    type?: true
    status?: true
    invoiceDate?: true
    dueDate?: true
    subtotalHt?: true
    discountAmount?: true
    totalVat?: true
    totalTtc?: true
    paidAmount?: true
    balanceDue?: true
    paymentTerms?: true
    lateFeeRate?: true
    terms?: true
    notes?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    sentAt?: true
  }

  export type InvoiceCountAggregateInputType = {
    id?: true
    invoiceNumber?: true
    customerId?: true
    customerAddressId?: true
    quoteId?: true
    type?: true
    status?: true
    invoiceDate?: true
    dueDate?: true
    subtotalHt?: true
    discountAmount?: true
    totalVat?: true
    totalTtc?: true
    paidAmount?: true
    balanceDue?: true
    paymentTerms?: true
    lateFeeRate?: true
    terms?: true
    notes?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    sentAt?: true
    _all?: true
  }

  export type InvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoice to aggregate.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invoices
    **/
    _count?: true | InvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceMaxAggregateInputType
  }

  export type GetInvoiceAggregateType<T extends InvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice[P]>
      : GetScalarType<T[P], AggregateInvoice[P]>
  }




  export type InvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithAggregationInput | InvoiceOrderByWithAggregationInput[]
    by: InvoiceScalarFieldEnum[] | InvoiceScalarFieldEnum
    having?: InvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceCountAggregateInputType | true
    _avg?: InvoiceAvgAggregateInputType
    _sum?: InvoiceSumAggregateInputType
    _min?: InvoiceMinAggregateInputType
    _max?: InvoiceMaxAggregateInputType
  }

  export type InvoiceGroupByOutputType = {
    id: number
    invoiceNumber: string
    customerId: number
    customerAddressId: number | null
    quoteId: number | null
    type: $Enums.InvoiceType
    status: $Enums.InvoiceStatus
    invoiceDate: Date
    dueDate: Date
    subtotalHt: number
    discountAmount: number
    totalVat: number
    totalTtc: number
    paidAmount: number
    balanceDue: number
    paymentTerms: number
    lateFeeRate: number
    terms: string | null
    notes: string | null
    createdBy: number
    createdAt: Date
    updatedAt: Date
    sentAt: Date | null
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  type GetInvoiceGroupByPayload<T extends InvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceNumber?: boolean
    customerId?: boolean
    customerAddressId?: boolean
    quoteId?: boolean
    type?: boolean
    status?: boolean
    invoiceDate?: boolean
    dueDate?: boolean
    subtotalHt?: boolean
    discountAmount?: boolean
    totalVat?: boolean
    totalTtc?: boolean
    paidAmount?: boolean
    balanceDue?: boolean
    paymentTerms?: boolean
    lateFeeRate?: boolean
    terms?: boolean
    notes?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sentAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    customerAddress?: boolean | Invoice$customerAddressArgs<ExtArgs>
    quote?: boolean | Invoice$quoteArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    items?: boolean | Invoice$itemsArgs<ExtArgs>
    paymentAllocations?: boolean | Invoice$paymentAllocationsArgs<ExtArgs>
    reminders?: boolean | Invoice$remindersArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceNumber?: boolean
    customerId?: boolean
    customerAddressId?: boolean
    quoteId?: boolean
    type?: boolean
    status?: boolean
    invoiceDate?: boolean
    dueDate?: boolean
    subtotalHt?: boolean
    discountAmount?: boolean
    totalVat?: boolean
    totalTtc?: boolean
    paidAmount?: boolean
    balanceDue?: boolean
    paymentTerms?: boolean
    lateFeeRate?: boolean
    terms?: boolean
    notes?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sentAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    customerAddress?: boolean | Invoice$customerAddressArgs<ExtArgs>
    quote?: boolean | Invoice$quoteArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectScalar = {
    id?: boolean
    invoiceNumber?: boolean
    customerId?: boolean
    customerAddressId?: boolean
    quoteId?: boolean
    type?: boolean
    status?: boolean
    invoiceDate?: boolean
    dueDate?: boolean
    subtotalHt?: boolean
    discountAmount?: boolean
    totalVat?: boolean
    totalTtc?: boolean
    paidAmount?: boolean
    balanceDue?: boolean
    paymentTerms?: boolean
    lateFeeRate?: boolean
    terms?: boolean
    notes?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sentAt?: boolean
  }

  export type InvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    customerAddress?: boolean | Invoice$customerAddressArgs<ExtArgs>
    quote?: boolean | Invoice$quoteArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    items?: boolean | Invoice$itemsArgs<ExtArgs>
    paymentAllocations?: boolean | Invoice$paymentAllocationsArgs<ExtArgs>
    reminders?: boolean | Invoice$remindersArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InvoiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    customerAddress?: boolean | Invoice$customerAddressArgs<ExtArgs>
    quote?: boolean | Invoice$quoteArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $InvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invoice"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
      customerAddress: Prisma.$CustomerAddressPayload<ExtArgs> | null
      quote: Prisma.$QuotePayload<ExtArgs> | null
      creator: Prisma.$UserPayload<ExtArgs>
      items: Prisma.$InvoiceItemPayload<ExtArgs>[]
      paymentAllocations: Prisma.$PaymentAllocationPayload<ExtArgs>[]
      reminders: Prisma.$ReminderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      invoiceNumber: string
      customerId: number
      customerAddressId: number | null
      quoteId: number | null
      type: $Enums.InvoiceType
      status: $Enums.InvoiceStatus
      invoiceDate: Date
      dueDate: Date
      subtotalHt: number
      discountAmount: number
      totalVat: number
      totalTtc: number
      paidAmount: number
      balanceDue: number
      paymentTerms: number
      lateFeeRate: number
      terms: string | null
      notes: string | null
      createdBy: number
      createdAt: Date
      updatedAt: Date
      sentAt: Date | null
    }, ExtArgs["result"]["invoice"]>
    composites: {}
  }

  type InvoiceGetPayload<S extends boolean | null | undefined | InvoiceDefaultArgs> = $Result.GetResult<Prisma.$InvoicePayload, S>

  type InvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InvoiceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InvoiceCountAggregateInputType | true
    }

  export interface InvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invoice'], meta: { name: 'Invoice' } }
    /**
     * Find zero or one Invoice that matches the filter.
     * @param {InvoiceFindUniqueArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceFindUniqueArgs>(args: SelectSubset<T, InvoiceFindUniqueArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Invoice that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InvoiceFindUniqueOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Invoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceFindFirstArgs>(args?: SelectSubset<T, InvoiceFindFirstArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Invoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoice.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceWithIdOnly = await prisma.invoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceFindManyArgs>(args?: SelectSubset<T, InvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Invoice.
     * @param {InvoiceCreateArgs} args - Arguments to create a Invoice.
     * @example
     * // Create one Invoice
     * const Invoice = await prisma.invoice.create({
     *   data: {
     *     // ... data to create a Invoice
     *   }
     * })
     * 
     */
    create<T extends InvoiceCreateArgs>(args: SelectSubset<T, InvoiceCreateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Invoices.
     * @param {InvoiceCreateManyArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceCreateManyArgs>(args?: SelectSubset<T, InvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invoices and returns the data saved in the database.
     * @param {InvoiceCreateManyAndReturnArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Invoice.
     * @param {InvoiceDeleteArgs} args - Arguments to delete one Invoice.
     * @example
     * // Delete one Invoice
     * const Invoice = await prisma.invoice.delete({
     *   where: {
     *     // ... filter to delete one Invoice
     *   }
     * })
     * 
     */
    delete<T extends InvoiceDeleteArgs>(args: SelectSubset<T, InvoiceDeleteArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Invoice.
     * @param {InvoiceUpdateArgs} args - Arguments to update one Invoice.
     * @example
     * // Update one Invoice
     * const invoice = await prisma.invoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceUpdateArgs>(args: SelectSubset<T, InvoiceUpdateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Invoices.
     * @param {InvoiceDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceDeleteManyArgs>(args?: SelectSubset<T, InvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceUpdateManyArgs>(args: SelectSubset<T, InvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Invoice.
     * @param {InvoiceUpsertArgs} args - Arguments to update or create a Invoice.
     * @example
     * // Update or create a Invoice
     * const invoice = await prisma.invoice.upsert({
     *   create: {
     *     // ... data to create a Invoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceUpsertArgs>(args: SelectSubset<T, InvoiceUpsertArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoice.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends InvoiceCountArgs>(
      args?: Subset<T, InvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceAggregateArgs>(args: Subset<T, InvoiceAggregateArgs>): Prisma.PrismaPromise<GetInvoiceAggregateType<T>>

    /**
     * Group by Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invoice model
   */
  readonly fields: InvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    customerAddress<T extends Invoice$customerAddressArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$customerAddressArgs<ExtArgs>>): Prisma__CustomerAddressClient<$Result.GetResult<Prisma.$CustomerAddressPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    quote<T extends Invoice$quoteArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$quoteArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    items<T extends Invoice$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findMany"> | Null>
    paymentAllocations<T extends Invoice$paymentAllocationsArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$paymentAllocationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentAllocationPayload<ExtArgs>, T, "findMany"> | Null>
    reminders<T extends Invoice$remindersArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$remindersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReminderPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invoice model
   */ 
  interface InvoiceFieldRefs {
    readonly id: FieldRef<"Invoice", 'Int'>
    readonly invoiceNumber: FieldRef<"Invoice", 'String'>
    readonly customerId: FieldRef<"Invoice", 'Int'>
    readonly customerAddressId: FieldRef<"Invoice", 'Int'>
    readonly quoteId: FieldRef<"Invoice", 'Int'>
    readonly type: FieldRef<"Invoice", 'InvoiceType'>
    readonly status: FieldRef<"Invoice", 'InvoiceStatus'>
    readonly invoiceDate: FieldRef<"Invoice", 'DateTime'>
    readonly dueDate: FieldRef<"Invoice", 'DateTime'>
    readonly subtotalHt: FieldRef<"Invoice", 'Float'>
    readonly discountAmount: FieldRef<"Invoice", 'Float'>
    readonly totalVat: FieldRef<"Invoice", 'Float'>
    readonly totalTtc: FieldRef<"Invoice", 'Float'>
    readonly paidAmount: FieldRef<"Invoice", 'Float'>
    readonly balanceDue: FieldRef<"Invoice", 'Float'>
    readonly paymentTerms: FieldRef<"Invoice", 'Int'>
    readonly lateFeeRate: FieldRef<"Invoice", 'Float'>
    readonly terms: FieldRef<"Invoice", 'String'>
    readonly notes: FieldRef<"Invoice", 'String'>
    readonly createdBy: FieldRef<"Invoice", 'Int'>
    readonly createdAt: FieldRef<"Invoice", 'DateTime'>
    readonly updatedAt: FieldRef<"Invoice", 'DateTime'>
    readonly sentAt: FieldRef<"Invoice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Invoice findUnique
   */
  export type InvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findUniqueOrThrow
   */
  export type InvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findFirst
   */
  export type InvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findFirstOrThrow
   */
  export type InvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findMany
   */
  export type InvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice create
   */
  export type InvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Invoice.
     */
    data: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
  }

  /**
   * Invoice createMany
   */
  export type InvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Invoice createManyAndReturn
   */
  export type InvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice update
   */
  export type InvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Invoice.
     */
    data: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
    /**
     * Choose, which Invoice to update.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice updateMany
   */
  export type InvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
  }

  /**
   * Invoice upsert
   */
  export type InvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Invoice to update in case it exists.
     */
    where: InvoiceWhereUniqueInput
    /**
     * In case the Invoice found by the `where` argument doesn't exist, create a new Invoice with this data.
     */
    create: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
    /**
     * In case the Invoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
  }

  /**
   * Invoice delete
   */
  export type InvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter which Invoice to delete.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice deleteMany
   */
  export type InvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoices to delete
     */
    where?: InvoiceWhereInput
  }

  /**
   * Invoice.customerAddress
   */
  export type Invoice$customerAddressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressInclude<ExtArgs> | null
    where?: CustomerAddressWhereInput
  }

  /**
   * Invoice.quote
   */
  export type Invoice$quoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    where?: QuoteWhereInput
  }

  /**
   * Invoice.items
   */
  export type Invoice$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    where?: InvoiceItemWhereInput
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    cursor?: InvoiceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * Invoice.paymentAllocations
   */
  export type Invoice$paymentAllocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAllocation
     */
    select?: PaymentAllocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentAllocationInclude<ExtArgs> | null
    where?: PaymentAllocationWhereInput
    orderBy?: PaymentAllocationOrderByWithRelationInput | PaymentAllocationOrderByWithRelationInput[]
    cursor?: PaymentAllocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentAllocationScalarFieldEnum | PaymentAllocationScalarFieldEnum[]
  }

  /**
   * Invoice.reminders
   */
  export type Invoice$remindersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reminder
     */
    select?: ReminderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReminderInclude<ExtArgs> | null
    where?: ReminderWhereInput
    orderBy?: ReminderOrderByWithRelationInput | ReminderOrderByWithRelationInput[]
    cursor?: ReminderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReminderScalarFieldEnum | ReminderScalarFieldEnum[]
  }

  /**
   * Invoice without action
   */
  export type InvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
  }


  /**
   * Model InvoiceItem
   */

  export type AggregateInvoiceItem = {
    _count: InvoiceItemCountAggregateOutputType | null
    _avg: InvoiceItemAvgAggregateOutputType | null
    _sum: InvoiceItemSumAggregateOutputType | null
    _min: InvoiceItemMinAggregateOutputType | null
    _max: InvoiceItemMaxAggregateOutputType | null
  }

  export type InvoiceItemAvgAggregateOutputType = {
    id: number | null
    invoiceId: number | null
    productId: number | null
    quantity: number | null
    unitPriceHt: number | null
    discountRate: number | null
    vatRate: number | null
    totalHt: number | null
    sortOrder: number | null
  }

  export type InvoiceItemSumAggregateOutputType = {
    id: number | null
    invoiceId: number | null
    productId: number | null
    quantity: number | null
    unitPriceHt: number | null
    discountRate: number | null
    vatRate: number | null
    totalHt: number | null
    sortOrder: number | null
  }

  export type InvoiceItemMinAggregateOutputType = {
    id: number | null
    invoiceId: number | null
    productId: number | null
    description: string | null
    quantity: number | null
    unitPriceHt: number | null
    discountRate: number | null
    vatRate: number | null
    totalHt: number | null
    sortOrder: number | null
  }

  export type InvoiceItemMaxAggregateOutputType = {
    id: number | null
    invoiceId: number | null
    productId: number | null
    description: string | null
    quantity: number | null
    unitPriceHt: number | null
    discountRate: number | null
    vatRate: number | null
    totalHt: number | null
    sortOrder: number | null
  }

  export type InvoiceItemCountAggregateOutputType = {
    id: number
    invoiceId: number
    productId: number
    description: number
    quantity: number
    unitPriceHt: number
    discountRate: number
    vatRate: number
    totalHt: number
    sortOrder: number
    _all: number
  }


  export type InvoiceItemAvgAggregateInputType = {
    id?: true
    invoiceId?: true
    productId?: true
    quantity?: true
    unitPriceHt?: true
    discountRate?: true
    vatRate?: true
    totalHt?: true
    sortOrder?: true
  }

  export type InvoiceItemSumAggregateInputType = {
    id?: true
    invoiceId?: true
    productId?: true
    quantity?: true
    unitPriceHt?: true
    discountRate?: true
    vatRate?: true
    totalHt?: true
    sortOrder?: true
  }

  export type InvoiceItemMinAggregateInputType = {
    id?: true
    invoiceId?: true
    productId?: true
    description?: true
    quantity?: true
    unitPriceHt?: true
    discountRate?: true
    vatRate?: true
    totalHt?: true
    sortOrder?: true
  }

  export type InvoiceItemMaxAggregateInputType = {
    id?: true
    invoiceId?: true
    productId?: true
    description?: true
    quantity?: true
    unitPriceHt?: true
    discountRate?: true
    vatRate?: true
    totalHt?: true
    sortOrder?: true
  }

  export type InvoiceItemCountAggregateInputType = {
    id?: true
    invoiceId?: true
    productId?: true
    description?: true
    quantity?: true
    unitPriceHt?: true
    discountRate?: true
    vatRate?: true
    totalHt?: true
    sortOrder?: true
    _all?: true
  }

  export type InvoiceItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoiceItem to aggregate.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InvoiceItems
    **/
    _count?: true | InvoiceItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceItemMaxAggregateInputType
  }

  export type GetInvoiceItemAggregateType<T extends InvoiceItemAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoiceItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoiceItem[P]>
      : GetScalarType<T[P], AggregateInvoiceItem[P]>
  }




  export type InvoiceItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceItemWhereInput
    orderBy?: InvoiceItemOrderByWithAggregationInput | InvoiceItemOrderByWithAggregationInput[]
    by: InvoiceItemScalarFieldEnum[] | InvoiceItemScalarFieldEnum
    having?: InvoiceItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceItemCountAggregateInputType | true
    _avg?: InvoiceItemAvgAggregateInputType
    _sum?: InvoiceItemSumAggregateInputType
    _min?: InvoiceItemMinAggregateInputType
    _max?: InvoiceItemMaxAggregateInputType
  }

  export type InvoiceItemGroupByOutputType = {
    id: number
    invoiceId: number
    productId: number | null
    description: string
    quantity: number
    unitPriceHt: number
    discountRate: number
    vatRate: number
    totalHt: number
    sortOrder: number
    _count: InvoiceItemCountAggregateOutputType | null
    _avg: InvoiceItemAvgAggregateOutputType | null
    _sum: InvoiceItemSumAggregateOutputType | null
    _min: InvoiceItemMinAggregateOutputType | null
    _max: InvoiceItemMaxAggregateOutputType | null
  }

  type GetInvoiceItemGroupByPayload<T extends InvoiceItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceItemGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceItemGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    productId?: boolean
    description?: boolean
    quantity?: boolean
    unitPriceHt?: boolean
    discountRate?: boolean
    vatRate?: boolean
    totalHt?: boolean
    sortOrder?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    product?: boolean | InvoiceItem$productArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceItem"]>

  export type InvoiceItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    productId?: boolean
    description?: boolean
    quantity?: boolean
    unitPriceHt?: boolean
    discountRate?: boolean
    vatRate?: boolean
    totalHt?: boolean
    sortOrder?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    product?: boolean | InvoiceItem$productArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceItem"]>

  export type InvoiceItemSelectScalar = {
    id?: boolean
    invoiceId?: boolean
    productId?: boolean
    description?: boolean
    quantity?: boolean
    unitPriceHt?: boolean
    discountRate?: boolean
    vatRate?: boolean
    totalHt?: boolean
    sortOrder?: boolean
  }

  export type InvoiceItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    product?: boolean | InvoiceItem$productArgs<ExtArgs>
  }
  export type InvoiceItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    product?: boolean | InvoiceItem$productArgs<ExtArgs>
  }

  export type $InvoiceItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InvoiceItem"
    objects: {
      invoice: Prisma.$InvoicePayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      invoiceId: number
      productId: number | null
      description: string
      quantity: number
      unitPriceHt: number
      discountRate: number
      vatRate: number
      totalHt: number
      sortOrder: number
    }, ExtArgs["result"]["invoiceItem"]>
    composites: {}
  }

  type InvoiceItemGetPayload<S extends boolean | null | undefined | InvoiceItemDefaultArgs> = $Result.GetResult<Prisma.$InvoiceItemPayload, S>

  type InvoiceItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InvoiceItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InvoiceItemCountAggregateInputType | true
    }

  export interface InvoiceItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InvoiceItem'], meta: { name: 'InvoiceItem' } }
    /**
     * Find zero or one InvoiceItem that matches the filter.
     * @param {InvoiceItemFindUniqueArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceItemFindUniqueArgs>(args: SelectSubset<T, InvoiceItemFindUniqueArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one InvoiceItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InvoiceItemFindUniqueOrThrowArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceItemFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first InvoiceItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemFindFirstArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceItemFindFirstArgs>(args?: SelectSubset<T, InvoiceItemFindFirstArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first InvoiceItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemFindFirstOrThrowArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceItemFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more InvoiceItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvoiceItems
     * const invoiceItems = await prisma.invoiceItem.findMany()
     * 
     * // Get first 10 InvoiceItems
     * const invoiceItems = await prisma.invoiceItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceItemWithIdOnly = await prisma.invoiceItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceItemFindManyArgs>(args?: SelectSubset<T, InvoiceItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a InvoiceItem.
     * @param {InvoiceItemCreateArgs} args - Arguments to create a InvoiceItem.
     * @example
     * // Create one InvoiceItem
     * const InvoiceItem = await prisma.invoiceItem.create({
     *   data: {
     *     // ... data to create a InvoiceItem
     *   }
     * })
     * 
     */
    create<T extends InvoiceItemCreateArgs>(args: SelectSubset<T, InvoiceItemCreateArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many InvoiceItems.
     * @param {InvoiceItemCreateManyArgs} args - Arguments to create many InvoiceItems.
     * @example
     * // Create many InvoiceItems
     * const invoiceItem = await prisma.invoiceItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceItemCreateManyArgs>(args?: SelectSubset<T, InvoiceItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InvoiceItems and returns the data saved in the database.
     * @param {InvoiceItemCreateManyAndReturnArgs} args - Arguments to create many InvoiceItems.
     * @example
     * // Create many InvoiceItems
     * const invoiceItem = await prisma.invoiceItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InvoiceItems and only return the `id`
     * const invoiceItemWithIdOnly = await prisma.invoiceItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceItemCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a InvoiceItem.
     * @param {InvoiceItemDeleteArgs} args - Arguments to delete one InvoiceItem.
     * @example
     * // Delete one InvoiceItem
     * const InvoiceItem = await prisma.invoiceItem.delete({
     *   where: {
     *     // ... filter to delete one InvoiceItem
     *   }
     * })
     * 
     */
    delete<T extends InvoiceItemDeleteArgs>(args: SelectSubset<T, InvoiceItemDeleteArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one InvoiceItem.
     * @param {InvoiceItemUpdateArgs} args - Arguments to update one InvoiceItem.
     * @example
     * // Update one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceItemUpdateArgs>(args: SelectSubset<T, InvoiceItemUpdateArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more InvoiceItems.
     * @param {InvoiceItemDeleteManyArgs} args - Arguments to filter InvoiceItems to delete.
     * @example
     * // Delete a few InvoiceItems
     * const { count } = await prisma.invoiceItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceItemDeleteManyArgs>(args?: SelectSubset<T, InvoiceItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvoiceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvoiceItems
     * const invoiceItem = await prisma.invoiceItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceItemUpdateManyArgs>(args: SelectSubset<T, InvoiceItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InvoiceItem.
     * @param {InvoiceItemUpsertArgs} args - Arguments to update or create a InvoiceItem.
     * @example
     * // Update or create a InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.upsert({
     *   create: {
     *     // ... data to create a InvoiceItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvoiceItem we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceItemUpsertArgs>(args: SelectSubset<T, InvoiceItemUpsertArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of InvoiceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemCountArgs} args - Arguments to filter InvoiceItems to count.
     * @example
     * // Count the number of InvoiceItems
     * const count = await prisma.invoiceItem.count({
     *   where: {
     *     // ... the filter for the InvoiceItems we want to count
     *   }
     * })
    **/
    count<T extends InvoiceItemCountArgs>(
      args?: Subset<T, InvoiceItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvoiceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceItemAggregateArgs>(args: Subset<T, InvoiceItemAggregateArgs>): Prisma.PrismaPromise<GetInvoiceItemAggregateType<T>>

    /**
     * Group by InvoiceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceItemGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InvoiceItem model
   */
  readonly fields: InvoiceItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InvoiceItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoice<T extends InvoiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceDefaultArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    product<T extends InvoiceItem$productArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceItem$productArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InvoiceItem model
   */ 
  interface InvoiceItemFieldRefs {
    readonly id: FieldRef<"InvoiceItem", 'Int'>
    readonly invoiceId: FieldRef<"InvoiceItem", 'Int'>
    readonly productId: FieldRef<"InvoiceItem", 'Int'>
    readonly description: FieldRef<"InvoiceItem", 'String'>
    readonly quantity: FieldRef<"InvoiceItem", 'Float'>
    readonly unitPriceHt: FieldRef<"InvoiceItem", 'Float'>
    readonly discountRate: FieldRef<"InvoiceItem", 'Float'>
    readonly vatRate: FieldRef<"InvoiceItem", 'Float'>
    readonly totalHt: FieldRef<"InvoiceItem", 'Float'>
    readonly sortOrder: FieldRef<"InvoiceItem", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * InvoiceItem findUnique
   */
  export type InvoiceItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where: InvoiceItemWhereUniqueInput
  }

  /**
   * InvoiceItem findUniqueOrThrow
   */
  export type InvoiceItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where: InvoiceItemWhereUniqueInput
  }

  /**
   * InvoiceItem findFirst
   */
  export type InvoiceItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoiceItems.
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoiceItems.
     */
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * InvoiceItem findFirstOrThrow
   */
  export type InvoiceItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoiceItems.
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoiceItems.
     */
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * InvoiceItem findMany
   */
  export type InvoiceItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItems to fetch.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InvoiceItems.
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * InvoiceItem create
   */
  export type InvoiceItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * The data needed to create a InvoiceItem.
     */
    data: XOR<InvoiceItemCreateInput, InvoiceItemUncheckedCreateInput>
  }

  /**
   * InvoiceItem createMany
   */
  export type InvoiceItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InvoiceItems.
     */
    data: InvoiceItemCreateManyInput | InvoiceItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InvoiceItem createManyAndReturn
   */
  export type InvoiceItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many InvoiceItems.
     */
    data: InvoiceItemCreateManyInput | InvoiceItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InvoiceItem update
   */
  export type InvoiceItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * The data needed to update a InvoiceItem.
     */
    data: XOR<InvoiceItemUpdateInput, InvoiceItemUncheckedUpdateInput>
    /**
     * Choose, which InvoiceItem to update.
     */
    where: InvoiceItemWhereUniqueInput
  }

  /**
   * InvoiceItem updateMany
   */
  export type InvoiceItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InvoiceItems.
     */
    data: XOR<InvoiceItemUpdateManyMutationInput, InvoiceItemUncheckedUpdateManyInput>
    /**
     * Filter which InvoiceItems to update
     */
    where?: InvoiceItemWhereInput
  }

  /**
   * InvoiceItem upsert
   */
  export type InvoiceItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * The filter to search for the InvoiceItem to update in case it exists.
     */
    where: InvoiceItemWhereUniqueInput
    /**
     * In case the InvoiceItem found by the `where` argument doesn't exist, create a new InvoiceItem with this data.
     */
    create: XOR<InvoiceItemCreateInput, InvoiceItemUncheckedCreateInput>
    /**
     * In case the InvoiceItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceItemUpdateInput, InvoiceItemUncheckedUpdateInput>
  }

  /**
   * InvoiceItem delete
   */
  export type InvoiceItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter which InvoiceItem to delete.
     */
    where: InvoiceItemWhereUniqueInput
  }

  /**
   * InvoiceItem deleteMany
   */
  export type InvoiceItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoiceItems to delete
     */
    where?: InvoiceItemWhereInput
  }

  /**
   * InvoiceItem.product
   */
  export type InvoiceItem$productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
  }

  /**
   * InvoiceItem without action
   */
  export type InvoiceItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    id: number | null
    customerId: number | null
    amount: number | null
    createdBy: number | null
  }

  export type PaymentSumAggregateOutputType = {
    id: number | null
    customerId: number | null
    amount: number | null
    createdBy: number | null
  }

  export type PaymentMinAggregateOutputType = {
    id: number | null
    paymentNumber: string | null
    customerId: number | null
    amount: number | null
    paymentDate: Date | null
    paymentMethod: $Enums.PaymentMethod | null
    reference: string | null
    notes: string | null
    createdBy: number | null
    createdAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: number | null
    paymentNumber: string | null
    customerId: number | null
    amount: number | null
    paymentDate: Date | null
    paymentMethod: $Enums.PaymentMethod | null
    reference: string | null
    notes: string | null
    createdBy: number | null
    createdAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    paymentNumber: number
    customerId: number
    amount: number
    paymentDate: number
    paymentMethod: number
    reference: number
    notes: number
    createdBy: number
    createdAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    id?: true
    customerId?: true
    amount?: true
    createdBy?: true
  }

  export type PaymentSumAggregateInputType = {
    id?: true
    customerId?: true
    amount?: true
    createdBy?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    paymentNumber?: true
    customerId?: true
    amount?: true
    paymentDate?: true
    paymentMethod?: true
    reference?: true
    notes?: true
    createdBy?: true
    createdAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    paymentNumber?: true
    customerId?: true
    amount?: true
    paymentDate?: true
    paymentMethod?: true
    reference?: true
    notes?: true
    createdBy?: true
    createdAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    paymentNumber?: true
    customerId?: true
    amount?: true
    paymentDate?: true
    paymentMethod?: true
    reference?: true
    notes?: true
    createdBy?: true
    createdAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: number
    paymentNumber: string
    customerId: number
    amount: number
    paymentDate: Date
    paymentMethod: $Enums.PaymentMethod
    reference: string | null
    notes: string | null
    createdBy: number
    createdAt: Date
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    paymentNumber?: boolean
    customerId?: boolean
    amount?: boolean
    paymentDate?: boolean
    paymentMethod?: boolean
    reference?: boolean
    notes?: boolean
    createdBy?: boolean
    createdAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    allocations?: boolean | Payment$allocationsArgs<ExtArgs>
    _count?: boolean | PaymentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    paymentNumber?: boolean
    customerId?: boolean
    amount?: boolean
    paymentDate?: boolean
    paymentMethod?: boolean
    reference?: boolean
    notes?: boolean
    createdBy?: boolean
    createdAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    paymentNumber?: boolean
    customerId?: boolean
    amount?: boolean
    paymentDate?: boolean
    paymentMethod?: boolean
    reference?: boolean
    notes?: boolean
    createdBy?: boolean
    createdAt?: boolean
  }

  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    allocations?: boolean | Payment$allocationsArgs<ExtArgs>
    _count?: boolean | PaymentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
      creator: Prisma.$UserPayload<ExtArgs>
      allocations: Prisma.$PaymentAllocationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      paymentNumber: string
      customerId: number
      amount: number
      paymentDate: Date
      paymentMethod: $Enums.PaymentMethod
      reference: string | null
      notes: string | null
      createdBy: number
      createdAt: Date
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    allocations<T extends Payment$allocationsArgs<ExtArgs> = {}>(args?: Subset<T, Payment$allocationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentAllocationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */ 
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'Int'>
    readonly paymentNumber: FieldRef<"Payment", 'String'>
    readonly customerId: FieldRef<"Payment", 'Int'>
    readonly amount: FieldRef<"Payment", 'Float'>
    readonly paymentDate: FieldRef<"Payment", 'DateTime'>
    readonly paymentMethod: FieldRef<"Payment", 'PaymentMethod'>
    readonly reference: FieldRef<"Payment", 'String'>
    readonly notes: FieldRef<"Payment", 'String'>
    readonly createdBy: FieldRef<"Payment", 'Int'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
  }

  /**
   * Payment.allocations
   */
  export type Payment$allocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAllocation
     */
    select?: PaymentAllocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentAllocationInclude<ExtArgs> | null
    where?: PaymentAllocationWhereInput
    orderBy?: PaymentAllocationOrderByWithRelationInput | PaymentAllocationOrderByWithRelationInput[]
    cursor?: PaymentAllocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentAllocationScalarFieldEnum | PaymentAllocationScalarFieldEnum[]
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model PaymentAllocation
   */

  export type AggregatePaymentAllocation = {
    _count: PaymentAllocationCountAggregateOutputType | null
    _avg: PaymentAllocationAvgAggregateOutputType | null
    _sum: PaymentAllocationSumAggregateOutputType | null
    _min: PaymentAllocationMinAggregateOutputType | null
    _max: PaymentAllocationMaxAggregateOutputType | null
  }

  export type PaymentAllocationAvgAggregateOutputType = {
    id: number | null
    paymentId: number | null
    invoiceId: number | null
    amount: number | null
  }

  export type PaymentAllocationSumAggregateOutputType = {
    id: number | null
    paymentId: number | null
    invoiceId: number | null
    amount: number | null
  }

  export type PaymentAllocationMinAggregateOutputType = {
    id: number | null
    paymentId: number | null
    invoiceId: number | null
    amount: number | null
    createdAt: Date | null
  }

  export type PaymentAllocationMaxAggregateOutputType = {
    id: number | null
    paymentId: number | null
    invoiceId: number | null
    amount: number | null
    createdAt: Date | null
  }

  export type PaymentAllocationCountAggregateOutputType = {
    id: number
    paymentId: number
    invoiceId: number
    amount: number
    createdAt: number
    _all: number
  }


  export type PaymentAllocationAvgAggregateInputType = {
    id?: true
    paymentId?: true
    invoiceId?: true
    amount?: true
  }

  export type PaymentAllocationSumAggregateInputType = {
    id?: true
    paymentId?: true
    invoiceId?: true
    amount?: true
  }

  export type PaymentAllocationMinAggregateInputType = {
    id?: true
    paymentId?: true
    invoiceId?: true
    amount?: true
    createdAt?: true
  }

  export type PaymentAllocationMaxAggregateInputType = {
    id?: true
    paymentId?: true
    invoiceId?: true
    amount?: true
    createdAt?: true
  }

  export type PaymentAllocationCountAggregateInputType = {
    id?: true
    paymentId?: true
    invoiceId?: true
    amount?: true
    createdAt?: true
    _all?: true
  }

  export type PaymentAllocationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentAllocation to aggregate.
     */
    where?: PaymentAllocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentAllocations to fetch.
     */
    orderBy?: PaymentAllocationOrderByWithRelationInput | PaymentAllocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentAllocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentAllocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentAllocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentAllocations
    **/
    _count?: true | PaymentAllocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAllocationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentAllocationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentAllocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentAllocationMaxAggregateInputType
  }

  export type GetPaymentAllocationAggregateType<T extends PaymentAllocationAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentAllocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentAllocation[P]>
      : GetScalarType<T[P], AggregatePaymentAllocation[P]>
  }




  export type PaymentAllocationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentAllocationWhereInput
    orderBy?: PaymentAllocationOrderByWithAggregationInput | PaymentAllocationOrderByWithAggregationInput[]
    by: PaymentAllocationScalarFieldEnum[] | PaymentAllocationScalarFieldEnum
    having?: PaymentAllocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentAllocationCountAggregateInputType | true
    _avg?: PaymentAllocationAvgAggregateInputType
    _sum?: PaymentAllocationSumAggregateInputType
    _min?: PaymentAllocationMinAggregateInputType
    _max?: PaymentAllocationMaxAggregateInputType
  }

  export type PaymentAllocationGroupByOutputType = {
    id: number
    paymentId: number
    invoiceId: number
    amount: number
    createdAt: Date
    _count: PaymentAllocationCountAggregateOutputType | null
    _avg: PaymentAllocationAvgAggregateOutputType | null
    _sum: PaymentAllocationSumAggregateOutputType | null
    _min: PaymentAllocationMinAggregateOutputType | null
    _max: PaymentAllocationMaxAggregateOutputType | null
  }

  type GetPaymentAllocationGroupByPayload<T extends PaymentAllocationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentAllocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentAllocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentAllocationGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentAllocationGroupByOutputType[P]>
        }
      >
    >


  export type PaymentAllocationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    paymentId?: boolean
    invoiceId?: boolean
    amount?: boolean
    createdAt?: boolean
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentAllocation"]>

  export type PaymentAllocationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    paymentId?: boolean
    invoiceId?: boolean
    amount?: boolean
    createdAt?: boolean
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentAllocation"]>

  export type PaymentAllocationSelectScalar = {
    id?: boolean
    paymentId?: boolean
    invoiceId?: boolean
    amount?: boolean
    createdAt?: boolean
  }

  export type PaymentAllocationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }
  export type PaymentAllocationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }

  export type $PaymentAllocationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PaymentAllocation"
    objects: {
      payment: Prisma.$PaymentPayload<ExtArgs>
      invoice: Prisma.$InvoicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      paymentId: number
      invoiceId: number
      amount: number
      createdAt: Date
    }, ExtArgs["result"]["paymentAllocation"]>
    composites: {}
  }

  type PaymentAllocationGetPayload<S extends boolean | null | undefined | PaymentAllocationDefaultArgs> = $Result.GetResult<Prisma.$PaymentAllocationPayload, S>

  type PaymentAllocationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PaymentAllocationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PaymentAllocationCountAggregateInputType | true
    }

  export interface PaymentAllocationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PaymentAllocation'], meta: { name: 'PaymentAllocation' } }
    /**
     * Find zero or one PaymentAllocation that matches the filter.
     * @param {PaymentAllocationFindUniqueArgs} args - Arguments to find a PaymentAllocation
     * @example
     * // Get one PaymentAllocation
     * const paymentAllocation = await prisma.paymentAllocation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentAllocationFindUniqueArgs>(args: SelectSubset<T, PaymentAllocationFindUniqueArgs<ExtArgs>>): Prisma__PaymentAllocationClient<$Result.GetResult<Prisma.$PaymentAllocationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PaymentAllocation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PaymentAllocationFindUniqueOrThrowArgs} args - Arguments to find a PaymentAllocation
     * @example
     * // Get one PaymentAllocation
     * const paymentAllocation = await prisma.paymentAllocation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentAllocationFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentAllocationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentAllocationClient<$Result.GetResult<Prisma.$PaymentAllocationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PaymentAllocation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAllocationFindFirstArgs} args - Arguments to find a PaymentAllocation
     * @example
     * // Get one PaymentAllocation
     * const paymentAllocation = await prisma.paymentAllocation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentAllocationFindFirstArgs>(args?: SelectSubset<T, PaymentAllocationFindFirstArgs<ExtArgs>>): Prisma__PaymentAllocationClient<$Result.GetResult<Prisma.$PaymentAllocationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PaymentAllocation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAllocationFindFirstOrThrowArgs} args - Arguments to find a PaymentAllocation
     * @example
     * // Get one PaymentAllocation
     * const paymentAllocation = await prisma.paymentAllocation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentAllocationFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentAllocationFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentAllocationClient<$Result.GetResult<Prisma.$PaymentAllocationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PaymentAllocations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAllocationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentAllocations
     * const paymentAllocations = await prisma.paymentAllocation.findMany()
     * 
     * // Get first 10 PaymentAllocations
     * const paymentAllocations = await prisma.paymentAllocation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentAllocationWithIdOnly = await prisma.paymentAllocation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentAllocationFindManyArgs>(args?: SelectSubset<T, PaymentAllocationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentAllocationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PaymentAllocation.
     * @param {PaymentAllocationCreateArgs} args - Arguments to create a PaymentAllocation.
     * @example
     * // Create one PaymentAllocation
     * const PaymentAllocation = await prisma.paymentAllocation.create({
     *   data: {
     *     // ... data to create a PaymentAllocation
     *   }
     * })
     * 
     */
    create<T extends PaymentAllocationCreateArgs>(args: SelectSubset<T, PaymentAllocationCreateArgs<ExtArgs>>): Prisma__PaymentAllocationClient<$Result.GetResult<Prisma.$PaymentAllocationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PaymentAllocations.
     * @param {PaymentAllocationCreateManyArgs} args - Arguments to create many PaymentAllocations.
     * @example
     * // Create many PaymentAllocations
     * const paymentAllocation = await prisma.paymentAllocation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentAllocationCreateManyArgs>(args?: SelectSubset<T, PaymentAllocationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PaymentAllocations and returns the data saved in the database.
     * @param {PaymentAllocationCreateManyAndReturnArgs} args - Arguments to create many PaymentAllocations.
     * @example
     * // Create many PaymentAllocations
     * const paymentAllocation = await prisma.paymentAllocation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PaymentAllocations and only return the `id`
     * const paymentAllocationWithIdOnly = await prisma.paymentAllocation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentAllocationCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentAllocationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentAllocationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PaymentAllocation.
     * @param {PaymentAllocationDeleteArgs} args - Arguments to delete one PaymentAllocation.
     * @example
     * // Delete one PaymentAllocation
     * const PaymentAllocation = await prisma.paymentAllocation.delete({
     *   where: {
     *     // ... filter to delete one PaymentAllocation
     *   }
     * })
     * 
     */
    delete<T extends PaymentAllocationDeleteArgs>(args: SelectSubset<T, PaymentAllocationDeleteArgs<ExtArgs>>): Prisma__PaymentAllocationClient<$Result.GetResult<Prisma.$PaymentAllocationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PaymentAllocation.
     * @param {PaymentAllocationUpdateArgs} args - Arguments to update one PaymentAllocation.
     * @example
     * // Update one PaymentAllocation
     * const paymentAllocation = await prisma.paymentAllocation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentAllocationUpdateArgs>(args: SelectSubset<T, PaymentAllocationUpdateArgs<ExtArgs>>): Prisma__PaymentAllocationClient<$Result.GetResult<Prisma.$PaymentAllocationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PaymentAllocations.
     * @param {PaymentAllocationDeleteManyArgs} args - Arguments to filter PaymentAllocations to delete.
     * @example
     * // Delete a few PaymentAllocations
     * const { count } = await prisma.paymentAllocation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentAllocationDeleteManyArgs>(args?: SelectSubset<T, PaymentAllocationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentAllocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAllocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentAllocations
     * const paymentAllocation = await prisma.paymentAllocation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentAllocationUpdateManyArgs>(args: SelectSubset<T, PaymentAllocationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PaymentAllocation.
     * @param {PaymentAllocationUpsertArgs} args - Arguments to update or create a PaymentAllocation.
     * @example
     * // Update or create a PaymentAllocation
     * const paymentAllocation = await prisma.paymentAllocation.upsert({
     *   create: {
     *     // ... data to create a PaymentAllocation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentAllocation we want to update
     *   }
     * })
     */
    upsert<T extends PaymentAllocationUpsertArgs>(args: SelectSubset<T, PaymentAllocationUpsertArgs<ExtArgs>>): Prisma__PaymentAllocationClient<$Result.GetResult<Prisma.$PaymentAllocationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PaymentAllocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAllocationCountArgs} args - Arguments to filter PaymentAllocations to count.
     * @example
     * // Count the number of PaymentAllocations
     * const count = await prisma.paymentAllocation.count({
     *   where: {
     *     // ... the filter for the PaymentAllocations we want to count
     *   }
     * })
    **/
    count<T extends PaymentAllocationCountArgs>(
      args?: Subset<T, PaymentAllocationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentAllocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentAllocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAllocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAllocationAggregateArgs>(args: Subset<T, PaymentAllocationAggregateArgs>): Prisma.PrismaPromise<GetPaymentAllocationAggregateType<T>>

    /**
     * Group by PaymentAllocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAllocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentAllocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentAllocationGroupByArgs['orderBy'] }
        : { orderBy?: PaymentAllocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentAllocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentAllocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PaymentAllocation model
   */
  readonly fields: PaymentAllocationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentAllocation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentAllocationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    payment<T extends PaymentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PaymentDefaultArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    invoice<T extends InvoiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceDefaultArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PaymentAllocation model
   */ 
  interface PaymentAllocationFieldRefs {
    readonly id: FieldRef<"PaymentAllocation", 'Int'>
    readonly paymentId: FieldRef<"PaymentAllocation", 'Int'>
    readonly invoiceId: FieldRef<"PaymentAllocation", 'Int'>
    readonly amount: FieldRef<"PaymentAllocation", 'Float'>
    readonly createdAt: FieldRef<"PaymentAllocation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PaymentAllocation findUnique
   */
  export type PaymentAllocationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAllocation
     */
    select?: PaymentAllocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentAllocationInclude<ExtArgs> | null
    /**
     * Filter, which PaymentAllocation to fetch.
     */
    where: PaymentAllocationWhereUniqueInput
  }

  /**
   * PaymentAllocation findUniqueOrThrow
   */
  export type PaymentAllocationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAllocation
     */
    select?: PaymentAllocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentAllocationInclude<ExtArgs> | null
    /**
     * Filter, which PaymentAllocation to fetch.
     */
    where: PaymentAllocationWhereUniqueInput
  }

  /**
   * PaymentAllocation findFirst
   */
  export type PaymentAllocationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAllocation
     */
    select?: PaymentAllocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentAllocationInclude<ExtArgs> | null
    /**
     * Filter, which PaymentAllocation to fetch.
     */
    where?: PaymentAllocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentAllocations to fetch.
     */
    orderBy?: PaymentAllocationOrderByWithRelationInput | PaymentAllocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentAllocations.
     */
    cursor?: PaymentAllocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentAllocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentAllocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentAllocations.
     */
    distinct?: PaymentAllocationScalarFieldEnum | PaymentAllocationScalarFieldEnum[]
  }

  /**
   * PaymentAllocation findFirstOrThrow
   */
  export type PaymentAllocationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAllocation
     */
    select?: PaymentAllocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentAllocationInclude<ExtArgs> | null
    /**
     * Filter, which PaymentAllocation to fetch.
     */
    where?: PaymentAllocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentAllocations to fetch.
     */
    orderBy?: PaymentAllocationOrderByWithRelationInput | PaymentAllocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentAllocations.
     */
    cursor?: PaymentAllocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentAllocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentAllocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentAllocations.
     */
    distinct?: PaymentAllocationScalarFieldEnum | PaymentAllocationScalarFieldEnum[]
  }

  /**
   * PaymentAllocation findMany
   */
  export type PaymentAllocationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAllocation
     */
    select?: PaymentAllocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentAllocationInclude<ExtArgs> | null
    /**
     * Filter, which PaymentAllocations to fetch.
     */
    where?: PaymentAllocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentAllocations to fetch.
     */
    orderBy?: PaymentAllocationOrderByWithRelationInput | PaymentAllocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentAllocations.
     */
    cursor?: PaymentAllocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentAllocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentAllocations.
     */
    skip?: number
    distinct?: PaymentAllocationScalarFieldEnum | PaymentAllocationScalarFieldEnum[]
  }

  /**
   * PaymentAllocation create
   */
  export type PaymentAllocationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAllocation
     */
    select?: PaymentAllocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentAllocationInclude<ExtArgs> | null
    /**
     * The data needed to create a PaymentAllocation.
     */
    data: XOR<PaymentAllocationCreateInput, PaymentAllocationUncheckedCreateInput>
  }

  /**
   * PaymentAllocation createMany
   */
  export type PaymentAllocationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PaymentAllocations.
     */
    data: PaymentAllocationCreateManyInput | PaymentAllocationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentAllocation createManyAndReturn
   */
  export type PaymentAllocationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAllocation
     */
    select?: PaymentAllocationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PaymentAllocations.
     */
    data: PaymentAllocationCreateManyInput | PaymentAllocationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentAllocationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PaymentAllocation update
   */
  export type PaymentAllocationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAllocation
     */
    select?: PaymentAllocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentAllocationInclude<ExtArgs> | null
    /**
     * The data needed to update a PaymentAllocation.
     */
    data: XOR<PaymentAllocationUpdateInput, PaymentAllocationUncheckedUpdateInput>
    /**
     * Choose, which PaymentAllocation to update.
     */
    where: PaymentAllocationWhereUniqueInput
  }

  /**
   * PaymentAllocation updateMany
   */
  export type PaymentAllocationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PaymentAllocations.
     */
    data: XOR<PaymentAllocationUpdateManyMutationInput, PaymentAllocationUncheckedUpdateManyInput>
    /**
     * Filter which PaymentAllocations to update
     */
    where?: PaymentAllocationWhereInput
  }

  /**
   * PaymentAllocation upsert
   */
  export type PaymentAllocationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAllocation
     */
    select?: PaymentAllocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentAllocationInclude<ExtArgs> | null
    /**
     * The filter to search for the PaymentAllocation to update in case it exists.
     */
    where: PaymentAllocationWhereUniqueInput
    /**
     * In case the PaymentAllocation found by the `where` argument doesn't exist, create a new PaymentAllocation with this data.
     */
    create: XOR<PaymentAllocationCreateInput, PaymentAllocationUncheckedCreateInput>
    /**
     * In case the PaymentAllocation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentAllocationUpdateInput, PaymentAllocationUncheckedUpdateInput>
  }

  /**
   * PaymentAllocation delete
   */
  export type PaymentAllocationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAllocation
     */
    select?: PaymentAllocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentAllocationInclude<ExtArgs> | null
    /**
     * Filter which PaymentAllocation to delete.
     */
    where: PaymentAllocationWhereUniqueInput
  }

  /**
   * PaymentAllocation deleteMany
   */
  export type PaymentAllocationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentAllocations to delete
     */
    where?: PaymentAllocationWhereInput
  }

  /**
   * PaymentAllocation without action
   */
  export type PaymentAllocationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAllocation
     */
    select?: PaymentAllocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentAllocationInclude<ExtArgs> | null
  }


  /**
   * Model RecurringInvoice
   */

  export type AggregateRecurringInvoice = {
    _count: RecurringInvoiceCountAggregateOutputType | null
    _avg: RecurringInvoiceAvgAggregateOutputType | null
    _sum: RecurringInvoiceSumAggregateOutputType | null
    _min: RecurringInvoiceMinAggregateOutputType | null
    _max: RecurringInvoiceMaxAggregateOutputType | null
  }

  export type RecurringInvoiceAvgAggregateOutputType = {
    id: number | null
    customerId: number | null
    subtotalHt: number | null
    totalVat: number | null
    totalTtc: number | null
    createdBy: number | null
  }

  export type RecurringInvoiceSumAggregateOutputType = {
    id: number | null
    customerId: number | null
    subtotalHt: number | null
    totalVat: number | null
    totalTtc: number | null
    createdBy: number | null
  }

  export type RecurringInvoiceMinAggregateOutputType = {
    id: number | null
    customerId: number | null
    templateName: string | null
    frequency: $Enums.RecurringFrequency | null
    startDate: Date | null
    endDate: Date | null
    nextInvoiceDate: Date | null
    isActive: boolean | null
    subtotalHt: number | null
    totalVat: number | null
    totalTtc: number | null
    terms: string | null
    notes: string | null
    createdBy: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RecurringInvoiceMaxAggregateOutputType = {
    id: number | null
    customerId: number | null
    templateName: string | null
    frequency: $Enums.RecurringFrequency | null
    startDate: Date | null
    endDate: Date | null
    nextInvoiceDate: Date | null
    isActive: boolean | null
    subtotalHt: number | null
    totalVat: number | null
    totalTtc: number | null
    terms: string | null
    notes: string | null
    createdBy: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RecurringInvoiceCountAggregateOutputType = {
    id: number
    customerId: number
    templateName: number
    frequency: number
    startDate: number
    endDate: number
    nextInvoiceDate: number
    isActive: number
    subtotalHt: number
    totalVat: number
    totalTtc: number
    terms: number
    notes: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RecurringInvoiceAvgAggregateInputType = {
    id?: true
    customerId?: true
    subtotalHt?: true
    totalVat?: true
    totalTtc?: true
    createdBy?: true
  }

  export type RecurringInvoiceSumAggregateInputType = {
    id?: true
    customerId?: true
    subtotalHt?: true
    totalVat?: true
    totalTtc?: true
    createdBy?: true
  }

  export type RecurringInvoiceMinAggregateInputType = {
    id?: true
    customerId?: true
    templateName?: true
    frequency?: true
    startDate?: true
    endDate?: true
    nextInvoiceDate?: true
    isActive?: true
    subtotalHt?: true
    totalVat?: true
    totalTtc?: true
    terms?: true
    notes?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RecurringInvoiceMaxAggregateInputType = {
    id?: true
    customerId?: true
    templateName?: true
    frequency?: true
    startDate?: true
    endDate?: true
    nextInvoiceDate?: true
    isActive?: true
    subtotalHt?: true
    totalVat?: true
    totalTtc?: true
    terms?: true
    notes?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RecurringInvoiceCountAggregateInputType = {
    id?: true
    customerId?: true
    templateName?: true
    frequency?: true
    startDate?: true
    endDate?: true
    nextInvoiceDate?: true
    isActive?: true
    subtotalHt?: true
    totalVat?: true
    totalTtc?: true
    terms?: true
    notes?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RecurringInvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecurringInvoice to aggregate.
     */
    where?: RecurringInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecurringInvoices to fetch.
     */
    orderBy?: RecurringInvoiceOrderByWithRelationInput | RecurringInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RecurringInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecurringInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecurringInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RecurringInvoices
    **/
    _count?: true | RecurringInvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RecurringInvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RecurringInvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecurringInvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecurringInvoiceMaxAggregateInputType
  }

  export type GetRecurringInvoiceAggregateType<T extends RecurringInvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateRecurringInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecurringInvoice[P]>
      : GetScalarType<T[P], AggregateRecurringInvoice[P]>
  }




  export type RecurringInvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecurringInvoiceWhereInput
    orderBy?: RecurringInvoiceOrderByWithAggregationInput | RecurringInvoiceOrderByWithAggregationInput[]
    by: RecurringInvoiceScalarFieldEnum[] | RecurringInvoiceScalarFieldEnum
    having?: RecurringInvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecurringInvoiceCountAggregateInputType | true
    _avg?: RecurringInvoiceAvgAggregateInputType
    _sum?: RecurringInvoiceSumAggregateInputType
    _min?: RecurringInvoiceMinAggregateInputType
    _max?: RecurringInvoiceMaxAggregateInputType
  }

  export type RecurringInvoiceGroupByOutputType = {
    id: number
    customerId: number
    templateName: string
    frequency: $Enums.RecurringFrequency
    startDate: Date
    endDate: Date | null
    nextInvoiceDate: Date
    isActive: boolean
    subtotalHt: number
    totalVat: number
    totalTtc: number
    terms: string | null
    notes: string | null
    createdBy: number
    createdAt: Date
    updatedAt: Date
    _count: RecurringInvoiceCountAggregateOutputType | null
    _avg: RecurringInvoiceAvgAggregateOutputType | null
    _sum: RecurringInvoiceSumAggregateOutputType | null
    _min: RecurringInvoiceMinAggregateOutputType | null
    _max: RecurringInvoiceMaxAggregateOutputType | null
  }

  type GetRecurringInvoiceGroupByPayload<T extends RecurringInvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecurringInvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecurringInvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecurringInvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], RecurringInvoiceGroupByOutputType[P]>
        }
      >
    >


  export type RecurringInvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    templateName?: boolean
    frequency?: boolean
    startDate?: boolean
    endDate?: boolean
    nextInvoiceDate?: boolean
    isActive?: boolean
    subtotalHt?: boolean
    totalVat?: boolean
    totalTtc?: boolean
    terms?: boolean
    notes?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    items?: boolean | RecurringInvoice$itemsArgs<ExtArgs>
    _count?: boolean | RecurringInvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recurringInvoice"]>

  export type RecurringInvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    templateName?: boolean
    frequency?: boolean
    startDate?: boolean
    endDate?: boolean
    nextInvoiceDate?: boolean
    isActive?: boolean
    subtotalHt?: boolean
    totalVat?: boolean
    totalTtc?: boolean
    terms?: boolean
    notes?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recurringInvoice"]>

  export type RecurringInvoiceSelectScalar = {
    id?: boolean
    customerId?: boolean
    templateName?: boolean
    frequency?: boolean
    startDate?: boolean
    endDate?: boolean
    nextInvoiceDate?: boolean
    isActive?: boolean
    subtotalHt?: boolean
    totalVat?: boolean
    totalTtc?: boolean
    terms?: boolean
    notes?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RecurringInvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    items?: boolean | RecurringInvoice$itemsArgs<ExtArgs>
    _count?: boolean | RecurringInvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RecurringInvoiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RecurringInvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RecurringInvoice"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
      creator: Prisma.$UserPayload<ExtArgs>
      items: Prisma.$RecurringInvoiceItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      customerId: number
      templateName: string
      frequency: $Enums.RecurringFrequency
      startDate: Date
      endDate: Date | null
      nextInvoiceDate: Date
      isActive: boolean
      subtotalHt: number
      totalVat: number
      totalTtc: number
      terms: string | null
      notes: string | null
      createdBy: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["recurringInvoice"]>
    composites: {}
  }

  type RecurringInvoiceGetPayload<S extends boolean | null | undefined | RecurringInvoiceDefaultArgs> = $Result.GetResult<Prisma.$RecurringInvoicePayload, S>

  type RecurringInvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RecurringInvoiceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RecurringInvoiceCountAggregateInputType | true
    }

  export interface RecurringInvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RecurringInvoice'], meta: { name: 'RecurringInvoice' } }
    /**
     * Find zero or one RecurringInvoice that matches the filter.
     * @param {RecurringInvoiceFindUniqueArgs} args - Arguments to find a RecurringInvoice
     * @example
     * // Get one RecurringInvoice
     * const recurringInvoice = await prisma.recurringInvoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RecurringInvoiceFindUniqueArgs>(args: SelectSubset<T, RecurringInvoiceFindUniqueArgs<ExtArgs>>): Prisma__RecurringInvoiceClient<$Result.GetResult<Prisma.$RecurringInvoicePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RecurringInvoice that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RecurringInvoiceFindUniqueOrThrowArgs} args - Arguments to find a RecurringInvoice
     * @example
     * // Get one RecurringInvoice
     * const recurringInvoice = await prisma.recurringInvoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RecurringInvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, RecurringInvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RecurringInvoiceClient<$Result.GetResult<Prisma.$RecurringInvoicePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RecurringInvoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringInvoiceFindFirstArgs} args - Arguments to find a RecurringInvoice
     * @example
     * // Get one RecurringInvoice
     * const recurringInvoice = await prisma.recurringInvoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RecurringInvoiceFindFirstArgs>(args?: SelectSubset<T, RecurringInvoiceFindFirstArgs<ExtArgs>>): Prisma__RecurringInvoiceClient<$Result.GetResult<Prisma.$RecurringInvoicePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RecurringInvoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringInvoiceFindFirstOrThrowArgs} args - Arguments to find a RecurringInvoice
     * @example
     * // Get one RecurringInvoice
     * const recurringInvoice = await prisma.recurringInvoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RecurringInvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, RecurringInvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__RecurringInvoiceClient<$Result.GetResult<Prisma.$RecurringInvoicePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RecurringInvoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringInvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RecurringInvoices
     * const recurringInvoices = await prisma.recurringInvoice.findMany()
     * 
     * // Get first 10 RecurringInvoices
     * const recurringInvoices = await prisma.recurringInvoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const recurringInvoiceWithIdOnly = await prisma.recurringInvoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RecurringInvoiceFindManyArgs>(args?: SelectSubset<T, RecurringInvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecurringInvoicePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RecurringInvoice.
     * @param {RecurringInvoiceCreateArgs} args - Arguments to create a RecurringInvoice.
     * @example
     * // Create one RecurringInvoice
     * const RecurringInvoice = await prisma.recurringInvoice.create({
     *   data: {
     *     // ... data to create a RecurringInvoice
     *   }
     * })
     * 
     */
    create<T extends RecurringInvoiceCreateArgs>(args: SelectSubset<T, RecurringInvoiceCreateArgs<ExtArgs>>): Prisma__RecurringInvoiceClient<$Result.GetResult<Prisma.$RecurringInvoicePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RecurringInvoices.
     * @param {RecurringInvoiceCreateManyArgs} args - Arguments to create many RecurringInvoices.
     * @example
     * // Create many RecurringInvoices
     * const recurringInvoice = await prisma.recurringInvoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RecurringInvoiceCreateManyArgs>(args?: SelectSubset<T, RecurringInvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RecurringInvoices and returns the data saved in the database.
     * @param {RecurringInvoiceCreateManyAndReturnArgs} args - Arguments to create many RecurringInvoices.
     * @example
     * // Create many RecurringInvoices
     * const recurringInvoice = await prisma.recurringInvoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RecurringInvoices and only return the `id`
     * const recurringInvoiceWithIdOnly = await prisma.recurringInvoice.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RecurringInvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, RecurringInvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecurringInvoicePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RecurringInvoice.
     * @param {RecurringInvoiceDeleteArgs} args - Arguments to delete one RecurringInvoice.
     * @example
     * // Delete one RecurringInvoice
     * const RecurringInvoice = await prisma.recurringInvoice.delete({
     *   where: {
     *     // ... filter to delete one RecurringInvoice
     *   }
     * })
     * 
     */
    delete<T extends RecurringInvoiceDeleteArgs>(args: SelectSubset<T, RecurringInvoiceDeleteArgs<ExtArgs>>): Prisma__RecurringInvoiceClient<$Result.GetResult<Prisma.$RecurringInvoicePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RecurringInvoice.
     * @param {RecurringInvoiceUpdateArgs} args - Arguments to update one RecurringInvoice.
     * @example
     * // Update one RecurringInvoice
     * const recurringInvoice = await prisma.recurringInvoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RecurringInvoiceUpdateArgs>(args: SelectSubset<T, RecurringInvoiceUpdateArgs<ExtArgs>>): Prisma__RecurringInvoiceClient<$Result.GetResult<Prisma.$RecurringInvoicePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RecurringInvoices.
     * @param {RecurringInvoiceDeleteManyArgs} args - Arguments to filter RecurringInvoices to delete.
     * @example
     * // Delete a few RecurringInvoices
     * const { count } = await prisma.recurringInvoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RecurringInvoiceDeleteManyArgs>(args?: SelectSubset<T, RecurringInvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecurringInvoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringInvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RecurringInvoices
     * const recurringInvoice = await prisma.recurringInvoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RecurringInvoiceUpdateManyArgs>(args: SelectSubset<T, RecurringInvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RecurringInvoice.
     * @param {RecurringInvoiceUpsertArgs} args - Arguments to update or create a RecurringInvoice.
     * @example
     * // Update or create a RecurringInvoice
     * const recurringInvoice = await prisma.recurringInvoice.upsert({
     *   create: {
     *     // ... data to create a RecurringInvoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RecurringInvoice we want to update
     *   }
     * })
     */
    upsert<T extends RecurringInvoiceUpsertArgs>(args: SelectSubset<T, RecurringInvoiceUpsertArgs<ExtArgs>>): Prisma__RecurringInvoiceClient<$Result.GetResult<Prisma.$RecurringInvoicePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RecurringInvoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringInvoiceCountArgs} args - Arguments to filter RecurringInvoices to count.
     * @example
     * // Count the number of RecurringInvoices
     * const count = await prisma.recurringInvoice.count({
     *   where: {
     *     // ... the filter for the RecurringInvoices we want to count
     *   }
     * })
    **/
    count<T extends RecurringInvoiceCountArgs>(
      args?: Subset<T, RecurringInvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecurringInvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RecurringInvoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringInvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecurringInvoiceAggregateArgs>(args: Subset<T, RecurringInvoiceAggregateArgs>): Prisma.PrismaPromise<GetRecurringInvoiceAggregateType<T>>

    /**
     * Group by RecurringInvoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringInvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecurringInvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecurringInvoiceGroupByArgs['orderBy'] }
        : { orderBy?: RecurringInvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecurringInvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecurringInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RecurringInvoice model
   */
  readonly fields: RecurringInvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RecurringInvoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RecurringInvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    items<T extends RecurringInvoice$itemsArgs<ExtArgs> = {}>(args?: Subset<T, RecurringInvoice$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecurringInvoiceItemPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RecurringInvoice model
   */ 
  interface RecurringInvoiceFieldRefs {
    readonly id: FieldRef<"RecurringInvoice", 'Int'>
    readonly customerId: FieldRef<"RecurringInvoice", 'Int'>
    readonly templateName: FieldRef<"RecurringInvoice", 'String'>
    readonly frequency: FieldRef<"RecurringInvoice", 'RecurringFrequency'>
    readonly startDate: FieldRef<"RecurringInvoice", 'DateTime'>
    readonly endDate: FieldRef<"RecurringInvoice", 'DateTime'>
    readonly nextInvoiceDate: FieldRef<"RecurringInvoice", 'DateTime'>
    readonly isActive: FieldRef<"RecurringInvoice", 'Boolean'>
    readonly subtotalHt: FieldRef<"RecurringInvoice", 'Float'>
    readonly totalVat: FieldRef<"RecurringInvoice", 'Float'>
    readonly totalTtc: FieldRef<"RecurringInvoice", 'Float'>
    readonly terms: FieldRef<"RecurringInvoice", 'String'>
    readonly notes: FieldRef<"RecurringInvoice", 'String'>
    readonly createdBy: FieldRef<"RecurringInvoice", 'Int'>
    readonly createdAt: FieldRef<"RecurringInvoice", 'DateTime'>
    readonly updatedAt: FieldRef<"RecurringInvoice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RecurringInvoice findUnique
   */
  export type RecurringInvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringInvoice
     */
    select?: RecurringInvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which RecurringInvoice to fetch.
     */
    where: RecurringInvoiceWhereUniqueInput
  }

  /**
   * RecurringInvoice findUniqueOrThrow
   */
  export type RecurringInvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringInvoice
     */
    select?: RecurringInvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which RecurringInvoice to fetch.
     */
    where: RecurringInvoiceWhereUniqueInput
  }

  /**
   * RecurringInvoice findFirst
   */
  export type RecurringInvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringInvoice
     */
    select?: RecurringInvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which RecurringInvoice to fetch.
     */
    where?: RecurringInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecurringInvoices to fetch.
     */
    orderBy?: RecurringInvoiceOrderByWithRelationInput | RecurringInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecurringInvoices.
     */
    cursor?: RecurringInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecurringInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecurringInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecurringInvoices.
     */
    distinct?: RecurringInvoiceScalarFieldEnum | RecurringInvoiceScalarFieldEnum[]
  }

  /**
   * RecurringInvoice findFirstOrThrow
   */
  export type RecurringInvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringInvoice
     */
    select?: RecurringInvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which RecurringInvoice to fetch.
     */
    where?: RecurringInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecurringInvoices to fetch.
     */
    orderBy?: RecurringInvoiceOrderByWithRelationInput | RecurringInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecurringInvoices.
     */
    cursor?: RecurringInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecurringInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecurringInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecurringInvoices.
     */
    distinct?: RecurringInvoiceScalarFieldEnum | RecurringInvoiceScalarFieldEnum[]
  }

  /**
   * RecurringInvoice findMany
   */
  export type RecurringInvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringInvoice
     */
    select?: RecurringInvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which RecurringInvoices to fetch.
     */
    where?: RecurringInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecurringInvoices to fetch.
     */
    orderBy?: RecurringInvoiceOrderByWithRelationInput | RecurringInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RecurringInvoices.
     */
    cursor?: RecurringInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecurringInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecurringInvoices.
     */
    skip?: number
    distinct?: RecurringInvoiceScalarFieldEnum | RecurringInvoiceScalarFieldEnum[]
  }

  /**
   * RecurringInvoice create
   */
  export type RecurringInvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringInvoice
     */
    select?: RecurringInvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringInvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a RecurringInvoice.
     */
    data: XOR<RecurringInvoiceCreateInput, RecurringInvoiceUncheckedCreateInput>
  }

  /**
   * RecurringInvoice createMany
   */
  export type RecurringInvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RecurringInvoices.
     */
    data: RecurringInvoiceCreateManyInput | RecurringInvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RecurringInvoice createManyAndReturn
   */
  export type RecurringInvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringInvoice
     */
    select?: RecurringInvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RecurringInvoices.
     */
    data: RecurringInvoiceCreateManyInput | RecurringInvoiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringInvoiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RecurringInvoice update
   */
  export type RecurringInvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringInvoice
     */
    select?: RecurringInvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringInvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a RecurringInvoice.
     */
    data: XOR<RecurringInvoiceUpdateInput, RecurringInvoiceUncheckedUpdateInput>
    /**
     * Choose, which RecurringInvoice to update.
     */
    where: RecurringInvoiceWhereUniqueInput
  }

  /**
   * RecurringInvoice updateMany
   */
  export type RecurringInvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RecurringInvoices.
     */
    data: XOR<RecurringInvoiceUpdateManyMutationInput, RecurringInvoiceUncheckedUpdateManyInput>
    /**
     * Filter which RecurringInvoices to update
     */
    where?: RecurringInvoiceWhereInput
  }

  /**
   * RecurringInvoice upsert
   */
  export type RecurringInvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringInvoice
     */
    select?: RecurringInvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringInvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the RecurringInvoice to update in case it exists.
     */
    where: RecurringInvoiceWhereUniqueInput
    /**
     * In case the RecurringInvoice found by the `where` argument doesn't exist, create a new RecurringInvoice with this data.
     */
    create: XOR<RecurringInvoiceCreateInput, RecurringInvoiceUncheckedCreateInput>
    /**
     * In case the RecurringInvoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RecurringInvoiceUpdateInput, RecurringInvoiceUncheckedUpdateInput>
  }

  /**
   * RecurringInvoice delete
   */
  export type RecurringInvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringInvoice
     */
    select?: RecurringInvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringInvoiceInclude<ExtArgs> | null
    /**
     * Filter which RecurringInvoice to delete.
     */
    where: RecurringInvoiceWhereUniqueInput
  }

  /**
   * RecurringInvoice deleteMany
   */
  export type RecurringInvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecurringInvoices to delete
     */
    where?: RecurringInvoiceWhereInput
  }

  /**
   * RecurringInvoice.items
   */
  export type RecurringInvoice$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringInvoiceItem
     */
    select?: RecurringInvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringInvoiceItemInclude<ExtArgs> | null
    where?: RecurringInvoiceItemWhereInput
    orderBy?: RecurringInvoiceItemOrderByWithRelationInput | RecurringInvoiceItemOrderByWithRelationInput[]
    cursor?: RecurringInvoiceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecurringInvoiceItemScalarFieldEnum | RecurringInvoiceItemScalarFieldEnum[]
  }

  /**
   * RecurringInvoice without action
   */
  export type RecurringInvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringInvoice
     */
    select?: RecurringInvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringInvoiceInclude<ExtArgs> | null
  }


  /**
   * Model RecurringInvoiceItem
   */

  export type AggregateRecurringInvoiceItem = {
    _count: RecurringInvoiceItemCountAggregateOutputType | null
    _avg: RecurringInvoiceItemAvgAggregateOutputType | null
    _sum: RecurringInvoiceItemSumAggregateOutputType | null
    _min: RecurringInvoiceItemMinAggregateOutputType | null
    _max: RecurringInvoiceItemMaxAggregateOutputType | null
  }

  export type RecurringInvoiceItemAvgAggregateOutputType = {
    id: number | null
    recurringInvoiceId: number | null
    productId: number | null
    quantity: number | null
    unitPriceHt: number | null
    vatRate: number | null
    totalHt: number | null
    sortOrder: number | null
  }

  export type RecurringInvoiceItemSumAggregateOutputType = {
    id: number | null
    recurringInvoiceId: number | null
    productId: number | null
    quantity: number | null
    unitPriceHt: number | null
    vatRate: number | null
    totalHt: number | null
    sortOrder: number | null
  }

  export type RecurringInvoiceItemMinAggregateOutputType = {
    id: number | null
    recurringInvoiceId: number | null
    productId: number | null
    description: string | null
    quantity: number | null
    unitPriceHt: number | null
    vatRate: number | null
    totalHt: number | null
    sortOrder: number | null
  }

  export type RecurringInvoiceItemMaxAggregateOutputType = {
    id: number | null
    recurringInvoiceId: number | null
    productId: number | null
    description: string | null
    quantity: number | null
    unitPriceHt: number | null
    vatRate: number | null
    totalHt: number | null
    sortOrder: number | null
  }

  export type RecurringInvoiceItemCountAggregateOutputType = {
    id: number
    recurringInvoiceId: number
    productId: number
    description: number
    quantity: number
    unitPriceHt: number
    vatRate: number
    totalHt: number
    sortOrder: number
    _all: number
  }


  export type RecurringInvoiceItemAvgAggregateInputType = {
    id?: true
    recurringInvoiceId?: true
    productId?: true
    quantity?: true
    unitPriceHt?: true
    vatRate?: true
    totalHt?: true
    sortOrder?: true
  }

  export type RecurringInvoiceItemSumAggregateInputType = {
    id?: true
    recurringInvoiceId?: true
    productId?: true
    quantity?: true
    unitPriceHt?: true
    vatRate?: true
    totalHt?: true
    sortOrder?: true
  }

  export type RecurringInvoiceItemMinAggregateInputType = {
    id?: true
    recurringInvoiceId?: true
    productId?: true
    description?: true
    quantity?: true
    unitPriceHt?: true
    vatRate?: true
    totalHt?: true
    sortOrder?: true
  }

  export type RecurringInvoiceItemMaxAggregateInputType = {
    id?: true
    recurringInvoiceId?: true
    productId?: true
    description?: true
    quantity?: true
    unitPriceHt?: true
    vatRate?: true
    totalHt?: true
    sortOrder?: true
  }

  export type RecurringInvoiceItemCountAggregateInputType = {
    id?: true
    recurringInvoiceId?: true
    productId?: true
    description?: true
    quantity?: true
    unitPriceHt?: true
    vatRate?: true
    totalHt?: true
    sortOrder?: true
    _all?: true
  }

  export type RecurringInvoiceItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecurringInvoiceItem to aggregate.
     */
    where?: RecurringInvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecurringInvoiceItems to fetch.
     */
    orderBy?: RecurringInvoiceItemOrderByWithRelationInput | RecurringInvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RecurringInvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecurringInvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecurringInvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RecurringInvoiceItems
    **/
    _count?: true | RecurringInvoiceItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RecurringInvoiceItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RecurringInvoiceItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecurringInvoiceItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecurringInvoiceItemMaxAggregateInputType
  }

  export type GetRecurringInvoiceItemAggregateType<T extends RecurringInvoiceItemAggregateArgs> = {
        [P in keyof T & keyof AggregateRecurringInvoiceItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecurringInvoiceItem[P]>
      : GetScalarType<T[P], AggregateRecurringInvoiceItem[P]>
  }




  export type RecurringInvoiceItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecurringInvoiceItemWhereInput
    orderBy?: RecurringInvoiceItemOrderByWithAggregationInput | RecurringInvoiceItemOrderByWithAggregationInput[]
    by: RecurringInvoiceItemScalarFieldEnum[] | RecurringInvoiceItemScalarFieldEnum
    having?: RecurringInvoiceItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecurringInvoiceItemCountAggregateInputType | true
    _avg?: RecurringInvoiceItemAvgAggregateInputType
    _sum?: RecurringInvoiceItemSumAggregateInputType
    _min?: RecurringInvoiceItemMinAggregateInputType
    _max?: RecurringInvoiceItemMaxAggregateInputType
  }

  export type RecurringInvoiceItemGroupByOutputType = {
    id: number
    recurringInvoiceId: number
    productId: number | null
    description: string
    quantity: number
    unitPriceHt: number
    vatRate: number
    totalHt: number
    sortOrder: number
    _count: RecurringInvoiceItemCountAggregateOutputType | null
    _avg: RecurringInvoiceItemAvgAggregateOutputType | null
    _sum: RecurringInvoiceItemSumAggregateOutputType | null
    _min: RecurringInvoiceItemMinAggregateOutputType | null
    _max: RecurringInvoiceItemMaxAggregateOutputType | null
  }

  type GetRecurringInvoiceItemGroupByPayload<T extends RecurringInvoiceItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecurringInvoiceItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecurringInvoiceItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecurringInvoiceItemGroupByOutputType[P]>
            : GetScalarType<T[P], RecurringInvoiceItemGroupByOutputType[P]>
        }
      >
    >


  export type RecurringInvoiceItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recurringInvoiceId?: boolean
    productId?: boolean
    description?: boolean
    quantity?: boolean
    unitPriceHt?: boolean
    vatRate?: boolean
    totalHt?: boolean
    sortOrder?: boolean
    recurringInvoice?: boolean | RecurringInvoiceDefaultArgs<ExtArgs>
    product?: boolean | RecurringInvoiceItem$productArgs<ExtArgs>
  }, ExtArgs["result"]["recurringInvoiceItem"]>

  export type RecurringInvoiceItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recurringInvoiceId?: boolean
    productId?: boolean
    description?: boolean
    quantity?: boolean
    unitPriceHt?: boolean
    vatRate?: boolean
    totalHt?: boolean
    sortOrder?: boolean
    recurringInvoice?: boolean | RecurringInvoiceDefaultArgs<ExtArgs>
    product?: boolean | RecurringInvoiceItem$productArgs<ExtArgs>
  }, ExtArgs["result"]["recurringInvoiceItem"]>

  export type RecurringInvoiceItemSelectScalar = {
    id?: boolean
    recurringInvoiceId?: boolean
    productId?: boolean
    description?: boolean
    quantity?: boolean
    unitPriceHt?: boolean
    vatRate?: boolean
    totalHt?: boolean
    sortOrder?: boolean
  }

  export type RecurringInvoiceItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recurringInvoice?: boolean | RecurringInvoiceDefaultArgs<ExtArgs>
    product?: boolean | RecurringInvoiceItem$productArgs<ExtArgs>
  }
  export type RecurringInvoiceItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recurringInvoice?: boolean | RecurringInvoiceDefaultArgs<ExtArgs>
    product?: boolean | RecurringInvoiceItem$productArgs<ExtArgs>
  }

  export type $RecurringInvoiceItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RecurringInvoiceItem"
    objects: {
      recurringInvoice: Prisma.$RecurringInvoicePayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      recurringInvoiceId: number
      productId: number | null
      description: string
      quantity: number
      unitPriceHt: number
      vatRate: number
      totalHt: number
      sortOrder: number
    }, ExtArgs["result"]["recurringInvoiceItem"]>
    composites: {}
  }

  type RecurringInvoiceItemGetPayload<S extends boolean | null | undefined | RecurringInvoiceItemDefaultArgs> = $Result.GetResult<Prisma.$RecurringInvoiceItemPayload, S>

  type RecurringInvoiceItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RecurringInvoiceItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RecurringInvoiceItemCountAggregateInputType | true
    }

  export interface RecurringInvoiceItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RecurringInvoiceItem'], meta: { name: 'RecurringInvoiceItem' } }
    /**
     * Find zero or one RecurringInvoiceItem that matches the filter.
     * @param {RecurringInvoiceItemFindUniqueArgs} args - Arguments to find a RecurringInvoiceItem
     * @example
     * // Get one RecurringInvoiceItem
     * const recurringInvoiceItem = await prisma.recurringInvoiceItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RecurringInvoiceItemFindUniqueArgs>(args: SelectSubset<T, RecurringInvoiceItemFindUniqueArgs<ExtArgs>>): Prisma__RecurringInvoiceItemClient<$Result.GetResult<Prisma.$RecurringInvoiceItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RecurringInvoiceItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RecurringInvoiceItemFindUniqueOrThrowArgs} args - Arguments to find a RecurringInvoiceItem
     * @example
     * // Get one RecurringInvoiceItem
     * const recurringInvoiceItem = await prisma.recurringInvoiceItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RecurringInvoiceItemFindUniqueOrThrowArgs>(args: SelectSubset<T, RecurringInvoiceItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RecurringInvoiceItemClient<$Result.GetResult<Prisma.$RecurringInvoiceItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RecurringInvoiceItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringInvoiceItemFindFirstArgs} args - Arguments to find a RecurringInvoiceItem
     * @example
     * // Get one RecurringInvoiceItem
     * const recurringInvoiceItem = await prisma.recurringInvoiceItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RecurringInvoiceItemFindFirstArgs>(args?: SelectSubset<T, RecurringInvoiceItemFindFirstArgs<ExtArgs>>): Prisma__RecurringInvoiceItemClient<$Result.GetResult<Prisma.$RecurringInvoiceItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RecurringInvoiceItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringInvoiceItemFindFirstOrThrowArgs} args - Arguments to find a RecurringInvoiceItem
     * @example
     * // Get one RecurringInvoiceItem
     * const recurringInvoiceItem = await prisma.recurringInvoiceItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RecurringInvoiceItemFindFirstOrThrowArgs>(args?: SelectSubset<T, RecurringInvoiceItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__RecurringInvoiceItemClient<$Result.GetResult<Prisma.$RecurringInvoiceItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RecurringInvoiceItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringInvoiceItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RecurringInvoiceItems
     * const recurringInvoiceItems = await prisma.recurringInvoiceItem.findMany()
     * 
     * // Get first 10 RecurringInvoiceItems
     * const recurringInvoiceItems = await prisma.recurringInvoiceItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const recurringInvoiceItemWithIdOnly = await prisma.recurringInvoiceItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RecurringInvoiceItemFindManyArgs>(args?: SelectSubset<T, RecurringInvoiceItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecurringInvoiceItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RecurringInvoiceItem.
     * @param {RecurringInvoiceItemCreateArgs} args - Arguments to create a RecurringInvoiceItem.
     * @example
     * // Create one RecurringInvoiceItem
     * const RecurringInvoiceItem = await prisma.recurringInvoiceItem.create({
     *   data: {
     *     // ... data to create a RecurringInvoiceItem
     *   }
     * })
     * 
     */
    create<T extends RecurringInvoiceItemCreateArgs>(args: SelectSubset<T, RecurringInvoiceItemCreateArgs<ExtArgs>>): Prisma__RecurringInvoiceItemClient<$Result.GetResult<Prisma.$RecurringInvoiceItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RecurringInvoiceItems.
     * @param {RecurringInvoiceItemCreateManyArgs} args - Arguments to create many RecurringInvoiceItems.
     * @example
     * // Create many RecurringInvoiceItems
     * const recurringInvoiceItem = await prisma.recurringInvoiceItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RecurringInvoiceItemCreateManyArgs>(args?: SelectSubset<T, RecurringInvoiceItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RecurringInvoiceItems and returns the data saved in the database.
     * @param {RecurringInvoiceItemCreateManyAndReturnArgs} args - Arguments to create many RecurringInvoiceItems.
     * @example
     * // Create many RecurringInvoiceItems
     * const recurringInvoiceItem = await prisma.recurringInvoiceItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RecurringInvoiceItems and only return the `id`
     * const recurringInvoiceItemWithIdOnly = await prisma.recurringInvoiceItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RecurringInvoiceItemCreateManyAndReturnArgs>(args?: SelectSubset<T, RecurringInvoiceItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecurringInvoiceItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RecurringInvoiceItem.
     * @param {RecurringInvoiceItemDeleteArgs} args - Arguments to delete one RecurringInvoiceItem.
     * @example
     * // Delete one RecurringInvoiceItem
     * const RecurringInvoiceItem = await prisma.recurringInvoiceItem.delete({
     *   where: {
     *     // ... filter to delete one RecurringInvoiceItem
     *   }
     * })
     * 
     */
    delete<T extends RecurringInvoiceItemDeleteArgs>(args: SelectSubset<T, RecurringInvoiceItemDeleteArgs<ExtArgs>>): Prisma__RecurringInvoiceItemClient<$Result.GetResult<Prisma.$RecurringInvoiceItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RecurringInvoiceItem.
     * @param {RecurringInvoiceItemUpdateArgs} args - Arguments to update one RecurringInvoiceItem.
     * @example
     * // Update one RecurringInvoiceItem
     * const recurringInvoiceItem = await prisma.recurringInvoiceItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RecurringInvoiceItemUpdateArgs>(args: SelectSubset<T, RecurringInvoiceItemUpdateArgs<ExtArgs>>): Prisma__RecurringInvoiceItemClient<$Result.GetResult<Prisma.$RecurringInvoiceItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RecurringInvoiceItems.
     * @param {RecurringInvoiceItemDeleteManyArgs} args - Arguments to filter RecurringInvoiceItems to delete.
     * @example
     * // Delete a few RecurringInvoiceItems
     * const { count } = await prisma.recurringInvoiceItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RecurringInvoiceItemDeleteManyArgs>(args?: SelectSubset<T, RecurringInvoiceItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecurringInvoiceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringInvoiceItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RecurringInvoiceItems
     * const recurringInvoiceItem = await prisma.recurringInvoiceItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RecurringInvoiceItemUpdateManyArgs>(args: SelectSubset<T, RecurringInvoiceItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RecurringInvoiceItem.
     * @param {RecurringInvoiceItemUpsertArgs} args - Arguments to update or create a RecurringInvoiceItem.
     * @example
     * // Update or create a RecurringInvoiceItem
     * const recurringInvoiceItem = await prisma.recurringInvoiceItem.upsert({
     *   create: {
     *     // ... data to create a RecurringInvoiceItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RecurringInvoiceItem we want to update
     *   }
     * })
     */
    upsert<T extends RecurringInvoiceItemUpsertArgs>(args: SelectSubset<T, RecurringInvoiceItemUpsertArgs<ExtArgs>>): Prisma__RecurringInvoiceItemClient<$Result.GetResult<Prisma.$RecurringInvoiceItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RecurringInvoiceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringInvoiceItemCountArgs} args - Arguments to filter RecurringInvoiceItems to count.
     * @example
     * // Count the number of RecurringInvoiceItems
     * const count = await prisma.recurringInvoiceItem.count({
     *   where: {
     *     // ... the filter for the RecurringInvoiceItems we want to count
     *   }
     * })
    **/
    count<T extends RecurringInvoiceItemCountArgs>(
      args?: Subset<T, RecurringInvoiceItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecurringInvoiceItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RecurringInvoiceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringInvoiceItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecurringInvoiceItemAggregateArgs>(args: Subset<T, RecurringInvoiceItemAggregateArgs>): Prisma.PrismaPromise<GetRecurringInvoiceItemAggregateType<T>>

    /**
     * Group by RecurringInvoiceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringInvoiceItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecurringInvoiceItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecurringInvoiceItemGroupByArgs['orderBy'] }
        : { orderBy?: RecurringInvoiceItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecurringInvoiceItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecurringInvoiceItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RecurringInvoiceItem model
   */
  readonly fields: RecurringInvoiceItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RecurringInvoiceItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RecurringInvoiceItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    recurringInvoice<T extends RecurringInvoiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RecurringInvoiceDefaultArgs<ExtArgs>>): Prisma__RecurringInvoiceClient<$Result.GetResult<Prisma.$RecurringInvoicePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    product<T extends RecurringInvoiceItem$productArgs<ExtArgs> = {}>(args?: Subset<T, RecurringInvoiceItem$productArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RecurringInvoiceItem model
   */ 
  interface RecurringInvoiceItemFieldRefs {
    readonly id: FieldRef<"RecurringInvoiceItem", 'Int'>
    readonly recurringInvoiceId: FieldRef<"RecurringInvoiceItem", 'Int'>
    readonly productId: FieldRef<"RecurringInvoiceItem", 'Int'>
    readonly description: FieldRef<"RecurringInvoiceItem", 'String'>
    readonly quantity: FieldRef<"RecurringInvoiceItem", 'Float'>
    readonly unitPriceHt: FieldRef<"RecurringInvoiceItem", 'Float'>
    readonly vatRate: FieldRef<"RecurringInvoiceItem", 'Float'>
    readonly totalHt: FieldRef<"RecurringInvoiceItem", 'Float'>
    readonly sortOrder: FieldRef<"RecurringInvoiceItem", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * RecurringInvoiceItem findUnique
   */
  export type RecurringInvoiceItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringInvoiceItem
     */
    select?: RecurringInvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringInvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which RecurringInvoiceItem to fetch.
     */
    where: RecurringInvoiceItemWhereUniqueInput
  }

  /**
   * RecurringInvoiceItem findUniqueOrThrow
   */
  export type RecurringInvoiceItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringInvoiceItem
     */
    select?: RecurringInvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringInvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which RecurringInvoiceItem to fetch.
     */
    where: RecurringInvoiceItemWhereUniqueInput
  }

  /**
   * RecurringInvoiceItem findFirst
   */
  export type RecurringInvoiceItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringInvoiceItem
     */
    select?: RecurringInvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringInvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which RecurringInvoiceItem to fetch.
     */
    where?: RecurringInvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecurringInvoiceItems to fetch.
     */
    orderBy?: RecurringInvoiceItemOrderByWithRelationInput | RecurringInvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecurringInvoiceItems.
     */
    cursor?: RecurringInvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecurringInvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecurringInvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecurringInvoiceItems.
     */
    distinct?: RecurringInvoiceItemScalarFieldEnum | RecurringInvoiceItemScalarFieldEnum[]
  }

  /**
   * RecurringInvoiceItem findFirstOrThrow
   */
  export type RecurringInvoiceItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringInvoiceItem
     */
    select?: RecurringInvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringInvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which RecurringInvoiceItem to fetch.
     */
    where?: RecurringInvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecurringInvoiceItems to fetch.
     */
    orderBy?: RecurringInvoiceItemOrderByWithRelationInput | RecurringInvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecurringInvoiceItems.
     */
    cursor?: RecurringInvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecurringInvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecurringInvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecurringInvoiceItems.
     */
    distinct?: RecurringInvoiceItemScalarFieldEnum | RecurringInvoiceItemScalarFieldEnum[]
  }

  /**
   * RecurringInvoiceItem findMany
   */
  export type RecurringInvoiceItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringInvoiceItem
     */
    select?: RecurringInvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringInvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which RecurringInvoiceItems to fetch.
     */
    where?: RecurringInvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecurringInvoiceItems to fetch.
     */
    orderBy?: RecurringInvoiceItemOrderByWithRelationInput | RecurringInvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RecurringInvoiceItems.
     */
    cursor?: RecurringInvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecurringInvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecurringInvoiceItems.
     */
    skip?: number
    distinct?: RecurringInvoiceItemScalarFieldEnum | RecurringInvoiceItemScalarFieldEnum[]
  }

  /**
   * RecurringInvoiceItem create
   */
  export type RecurringInvoiceItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringInvoiceItem
     */
    select?: RecurringInvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringInvoiceItemInclude<ExtArgs> | null
    /**
     * The data needed to create a RecurringInvoiceItem.
     */
    data: XOR<RecurringInvoiceItemCreateInput, RecurringInvoiceItemUncheckedCreateInput>
  }

  /**
   * RecurringInvoiceItem createMany
   */
  export type RecurringInvoiceItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RecurringInvoiceItems.
     */
    data: RecurringInvoiceItemCreateManyInput | RecurringInvoiceItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RecurringInvoiceItem createManyAndReturn
   */
  export type RecurringInvoiceItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringInvoiceItem
     */
    select?: RecurringInvoiceItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RecurringInvoiceItems.
     */
    data: RecurringInvoiceItemCreateManyInput | RecurringInvoiceItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringInvoiceItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RecurringInvoiceItem update
   */
  export type RecurringInvoiceItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringInvoiceItem
     */
    select?: RecurringInvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringInvoiceItemInclude<ExtArgs> | null
    /**
     * The data needed to update a RecurringInvoiceItem.
     */
    data: XOR<RecurringInvoiceItemUpdateInput, RecurringInvoiceItemUncheckedUpdateInput>
    /**
     * Choose, which RecurringInvoiceItem to update.
     */
    where: RecurringInvoiceItemWhereUniqueInput
  }

  /**
   * RecurringInvoiceItem updateMany
   */
  export type RecurringInvoiceItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RecurringInvoiceItems.
     */
    data: XOR<RecurringInvoiceItemUpdateManyMutationInput, RecurringInvoiceItemUncheckedUpdateManyInput>
    /**
     * Filter which RecurringInvoiceItems to update
     */
    where?: RecurringInvoiceItemWhereInput
  }

  /**
   * RecurringInvoiceItem upsert
   */
  export type RecurringInvoiceItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringInvoiceItem
     */
    select?: RecurringInvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringInvoiceItemInclude<ExtArgs> | null
    /**
     * The filter to search for the RecurringInvoiceItem to update in case it exists.
     */
    where: RecurringInvoiceItemWhereUniqueInput
    /**
     * In case the RecurringInvoiceItem found by the `where` argument doesn't exist, create a new RecurringInvoiceItem with this data.
     */
    create: XOR<RecurringInvoiceItemCreateInput, RecurringInvoiceItemUncheckedCreateInput>
    /**
     * In case the RecurringInvoiceItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RecurringInvoiceItemUpdateInput, RecurringInvoiceItemUncheckedUpdateInput>
  }

  /**
   * RecurringInvoiceItem delete
   */
  export type RecurringInvoiceItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringInvoiceItem
     */
    select?: RecurringInvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringInvoiceItemInclude<ExtArgs> | null
    /**
     * Filter which RecurringInvoiceItem to delete.
     */
    where: RecurringInvoiceItemWhereUniqueInput
  }

  /**
   * RecurringInvoiceItem deleteMany
   */
  export type RecurringInvoiceItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecurringInvoiceItems to delete
     */
    where?: RecurringInvoiceItemWhereInput
  }

  /**
   * RecurringInvoiceItem.product
   */
  export type RecurringInvoiceItem$productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
  }

  /**
   * RecurringInvoiceItem without action
   */
  export type RecurringInvoiceItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringInvoiceItem
     */
    select?: RecurringInvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringInvoiceItemInclude<ExtArgs> | null
  }


  /**
   * Model Reminder
   */

  export type AggregateReminder = {
    _count: ReminderCountAggregateOutputType | null
    _avg: ReminderAvgAggregateOutputType | null
    _sum: ReminderSumAggregateOutputType | null
    _min: ReminderMinAggregateOutputType | null
    _max: ReminderMaxAggregateOutputType | null
  }

  export type ReminderAvgAggregateOutputType = {
    id: number | null
    invoiceId: number | null
    amountDue: number | null
    lateFees: number | null
    createdBy: number | null
  }

  export type ReminderSumAggregateOutputType = {
    id: number | null
    invoiceId: number | null
    amountDue: number | null
    lateFees: number | null
    createdBy: number | null
  }

  export type ReminderMinAggregateOutputType = {
    id: number | null
    invoiceId: number | null
    type: $Enums.ReminderType | null
    sentDate: Date | null
    dueDate: Date | null
    amountDue: number | null
    lateFees: number | null
    status: $Enums.ReminderStatus | null
    emailSubject: string | null
    emailBody: string | null
    createdBy: number | null
    createdAt: Date | null
  }

  export type ReminderMaxAggregateOutputType = {
    id: number | null
    invoiceId: number | null
    type: $Enums.ReminderType | null
    sentDate: Date | null
    dueDate: Date | null
    amountDue: number | null
    lateFees: number | null
    status: $Enums.ReminderStatus | null
    emailSubject: string | null
    emailBody: string | null
    createdBy: number | null
    createdAt: Date | null
  }

  export type ReminderCountAggregateOutputType = {
    id: number
    invoiceId: number
    type: number
    sentDate: number
    dueDate: number
    amountDue: number
    lateFees: number
    status: number
    emailSubject: number
    emailBody: number
    createdBy: number
    createdAt: number
    _all: number
  }


  export type ReminderAvgAggregateInputType = {
    id?: true
    invoiceId?: true
    amountDue?: true
    lateFees?: true
    createdBy?: true
  }

  export type ReminderSumAggregateInputType = {
    id?: true
    invoiceId?: true
    amountDue?: true
    lateFees?: true
    createdBy?: true
  }

  export type ReminderMinAggregateInputType = {
    id?: true
    invoiceId?: true
    type?: true
    sentDate?: true
    dueDate?: true
    amountDue?: true
    lateFees?: true
    status?: true
    emailSubject?: true
    emailBody?: true
    createdBy?: true
    createdAt?: true
  }

  export type ReminderMaxAggregateInputType = {
    id?: true
    invoiceId?: true
    type?: true
    sentDate?: true
    dueDate?: true
    amountDue?: true
    lateFees?: true
    status?: true
    emailSubject?: true
    emailBody?: true
    createdBy?: true
    createdAt?: true
  }

  export type ReminderCountAggregateInputType = {
    id?: true
    invoiceId?: true
    type?: true
    sentDate?: true
    dueDate?: true
    amountDue?: true
    lateFees?: true
    status?: true
    emailSubject?: true
    emailBody?: true
    createdBy?: true
    createdAt?: true
    _all?: true
  }

  export type ReminderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reminder to aggregate.
     */
    where?: ReminderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reminders to fetch.
     */
    orderBy?: ReminderOrderByWithRelationInput | ReminderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReminderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reminders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reminders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reminders
    **/
    _count?: true | ReminderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReminderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReminderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReminderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReminderMaxAggregateInputType
  }

  export type GetReminderAggregateType<T extends ReminderAggregateArgs> = {
        [P in keyof T & keyof AggregateReminder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReminder[P]>
      : GetScalarType<T[P], AggregateReminder[P]>
  }




  export type ReminderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReminderWhereInput
    orderBy?: ReminderOrderByWithAggregationInput | ReminderOrderByWithAggregationInput[]
    by: ReminderScalarFieldEnum[] | ReminderScalarFieldEnum
    having?: ReminderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReminderCountAggregateInputType | true
    _avg?: ReminderAvgAggregateInputType
    _sum?: ReminderSumAggregateInputType
    _min?: ReminderMinAggregateInputType
    _max?: ReminderMaxAggregateInputType
  }

  export type ReminderGroupByOutputType = {
    id: number
    invoiceId: number
    type: $Enums.ReminderType
    sentDate: Date
    dueDate: Date | null
    amountDue: number
    lateFees: number
    status: $Enums.ReminderStatus
    emailSubject: string | null
    emailBody: string | null
    createdBy: number
    createdAt: Date
    _count: ReminderCountAggregateOutputType | null
    _avg: ReminderAvgAggregateOutputType | null
    _sum: ReminderSumAggregateOutputType | null
    _min: ReminderMinAggregateOutputType | null
    _max: ReminderMaxAggregateOutputType | null
  }

  type GetReminderGroupByPayload<T extends ReminderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReminderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReminderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReminderGroupByOutputType[P]>
            : GetScalarType<T[P], ReminderGroupByOutputType[P]>
        }
      >
    >


  export type ReminderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    type?: boolean
    sentDate?: boolean
    dueDate?: boolean
    amountDue?: boolean
    lateFees?: boolean
    status?: boolean
    emailSubject?: boolean
    emailBody?: boolean
    createdBy?: boolean
    createdAt?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reminder"]>

  export type ReminderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    type?: boolean
    sentDate?: boolean
    dueDate?: boolean
    amountDue?: boolean
    lateFees?: boolean
    status?: boolean
    emailSubject?: boolean
    emailBody?: boolean
    createdBy?: boolean
    createdAt?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reminder"]>

  export type ReminderSelectScalar = {
    id?: boolean
    invoiceId?: boolean
    type?: boolean
    sentDate?: boolean
    dueDate?: boolean
    amountDue?: boolean
    lateFees?: boolean
    status?: boolean
    emailSubject?: boolean
    emailBody?: boolean
    createdBy?: boolean
    createdAt?: boolean
  }

  export type ReminderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ReminderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ReminderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Reminder"
    objects: {
      invoice: Prisma.$InvoicePayload<ExtArgs>
      creator: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      invoiceId: number
      type: $Enums.ReminderType
      sentDate: Date
      dueDate: Date | null
      amountDue: number
      lateFees: number
      status: $Enums.ReminderStatus
      emailSubject: string | null
      emailBody: string | null
      createdBy: number
      createdAt: Date
    }, ExtArgs["result"]["reminder"]>
    composites: {}
  }

  type ReminderGetPayload<S extends boolean | null | undefined | ReminderDefaultArgs> = $Result.GetResult<Prisma.$ReminderPayload, S>

  type ReminderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReminderFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReminderCountAggregateInputType | true
    }

  export interface ReminderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Reminder'], meta: { name: 'Reminder' } }
    /**
     * Find zero or one Reminder that matches the filter.
     * @param {ReminderFindUniqueArgs} args - Arguments to find a Reminder
     * @example
     * // Get one Reminder
     * const reminder = await prisma.reminder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReminderFindUniqueArgs>(args: SelectSubset<T, ReminderFindUniqueArgs<ExtArgs>>): Prisma__ReminderClient<$Result.GetResult<Prisma.$ReminderPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Reminder that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReminderFindUniqueOrThrowArgs} args - Arguments to find a Reminder
     * @example
     * // Get one Reminder
     * const reminder = await prisma.reminder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReminderFindUniqueOrThrowArgs>(args: SelectSubset<T, ReminderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReminderClient<$Result.GetResult<Prisma.$ReminderPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Reminder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReminderFindFirstArgs} args - Arguments to find a Reminder
     * @example
     * // Get one Reminder
     * const reminder = await prisma.reminder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReminderFindFirstArgs>(args?: SelectSubset<T, ReminderFindFirstArgs<ExtArgs>>): Prisma__ReminderClient<$Result.GetResult<Prisma.$ReminderPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Reminder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReminderFindFirstOrThrowArgs} args - Arguments to find a Reminder
     * @example
     * // Get one Reminder
     * const reminder = await prisma.reminder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReminderFindFirstOrThrowArgs>(args?: SelectSubset<T, ReminderFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReminderClient<$Result.GetResult<Prisma.$ReminderPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Reminders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReminderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reminders
     * const reminders = await prisma.reminder.findMany()
     * 
     * // Get first 10 Reminders
     * const reminders = await prisma.reminder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reminderWithIdOnly = await prisma.reminder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReminderFindManyArgs>(args?: SelectSubset<T, ReminderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReminderPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Reminder.
     * @param {ReminderCreateArgs} args - Arguments to create a Reminder.
     * @example
     * // Create one Reminder
     * const Reminder = await prisma.reminder.create({
     *   data: {
     *     // ... data to create a Reminder
     *   }
     * })
     * 
     */
    create<T extends ReminderCreateArgs>(args: SelectSubset<T, ReminderCreateArgs<ExtArgs>>): Prisma__ReminderClient<$Result.GetResult<Prisma.$ReminderPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Reminders.
     * @param {ReminderCreateManyArgs} args - Arguments to create many Reminders.
     * @example
     * // Create many Reminders
     * const reminder = await prisma.reminder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReminderCreateManyArgs>(args?: SelectSubset<T, ReminderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reminders and returns the data saved in the database.
     * @param {ReminderCreateManyAndReturnArgs} args - Arguments to create many Reminders.
     * @example
     * // Create many Reminders
     * const reminder = await prisma.reminder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reminders and only return the `id`
     * const reminderWithIdOnly = await prisma.reminder.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReminderCreateManyAndReturnArgs>(args?: SelectSubset<T, ReminderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReminderPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Reminder.
     * @param {ReminderDeleteArgs} args - Arguments to delete one Reminder.
     * @example
     * // Delete one Reminder
     * const Reminder = await prisma.reminder.delete({
     *   where: {
     *     // ... filter to delete one Reminder
     *   }
     * })
     * 
     */
    delete<T extends ReminderDeleteArgs>(args: SelectSubset<T, ReminderDeleteArgs<ExtArgs>>): Prisma__ReminderClient<$Result.GetResult<Prisma.$ReminderPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Reminder.
     * @param {ReminderUpdateArgs} args - Arguments to update one Reminder.
     * @example
     * // Update one Reminder
     * const reminder = await prisma.reminder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReminderUpdateArgs>(args: SelectSubset<T, ReminderUpdateArgs<ExtArgs>>): Prisma__ReminderClient<$Result.GetResult<Prisma.$ReminderPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Reminders.
     * @param {ReminderDeleteManyArgs} args - Arguments to filter Reminders to delete.
     * @example
     * // Delete a few Reminders
     * const { count } = await prisma.reminder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReminderDeleteManyArgs>(args?: SelectSubset<T, ReminderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reminders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReminderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reminders
     * const reminder = await prisma.reminder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReminderUpdateManyArgs>(args: SelectSubset<T, ReminderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Reminder.
     * @param {ReminderUpsertArgs} args - Arguments to update or create a Reminder.
     * @example
     * // Update or create a Reminder
     * const reminder = await prisma.reminder.upsert({
     *   create: {
     *     // ... data to create a Reminder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reminder we want to update
     *   }
     * })
     */
    upsert<T extends ReminderUpsertArgs>(args: SelectSubset<T, ReminderUpsertArgs<ExtArgs>>): Prisma__ReminderClient<$Result.GetResult<Prisma.$ReminderPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Reminders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReminderCountArgs} args - Arguments to filter Reminders to count.
     * @example
     * // Count the number of Reminders
     * const count = await prisma.reminder.count({
     *   where: {
     *     // ... the filter for the Reminders we want to count
     *   }
     * })
    **/
    count<T extends ReminderCountArgs>(
      args?: Subset<T, ReminderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReminderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reminder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReminderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReminderAggregateArgs>(args: Subset<T, ReminderAggregateArgs>): Prisma.PrismaPromise<GetReminderAggregateType<T>>

    /**
     * Group by Reminder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReminderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReminderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReminderGroupByArgs['orderBy'] }
        : { orderBy?: ReminderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReminderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReminderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Reminder model
   */
  readonly fields: ReminderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Reminder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReminderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoice<T extends InvoiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceDefaultArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Reminder model
   */ 
  interface ReminderFieldRefs {
    readonly id: FieldRef<"Reminder", 'Int'>
    readonly invoiceId: FieldRef<"Reminder", 'Int'>
    readonly type: FieldRef<"Reminder", 'ReminderType'>
    readonly sentDate: FieldRef<"Reminder", 'DateTime'>
    readonly dueDate: FieldRef<"Reminder", 'DateTime'>
    readonly amountDue: FieldRef<"Reminder", 'Float'>
    readonly lateFees: FieldRef<"Reminder", 'Float'>
    readonly status: FieldRef<"Reminder", 'ReminderStatus'>
    readonly emailSubject: FieldRef<"Reminder", 'String'>
    readonly emailBody: FieldRef<"Reminder", 'String'>
    readonly createdBy: FieldRef<"Reminder", 'Int'>
    readonly createdAt: FieldRef<"Reminder", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Reminder findUnique
   */
  export type ReminderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reminder
     */
    select?: ReminderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReminderInclude<ExtArgs> | null
    /**
     * Filter, which Reminder to fetch.
     */
    where: ReminderWhereUniqueInput
  }

  /**
   * Reminder findUniqueOrThrow
   */
  export type ReminderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reminder
     */
    select?: ReminderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReminderInclude<ExtArgs> | null
    /**
     * Filter, which Reminder to fetch.
     */
    where: ReminderWhereUniqueInput
  }

  /**
   * Reminder findFirst
   */
  export type ReminderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reminder
     */
    select?: ReminderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReminderInclude<ExtArgs> | null
    /**
     * Filter, which Reminder to fetch.
     */
    where?: ReminderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reminders to fetch.
     */
    orderBy?: ReminderOrderByWithRelationInput | ReminderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reminders.
     */
    cursor?: ReminderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reminders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reminders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reminders.
     */
    distinct?: ReminderScalarFieldEnum | ReminderScalarFieldEnum[]
  }

  /**
   * Reminder findFirstOrThrow
   */
  export type ReminderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reminder
     */
    select?: ReminderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReminderInclude<ExtArgs> | null
    /**
     * Filter, which Reminder to fetch.
     */
    where?: ReminderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reminders to fetch.
     */
    orderBy?: ReminderOrderByWithRelationInput | ReminderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reminders.
     */
    cursor?: ReminderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reminders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reminders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reminders.
     */
    distinct?: ReminderScalarFieldEnum | ReminderScalarFieldEnum[]
  }

  /**
   * Reminder findMany
   */
  export type ReminderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reminder
     */
    select?: ReminderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReminderInclude<ExtArgs> | null
    /**
     * Filter, which Reminders to fetch.
     */
    where?: ReminderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reminders to fetch.
     */
    orderBy?: ReminderOrderByWithRelationInput | ReminderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reminders.
     */
    cursor?: ReminderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reminders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reminders.
     */
    skip?: number
    distinct?: ReminderScalarFieldEnum | ReminderScalarFieldEnum[]
  }

  /**
   * Reminder create
   */
  export type ReminderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reminder
     */
    select?: ReminderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReminderInclude<ExtArgs> | null
    /**
     * The data needed to create a Reminder.
     */
    data: XOR<ReminderCreateInput, ReminderUncheckedCreateInput>
  }

  /**
   * Reminder createMany
   */
  export type ReminderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reminders.
     */
    data: ReminderCreateManyInput | ReminderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Reminder createManyAndReturn
   */
  export type ReminderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reminder
     */
    select?: ReminderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Reminders.
     */
    data: ReminderCreateManyInput | ReminderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReminderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Reminder update
   */
  export type ReminderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reminder
     */
    select?: ReminderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReminderInclude<ExtArgs> | null
    /**
     * The data needed to update a Reminder.
     */
    data: XOR<ReminderUpdateInput, ReminderUncheckedUpdateInput>
    /**
     * Choose, which Reminder to update.
     */
    where: ReminderWhereUniqueInput
  }

  /**
   * Reminder updateMany
   */
  export type ReminderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reminders.
     */
    data: XOR<ReminderUpdateManyMutationInput, ReminderUncheckedUpdateManyInput>
    /**
     * Filter which Reminders to update
     */
    where?: ReminderWhereInput
  }

  /**
   * Reminder upsert
   */
  export type ReminderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reminder
     */
    select?: ReminderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReminderInclude<ExtArgs> | null
    /**
     * The filter to search for the Reminder to update in case it exists.
     */
    where: ReminderWhereUniqueInput
    /**
     * In case the Reminder found by the `where` argument doesn't exist, create a new Reminder with this data.
     */
    create: XOR<ReminderCreateInput, ReminderUncheckedCreateInput>
    /**
     * In case the Reminder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReminderUpdateInput, ReminderUncheckedUpdateInput>
  }

  /**
   * Reminder delete
   */
  export type ReminderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reminder
     */
    select?: ReminderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReminderInclude<ExtArgs> | null
    /**
     * Filter which Reminder to delete.
     */
    where: ReminderWhereUniqueInput
  }

  /**
   * Reminder deleteMany
   */
  export type ReminderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reminders to delete
     */
    where?: ReminderWhereInput
  }

  /**
   * Reminder without action
   */
  export type ReminderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reminder
     */
    select?: ReminderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReminderInclude<ExtArgs> | null
  }


  /**
   * Model Document
   */

  export type AggregateDocument = {
    _count: DocumentCountAggregateOutputType | null
    _avg: DocumentAvgAggregateOutputType | null
    _sum: DocumentSumAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  export type DocumentAvgAggregateOutputType = {
    id: number | null
    referenceId: number | null
    fileSize: number | null
  }

  export type DocumentSumAggregateOutputType = {
    id: number | null
    referenceId: number | null
    fileSize: number | null
  }

  export type DocumentMinAggregateOutputType = {
    id: number | null
    type: $Enums.DocumentType | null
    referenceId: number | null
    filename: string | null
    filePath: string | null
    fileSize: number | null
    mimeType: string | null
    generatedAt: Date | null
  }

  export type DocumentMaxAggregateOutputType = {
    id: number | null
    type: $Enums.DocumentType | null
    referenceId: number | null
    filename: string | null
    filePath: string | null
    fileSize: number | null
    mimeType: string | null
    generatedAt: Date | null
  }

  export type DocumentCountAggregateOutputType = {
    id: number
    type: number
    referenceId: number
    filename: number
    filePath: number
    fileSize: number
    mimeType: number
    generatedAt: number
    _all: number
  }


  export type DocumentAvgAggregateInputType = {
    id?: true
    referenceId?: true
    fileSize?: true
  }

  export type DocumentSumAggregateInputType = {
    id?: true
    referenceId?: true
    fileSize?: true
  }

  export type DocumentMinAggregateInputType = {
    id?: true
    type?: true
    referenceId?: true
    filename?: true
    filePath?: true
    fileSize?: true
    mimeType?: true
    generatedAt?: true
  }

  export type DocumentMaxAggregateInputType = {
    id?: true
    type?: true
    referenceId?: true
    filename?: true
    filePath?: true
    fileSize?: true
    mimeType?: true
    generatedAt?: true
  }

  export type DocumentCountAggregateInputType = {
    id?: true
    type?: true
    referenceId?: true
    filename?: true
    filePath?: true
    fileSize?: true
    mimeType?: true
    generatedAt?: true
    _all?: true
  }

  export type DocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Document to aggregate.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Documents
    **/
    _count?: true | DocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DocumentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DocumentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentMaxAggregateInputType
  }

  export type GetDocumentAggregateType<T extends DocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocument[P]>
      : GetScalarType<T[P], AggregateDocument[P]>
  }




  export type DocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithAggregationInput | DocumentOrderByWithAggregationInput[]
    by: DocumentScalarFieldEnum[] | DocumentScalarFieldEnum
    having?: DocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentCountAggregateInputType | true
    _avg?: DocumentAvgAggregateInputType
    _sum?: DocumentSumAggregateInputType
    _min?: DocumentMinAggregateInputType
    _max?: DocumentMaxAggregateInputType
  }

  export type DocumentGroupByOutputType = {
    id: number
    type: $Enums.DocumentType
    referenceId: number
    filename: string
    filePath: string
    fileSize: number | null
    mimeType: string | null
    generatedAt: Date
    _count: DocumentCountAggregateOutputType | null
    _avg: DocumentAvgAggregateOutputType | null
    _sum: DocumentSumAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  type GetDocumentGroupByPayload<T extends DocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentGroupByOutputType[P]>
        }
      >
    >


  export type DocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    referenceId?: boolean
    filename?: boolean
    filePath?: boolean
    fileSize?: boolean
    mimeType?: boolean
    generatedAt?: boolean
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    referenceId?: boolean
    filename?: boolean
    filePath?: boolean
    fileSize?: boolean
    mimeType?: boolean
    generatedAt?: boolean
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectScalar = {
    id?: boolean
    type?: boolean
    referenceId?: boolean
    filename?: boolean
    filePath?: boolean
    fileSize?: boolean
    mimeType?: boolean
    generatedAt?: boolean
  }


  export type $DocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Document"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      type: $Enums.DocumentType
      referenceId: number
      filename: string
      filePath: string
      fileSize: number | null
      mimeType: string | null
      generatedAt: Date
    }, ExtArgs["result"]["document"]>
    composites: {}
  }

  type DocumentGetPayload<S extends boolean | null | undefined | DocumentDefaultArgs> = $Result.GetResult<Prisma.$DocumentPayload, S>

  type DocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DocumentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DocumentCountAggregateInputType | true
    }

  export interface DocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Document'], meta: { name: 'Document' } }
    /**
     * Find zero or one Document that matches the filter.
     * @param {DocumentFindUniqueArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentFindUniqueArgs>(args: SelectSubset<T, DocumentFindUniqueArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Document that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DocumentFindUniqueOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Document that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentFindFirstArgs>(args?: SelectSubset<T, DocumentFindFirstArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Document that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Documents
     * const documents = await prisma.document.findMany()
     * 
     * // Get first 10 Documents
     * const documents = await prisma.document.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentWithIdOnly = await prisma.document.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentFindManyArgs>(args?: SelectSubset<T, DocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Document.
     * @param {DocumentCreateArgs} args - Arguments to create a Document.
     * @example
     * // Create one Document
     * const Document = await prisma.document.create({
     *   data: {
     *     // ... data to create a Document
     *   }
     * })
     * 
     */
    create<T extends DocumentCreateArgs>(args: SelectSubset<T, DocumentCreateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Documents.
     * @param {DocumentCreateManyArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentCreateManyArgs>(args?: SelectSubset<T, DocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Documents and returns the data saved in the database.
     * @param {DocumentCreateManyAndReturnArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Documents and only return the `id`
     * const documentWithIdOnly = await prisma.document.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, DocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Document.
     * @param {DocumentDeleteArgs} args - Arguments to delete one Document.
     * @example
     * // Delete one Document
     * const Document = await prisma.document.delete({
     *   where: {
     *     // ... filter to delete one Document
     *   }
     * })
     * 
     */
    delete<T extends DocumentDeleteArgs>(args: SelectSubset<T, DocumentDeleteArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Document.
     * @param {DocumentUpdateArgs} args - Arguments to update one Document.
     * @example
     * // Update one Document
     * const document = await prisma.document.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentUpdateArgs>(args: SelectSubset<T, DocumentUpdateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Documents.
     * @param {DocumentDeleteManyArgs} args - Arguments to filter Documents to delete.
     * @example
     * // Delete a few Documents
     * const { count } = await prisma.document.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentDeleteManyArgs>(args?: SelectSubset<T, DocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentUpdateManyArgs>(args: SelectSubset<T, DocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Document.
     * @param {DocumentUpsertArgs} args - Arguments to update or create a Document.
     * @example
     * // Update or create a Document
     * const document = await prisma.document.upsert({
     *   create: {
     *     // ... data to create a Document
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Document we want to update
     *   }
     * })
     */
    upsert<T extends DocumentUpsertArgs>(args: SelectSubset<T, DocumentUpsertArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCountArgs} args - Arguments to filter Documents to count.
     * @example
     * // Count the number of Documents
     * const count = await prisma.document.count({
     *   where: {
     *     // ... the filter for the Documents we want to count
     *   }
     * })
    **/
    count<T extends DocumentCountArgs>(
      args?: Subset<T, DocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentAggregateArgs>(args: Subset<T, DocumentAggregateArgs>): Prisma.PrismaPromise<GetDocumentAggregateType<T>>

    /**
     * Group by Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentGroupByArgs['orderBy'] }
        : { orderBy?: DocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Document model
   */
  readonly fields: DocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Document.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Document model
   */ 
  interface DocumentFieldRefs {
    readonly id: FieldRef<"Document", 'Int'>
    readonly type: FieldRef<"Document", 'DocumentType'>
    readonly referenceId: FieldRef<"Document", 'Int'>
    readonly filename: FieldRef<"Document", 'String'>
    readonly filePath: FieldRef<"Document", 'String'>
    readonly fileSize: FieldRef<"Document", 'Int'>
    readonly mimeType: FieldRef<"Document", 'String'>
    readonly generatedAt: FieldRef<"Document", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Document findUnique
   */
  export type DocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findUniqueOrThrow
   */
  export type DocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findFirst
   */
  export type DocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findFirstOrThrow
   */
  export type DocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findMany
   */
  export type DocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Filter, which Documents to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document create
   */
  export type DocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * The data needed to create a Document.
     */
    data: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
  }

  /**
   * Document createMany
   */
  export type DocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Document createManyAndReturn
   */
  export type DocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Document update
   */
  export type DocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * The data needed to update a Document.
     */
    data: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
    /**
     * Choose, which Document to update.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document updateMany
   */
  export type DocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
  }

  /**
   * Document upsert
   */
  export type DocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * The filter to search for the Document to update in case it exists.
     */
    where: DocumentWhereUniqueInput
    /**
     * In case the Document found by the `where` argument doesn't exist, create a new Document with this data.
     */
    create: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
    /**
     * In case the Document was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
  }

  /**
   * Document delete
   */
  export type DocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Filter which Document to delete.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document deleteMany
   */
  export type DocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Documents to delete
     */
    where?: DocumentWhereInput
  }

  /**
   * Document without action
   */
  export type DocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
  }


  /**
   * Model Expense
   */

  export type AggregateExpense = {
    _count: ExpenseCountAggregateOutputType | null
    _avg: ExpenseAvgAggregateOutputType | null
    _sum: ExpenseSumAggregateOutputType | null
    _min: ExpenseMinAggregateOutputType | null
    _max: ExpenseMaxAggregateOutputType | null
  }

  export type ExpenseAvgAggregateOutputType = {
    id: number | null
    supplierId: number | null
    amountHt: number | null
    vatAmount: number | null
    totalTtc: number | null
    createdBy: number | null
  }

  export type ExpenseSumAggregateOutputType = {
    id: number | null
    supplierId: number | null
    amountHt: number | null
    vatAmount: number | null
    totalTtc: number | null
    createdBy: number | null
  }

  export type ExpenseMinAggregateOutputType = {
    id: number | null
    expenseNumber: string | null
    supplierId: number | null
    category: string | null
    description: string | null
    amountHt: number | null
    vatAmount: number | null
    totalTtc: number | null
    expenseDate: Date | null
    paymentDate: Date | null
    paymentMethod: $Enums.PaymentMethod | null
    status: $Enums.ExpenseStatus | null
    receiptUrl: string | null
    notes: string | null
    createdBy: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExpenseMaxAggregateOutputType = {
    id: number | null
    expenseNumber: string | null
    supplierId: number | null
    category: string | null
    description: string | null
    amountHt: number | null
    vatAmount: number | null
    totalTtc: number | null
    expenseDate: Date | null
    paymentDate: Date | null
    paymentMethod: $Enums.PaymentMethod | null
    status: $Enums.ExpenseStatus | null
    receiptUrl: string | null
    notes: string | null
    createdBy: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExpenseCountAggregateOutputType = {
    id: number
    expenseNumber: number
    supplierId: number
    category: number
    description: number
    amountHt: number
    vatAmount: number
    totalTtc: number
    expenseDate: number
    paymentDate: number
    paymentMethod: number
    status: number
    receiptUrl: number
    notes: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ExpenseAvgAggregateInputType = {
    id?: true
    supplierId?: true
    amountHt?: true
    vatAmount?: true
    totalTtc?: true
    createdBy?: true
  }

  export type ExpenseSumAggregateInputType = {
    id?: true
    supplierId?: true
    amountHt?: true
    vatAmount?: true
    totalTtc?: true
    createdBy?: true
  }

  export type ExpenseMinAggregateInputType = {
    id?: true
    expenseNumber?: true
    supplierId?: true
    category?: true
    description?: true
    amountHt?: true
    vatAmount?: true
    totalTtc?: true
    expenseDate?: true
    paymentDate?: true
    paymentMethod?: true
    status?: true
    receiptUrl?: true
    notes?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExpenseMaxAggregateInputType = {
    id?: true
    expenseNumber?: true
    supplierId?: true
    category?: true
    description?: true
    amountHt?: true
    vatAmount?: true
    totalTtc?: true
    expenseDate?: true
    paymentDate?: true
    paymentMethod?: true
    status?: true
    receiptUrl?: true
    notes?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExpenseCountAggregateInputType = {
    id?: true
    expenseNumber?: true
    supplierId?: true
    category?: true
    description?: true
    amountHt?: true
    vatAmount?: true
    totalTtc?: true
    expenseDate?: true
    paymentDate?: true
    paymentMethod?: true
    status?: true
    receiptUrl?: true
    notes?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ExpenseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Expense to aggregate.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Expenses
    **/
    _count?: true | ExpenseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExpenseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExpenseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExpenseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExpenseMaxAggregateInputType
  }

  export type GetExpenseAggregateType<T extends ExpenseAggregateArgs> = {
        [P in keyof T & keyof AggregateExpense]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExpense[P]>
      : GetScalarType<T[P], AggregateExpense[P]>
  }




  export type ExpenseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseWhereInput
    orderBy?: ExpenseOrderByWithAggregationInput | ExpenseOrderByWithAggregationInput[]
    by: ExpenseScalarFieldEnum[] | ExpenseScalarFieldEnum
    having?: ExpenseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExpenseCountAggregateInputType | true
    _avg?: ExpenseAvgAggregateInputType
    _sum?: ExpenseSumAggregateInputType
    _min?: ExpenseMinAggregateInputType
    _max?: ExpenseMaxAggregateInputType
  }

  export type ExpenseGroupByOutputType = {
    id: number
    expenseNumber: string
    supplierId: number | null
    category: string
    description: string | null
    amountHt: number
    vatAmount: number
    totalTtc: number
    expenseDate: Date
    paymentDate: Date | null
    paymentMethod: $Enums.PaymentMethod
    status: $Enums.ExpenseStatus
    receiptUrl: string | null
    notes: string | null
    createdBy: number
    createdAt: Date
    updatedAt: Date
    _count: ExpenseCountAggregateOutputType | null
    _avg: ExpenseAvgAggregateOutputType | null
    _sum: ExpenseSumAggregateOutputType | null
    _min: ExpenseMinAggregateOutputType | null
    _max: ExpenseMaxAggregateOutputType | null
  }

  type GetExpenseGroupByPayload<T extends ExpenseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExpenseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExpenseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExpenseGroupByOutputType[P]>
            : GetScalarType<T[P], ExpenseGroupByOutputType[P]>
        }
      >
    >


  export type ExpenseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expenseNumber?: boolean
    supplierId?: boolean
    category?: boolean
    description?: boolean
    amountHt?: boolean
    vatAmount?: boolean
    totalTtc?: boolean
    expenseDate?: boolean
    paymentDate?: boolean
    paymentMethod?: boolean
    status?: boolean
    receiptUrl?: boolean
    notes?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    supplier?: boolean | Expense$supplierArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["expense"]>

  export type ExpenseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expenseNumber?: boolean
    supplierId?: boolean
    category?: boolean
    description?: boolean
    amountHt?: boolean
    vatAmount?: boolean
    totalTtc?: boolean
    expenseDate?: boolean
    paymentDate?: boolean
    paymentMethod?: boolean
    status?: boolean
    receiptUrl?: boolean
    notes?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    supplier?: boolean | Expense$supplierArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["expense"]>

  export type ExpenseSelectScalar = {
    id?: boolean
    expenseNumber?: boolean
    supplierId?: boolean
    category?: boolean
    description?: boolean
    amountHt?: boolean
    vatAmount?: boolean
    totalTtc?: boolean
    expenseDate?: boolean
    paymentDate?: boolean
    paymentMethod?: boolean
    status?: boolean
    receiptUrl?: boolean
    notes?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ExpenseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    supplier?: boolean | Expense$supplierArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ExpenseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    supplier?: boolean | Expense$supplierArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ExpensePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Expense"
    objects: {
      supplier: Prisma.$SupplierPayload<ExtArgs> | null
      creator: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      expenseNumber: string
      supplierId: number | null
      category: string
      description: string | null
      amountHt: number
      vatAmount: number
      totalTtc: number
      expenseDate: Date
      paymentDate: Date | null
      paymentMethod: $Enums.PaymentMethod
      status: $Enums.ExpenseStatus
      receiptUrl: string | null
      notes: string | null
      createdBy: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["expense"]>
    composites: {}
  }

  type ExpenseGetPayload<S extends boolean | null | undefined | ExpenseDefaultArgs> = $Result.GetResult<Prisma.$ExpensePayload, S>

  type ExpenseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ExpenseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ExpenseCountAggregateInputType | true
    }

  export interface ExpenseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Expense'], meta: { name: 'Expense' } }
    /**
     * Find zero or one Expense that matches the filter.
     * @param {ExpenseFindUniqueArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExpenseFindUniqueArgs>(args: SelectSubset<T, ExpenseFindUniqueArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Expense that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ExpenseFindUniqueOrThrowArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExpenseFindUniqueOrThrowArgs>(args: SelectSubset<T, ExpenseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Expense that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseFindFirstArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExpenseFindFirstArgs>(args?: SelectSubset<T, ExpenseFindFirstArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Expense that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseFindFirstOrThrowArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExpenseFindFirstOrThrowArgs>(args?: SelectSubset<T, ExpenseFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Expenses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Expenses
     * const expenses = await prisma.expense.findMany()
     * 
     * // Get first 10 Expenses
     * const expenses = await prisma.expense.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const expenseWithIdOnly = await prisma.expense.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExpenseFindManyArgs>(args?: SelectSubset<T, ExpenseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Expense.
     * @param {ExpenseCreateArgs} args - Arguments to create a Expense.
     * @example
     * // Create one Expense
     * const Expense = await prisma.expense.create({
     *   data: {
     *     // ... data to create a Expense
     *   }
     * })
     * 
     */
    create<T extends ExpenseCreateArgs>(args: SelectSubset<T, ExpenseCreateArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Expenses.
     * @param {ExpenseCreateManyArgs} args - Arguments to create many Expenses.
     * @example
     * // Create many Expenses
     * const expense = await prisma.expense.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExpenseCreateManyArgs>(args?: SelectSubset<T, ExpenseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Expenses and returns the data saved in the database.
     * @param {ExpenseCreateManyAndReturnArgs} args - Arguments to create many Expenses.
     * @example
     * // Create many Expenses
     * const expense = await prisma.expense.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Expenses and only return the `id`
     * const expenseWithIdOnly = await prisma.expense.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExpenseCreateManyAndReturnArgs>(args?: SelectSubset<T, ExpenseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Expense.
     * @param {ExpenseDeleteArgs} args - Arguments to delete one Expense.
     * @example
     * // Delete one Expense
     * const Expense = await prisma.expense.delete({
     *   where: {
     *     // ... filter to delete one Expense
     *   }
     * })
     * 
     */
    delete<T extends ExpenseDeleteArgs>(args: SelectSubset<T, ExpenseDeleteArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Expense.
     * @param {ExpenseUpdateArgs} args - Arguments to update one Expense.
     * @example
     * // Update one Expense
     * const expense = await prisma.expense.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExpenseUpdateArgs>(args: SelectSubset<T, ExpenseUpdateArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Expenses.
     * @param {ExpenseDeleteManyArgs} args - Arguments to filter Expenses to delete.
     * @example
     * // Delete a few Expenses
     * const { count } = await prisma.expense.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExpenseDeleteManyArgs>(args?: SelectSubset<T, ExpenseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Expenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Expenses
     * const expense = await prisma.expense.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExpenseUpdateManyArgs>(args: SelectSubset<T, ExpenseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Expense.
     * @param {ExpenseUpsertArgs} args - Arguments to update or create a Expense.
     * @example
     * // Update or create a Expense
     * const expense = await prisma.expense.upsert({
     *   create: {
     *     // ... data to create a Expense
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Expense we want to update
     *   }
     * })
     */
    upsert<T extends ExpenseUpsertArgs>(args: SelectSubset<T, ExpenseUpsertArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Expenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseCountArgs} args - Arguments to filter Expenses to count.
     * @example
     * // Count the number of Expenses
     * const count = await prisma.expense.count({
     *   where: {
     *     // ... the filter for the Expenses we want to count
     *   }
     * })
    **/
    count<T extends ExpenseCountArgs>(
      args?: Subset<T, ExpenseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExpenseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Expense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExpenseAggregateArgs>(args: Subset<T, ExpenseAggregateArgs>): Prisma.PrismaPromise<GetExpenseAggregateType<T>>

    /**
     * Group by Expense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExpenseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExpenseGroupByArgs['orderBy'] }
        : { orderBy?: ExpenseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExpenseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExpenseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Expense model
   */
  readonly fields: ExpenseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Expense.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExpenseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    supplier<T extends Expense$supplierArgs<ExtArgs> = {}>(args?: Subset<T, Expense$supplierArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Expense model
   */ 
  interface ExpenseFieldRefs {
    readonly id: FieldRef<"Expense", 'Int'>
    readonly expenseNumber: FieldRef<"Expense", 'String'>
    readonly supplierId: FieldRef<"Expense", 'Int'>
    readonly category: FieldRef<"Expense", 'String'>
    readonly description: FieldRef<"Expense", 'String'>
    readonly amountHt: FieldRef<"Expense", 'Float'>
    readonly vatAmount: FieldRef<"Expense", 'Float'>
    readonly totalTtc: FieldRef<"Expense", 'Float'>
    readonly expenseDate: FieldRef<"Expense", 'DateTime'>
    readonly paymentDate: FieldRef<"Expense", 'DateTime'>
    readonly paymentMethod: FieldRef<"Expense", 'PaymentMethod'>
    readonly status: FieldRef<"Expense", 'ExpenseStatus'>
    readonly receiptUrl: FieldRef<"Expense", 'String'>
    readonly notes: FieldRef<"Expense", 'String'>
    readonly createdBy: FieldRef<"Expense", 'Int'>
    readonly createdAt: FieldRef<"Expense", 'DateTime'>
    readonly updatedAt: FieldRef<"Expense", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Expense findUnique
   */
  export type ExpenseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense findUniqueOrThrow
   */
  export type ExpenseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense findFirst
   */
  export type ExpenseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Expenses.
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Expenses.
     */
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Expense findFirstOrThrow
   */
  export type ExpenseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Expenses.
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Expenses.
     */
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Expense findMany
   */
  export type ExpenseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expenses to fetch.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Expenses.
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Expense create
   */
  export type ExpenseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * The data needed to create a Expense.
     */
    data: XOR<ExpenseCreateInput, ExpenseUncheckedCreateInput>
  }

  /**
   * Expense createMany
   */
  export type ExpenseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Expenses.
     */
    data: ExpenseCreateManyInput | ExpenseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Expense createManyAndReturn
   */
  export type ExpenseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Expenses.
     */
    data: ExpenseCreateManyInput | ExpenseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Expense update
   */
  export type ExpenseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * The data needed to update a Expense.
     */
    data: XOR<ExpenseUpdateInput, ExpenseUncheckedUpdateInput>
    /**
     * Choose, which Expense to update.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense updateMany
   */
  export type ExpenseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Expenses.
     */
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyInput>
    /**
     * Filter which Expenses to update
     */
    where?: ExpenseWhereInput
  }

  /**
   * Expense upsert
   */
  export type ExpenseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * The filter to search for the Expense to update in case it exists.
     */
    where: ExpenseWhereUniqueInput
    /**
     * In case the Expense found by the `where` argument doesn't exist, create a new Expense with this data.
     */
    create: XOR<ExpenseCreateInput, ExpenseUncheckedCreateInput>
    /**
     * In case the Expense was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExpenseUpdateInput, ExpenseUncheckedUpdateInput>
  }

  /**
   * Expense delete
   */
  export type ExpenseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter which Expense to delete.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense deleteMany
   */
  export type ExpenseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Expenses to delete
     */
    where?: ExpenseWhereInput
  }

  /**
   * Expense.supplier
   */
  export type Expense$supplierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    where?: SupplierWhereInput
  }

  /**
   * Expense without action
   */
  export type ExpenseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
  }


  /**
   * Model Supplier
   */

  export type AggregateSupplier = {
    _count: SupplierCountAggregateOutputType | null
    _avg: SupplierAvgAggregateOutputType | null
    _sum: SupplierSumAggregateOutputType | null
    _min: SupplierMinAggregateOutputType | null
    _max: SupplierMaxAggregateOutputType | null
  }

  export type SupplierAvgAggregateOutputType = {
    id: number | null
    paymentTerms: number | null
  }

  export type SupplierSumAggregateOutputType = {
    id: number | null
    paymentTerms: number | null
  }

  export type SupplierMinAggregateOutputType = {
    id: number | null
    name: string | null
    contactPerson: string | null
    email: string | null
    phone: string | null
    addressLine1: string | null
    city: string | null
    postalCode: string | null
    country: string | null
    vatNumber: string | null
    bankName: string | null
    bankIban: string | null
    bankBic: string | null
    paymentTerms: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SupplierMaxAggregateOutputType = {
    id: number | null
    name: string | null
    contactPerson: string | null
    email: string | null
    phone: string | null
    addressLine1: string | null
    city: string | null
    postalCode: string | null
    country: string | null
    vatNumber: string | null
    bankName: string | null
    bankIban: string | null
    bankBic: string | null
    paymentTerms: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SupplierCountAggregateOutputType = {
    id: number
    name: number
    contactPerson: number
    email: number
    phone: number
    addressLine1: number
    city: number
    postalCode: number
    country: number
    vatNumber: number
    bankName: number
    bankIban: number
    bankBic: number
    paymentTerms: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SupplierAvgAggregateInputType = {
    id?: true
    paymentTerms?: true
  }

  export type SupplierSumAggregateInputType = {
    id?: true
    paymentTerms?: true
  }

  export type SupplierMinAggregateInputType = {
    id?: true
    name?: true
    contactPerson?: true
    email?: true
    phone?: true
    addressLine1?: true
    city?: true
    postalCode?: true
    country?: true
    vatNumber?: true
    bankName?: true
    bankIban?: true
    bankBic?: true
    paymentTerms?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SupplierMaxAggregateInputType = {
    id?: true
    name?: true
    contactPerson?: true
    email?: true
    phone?: true
    addressLine1?: true
    city?: true
    postalCode?: true
    country?: true
    vatNumber?: true
    bankName?: true
    bankIban?: true
    bankBic?: true
    paymentTerms?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SupplierCountAggregateInputType = {
    id?: true
    name?: true
    contactPerson?: true
    email?: true
    phone?: true
    addressLine1?: true
    city?: true
    postalCode?: true
    country?: true
    vatNumber?: true
    bankName?: true
    bankIban?: true
    bankBic?: true
    paymentTerms?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SupplierAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Supplier to aggregate.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Suppliers
    **/
    _count?: true | SupplierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SupplierAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SupplierSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupplierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupplierMaxAggregateInputType
  }

  export type GetSupplierAggregateType<T extends SupplierAggregateArgs> = {
        [P in keyof T & keyof AggregateSupplier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupplier[P]>
      : GetScalarType<T[P], AggregateSupplier[P]>
  }




  export type SupplierGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierWhereInput
    orderBy?: SupplierOrderByWithAggregationInput | SupplierOrderByWithAggregationInput[]
    by: SupplierScalarFieldEnum[] | SupplierScalarFieldEnum
    having?: SupplierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupplierCountAggregateInputType | true
    _avg?: SupplierAvgAggregateInputType
    _sum?: SupplierSumAggregateInputType
    _min?: SupplierMinAggregateInputType
    _max?: SupplierMaxAggregateInputType
  }

  export type SupplierGroupByOutputType = {
    id: number
    name: string
    contactPerson: string | null
    email: string | null
    phone: string | null
    addressLine1: string | null
    city: string | null
    postalCode: string | null
    country: string | null
    vatNumber: string | null
    bankName: string | null
    bankIban: string | null
    bankBic: string | null
    paymentTerms: number
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: SupplierCountAggregateOutputType | null
    _avg: SupplierAvgAggregateOutputType | null
    _sum: SupplierSumAggregateOutputType | null
    _min: SupplierMinAggregateOutputType | null
    _max: SupplierMaxAggregateOutputType | null
  }

  type GetSupplierGroupByPayload<T extends SupplierGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupplierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupplierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupplierGroupByOutputType[P]>
            : GetScalarType<T[P], SupplierGroupByOutputType[P]>
        }
      >
    >


  export type SupplierSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    contactPerson?: boolean
    email?: boolean
    phone?: boolean
    addressLine1?: boolean
    city?: boolean
    postalCode?: boolean
    country?: boolean
    vatNumber?: boolean
    bankName?: boolean
    bankIban?: boolean
    bankBic?: boolean
    paymentTerms?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    expenses?: boolean | Supplier$expensesArgs<ExtArgs>
    _count?: boolean | SupplierCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplier"]>

  export type SupplierSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    contactPerson?: boolean
    email?: boolean
    phone?: boolean
    addressLine1?: boolean
    city?: boolean
    postalCode?: boolean
    country?: boolean
    vatNumber?: boolean
    bankName?: boolean
    bankIban?: boolean
    bankBic?: boolean
    paymentTerms?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["supplier"]>

  export type SupplierSelectScalar = {
    id?: boolean
    name?: boolean
    contactPerson?: boolean
    email?: boolean
    phone?: boolean
    addressLine1?: boolean
    city?: boolean
    postalCode?: boolean
    country?: boolean
    vatNumber?: boolean
    bankName?: boolean
    bankIban?: boolean
    bankBic?: boolean
    paymentTerms?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SupplierInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    expenses?: boolean | Supplier$expensesArgs<ExtArgs>
    _count?: boolean | SupplierCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SupplierIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SupplierPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Supplier"
    objects: {
      expenses: Prisma.$ExpensePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      contactPerson: string | null
      email: string | null
      phone: string | null
      addressLine1: string | null
      city: string | null
      postalCode: string | null
      country: string | null
      vatNumber: string | null
      bankName: string | null
      bankIban: string | null
      bankBic: string | null
      paymentTerms: number
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["supplier"]>
    composites: {}
  }

  type SupplierGetPayload<S extends boolean | null | undefined | SupplierDefaultArgs> = $Result.GetResult<Prisma.$SupplierPayload, S>

  type SupplierCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SupplierFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SupplierCountAggregateInputType | true
    }

  export interface SupplierDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Supplier'], meta: { name: 'Supplier' } }
    /**
     * Find zero or one Supplier that matches the filter.
     * @param {SupplierFindUniqueArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SupplierFindUniqueArgs>(args: SelectSubset<T, SupplierFindUniqueArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Supplier that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SupplierFindUniqueOrThrowArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SupplierFindUniqueOrThrowArgs>(args: SelectSubset<T, SupplierFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Supplier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindFirstArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SupplierFindFirstArgs>(args?: SelectSubset<T, SupplierFindFirstArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Supplier that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindFirstOrThrowArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SupplierFindFirstOrThrowArgs>(args?: SelectSubset<T, SupplierFindFirstOrThrowArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Suppliers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Suppliers
     * const suppliers = await prisma.supplier.findMany()
     * 
     * // Get first 10 Suppliers
     * const suppliers = await prisma.supplier.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const supplierWithIdOnly = await prisma.supplier.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SupplierFindManyArgs>(args?: SelectSubset<T, SupplierFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Supplier.
     * @param {SupplierCreateArgs} args - Arguments to create a Supplier.
     * @example
     * // Create one Supplier
     * const Supplier = await prisma.supplier.create({
     *   data: {
     *     // ... data to create a Supplier
     *   }
     * })
     * 
     */
    create<T extends SupplierCreateArgs>(args: SelectSubset<T, SupplierCreateArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Suppliers.
     * @param {SupplierCreateManyArgs} args - Arguments to create many Suppliers.
     * @example
     * // Create many Suppliers
     * const supplier = await prisma.supplier.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SupplierCreateManyArgs>(args?: SelectSubset<T, SupplierCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Suppliers and returns the data saved in the database.
     * @param {SupplierCreateManyAndReturnArgs} args - Arguments to create many Suppliers.
     * @example
     * // Create many Suppliers
     * const supplier = await prisma.supplier.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Suppliers and only return the `id`
     * const supplierWithIdOnly = await prisma.supplier.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SupplierCreateManyAndReturnArgs>(args?: SelectSubset<T, SupplierCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Supplier.
     * @param {SupplierDeleteArgs} args - Arguments to delete one Supplier.
     * @example
     * // Delete one Supplier
     * const Supplier = await prisma.supplier.delete({
     *   where: {
     *     // ... filter to delete one Supplier
     *   }
     * })
     * 
     */
    delete<T extends SupplierDeleteArgs>(args: SelectSubset<T, SupplierDeleteArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Supplier.
     * @param {SupplierUpdateArgs} args - Arguments to update one Supplier.
     * @example
     * // Update one Supplier
     * const supplier = await prisma.supplier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SupplierUpdateArgs>(args: SelectSubset<T, SupplierUpdateArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Suppliers.
     * @param {SupplierDeleteManyArgs} args - Arguments to filter Suppliers to delete.
     * @example
     * // Delete a few Suppliers
     * const { count } = await prisma.supplier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SupplierDeleteManyArgs>(args?: SelectSubset<T, SupplierDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Suppliers
     * const supplier = await prisma.supplier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SupplierUpdateManyArgs>(args: SelectSubset<T, SupplierUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Supplier.
     * @param {SupplierUpsertArgs} args - Arguments to update or create a Supplier.
     * @example
     * // Update or create a Supplier
     * const supplier = await prisma.supplier.upsert({
     *   create: {
     *     // ... data to create a Supplier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Supplier we want to update
     *   }
     * })
     */
    upsert<T extends SupplierUpsertArgs>(args: SelectSubset<T, SupplierUpsertArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierCountArgs} args - Arguments to filter Suppliers to count.
     * @example
     * // Count the number of Suppliers
     * const count = await prisma.supplier.count({
     *   where: {
     *     // ... the filter for the Suppliers we want to count
     *   }
     * })
    **/
    count<T extends SupplierCountArgs>(
      args?: Subset<T, SupplierCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupplierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Supplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupplierAggregateArgs>(args: Subset<T, SupplierAggregateArgs>): Prisma.PrismaPromise<GetSupplierAggregateType<T>>

    /**
     * Group by Supplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SupplierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SupplierGroupByArgs['orderBy'] }
        : { orderBy?: SupplierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SupplierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupplierGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Supplier model
   */
  readonly fields: SupplierFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Supplier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SupplierClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    expenses<T extends Supplier$expensesArgs<ExtArgs> = {}>(args?: Subset<T, Supplier$expensesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Supplier model
   */ 
  interface SupplierFieldRefs {
    readonly id: FieldRef<"Supplier", 'Int'>
    readonly name: FieldRef<"Supplier", 'String'>
    readonly contactPerson: FieldRef<"Supplier", 'String'>
    readonly email: FieldRef<"Supplier", 'String'>
    readonly phone: FieldRef<"Supplier", 'String'>
    readonly addressLine1: FieldRef<"Supplier", 'String'>
    readonly city: FieldRef<"Supplier", 'String'>
    readonly postalCode: FieldRef<"Supplier", 'String'>
    readonly country: FieldRef<"Supplier", 'String'>
    readonly vatNumber: FieldRef<"Supplier", 'String'>
    readonly bankName: FieldRef<"Supplier", 'String'>
    readonly bankIban: FieldRef<"Supplier", 'String'>
    readonly bankBic: FieldRef<"Supplier", 'String'>
    readonly paymentTerms: FieldRef<"Supplier", 'Int'>
    readonly notes: FieldRef<"Supplier", 'String'>
    readonly createdAt: FieldRef<"Supplier", 'DateTime'>
    readonly updatedAt: FieldRef<"Supplier", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Supplier findUnique
   */
  export type SupplierFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier findUniqueOrThrow
   */
  export type SupplierFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier findFirst
   */
  export type SupplierFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Suppliers.
     */
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Supplier findFirstOrThrow
   */
  export type SupplierFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Suppliers.
     */
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Supplier findMany
   */
  export type SupplierFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Suppliers to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Supplier create
   */
  export type SupplierCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The data needed to create a Supplier.
     */
    data: XOR<SupplierCreateInput, SupplierUncheckedCreateInput>
  }

  /**
   * Supplier createMany
   */
  export type SupplierCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Suppliers.
     */
    data: SupplierCreateManyInput | SupplierCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Supplier createManyAndReturn
   */
  export type SupplierCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Suppliers.
     */
    data: SupplierCreateManyInput | SupplierCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Supplier update
   */
  export type SupplierUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The data needed to update a Supplier.
     */
    data: XOR<SupplierUpdateInput, SupplierUncheckedUpdateInput>
    /**
     * Choose, which Supplier to update.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier updateMany
   */
  export type SupplierUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Suppliers.
     */
    data: XOR<SupplierUpdateManyMutationInput, SupplierUncheckedUpdateManyInput>
    /**
     * Filter which Suppliers to update
     */
    where?: SupplierWhereInput
  }

  /**
   * Supplier upsert
   */
  export type SupplierUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The filter to search for the Supplier to update in case it exists.
     */
    where: SupplierWhereUniqueInput
    /**
     * In case the Supplier found by the `where` argument doesn't exist, create a new Supplier with this data.
     */
    create: XOR<SupplierCreateInput, SupplierUncheckedCreateInput>
    /**
     * In case the Supplier was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SupplierUpdateInput, SupplierUncheckedUpdateInput>
  }

  /**
   * Supplier delete
   */
  export type SupplierDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter which Supplier to delete.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier deleteMany
   */
  export type SupplierDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Suppliers to delete
     */
    where?: SupplierWhereInput
  }

  /**
   * Supplier.expenses
   */
  export type Supplier$expensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    where?: ExpenseWhereInput
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    cursor?: ExpenseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Supplier without action
   */
  export type SupplierDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
  }


  /**
   * Model AccountingEntry
   */

  export type AggregateAccountingEntry = {
    _count: AccountingEntryCountAggregateOutputType | null
    _avg: AccountingEntryAvgAggregateOutputType | null
    _sum: AccountingEntrySumAggregateOutputType | null
    _min: AccountingEntryMinAggregateOutputType | null
    _max: AccountingEntryMaxAggregateOutputType | null
  }

  export type AccountingEntryAvgAggregateOutputType = {
    id: number | null
    debit: number | null
    credit: number | null
    sourceDocumentId: number | null
    createdBy: number | null
  }

  export type AccountingEntrySumAggregateOutputType = {
    id: number | null
    debit: number | null
    credit: number | null
    sourceDocumentId: number | null
    createdBy: number | null
  }

  export type AccountingEntryMinAggregateOutputType = {
    id: number | null
    entryDate: Date | null
    accountNumber: string | null
    debit: number | null
    credit: number | null
    description: string | null
    sourceDocumentType: $Enums.SourceDocumentType | null
    sourceDocumentId: number | null
    createdBy: number | null
    createdAt: Date | null
  }

  export type AccountingEntryMaxAggregateOutputType = {
    id: number | null
    entryDate: Date | null
    accountNumber: string | null
    debit: number | null
    credit: number | null
    description: string | null
    sourceDocumentType: $Enums.SourceDocumentType | null
    sourceDocumentId: number | null
    createdBy: number | null
    createdAt: Date | null
  }

  export type AccountingEntryCountAggregateOutputType = {
    id: number
    entryDate: number
    accountNumber: number
    debit: number
    credit: number
    description: number
    sourceDocumentType: number
    sourceDocumentId: number
    createdBy: number
    createdAt: number
    _all: number
  }


  export type AccountingEntryAvgAggregateInputType = {
    id?: true
    debit?: true
    credit?: true
    sourceDocumentId?: true
    createdBy?: true
  }

  export type AccountingEntrySumAggregateInputType = {
    id?: true
    debit?: true
    credit?: true
    sourceDocumentId?: true
    createdBy?: true
  }

  export type AccountingEntryMinAggregateInputType = {
    id?: true
    entryDate?: true
    accountNumber?: true
    debit?: true
    credit?: true
    description?: true
    sourceDocumentType?: true
    sourceDocumentId?: true
    createdBy?: true
    createdAt?: true
  }

  export type AccountingEntryMaxAggregateInputType = {
    id?: true
    entryDate?: true
    accountNumber?: true
    debit?: true
    credit?: true
    description?: true
    sourceDocumentType?: true
    sourceDocumentId?: true
    createdBy?: true
    createdAt?: true
  }

  export type AccountingEntryCountAggregateInputType = {
    id?: true
    entryDate?: true
    accountNumber?: true
    debit?: true
    credit?: true
    description?: true
    sourceDocumentType?: true
    sourceDocumentId?: true
    createdBy?: true
    createdAt?: true
    _all?: true
  }

  export type AccountingEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccountingEntry to aggregate.
     */
    where?: AccountingEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountingEntries to fetch.
     */
    orderBy?: AccountingEntryOrderByWithRelationInput | AccountingEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountingEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountingEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountingEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AccountingEntries
    **/
    _count?: true | AccountingEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountingEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountingEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountingEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountingEntryMaxAggregateInputType
  }

  export type GetAccountingEntryAggregateType<T extends AccountingEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateAccountingEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccountingEntry[P]>
      : GetScalarType<T[P], AggregateAccountingEntry[P]>
  }




  export type AccountingEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountingEntryWhereInput
    orderBy?: AccountingEntryOrderByWithAggregationInput | AccountingEntryOrderByWithAggregationInput[]
    by: AccountingEntryScalarFieldEnum[] | AccountingEntryScalarFieldEnum
    having?: AccountingEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountingEntryCountAggregateInputType | true
    _avg?: AccountingEntryAvgAggregateInputType
    _sum?: AccountingEntrySumAggregateInputType
    _min?: AccountingEntryMinAggregateInputType
    _max?: AccountingEntryMaxAggregateInputType
  }

  export type AccountingEntryGroupByOutputType = {
    id: number
    entryDate: Date
    accountNumber: string
    debit: number
    credit: number
    description: string | null
    sourceDocumentType: $Enums.SourceDocumentType
    sourceDocumentId: number
    createdBy: number
    createdAt: Date
    _count: AccountingEntryCountAggregateOutputType | null
    _avg: AccountingEntryAvgAggregateOutputType | null
    _sum: AccountingEntrySumAggregateOutputType | null
    _min: AccountingEntryMinAggregateOutputType | null
    _max: AccountingEntryMaxAggregateOutputType | null
  }

  type GetAccountingEntryGroupByPayload<T extends AccountingEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountingEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountingEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountingEntryGroupByOutputType[P]>
            : GetScalarType<T[P], AccountingEntryGroupByOutputType[P]>
        }
      >
    >


  export type AccountingEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entryDate?: boolean
    accountNumber?: boolean
    debit?: boolean
    credit?: boolean
    description?: boolean
    sourceDocumentType?: boolean
    sourceDocumentId?: boolean
    createdBy?: boolean
    createdAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accountingEntry"]>

  export type AccountingEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entryDate?: boolean
    accountNumber?: boolean
    debit?: boolean
    credit?: boolean
    description?: boolean
    sourceDocumentType?: boolean
    sourceDocumentId?: boolean
    createdBy?: boolean
    createdAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accountingEntry"]>

  export type AccountingEntrySelectScalar = {
    id?: boolean
    entryDate?: boolean
    accountNumber?: boolean
    debit?: boolean
    credit?: boolean
    description?: boolean
    sourceDocumentType?: boolean
    sourceDocumentId?: boolean
    createdBy?: boolean
    createdAt?: boolean
  }

  export type AccountingEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountingEntryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountingEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AccountingEntry"
    objects: {
      creator: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      entryDate: Date
      accountNumber: string
      debit: number
      credit: number
      description: string | null
      sourceDocumentType: $Enums.SourceDocumentType
      sourceDocumentId: number
      createdBy: number
      createdAt: Date
    }, ExtArgs["result"]["accountingEntry"]>
    composites: {}
  }

  type AccountingEntryGetPayload<S extends boolean | null | undefined | AccountingEntryDefaultArgs> = $Result.GetResult<Prisma.$AccountingEntryPayload, S>

  type AccountingEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AccountingEntryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AccountingEntryCountAggregateInputType | true
    }

  export interface AccountingEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AccountingEntry'], meta: { name: 'AccountingEntry' } }
    /**
     * Find zero or one AccountingEntry that matches the filter.
     * @param {AccountingEntryFindUniqueArgs} args - Arguments to find a AccountingEntry
     * @example
     * // Get one AccountingEntry
     * const accountingEntry = await prisma.accountingEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountingEntryFindUniqueArgs>(args: SelectSubset<T, AccountingEntryFindUniqueArgs<ExtArgs>>): Prisma__AccountingEntryClient<$Result.GetResult<Prisma.$AccountingEntryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AccountingEntry that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AccountingEntryFindUniqueOrThrowArgs} args - Arguments to find a AccountingEntry
     * @example
     * // Get one AccountingEntry
     * const accountingEntry = await prisma.accountingEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountingEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountingEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountingEntryClient<$Result.GetResult<Prisma.$AccountingEntryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AccountingEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountingEntryFindFirstArgs} args - Arguments to find a AccountingEntry
     * @example
     * // Get one AccountingEntry
     * const accountingEntry = await prisma.accountingEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountingEntryFindFirstArgs>(args?: SelectSubset<T, AccountingEntryFindFirstArgs<ExtArgs>>): Prisma__AccountingEntryClient<$Result.GetResult<Prisma.$AccountingEntryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AccountingEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountingEntryFindFirstOrThrowArgs} args - Arguments to find a AccountingEntry
     * @example
     * // Get one AccountingEntry
     * const accountingEntry = await prisma.accountingEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountingEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountingEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountingEntryClient<$Result.GetResult<Prisma.$AccountingEntryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AccountingEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountingEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AccountingEntries
     * const accountingEntries = await prisma.accountingEntry.findMany()
     * 
     * // Get first 10 AccountingEntries
     * const accountingEntries = await prisma.accountingEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountingEntryWithIdOnly = await prisma.accountingEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountingEntryFindManyArgs>(args?: SelectSubset<T, AccountingEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountingEntryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AccountingEntry.
     * @param {AccountingEntryCreateArgs} args - Arguments to create a AccountingEntry.
     * @example
     * // Create one AccountingEntry
     * const AccountingEntry = await prisma.accountingEntry.create({
     *   data: {
     *     // ... data to create a AccountingEntry
     *   }
     * })
     * 
     */
    create<T extends AccountingEntryCreateArgs>(args: SelectSubset<T, AccountingEntryCreateArgs<ExtArgs>>): Prisma__AccountingEntryClient<$Result.GetResult<Prisma.$AccountingEntryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AccountingEntries.
     * @param {AccountingEntryCreateManyArgs} args - Arguments to create many AccountingEntries.
     * @example
     * // Create many AccountingEntries
     * const accountingEntry = await prisma.accountingEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountingEntryCreateManyArgs>(args?: SelectSubset<T, AccountingEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AccountingEntries and returns the data saved in the database.
     * @param {AccountingEntryCreateManyAndReturnArgs} args - Arguments to create many AccountingEntries.
     * @example
     * // Create many AccountingEntries
     * const accountingEntry = await prisma.accountingEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AccountingEntries and only return the `id`
     * const accountingEntryWithIdOnly = await prisma.accountingEntry.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountingEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountingEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountingEntryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AccountingEntry.
     * @param {AccountingEntryDeleteArgs} args - Arguments to delete one AccountingEntry.
     * @example
     * // Delete one AccountingEntry
     * const AccountingEntry = await prisma.accountingEntry.delete({
     *   where: {
     *     // ... filter to delete one AccountingEntry
     *   }
     * })
     * 
     */
    delete<T extends AccountingEntryDeleteArgs>(args: SelectSubset<T, AccountingEntryDeleteArgs<ExtArgs>>): Prisma__AccountingEntryClient<$Result.GetResult<Prisma.$AccountingEntryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AccountingEntry.
     * @param {AccountingEntryUpdateArgs} args - Arguments to update one AccountingEntry.
     * @example
     * // Update one AccountingEntry
     * const accountingEntry = await prisma.accountingEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountingEntryUpdateArgs>(args: SelectSubset<T, AccountingEntryUpdateArgs<ExtArgs>>): Prisma__AccountingEntryClient<$Result.GetResult<Prisma.$AccountingEntryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AccountingEntries.
     * @param {AccountingEntryDeleteManyArgs} args - Arguments to filter AccountingEntries to delete.
     * @example
     * // Delete a few AccountingEntries
     * const { count } = await prisma.accountingEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountingEntryDeleteManyArgs>(args?: SelectSubset<T, AccountingEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AccountingEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountingEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AccountingEntries
     * const accountingEntry = await prisma.accountingEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountingEntryUpdateManyArgs>(args: SelectSubset<T, AccountingEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AccountingEntry.
     * @param {AccountingEntryUpsertArgs} args - Arguments to update or create a AccountingEntry.
     * @example
     * // Update or create a AccountingEntry
     * const accountingEntry = await prisma.accountingEntry.upsert({
     *   create: {
     *     // ... data to create a AccountingEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AccountingEntry we want to update
     *   }
     * })
     */
    upsert<T extends AccountingEntryUpsertArgs>(args: SelectSubset<T, AccountingEntryUpsertArgs<ExtArgs>>): Prisma__AccountingEntryClient<$Result.GetResult<Prisma.$AccountingEntryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AccountingEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountingEntryCountArgs} args - Arguments to filter AccountingEntries to count.
     * @example
     * // Count the number of AccountingEntries
     * const count = await prisma.accountingEntry.count({
     *   where: {
     *     // ... the filter for the AccountingEntries we want to count
     *   }
     * })
    **/
    count<T extends AccountingEntryCountArgs>(
      args?: Subset<T, AccountingEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountingEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AccountingEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountingEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountingEntryAggregateArgs>(args: Subset<T, AccountingEntryAggregateArgs>): Prisma.PrismaPromise<GetAccountingEntryAggregateType<T>>

    /**
     * Group by AccountingEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountingEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountingEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountingEntryGroupByArgs['orderBy'] }
        : { orderBy?: AccountingEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountingEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountingEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AccountingEntry model
   */
  readonly fields: AccountingEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AccountingEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountingEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AccountingEntry model
   */ 
  interface AccountingEntryFieldRefs {
    readonly id: FieldRef<"AccountingEntry", 'Int'>
    readonly entryDate: FieldRef<"AccountingEntry", 'DateTime'>
    readonly accountNumber: FieldRef<"AccountingEntry", 'String'>
    readonly debit: FieldRef<"AccountingEntry", 'Float'>
    readonly credit: FieldRef<"AccountingEntry", 'Float'>
    readonly description: FieldRef<"AccountingEntry", 'String'>
    readonly sourceDocumentType: FieldRef<"AccountingEntry", 'SourceDocumentType'>
    readonly sourceDocumentId: FieldRef<"AccountingEntry", 'Int'>
    readonly createdBy: FieldRef<"AccountingEntry", 'Int'>
    readonly createdAt: FieldRef<"AccountingEntry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AccountingEntry findUnique
   */
  export type AccountingEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountingEntry
     */
    select?: AccountingEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountingEntryInclude<ExtArgs> | null
    /**
     * Filter, which AccountingEntry to fetch.
     */
    where: AccountingEntryWhereUniqueInput
  }

  /**
   * AccountingEntry findUniqueOrThrow
   */
  export type AccountingEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountingEntry
     */
    select?: AccountingEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountingEntryInclude<ExtArgs> | null
    /**
     * Filter, which AccountingEntry to fetch.
     */
    where: AccountingEntryWhereUniqueInput
  }

  /**
   * AccountingEntry findFirst
   */
  export type AccountingEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountingEntry
     */
    select?: AccountingEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountingEntryInclude<ExtArgs> | null
    /**
     * Filter, which AccountingEntry to fetch.
     */
    where?: AccountingEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountingEntries to fetch.
     */
    orderBy?: AccountingEntryOrderByWithRelationInput | AccountingEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccountingEntries.
     */
    cursor?: AccountingEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountingEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountingEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccountingEntries.
     */
    distinct?: AccountingEntryScalarFieldEnum | AccountingEntryScalarFieldEnum[]
  }

  /**
   * AccountingEntry findFirstOrThrow
   */
  export type AccountingEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountingEntry
     */
    select?: AccountingEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountingEntryInclude<ExtArgs> | null
    /**
     * Filter, which AccountingEntry to fetch.
     */
    where?: AccountingEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountingEntries to fetch.
     */
    orderBy?: AccountingEntryOrderByWithRelationInput | AccountingEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccountingEntries.
     */
    cursor?: AccountingEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountingEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountingEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccountingEntries.
     */
    distinct?: AccountingEntryScalarFieldEnum | AccountingEntryScalarFieldEnum[]
  }

  /**
   * AccountingEntry findMany
   */
  export type AccountingEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountingEntry
     */
    select?: AccountingEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountingEntryInclude<ExtArgs> | null
    /**
     * Filter, which AccountingEntries to fetch.
     */
    where?: AccountingEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountingEntries to fetch.
     */
    orderBy?: AccountingEntryOrderByWithRelationInput | AccountingEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AccountingEntries.
     */
    cursor?: AccountingEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountingEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountingEntries.
     */
    skip?: number
    distinct?: AccountingEntryScalarFieldEnum | AccountingEntryScalarFieldEnum[]
  }

  /**
   * AccountingEntry create
   */
  export type AccountingEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountingEntry
     */
    select?: AccountingEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountingEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a AccountingEntry.
     */
    data: XOR<AccountingEntryCreateInput, AccountingEntryUncheckedCreateInput>
  }

  /**
   * AccountingEntry createMany
   */
  export type AccountingEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AccountingEntries.
     */
    data: AccountingEntryCreateManyInput | AccountingEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AccountingEntry createManyAndReturn
   */
  export type AccountingEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountingEntry
     */
    select?: AccountingEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AccountingEntries.
     */
    data: AccountingEntryCreateManyInput | AccountingEntryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountingEntryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AccountingEntry update
   */
  export type AccountingEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountingEntry
     */
    select?: AccountingEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountingEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a AccountingEntry.
     */
    data: XOR<AccountingEntryUpdateInput, AccountingEntryUncheckedUpdateInput>
    /**
     * Choose, which AccountingEntry to update.
     */
    where: AccountingEntryWhereUniqueInput
  }

  /**
   * AccountingEntry updateMany
   */
  export type AccountingEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AccountingEntries.
     */
    data: XOR<AccountingEntryUpdateManyMutationInput, AccountingEntryUncheckedUpdateManyInput>
    /**
     * Filter which AccountingEntries to update
     */
    where?: AccountingEntryWhereInput
  }

  /**
   * AccountingEntry upsert
   */
  export type AccountingEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountingEntry
     */
    select?: AccountingEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountingEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the AccountingEntry to update in case it exists.
     */
    where: AccountingEntryWhereUniqueInput
    /**
     * In case the AccountingEntry found by the `where` argument doesn't exist, create a new AccountingEntry with this data.
     */
    create: XOR<AccountingEntryCreateInput, AccountingEntryUncheckedCreateInput>
    /**
     * In case the AccountingEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountingEntryUpdateInput, AccountingEntryUncheckedUpdateInput>
  }

  /**
   * AccountingEntry delete
   */
  export type AccountingEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountingEntry
     */
    select?: AccountingEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountingEntryInclude<ExtArgs> | null
    /**
     * Filter which AccountingEntry to delete.
     */
    where: AccountingEntryWhereUniqueInput
  }

  /**
   * AccountingEntry deleteMany
   */
  export type AccountingEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccountingEntries to delete
     */
    where?: AccountingEntryWhereInput
  }

  /**
   * AccountingEntry without action
   */
  export type AccountingEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountingEntry
     */
    select?: AccountingEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountingEntryInclude<ExtArgs> | null
  }


  /**
   * Model CashFlow
   */

  export type AggregateCashFlow = {
    _count: CashFlowCountAggregateOutputType | null
    _avg: CashFlowAvgAggregateOutputType | null
    _sum: CashFlowSumAggregateOutputType | null
    _min: CashFlowMinAggregateOutputType | null
    _max: CashFlowMaxAggregateOutputType | null
  }

  export type CashFlowAvgAggregateOutputType = {
    id: number | null
    amount: number | null
    sourceDocumentId: number | null
    createdBy: number | null
  }

  export type CashFlowSumAggregateOutputType = {
    id: number | null
    amount: number | null
    sourceDocumentId: number | null
    createdBy: number | null
  }

  export type CashFlowMinAggregateOutputType = {
    id: number | null
    transactionDate: Date | null
    type: $Enums.CashFlowType | null
    amount: number | null
    description: string | null
    category: string | null
    sourceDocumentType: $Enums.SourceDocumentType | null
    sourceDocumentId: number | null
    createdBy: number | null
    createdAt: Date | null
  }

  export type CashFlowMaxAggregateOutputType = {
    id: number | null
    transactionDate: Date | null
    type: $Enums.CashFlowType | null
    amount: number | null
    description: string | null
    category: string | null
    sourceDocumentType: $Enums.SourceDocumentType | null
    sourceDocumentId: number | null
    createdBy: number | null
    createdAt: Date | null
  }

  export type CashFlowCountAggregateOutputType = {
    id: number
    transactionDate: number
    type: number
    amount: number
    description: number
    category: number
    sourceDocumentType: number
    sourceDocumentId: number
    createdBy: number
    createdAt: number
    _all: number
  }


  export type CashFlowAvgAggregateInputType = {
    id?: true
    amount?: true
    sourceDocumentId?: true
    createdBy?: true
  }

  export type CashFlowSumAggregateInputType = {
    id?: true
    amount?: true
    sourceDocumentId?: true
    createdBy?: true
  }

  export type CashFlowMinAggregateInputType = {
    id?: true
    transactionDate?: true
    type?: true
    amount?: true
    description?: true
    category?: true
    sourceDocumentType?: true
    sourceDocumentId?: true
    createdBy?: true
    createdAt?: true
  }

  export type CashFlowMaxAggregateInputType = {
    id?: true
    transactionDate?: true
    type?: true
    amount?: true
    description?: true
    category?: true
    sourceDocumentType?: true
    sourceDocumentId?: true
    createdBy?: true
    createdAt?: true
  }

  export type CashFlowCountAggregateInputType = {
    id?: true
    transactionDate?: true
    type?: true
    amount?: true
    description?: true
    category?: true
    sourceDocumentType?: true
    sourceDocumentId?: true
    createdBy?: true
    createdAt?: true
    _all?: true
  }

  export type CashFlowAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CashFlow to aggregate.
     */
    where?: CashFlowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashFlows to fetch.
     */
    orderBy?: CashFlowOrderByWithRelationInput | CashFlowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CashFlowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashFlows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashFlows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CashFlows
    **/
    _count?: true | CashFlowCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CashFlowAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CashFlowSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CashFlowMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CashFlowMaxAggregateInputType
  }

  export type GetCashFlowAggregateType<T extends CashFlowAggregateArgs> = {
        [P in keyof T & keyof AggregateCashFlow]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCashFlow[P]>
      : GetScalarType<T[P], AggregateCashFlow[P]>
  }




  export type CashFlowGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CashFlowWhereInput
    orderBy?: CashFlowOrderByWithAggregationInput | CashFlowOrderByWithAggregationInput[]
    by: CashFlowScalarFieldEnum[] | CashFlowScalarFieldEnum
    having?: CashFlowScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CashFlowCountAggregateInputType | true
    _avg?: CashFlowAvgAggregateInputType
    _sum?: CashFlowSumAggregateInputType
    _min?: CashFlowMinAggregateInputType
    _max?: CashFlowMaxAggregateInputType
  }

  export type CashFlowGroupByOutputType = {
    id: number
    transactionDate: Date
    type: $Enums.CashFlowType
    amount: number
    description: string | null
    category: string | null
    sourceDocumentType: $Enums.SourceDocumentType
    sourceDocumentId: number
    createdBy: number
    createdAt: Date
    _count: CashFlowCountAggregateOutputType | null
    _avg: CashFlowAvgAggregateOutputType | null
    _sum: CashFlowSumAggregateOutputType | null
    _min: CashFlowMinAggregateOutputType | null
    _max: CashFlowMaxAggregateOutputType | null
  }

  type GetCashFlowGroupByPayload<T extends CashFlowGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CashFlowGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CashFlowGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CashFlowGroupByOutputType[P]>
            : GetScalarType<T[P], CashFlowGroupByOutputType[P]>
        }
      >
    >


  export type CashFlowSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionDate?: boolean
    type?: boolean
    amount?: boolean
    description?: boolean
    category?: boolean
    sourceDocumentType?: boolean
    sourceDocumentId?: boolean
    createdBy?: boolean
    createdAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cashFlow"]>

  export type CashFlowSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionDate?: boolean
    type?: boolean
    amount?: boolean
    description?: boolean
    category?: boolean
    sourceDocumentType?: boolean
    sourceDocumentId?: boolean
    createdBy?: boolean
    createdAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cashFlow"]>

  export type CashFlowSelectScalar = {
    id?: boolean
    transactionDate?: boolean
    type?: boolean
    amount?: boolean
    description?: boolean
    category?: boolean
    sourceDocumentType?: boolean
    sourceDocumentId?: boolean
    createdBy?: boolean
    createdAt?: boolean
  }

  export type CashFlowInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CashFlowIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CashFlowPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CashFlow"
    objects: {
      creator: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      transactionDate: Date
      type: $Enums.CashFlowType
      amount: number
      description: string | null
      category: string | null
      sourceDocumentType: $Enums.SourceDocumentType
      sourceDocumentId: number
      createdBy: number
      createdAt: Date
    }, ExtArgs["result"]["cashFlow"]>
    composites: {}
  }

  type CashFlowGetPayload<S extends boolean | null | undefined | CashFlowDefaultArgs> = $Result.GetResult<Prisma.$CashFlowPayload, S>

  type CashFlowCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CashFlowFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CashFlowCountAggregateInputType | true
    }

  export interface CashFlowDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CashFlow'], meta: { name: 'CashFlow' } }
    /**
     * Find zero or one CashFlow that matches the filter.
     * @param {CashFlowFindUniqueArgs} args - Arguments to find a CashFlow
     * @example
     * // Get one CashFlow
     * const cashFlow = await prisma.cashFlow.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CashFlowFindUniqueArgs>(args: SelectSubset<T, CashFlowFindUniqueArgs<ExtArgs>>): Prisma__CashFlowClient<$Result.GetResult<Prisma.$CashFlowPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CashFlow that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CashFlowFindUniqueOrThrowArgs} args - Arguments to find a CashFlow
     * @example
     * // Get one CashFlow
     * const cashFlow = await prisma.cashFlow.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CashFlowFindUniqueOrThrowArgs>(args: SelectSubset<T, CashFlowFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CashFlowClient<$Result.GetResult<Prisma.$CashFlowPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CashFlow that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashFlowFindFirstArgs} args - Arguments to find a CashFlow
     * @example
     * // Get one CashFlow
     * const cashFlow = await prisma.cashFlow.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CashFlowFindFirstArgs>(args?: SelectSubset<T, CashFlowFindFirstArgs<ExtArgs>>): Prisma__CashFlowClient<$Result.GetResult<Prisma.$CashFlowPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CashFlow that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashFlowFindFirstOrThrowArgs} args - Arguments to find a CashFlow
     * @example
     * // Get one CashFlow
     * const cashFlow = await prisma.cashFlow.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CashFlowFindFirstOrThrowArgs>(args?: SelectSubset<T, CashFlowFindFirstOrThrowArgs<ExtArgs>>): Prisma__CashFlowClient<$Result.GetResult<Prisma.$CashFlowPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CashFlows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashFlowFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CashFlows
     * const cashFlows = await prisma.cashFlow.findMany()
     * 
     * // Get first 10 CashFlows
     * const cashFlows = await prisma.cashFlow.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cashFlowWithIdOnly = await prisma.cashFlow.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CashFlowFindManyArgs>(args?: SelectSubset<T, CashFlowFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashFlowPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CashFlow.
     * @param {CashFlowCreateArgs} args - Arguments to create a CashFlow.
     * @example
     * // Create one CashFlow
     * const CashFlow = await prisma.cashFlow.create({
     *   data: {
     *     // ... data to create a CashFlow
     *   }
     * })
     * 
     */
    create<T extends CashFlowCreateArgs>(args: SelectSubset<T, CashFlowCreateArgs<ExtArgs>>): Prisma__CashFlowClient<$Result.GetResult<Prisma.$CashFlowPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CashFlows.
     * @param {CashFlowCreateManyArgs} args - Arguments to create many CashFlows.
     * @example
     * // Create many CashFlows
     * const cashFlow = await prisma.cashFlow.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CashFlowCreateManyArgs>(args?: SelectSubset<T, CashFlowCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CashFlows and returns the data saved in the database.
     * @param {CashFlowCreateManyAndReturnArgs} args - Arguments to create many CashFlows.
     * @example
     * // Create many CashFlows
     * const cashFlow = await prisma.cashFlow.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CashFlows and only return the `id`
     * const cashFlowWithIdOnly = await prisma.cashFlow.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CashFlowCreateManyAndReturnArgs>(args?: SelectSubset<T, CashFlowCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashFlowPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CashFlow.
     * @param {CashFlowDeleteArgs} args - Arguments to delete one CashFlow.
     * @example
     * // Delete one CashFlow
     * const CashFlow = await prisma.cashFlow.delete({
     *   where: {
     *     // ... filter to delete one CashFlow
     *   }
     * })
     * 
     */
    delete<T extends CashFlowDeleteArgs>(args: SelectSubset<T, CashFlowDeleteArgs<ExtArgs>>): Prisma__CashFlowClient<$Result.GetResult<Prisma.$CashFlowPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CashFlow.
     * @param {CashFlowUpdateArgs} args - Arguments to update one CashFlow.
     * @example
     * // Update one CashFlow
     * const cashFlow = await prisma.cashFlow.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CashFlowUpdateArgs>(args: SelectSubset<T, CashFlowUpdateArgs<ExtArgs>>): Prisma__CashFlowClient<$Result.GetResult<Prisma.$CashFlowPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CashFlows.
     * @param {CashFlowDeleteManyArgs} args - Arguments to filter CashFlows to delete.
     * @example
     * // Delete a few CashFlows
     * const { count } = await prisma.cashFlow.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CashFlowDeleteManyArgs>(args?: SelectSubset<T, CashFlowDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CashFlows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashFlowUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CashFlows
     * const cashFlow = await prisma.cashFlow.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CashFlowUpdateManyArgs>(args: SelectSubset<T, CashFlowUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CashFlow.
     * @param {CashFlowUpsertArgs} args - Arguments to update or create a CashFlow.
     * @example
     * // Update or create a CashFlow
     * const cashFlow = await prisma.cashFlow.upsert({
     *   create: {
     *     // ... data to create a CashFlow
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CashFlow we want to update
     *   }
     * })
     */
    upsert<T extends CashFlowUpsertArgs>(args: SelectSubset<T, CashFlowUpsertArgs<ExtArgs>>): Prisma__CashFlowClient<$Result.GetResult<Prisma.$CashFlowPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CashFlows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashFlowCountArgs} args - Arguments to filter CashFlows to count.
     * @example
     * // Count the number of CashFlows
     * const count = await prisma.cashFlow.count({
     *   where: {
     *     // ... the filter for the CashFlows we want to count
     *   }
     * })
    **/
    count<T extends CashFlowCountArgs>(
      args?: Subset<T, CashFlowCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CashFlowCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CashFlow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashFlowAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CashFlowAggregateArgs>(args: Subset<T, CashFlowAggregateArgs>): Prisma.PrismaPromise<GetCashFlowAggregateType<T>>

    /**
     * Group by CashFlow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashFlowGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CashFlowGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CashFlowGroupByArgs['orderBy'] }
        : { orderBy?: CashFlowGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CashFlowGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCashFlowGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CashFlow model
   */
  readonly fields: CashFlowFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CashFlow.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CashFlowClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CashFlow model
   */ 
  interface CashFlowFieldRefs {
    readonly id: FieldRef<"CashFlow", 'Int'>
    readonly transactionDate: FieldRef<"CashFlow", 'DateTime'>
    readonly type: FieldRef<"CashFlow", 'CashFlowType'>
    readonly amount: FieldRef<"CashFlow", 'Float'>
    readonly description: FieldRef<"CashFlow", 'String'>
    readonly category: FieldRef<"CashFlow", 'String'>
    readonly sourceDocumentType: FieldRef<"CashFlow", 'SourceDocumentType'>
    readonly sourceDocumentId: FieldRef<"CashFlow", 'Int'>
    readonly createdBy: FieldRef<"CashFlow", 'Int'>
    readonly createdAt: FieldRef<"CashFlow", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CashFlow findUnique
   */
  export type CashFlowFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashFlow
     */
    select?: CashFlowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashFlowInclude<ExtArgs> | null
    /**
     * Filter, which CashFlow to fetch.
     */
    where: CashFlowWhereUniqueInput
  }

  /**
   * CashFlow findUniqueOrThrow
   */
  export type CashFlowFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashFlow
     */
    select?: CashFlowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashFlowInclude<ExtArgs> | null
    /**
     * Filter, which CashFlow to fetch.
     */
    where: CashFlowWhereUniqueInput
  }

  /**
   * CashFlow findFirst
   */
  export type CashFlowFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashFlow
     */
    select?: CashFlowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashFlowInclude<ExtArgs> | null
    /**
     * Filter, which CashFlow to fetch.
     */
    where?: CashFlowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashFlows to fetch.
     */
    orderBy?: CashFlowOrderByWithRelationInput | CashFlowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CashFlows.
     */
    cursor?: CashFlowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashFlows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashFlows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CashFlows.
     */
    distinct?: CashFlowScalarFieldEnum | CashFlowScalarFieldEnum[]
  }

  /**
   * CashFlow findFirstOrThrow
   */
  export type CashFlowFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashFlow
     */
    select?: CashFlowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashFlowInclude<ExtArgs> | null
    /**
     * Filter, which CashFlow to fetch.
     */
    where?: CashFlowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashFlows to fetch.
     */
    orderBy?: CashFlowOrderByWithRelationInput | CashFlowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CashFlows.
     */
    cursor?: CashFlowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashFlows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashFlows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CashFlows.
     */
    distinct?: CashFlowScalarFieldEnum | CashFlowScalarFieldEnum[]
  }

  /**
   * CashFlow findMany
   */
  export type CashFlowFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashFlow
     */
    select?: CashFlowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashFlowInclude<ExtArgs> | null
    /**
     * Filter, which CashFlows to fetch.
     */
    where?: CashFlowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashFlows to fetch.
     */
    orderBy?: CashFlowOrderByWithRelationInput | CashFlowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CashFlows.
     */
    cursor?: CashFlowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashFlows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashFlows.
     */
    skip?: number
    distinct?: CashFlowScalarFieldEnum | CashFlowScalarFieldEnum[]
  }

  /**
   * CashFlow create
   */
  export type CashFlowCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashFlow
     */
    select?: CashFlowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashFlowInclude<ExtArgs> | null
    /**
     * The data needed to create a CashFlow.
     */
    data: XOR<CashFlowCreateInput, CashFlowUncheckedCreateInput>
  }

  /**
   * CashFlow createMany
   */
  export type CashFlowCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CashFlows.
     */
    data: CashFlowCreateManyInput | CashFlowCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CashFlow createManyAndReturn
   */
  export type CashFlowCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashFlow
     */
    select?: CashFlowSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CashFlows.
     */
    data: CashFlowCreateManyInput | CashFlowCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashFlowIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CashFlow update
   */
  export type CashFlowUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashFlow
     */
    select?: CashFlowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashFlowInclude<ExtArgs> | null
    /**
     * The data needed to update a CashFlow.
     */
    data: XOR<CashFlowUpdateInput, CashFlowUncheckedUpdateInput>
    /**
     * Choose, which CashFlow to update.
     */
    where: CashFlowWhereUniqueInput
  }

  /**
   * CashFlow updateMany
   */
  export type CashFlowUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CashFlows.
     */
    data: XOR<CashFlowUpdateManyMutationInput, CashFlowUncheckedUpdateManyInput>
    /**
     * Filter which CashFlows to update
     */
    where?: CashFlowWhereInput
  }

  /**
   * CashFlow upsert
   */
  export type CashFlowUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashFlow
     */
    select?: CashFlowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashFlowInclude<ExtArgs> | null
    /**
     * The filter to search for the CashFlow to update in case it exists.
     */
    where: CashFlowWhereUniqueInput
    /**
     * In case the CashFlow found by the `where` argument doesn't exist, create a new CashFlow with this data.
     */
    create: XOR<CashFlowCreateInput, CashFlowUncheckedCreateInput>
    /**
     * In case the CashFlow was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CashFlowUpdateInput, CashFlowUncheckedUpdateInput>
  }

  /**
   * CashFlow delete
   */
  export type CashFlowDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashFlow
     */
    select?: CashFlowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashFlowInclude<ExtArgs> | null
    /**
     * Filter which CashFlow to delete.
     */
    where: CashFlowWhereUniqueInput
  }

  /**
   * CashFlow deleteMany
   */
  export type CashFlowDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CashFlows to delete
     */
    where?: CashFlowWhereInput
  }

  /**
   * CashFlow without action
   */
  export type CashFlowDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashFlow
     */
    select?: CashFlowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashFlowInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _avg: AuditLogAvgAggregateOutputType | null
    _sum: AuditLogSumAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type AuditLogSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: number | null
    userId: number | null
    action: string | null
    details: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    action: string | null
    details: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    userId: number
    action: number
    details: number
    createdAt: number
    _all: number
  }


  export type AuditLogAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type AuditLogSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type AuditLogMinAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    details?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    details?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    details?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AuditLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AuditLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _avg?: AuditLogAvgAggregateInputType
    _sum?: AuditLogSumAggregateInputType
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: number
    userId: number
    action: string
    details: string | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _avg: AuditLogAvgAggregateOutputType | null
    _sum: AuditLogSumAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    details?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    details?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    userId?: boolean
    action?: boolean
    details?: boolean
    createdAt?: boolean
  }

  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      action: string
      details: string | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */ 
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'Int'>
    readonly userId: FieldRef<"AuditLog", 'Int'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly details: FieldRef<"AuditLog", 'String'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model Employee
   */

  export type AggregateEmployee = {
    _count: EmployeeCountAggregateOutputType | null
    _avg: EmployeeAvgAggregateOutputType | null
    _sum: EmployeeSumAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  export type EmployeeAvgAggregateOutputType = {
    id: number | null
    serviceId: number | null
    userId: number | null
  }

  export type EmployeeSumAggregateOutputType = {
    id: number | null
    serviceId: number | null
    userId: number | null
  }

  export type EmployeeMinAggregateOutputType = {
    id: number | null
    employeeNumber: string | null
    registrationNumber: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    address: string | null
    dateOfBirth: Date | null
    placeOfBirth: string | null
    nationality: string | null
    socialSecurityNumber: string | null
    cnpsNumber: string | null
    cnamNumber: string | null
    bankAccount: string | null
    emergencyContact: string | null
    serviceId: number | null
    position: string | null
    department: string | null
    category: string | null
    level: string | null
    manager: string | null
    hireDate: Date | null
    isActive: boolean | null
    userId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmployeeMaxAggregateOutputType = {
    id: number | null
    employeeNumber: string | null
    registrationNumber: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    address: string | null
    dateOfBirth: Date | null
    placeOfBirth: string | null
    nationality: string | null
    socialSecurityNumber: string | null
    cnpsNumber: string | null
    cnamNumber: string | null
    bankAccount: string | null
    emergencyContact: string | null
    serviceId: number | null
    position: string | null
    department: string | null
    category: string | null
    level: string | null
    manager: string | null
    hireDate: Date | null
    isActive: boolean | null
    userId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmployeeCountAggregateOutputType = {
    id: number
    employeeNumber: number
    registrationNumber: number
    firstName: number
    lastName: number
    email: number
    phone: number
    address: number
    dateOfBirth: number
    placeOfBirth: number
    nationality: number
    socialSecurityNumber: number
    cnpsNumber: number
    cnamNumber: number
    bankAccount: number
    emergencyContact: number
    serviceId: number
    position: number
    department: number
    category: number
    level: number
    manager: number
    hireDate: number
    isActive: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmployeeAvgAggregateInputType = {
    id?: true
    serviceId?: true
    userId?: true
  }

  export type EmployeeSumAggregateInputType = {
    id?: true
    serviceId?: true
    userId?: true
  }

  export type EmployeeMinAggregateInputType = {
    id?: true
    employeeNumber?: true
    registrationNumber?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    address?: true
    dateOfBirth?: true
    placeOfBirth?: true
    nationality?: true
    socialSecurityNumber?: true
    cnpsNumber?: true
    cnamNumber?: true
    bankAccount?: true
    emergencyContact?: true
    serviceId?: true
    position?: true
    department?: true
    category?: true
    level?: true
    manager?: true
    hireDate?: true
    isActive?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmployeeMaxAggregateInputType = {
    id?: true
    employeeNumber?: true
    registrationNumber?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    address?: true
    dateOfBirth?: true
    placeOfBirth?: true
    nationality?: true
    socialSecurityNumber?: true
    cnpsNumber?: true
    cnamNumber?: true
    bankAccount?: true
    emergencyContact?: true
    serviceId?: true
    position?: true
    department?: true
    category?: true
    level?: true
    manager?: true
    hireDate?: true
    isActive?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmployeeCountAggregateInputType = {
    id?: true
    employeeNumber?: true
    registrationNumber?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    address?: true
    dateOfBirth?: true
    placeOfBirth?: true
    nationality?: true
    socialSecurityNumber?: true
    cnpsNumber?: true
    cnamNumber?: true
    bankAccount?: true
    emergencyContact?: true
    serviceId?: true
    position?: true
    department?: true
    category?: true
    level?: true
    manager?: true
    hireDate?: true
    isActive?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmployeeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employee to aggregate.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Employees
    **/
    _count?: true | EmployeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmployeeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmployeeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeMaxAggregateInputType
  }

  export type GetEmployeeAggregateType<T extends EmployeeAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployee[P]>
      : GetScalarType<T[P], AggregateEmployee[P]>
  }




  export type EmployeeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithAggregationInput | EmployeeOrderByWithAggregationInput[]
    by: EmployeeScalarFieldEnum[] | EmployeeScalarFieldEnum
    having?: EmployeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeCountAggregateInputType | true
    _avg?: EmployeeAvgAggregateInputType
    _sum?: EmployeeSumAggregateInputType
    _min?: EmployeeMinAggregateInputType
    _max?: EmployeeMaxAggregateInputType
  }

  export type EmployeeGroupByOutputType = {
    id: number
    employeeNumber: string
    registrationNumber: string | null
    firstName: string
    lastName: string
    email: string | null
    phone: string | null
    address: string | null
    dateOfBirth: Date
    placeOfBirth: string | null
    nationality: string | null
    socialSecurityNumber: string | null
    cnpsNumber: string | null
    cnamNumber: string | null
    bankAccount: string | null
    emergencyContact: string | null
    serviceId: number | null
    position: string
    department: string | null
    category: string | null
    level: string | null
    manager: string | null
    hireDate: Date
    isActive: boolean
    userId: number | null
    createdAt: Date
    updatedAt: Date
    _count: EmployeeCountAggregateOutputType | null
    _avg: EmployeeAvgAggregateOutputType | null
    _sum: EmployeeSumAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  type GetEmployeeGroupByPayload<T extends EmployeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeNumber?: boolean
    registrationNumber?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    dateOfBirth?: boolean
    placeOfBirth?: boolean
    nationality?: boolean
    socialSecurityNumber?: boolean
    cnpsNumber?: boolean
    cnamNumber?: boolean
    bankAccount?: boolean
    emergencyContact?: boolean
    serviceId?: boolean
    position?: boolean
    department?: boolean
    category?: boolean
    level?: boolean
    manager?: boolean
    hireDate?: boolean
    isActive?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    service?: boolean | Employee$serviceArgs<ExtArgs>
    user?: boolean | Employee$userArgs<ExtArgs>
    contracts?: boolean | Employee$contractsArgs<ExtArgs>
    salaries?: boolean | Employee$salariesArgs<ExtArgs>
    leaveRequests?: boolean | Employee$leaveRequestsArgs<ExtArgs>
    loans?: boolean | Employee$loansArgs<ExtArgs>
    _count?: boolean | EmployeeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeNumber?: boolean
    registrationNumber?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    dateOfBirth?: boolean
    placeOfBirth?: boolean
    nationality?: boolean
    socialSecurityNumber?: boolean
    cnpsNumber?: boolean
    cnamNumber?: boolean
    bankAccount?: boolean
    emergencyContact?: boolean
    serviceId?: boolean
    position?: boolean
    department?: boolean
    category?: boolean
    level?: boolean
    manager?: boolean
    hireDate?: boolean
    isActive?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    service?: boolean | Employee$serviceArgs<ExtArgs>
    user?: boolean | Employee$userArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectScalar = {
    id?: boolean
    employeeNumber?: boolean
    registrationNumber?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    dateOfBirth?: boolean
    placeOfBirth?: boolean
    nationality?: boolean
    socialSecurityNumber?: boolean
    cnpsNumber?: boolean
    cnamNumber?: boolean
    bankAccount?: boolean
    emergencyContact?: boolean
    serviceId?: boolean
    position?: boolean
    department?: boolean
    category?: boolean
    level?: boolean
    manager?: boolean
    hireDate?: boolean
    isActive?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EmployeeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | Employee$serviceArgs<ExtArgs>
    user?: boolean | Employee$userArgs<ExtArgs>
    contracts?: boolean | Employee$contractsArgs<ExtArgs>
    salaries?: boolean | Employee$salariesArgs<ExtArgs>
    leaveRequests?: boolean | Employee$leaveRequestsArgs<ExtArgs>
    loans?: boolean | Employee$loansArgs<ExtArgs>
    _count?: boolean | EmployeeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EmployeeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | Employee$serviceArgs<ExtArgs>
    user?: boolean | Employee$userArgs<ExtArgs>
  }

  export type $EmployeePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Employee"
    objects: {
      service: Prisma.$ServicePayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs> | null
      contracts: Prisma.$ContractPayload<ExtArgs>[]
      salaries: Prisma.$SalaryPayload<ExtArgs>[]
      leaveRequests: Prisma.$LeaveRequestPayload<ExtArgs>[]
      loans: Prisma.$LoanPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      employeeNumber: string
      registrationNumber: string | null
      firstName: string
      lastName: string
      email: string | null
      phone: string | null
      address: string | null
      dateOfBirth: Date
      placeOfBirth: string | null
      nationality: string | null
      socialSecurityNumber: string | null
      cnpsNumber: string | null
      cnamNumber: string | null
      bankAccount: string | null
      emergencyContact: string | null
      serviceId: number | null
      position: string
      department: string | null
      category: string | null
      level: string | null
      manager: string | null
      hireDate: Date
      isActive: boolean
      userId: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["employee"]>
    composites: {}
  }

  type EmployeeGetPayload<S extends boolean | null | undefined | EmployeeDefaultArgs> = $Result.GetResult<Prisma.$EmployeePayload, S>

  type EmployeeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmployeeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmployeeCountAggregateInputType | true
    }

  export interface EmployeeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Employee'], meta: { name: 'Employee' } }
    /**
     * Find zero or one Employee that matches the filter.
     * @param {EmployeeFindUniqueArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeeFindUniqueArgs>(args: SelectSubset<T, EmployeeFindUniqueArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Employee that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EmployeeFindUniqueOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeeFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Employee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindFirstArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeeFindFirstArgs>(args?: SelectSubset<T, EmployeeFindFirstArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Employee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindFirstOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeeFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeeFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Employees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Employees
     * const employees = await prisma.employee.findMany()
     * 
     * // Get first 10 Employees
     * const employees = await prisma.employee.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employeeWithIdOnly = await prisma.employee.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmployeeFindManyArgs>(args?: SelectSubset<T, EmployeeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Employee.
     * @param {EmployeeCreateArgs} args - Arguments to create a Employee.
     * @example
     * // Create one Employee
     * const Employee = await prisma.employee.create({
     *   data: {
     *     // ... data to create a Employee
     *   }
     * })
     * 
     */
    create<T extends EmployeeCreateArgs>(args: SelectSubset<T, EmployeeCreateArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Employees.
     * @param {EmployeeCreateManyArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employee = await prisma.employee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeeCreateManyArgs>(args?: SelectSubset<T, EmployeeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Employees and returns the data saved in the database.
     * @param {EmployeeCreateManyAndReturnArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employee = await prisma.employee.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Employees and only return the `id`
     * const employeeWithIdOnly = await prisma.employee.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmployeeCreateManyAndReturnArgs>(args?: SelectSubset<T, EmployeeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Employee.
     * @param {EmployeeDeleteArgs} args - Arguments to delete one Employee.
     * @example
     * // Delete one Employee
     * const Employee = await prisma.employee.delete({
     *   where: {
     *     // ... filter to delete one Employee
     *   }
     * })
     * 
     */
    delete<T extends EmployeeDeleteArgs>(args: SelectSubset<T, EmployeeDeleteArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Employee.
     * @param {EmployeeUpdateArgs} args - Arguments to update one Employee.
     * @example
     * // Update one Employee
     * const employee = await prisma.employee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeeUpdateArgs>(args: SelectSubset<T, EmployeeUpdateArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Employees.
     * @param {EmployeeDeleteManyArgs} args - Arguments to filter Employees to delete.
     * @example
     * // Delete a few Employees
     * const { count } = await prisma.employee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeeDeleteManyArgs>(args?: SelectSubset<T, EmployeeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Employees
     * const employee = await prisma.employee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeeUpdateManyArgs>(args: SelectSubset<T, EmployeeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Employee.
     * @param {EmployeeUpsertArgs} args - Arguments to update or create a Employee.
     * @example
     * // Update or create a Employee
     * const employee = await prisma.employee.upsert({
     *   create: {
     *     // ... data to create a Employee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Employee we want to update
     *   }
     * })
     */
    upsert<T extends EmployeeUpsertArgs>(args: SelectSubset<T, EmployeeUpsertArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeCountArgs} args - Arguments to filter Employees to count.
     * @example
     * // Count the number of Employees
     * const count = await prisma.employee.count({
     *   where: {
     *     // ... the filter for the Employees we want to count
     *   }
     * })
    **/
    count<T extends EmployeeCountArgs>(
      args?: Subset<T, EmployeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeAggregateArgs>(args: Subset<T, EmployeeAggregateArgs>): Prisma.PrismaPromise<GetEmployeeAggregateType<T>>

    /**
     * Group by Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Employee model
   */
  readonly fields: EmployeeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Employee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    service<T extends Employee$serviceArgs<ExtArgs> = {}>(args?: Subset<T, Employee$serviceArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    user<T extends Employee$userArgs<ExtArgs> = {}>(args?: Subset<T, Employee$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    contracts<T extends Employee$contractsArgs<ExtArgs> = {}>(args?: Subset<T, Employee$contractsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findMany"> | Null>
    salaries<T extends Employee$salariesArgs<ExtArgs> = {}>(args?: Subset<T, Employee$salariesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalaryPayload<ExtArgs>, T, "findMany"> | Null>
    leaveRequests<T extends Employee$leaveRequestsArgs<ExtArgs> = {}>(args?: Subset<T, Employee$leaveRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "findMany"> | Null>
    loans<T extends Employee$loansArgs<ExtArgs> = {}>(args?: Subset<T, Employee$loansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoanPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Employee model
   */ 
  interface EmployeeFieldRefs {
    readonly id: FieldRef<"Employee", 'Int'>
    readonly employeeNumber: FieldRef<"Employee", 'String'>
    readonly registrationNumber: FieldRef<"Employee", 'String'>
    readonly firstName: FieldRef<"Employee", 'String'>
    readonly lastName: FieldRef<"Employee", 'String'>
    readonly email: FieldRef<"Employee", 'String'>
    readonly phone: FieldRef<"Employee", 'String'>
    readonly address: FieldRef<"Employee", 'String'>
    readonly dateOfBirth: FieldRef<"Employee", 'DateTime'>
    readonly placeOfBirth: FieldRef<"Employee", 'String'>
    readonly nationality: FieldRef<"Employee", 'String'>
    readonly socialSecurityNumber: FieldRef<"Employee", 'String'>
    readonly cnpsNumber: FieldRef<"Employee", 'String'>
    readonly cnamNumber: FieldRef<"Employee", 'String'>
    readonly bankAccount: FieldRef<"Employee", 'String'>
    readonly emergencyContact: FieldRef<"Employee", 'String'>
    readonly serviceId: FieldRef<"Employee", 'Int'>
    readonly position: FieldRef<"Employee", 'String'>
    readonly department: FieldRef<"Employee", 'String'>
    readonly category: FieldRef<"Employee", 'String'>
    readonly level: FieldRef<"Employee", 'String'>
    readonly manager: FieldRef<"Employee", 'String'>
    readonly hireDate: FieldRef<"Employee", 'DateTime'>
    readonly isActive: FieldRef<"Employee", 'Boolean'>
    readonly userId: FieldRef<"Employee", 'Int'>
    readonly createdAt: FieldRef<"Employee", 'DateTime'>
    readonly updatedAt: FieldRef<"Employee", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Employee findUnique
   */
  export type EmployeeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee findUniqueOrThrow
   */
  export type EmployeeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee findFirst
   */
  export type EmployeeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee findFirstOrThrow
   */
  export type EmployeeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee findMany
   */
  export type EmployeeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employees to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee create
   */
  export type EmployeeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The data needed to create a Employee.
     */
    data: XOR<EmployeeCreateInput, EmployeeUncheckedCreateInput>
  }

  /**
   * Employee createMany
   */
  export type EmployeeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Employees.
     */
    data: EmployeeCreateManyInput | EmployeeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Employee createManyAndReturn
   */
  export type EmployeeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Employees.
     */
    data: EmployeeCreateManyInput | EmployeeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Employee update
   */
  export type EmployeeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The data needed to update a Employee.
     */
    data: XOR<EmployeeUpdateInput, EmployeeUncheckedUpdateInput>
    /**
     * Choose, which Employee to update.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee updateMany
   */
  export type EmployeeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Employees.
     */
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyInput>
    /**
     * Filter which Employees to update
     */
    where?: EmployeeWhereInput
  }

  /**
   * Employee upsert
   */
  export type EmployeeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The filter to search for the Employee to update in case it exists.
     */
    where: EmployeeWhereUniqueInput
    /**
     * In case the Employee found by the `where` argument doesn't exist, create a new Employee with this data.
     */
    create: XOR<EmployeeCreateInput, EmployeeUncheckedCreateInput>
    /**
     * In case the Employee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeeUpdateInput, EmployeeUncheckedUpdateInput>
  }

  /**
   * Employee delete
   */
  export type EmployeeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter which Employee to delete.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee deleteMany
   */
  export type EmployeeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employees to delete
     */
    where?: EmployeeWhereInput
  }

  /**
   * Employee.service
   */
  export type Employee$serviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    where?: ServiceWhereInput
  }

  /**
   * Employee.user
   */
  export type Employee$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Employee.contracts
   */
  export type Employee$contractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    where?: ContractWhereInput
    orderBy?: ContractOrderByWithRelationInput | ContractOrderByWithRelationInput[]
    cursor?: ContractWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContractScalarFieldEnum | ContractScalarFieldEnum[]
  }

  /**
   * Employee.salaries
   */
  export type Employee$salariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salary
     */
    select?: SalarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryInclude<ExtArgs> | null
    where?: SalaryWhereInput
    orderBy?: SalaryOrderByWithRelationInput | SalaryOrderByWithRelationInput[]
    cursor?: SalaryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalaryScalarFieldEnum | SalaryScalarFieldEnum[]
  }

  /**
   * Employee.leaveRequests
   */
  export type Employee$leaveRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    where?: LeaveRequestWhereInput
    orderBy?: LeaveRequestOrderByWithRelationInput | LeaveRequestOrderByWithRelationInput[]
    cursor?: LeaveRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeaveRequestScalarFieldEnum | LeaveRequestScalarFieldEnum[]
  }

  /**
   * Employee.loans
   */
  export type Employee$loansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loan
     */
    select?: LoanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanInclude<ExtArgs> | null
    where?: LoanWhereInput
    orderBy?: LoanOrderByWithRelationInput | LoanOrderByWithRelationInput[]
    cursor?: LoanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LoanScalarFieldEnum | LoanScalarFieldEnum[]
  }

  /**
   * Employee without action
   */
  export type EmployeeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
  }


  /**
   * Model Contract
   */

  export type AggregateContract = {
    _count: ContractCountAggregateOutputType | null
    _avg: ContractAvgAggregateOutputType | null
    _sum: ContractSumAggregateOutputType | null
    _min: ContractMinAggregateOutputType | null
    _max: ContractMaxAggregateOutputType | null
  }

  export type ContractAvgAggregateOutputType = {
    id: number | null
    employeeId: number | null
    baseSalary: number | null
    workingHours: number | null
  }

  export type ContractSumAggregateOutputType = {
    id: number | null
    employeeId: number | null
    baseSalary: number | null
    workingHours: number | null
  }

  export type ContractMinAggregateOutputType = {
    id: number | null
    employeeId: number | null
    contractType: $Enums.ContractType | null
    startDate: Date | null
    endDate: Date | null
    baseSalary: number | null
    workingHours: number | null
    benefits: string | null
    terms: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContractMaxAggregateOutputType = {
    id: number | null
    employeeId: number | null
    contractType: $Enums.ContractType | null
    startDate: Date | null
    endDate: Date | null
    baseSalary: number | null
    workingHours: number | null
    benefits: string | null
    terms: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContractCountAggregateOutputType = {
    id: number
    employeeId: number
    contractType: number
    startDate: number
    endDate: number
    baseSalary: number
    workingHours: number
    benefits: number
    terms: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContractAvgAggregateInputType = {
    id?: true
    employeeId?: true
    baseSalary?: true
    workingHours?: true
  }

  export type ContractSumAggregateInputType = {
    id?: true
    employeeId?: true
    baseSalary?: true
    workingHours?: true
  }

  export type ContractMinAggregateInputType = {
    id?: true
    employeeId?: true
    contractType?: true
    startDate?: true
    endDate?: true
    baseSalary?: true
    workingHours?: true
    benefits?: true
    terms?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContractMaxAggregateInputType = {
    id?: true
    employeeId?: true
    contractType?: true
    startDate?: true
    endDate?: true
    baseSalary?: true
    workingHours?: true
    benefits?: true
    terms?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContractCountAggregateInputType = {
    id?: true
    employeeId?: true
    contractType?: true
    startDate?: true
    endDate?: true
    baseSalary?: true
    workingHours?: true
    benefits?: true
    terms?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContractAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contract to aggregate.
     */
    where?: ContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contracts to fetch.
     */
    orderBy?: ContractOrderByWithRelationInput | ContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contracts
    **/
    _count?: true | ContractCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContractAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContractSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContractMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContractMaxAggregateInputType
  }

  export type GetContractAggregateType<T extends ContractAggregateArgs> = {
        [P in keyof T & keyof AggregateContract]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContract[P]>
      : GetScalarType<T[P], AggregateContract[P]>
  }




  export type ContractGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContractWhereInput
    orderBy?: ContractOrderByWithAggregationInput | ContractOrderByWithAggregationInput[]
    by: ContractScalarFieldEnum[] | ContractScalarFieldEnum
    having?: ContractScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContractCountAggregateInputType | true
    _avg?: ContractAvgAggregateInputType
    _sum?: ContractSumAggregateInputType
    _min?: ContractMinAggregateInputType
    _max?: ContractMaxAggregateInputType
  }

  export type ContractGroupByOutputType = {
    id: number
    employeeId: number
    contractType: $Enums.ContractType
    startDate: Date
    endDate: Date | null
    baseSalary: number
    workingHours: number
    benefits: string | null
    terms: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: ContractCountAggregateOutputType | null
    _avg: ContractAvgAggregateOutputType | null
    _sum: ContractSumAggregateOutputType | null
    _min: ContractMinAggregateOutputType | null
    _max: ContractMaxAggregateOutputType | null
  }

  type GetContractGroupByPayload<T extends ContractGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContractGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContractGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContractGroupByOutputType[P]>
            : GetScalarType<T[P], ContractGroupByOutputType[P]>
        }
      >
    >


  export type ContractSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    contractType?: boolean
    startDate?: boolean
    endDate?: boolean
    baseSalary?: boolean
    workingHours?: boolean
    benefits?: boolean
    terms?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contract"]>

  export type ContractSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    contractType?: boolean
    startDate?: boolean
    endDate?: boolean
    baseSalary?: boolean
    workingHours?: boolean
    benefits?: boolean
    terms?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contract"]>

  export type ContractSelectScalar = {
    id?: boolean
    employeeId?: boolean
    contractType?: boolean
    startDate?: boolean
    endDate?: boolean
    baseSalary?: boolean
    workingHours?: boolean
    benefits?: boolean
    terms?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContractInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type ContractIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }

  export type $ContractPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Contract"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      employeeId: number
      contractType: $Enums.ContractType
      startDate: Date
      endDate: Date | null
      baseSalary: number
      workingHours: number
      benefits: string | null
      terms: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["contract"]>
    composites: {}
  }

  type ContractGetPayload<S extends boolean | null | undefined | ContractDefaultArgs> = $Result.GetResult<Prisma.$ContractPayload, S>

  type ContractCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ContractFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ContractCountAggregateInputType | true
    }

  export interface ContractDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Contract'], meta: { name: 'Contract' } }
    /**
     * Find zero or one Contract that matches the filter.
     * @param {ContractFindUniqueArgs} args - Arguments to find a Contract
     * @example
     * // Get one Contract
     * const contract = await prisma.contract.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContractFindUniqueArgs>(args: SelectSubset<T, ContractFindUniqueArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Contract that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ContractFindUniqueOrThrowArgs} args - Arguments to find a Contract
     * @example
     * // Get one Contract
     * const contract = await prisma.contract.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContractFindUniqueOrThrowArgs>(args: SelectSubset<T, ContractFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Contract that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractFindFirstArgs} args - Arguments to find a Contract
     * @example
     * // Get one Contract
     * const contract = await prisma.contract.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContractFindFirstArgs>(args?: SelectSubset<T, ContractFindFirstArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Contract that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractFindFirstOrThrowArgs} args - Arguments to find a Contract
     * @example
     * // Get one Contract
     * const contract = await prisma.contract.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContractFindFirstOrThrowArgs>(args?: SelectSubset<T, ContractFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Contracts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contracts
     * const contracts = await prisma.contract.findMany()
     * 
     * // Get first 10 Contracts
     * const contracts = await prisma.contract.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contractWithIdOnly = await prisma.contract.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContractFindManyArgs>(args?: SelectSubset<T, ContractFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Contract.
     * @param {ContractCreateArgs} args - Arguments to create a Contract.
     * @example
     * // Create one Contract
     * const Contract = await prisma.contract.create({
     *   data: {
     *     // ... data to create a Contract
     *   }
     * })
     * 
     */
    create<T extends ContractCreateArgs>(args: SelectSubset<T, ContractCreateArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Contracts.
     * @param {ContractCreateManyArgs} args - Arguments to create many Contracts.
     * @example
     * // Create many Contracts
     * const contract = await prisma.contract.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContractCreateManyArgs>(args?: SelectSubset<T, ContractCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Contracts and returns the data saved in the database.
     * @param {ContractCreateManyAndReturnArgs} args - Arguments to create many Contracts.
     * @example
     * // Create many Contracts
     * const contract = await prisma.contract.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Contracts and only return the `id`
     * const contractWithIdOnly = await prisma.contract.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContractCreateManyAndReturnArgs>(args?: SelectSubset<T, ContractCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Contract.
     * @param {ContractDeleteArgs} args - Arguments to delete one Contract.
     * @example
     * // Delete one Contract
     * const Contract = await prisma.contract.delete({
     *   where: {
     *     // ... filter to delete one Contract
     *   }
     * })
     * 
     */
    delete<T extends ContractDeleteArgs>(args: SelectSubset<T, ContractDeleteArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Contract.
     * @param {ContractUpdateArgs} args - Arguments to update one Contract.
     * @example
     * // Update one Contract
     * const contract = await prisma.contract.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContractUpdateArgs>(args: SelectSubset<T, ContractUpdateArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Contracts.
     * @param {ContractDeleteManyArgs} args - Arguments to filter Contracts to delete.
     * @example
     * // Delete a few Contracts
     * const { count } = await prisma.contract.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContractDeleteManyArgs>(args?: SelectSubset<T, ContractDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contracts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contracts
     * const contract = await prisma.contract.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContractUpdateManyArgs>(args: SelectSubset<T, ContractUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Contract.
     * @param {ContractUpsertArgs} args - Arguments to update or create a Contract.
     * @example
     * // Update or create a Contract
     * const contract = await prisma.contract.upsert({
     *   create: {
     *     // ... data to create a Contract
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contract we want to update
     *   }
     * })
     */
    upsert<T extends ContractUpsertArgs>(args: SelectSubset<T, ContractUpsertArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Contracts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractCountArgs} args - Arguments to filter Contracts to count.
     * @example
     * // Count the number of Contracts
     * const count = await prisma.contract.count({
     *   where: {
     *     // ... the filter for the Contracts we want to count
     *   }
     * })
    **/
    count<T extends ContractCountArgs>(
      args?: Subset<T, ContractCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContractCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contract.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContractAggregateArgs>(args: Subset<T, ContractAggregateArgs>): Prisma.PrismaPromise<GetContractAggregateType<T>>

    /**
     * Group by Contract.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContractGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContractGroupByArgs['orderBy'] }
        : { orderBy?: ContractGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContractGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContractGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Contract model
   */
  readonly fields: ContractFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Contract.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContractClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Contract model
   */ 
  interface ContractFieldRefs {
    readonly id: FieldRef<"Contract", 'Int'>
    readonly employeeId: FieldRef<"Contract", 'Int'>
    readonly contractType: FieldRef<"Contract", 'ContractType'>
    readonly startDate: FieldRef<"Contract", 'DateTime'>
    readonly endDate: FieldRef<"Contract", 'DateTime'>
    readonly baseSalary: FieldRef<"Contract", 'Float'>
    readonly workingHours: FieldRef<"Contract", 'Float'>
    readonly benefits: FieldRef<"Contract", 'String'>
    readonly terms: FieldRef<"Contract", 'String'>
    readonly isActive: FieldRef<"Contract", 'Boolean'>
    readonly createdAt: FieldRef<"Contract", 'DateTime'>
    readonly updatedAt: FieldRef<"Contract", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Contract findUnique
   */
  export type ContractFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter, which Contract to fetch.
     */
    where: ContractWhereUniqueInput
  }

  /**
   * Contract findUniqueOrThrow
   */
  export type ContractFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter, which Contract to fetch.
     */
    where: ContractWhereUniqueInput
  }

  /**
   * Contract findFirst
   */
  export type ContractFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter, which Contract to fetch.
     */
    where?: ContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contracts to fetch.
     */
    orderBy?: ContractOrderByWithRelationInput | ContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contracts.
     */
    cursor?: ContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contracts.
     */
    distinct?: ContractScalarFieldEnum | ContractScalarFieldEnum[]
  }

  /**
   * Contract findFirstOrThrow
   */
  export type ContractFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter, which Contract to fetch.
     */
    where?: ContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contracts to fetch.
     */
    orderBy?: ContractOrderByWithRelationInput | ContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contracts.
     */
    cursor?: ContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contracts.
     */
    distinct?: ContractScalarFieldEnum | ContractScalarFieldEnum[]
  }

  /**
   * Contract findMany
   */
  export type ContractFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter, which Contracts to fetch.
     */
    where?: ContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contracts to fetch.
     */
    orderBy?: ContractOrderByWithRelationInput | ContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contracts.
     */
    cursor?: ContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contracts.
     */
    skip?: number
    distinct?: ContractScalarFieldEnum | ContractScalarFieldEnum[]
  }

  /**
   * Contract create
   */
  export type ContractCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * The data needed to create a Contract.
     */
    data: XOR<ContractCreateInput, ContractUncheckedCreateInput>
  }

  /**
   * Contract createMany
   */
  export type ContractCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contracts.
     */
    data: ContractCreateManyInput | ContractCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contract createManyAndReturn
   */
  export type ContractCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Contracts.
     */
    data: ContractCreateManyInput | ContractCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Contract update
   */
  export type ContractUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * The data needed to update a Contract.
     */
    data: XOR<ContractUpdateInput, ContractUncheckedUpdateInput>
    /**
     * Choose, which Contract to update.
     */
    where: ContractWhereUniqueInput
  }

  /**
   * Contract updateMany
   */
  export type ContractUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contracts.
     */
    data: XOR<ContractUpdateManyMutationInput, ContractUncheckedUpdateManyInput>
    /**
     * Filter which Contracts to update
     */
    where?: ContractWhereInput
  }

  /**
   * Contract upsert
   */
  export type ContractUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * The filter to search for the Contract to update in case it exists.
     */
    where: ContractWhereUniqueInput
    /**
     * In case the Contract found by the `where` argument doesn't exist, create a new Contract with this data.
     */
    create: XOR<ContractCreateInput, ContractUncheckedCreateInput>
    /**
     * In case the Contract was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContractUpdateInput, ContractUncheckedUpdateInput>
  }

  /**
   * Contract delete
   */
  export type ContractDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter which Contract to delete.
     */
    where: ContractWhereUniqueInput
  }

  /**
   * Contract deleteMany
   */
  export type ContractDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contracts to delete
     */
    where?: ContractWhereInput
  }

  /**
   * Contract without action
   */
  export type ContractDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
  }


  /**
   * Model Salary
   */

  export type AggregateSalary = {
    _count: SalaryCountAggregateOutputType | null
    _avg: SalaryAvgAggregateOutputType | null
    _sum: SalarySumAggregateOutputType | null
    _min: SalaryMinAggregateOutputType | null
    _max: SalaryMaxAggregateOutputType | null
  }

  export type SalaryAvgAggregateOutputType = {
    id: number | null
    employeeId: number | null
    workingDays: number | null
    baseSalary: number | null
    overtime: number | null
    bonuses: number | null
    allowances: number | null
    paidLeave: number | null
    grossSalary: number | null
    socialContributions: number | null
    cnpsEmployee: number | null
    cnamEmployee: number | null
    fdfpEmployee: number | null
    taxes: number | null
    nonTaxableAmount: number | null
    otherDeductions: number | null
    loanDeductions: number | null
    totalDeductions: number | null
    netSalary: number | null
  }

  export type SalarySumAggregateOutputType = {
    id: number | null
    employeeId: number | null
    workingDays: number | null
    baseSalary: number | null
    overtime: number | null
    bonuses: number | null
    allowances: number | null
    paidLeave: number | null
    grossSalary: number | null
    socialContributions: number | null
    cnpsEmployee: number | null
    cnamEmployee: number | null
    fdfpEmployee: number | null
    taxes: number | null
    nonTaxableAmount: number | null
    otherDeductions: number | null
    loanDeductions: number | null
    totalDeductions: number | null
    netSalary: number | null
  }

  export type SalaryMinAggregateOutputType = {
    id: number | null
    employeeId: number | null
    paymentDate: Date | null
    workingDays: number | null
    baseSalary: number | null
    overtime: number | null
    bonuses: number | null
    allowances: number | null
    paidLeave: number | null
    grossSalary: number | null
    socialContributions: number | null
    cnpsEmployee: number | null
    cnamEmployee: number | null
    fdfpEmployee: number | null
    taxes: number | null
    nonTaxableAmount: number | null
    otherDeductions: number | null
    loanDeductions: number | null
    totalDeductions: number | null
    netSalary: number | null
    status: $Enums.SalaryStatus | null
    paymentMethod: $Enums.PaymentMethod | null
    reference: string | null
    notes: string | null
    createdAt: Date | null
  }

  export type SalaryMaxAggregateOutputType = {
    id: number | null
    employeeId: number | null
    paymentDate: Date | null
    workingDays: number | null
    baseSalary: number | null
    overtime: number | null
    bonuses: number | null
    allowances: number | null
    paidLeave: number | null
    grossSalary: number | null
    socialContributions: number | null
    cnpsEmployee: number | null
    cnamEmployee: number | null
    fdfpEmployee: number | null
    taxes: number | null
    nonTaxableAmount: number | null
    otherDeductions: number | null
    loanDeductions: number | null
    totalDeductions: number | null
    netSalary: number | null
    status: $Enums.SalaryStatus | null
    paymentMethod: $Enums.PaymentMethod | null
    reference: string | null
    notes: string | null
    createdAt: Date | null
  }

  export type SalaryCountAggregateOutputType = {
    id: number
    employeeId: number
    paymentDate: number
    workingDays: number
    baseSalary: number
    overtime: number
    bonuses: number
    allowances: number
    paidLeave: number
    grossSalary: number
    socialContributions: number
    cnpsEmployee: number
    cnamEmployee: number
    fdfpEmployee: number
    taxes: number
    nonTaxableAmount: number
    otherDeductions: number
    loanDeductions: number
    totalDeductions: number
    netSalary: number
    status: number
    paymentMethod: number
    reference: number
    notes: number
    createdAt: number
    _all: number
  }


  export type SalaryAvgAggregateInputType = {
    id?: true
    employeeId?: true
    workingDays?: true
    baseSalary?: true
    overtime?: true
    bonuses?: true
    allowances?: true
    paidLeave?: true
    grossSalary?: true
    socialContributions?: true
    cnpsEmployee?: true
    cnamEmployee?: true
    fdfpEmployee?: true
    taxes?: true
    nonTaxableAmount?: true
    otherDeductions?: true
    loanDeductions?: true
    totalDeductions?: true
    netSalary?: true
  }

  export type SalarySumAggregateInputType = {
    id?: true
    employeeId?: true
    workingDays?: true
    baseSalary?: true
    overtime?: true
    bonuses?: true
    allowances?: true
    paidLeave?: true
    grossSalary?: true
    socialContributions?: true
    cnpsEmployee?: true
    cnamEmployee?: true
    fdfpEmployee?: true
    taxes?: true
    nonTaxableAmount?: true
    otherDeductions?: true
    loanDeductions?: true
    totalDeductions?: true
    netSalary?: true
  }

  export type SalaryMinAggregateInputType = {
    id?: true
    employeeId?: true
    paymentDate?: true
    workingDays?: true
    baseSalary?: true
    overtime?: true
    bonuses?: true
    allowances?: true
    paidLeave?: true
    grossSalary?: true
    socialContributions?: true
    cnpsEmployee?: true
    cnamEmployee?: true
    fdfpEmployee?: true
    taxes?: true
    nonTaxableAmount?: true
    otherDeductions?: true
    loanDeductions?: true
    totalDeductions?: true
    netSalary?: true
    status?: true
    paymentMethod?: true
    reference?: true
    notes?: true
    createdAt?: true
  }

  export type SalaryMaxAggregateInputType = {
    id?: true
    employeeId?: true
    paymentDate?: true
    workingDays?: true
    baseSalary?: true
    overtime?: true
    bonuses?: true
    allowances?: true
    paidLeave?: true
    grossSalary?: true
    socialContributions?: true
    cnpsEmployee?: true
    cnamEmployee?: true
    fdfpEmployee?: true
    taxes?: true
    nonTaxableAmount?: true
    otherDeductions?: true
    loanDeductions?: true
    totalDeductions?: true
    netSalary?: true
    status?: true
    paymentMethod?: true
    reference?: true
    notes?: true
    createdAt?: true
  }

  export type SalaryCountAggregateInputType = {
    id?: true
    employeeId?: true
    paymentDate?: true
    workingDays?: true
    baseSalary?: true
    overtime?: true
    bonuses?: true
    allowances?: true
    paidLeave?: true
    grossSalary?: true
    socialContributions?: true
    cnpsEmployee?: true
    cnamEmployee?: true
    fdfpEmployee?: true
    taxes?: true
    nonTaxableAmount?: true
    otherDeductions?: true
    loanDeductions?: true
    totalDeductions?: true
    netSalary?: true
    status?: true
    paymentMethod?: true
    reference?: true
    notes?: true
    createdAt?: true
    _all?: true
  }

  export type SalaryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Salary to aggregate.
     */
    where?: SalaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Salaries to fetch.
     */
    orderBy?: SalaryOrderByWithRelationInput | SalaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SalaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Salaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Salaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Salaries
    **/
    _count?: true | SalaryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SalaryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SalarySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SalaryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SalaryMaxAggregateInputType
  }

  export type GetSalaryAggregateType<T extends SalaryAggregateArgs> = {
        [P in keyof T & keyof AggregateSalary]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSalary[P]>
      : GetScalarType<T[P], AggregateSalary[P]>
  }




  export type SalaryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalaryWhereInput
    orderBy?: SalaryOrderByWithAggregationInput | SalaryOrderByWithAggregationInput[]
    by: SalaryScalarFieldEnum[] | SalaryScalarFieldEnum
    having?: SalaryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SalaryCountAggregateInputType | true
    _avg?: SalaryAvgAggregateInputType
    _sum?: SalarySumAggregateInputType
    _min?: SalaryMinAggregateInputType
    _max?: SalaryMaxAggregateInputType
  }

  export type SalaryGroupByOutputType = {
    id: number
    employeeId: number
    paymentDate: Date
    workingDays: number
    baseSalary: number
    overtime: number
    bonuses: number
    allowances: number
    paidLeave: number
    grossSalary: number
    socialContributions: number
    cnpsEmployee: number
    cnamEmployee: number
    fdfpEmployee: number
    taxes: number
    nonTaxableAmount: number
    otherDeductions: number
    loanDeductions: number
    totalDeductions: number
    netSalary: number
    status: $Enums.SalaryStatus
    paymentMethod: $Enums.PaymentMethod | null
    reference: string | null
    notes: string | null
    createdAt: Date
    _count: SalaryCountAggregateOutputType | null
    _avg: SalaryAvgAggregateOutputType | null
    _sum: SalarySumAggregateOutputType | null
    _min: SalaryMinAggregateOutputType | null
    _max: SalaryMaxAggregateOutputType | null
  }

  type GetSalaryGroupByPayload<T extends SalaryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SalaryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SalaryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SalaryGroupByOutputType[P]>
            : GetScalarType<T[P], SalaryGroupByOutputType[P]>
        }
      >
    >


  export type SalarySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    paymentDate?: boolean
    workingDays?: boolean
    baseSalary?: boolean
    overtime?: boolean
    bonuses?: boolean
    allowances?: boolean
    paidLeave?: boolean
    grossSalary?: boolean
    socialContributions?: boolean
    cnpsEmployee?: boolean
    cnamEmployee?: boolean
    fdfpEmployee?: boolean
    taxes?: boolean
    nonTaxableAmount?: boolean
    otherDeductions?: boolean
    loanDeductions?: boolean
    totalDeductions?: boolean
    netSalary?: boolean
    status?: boolean
    paymentMethod?: boolean
    reference?: boolean
    notes?: boolean
    createdAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    loanPayments?: boolean | Salary$loanPaymentsArgs<ExtArgs>
    _count?: boolean | SalaryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salary"]>

  export type SalarySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    paymentDate?: boolean
    workingDays?: boolean
    baseSalary?: boolean
    overtime?: boolean
    bonuses?: boolean
    allowances?: boolean
    paidLeave?: boolean
    grossSalary?: boolean
    socialContributions?: boolean
    cnpsEmployee?: boolean
    cnamEmployee?: boolean
    fdfpEmployee?: boolean
    taxes?: boolean
    nonTaxableAmount?: boolean
    otherDeductions?: boolean
    loanDeductions?: boolean
    totalDeductions?: boolean
    netSalary?: boolean
    status?: boolean
    paymentMethod?: boolean
    reference?: boolean
    notes?: boolean
    createdAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salary"]>

  export type SalarySelectScalar = {
    id?: boolean
    employeeId?: boolean
    paymentDate?: boolean
    workingDays?: boolean
    baseSalary?: boolean
    overtime?: boolean
    bonuses?: boolean
    allowances?: boolean
    paidLeave?: boolean
    grossSalary?: boolean
    socialContributions?: boolean
    cnpsEmployee?: boolean
    cnamEmployee?: boolean
    fdfpEmployee?: boolean
    taxes?: boolean
    nonTaxableAmount?: boolean
    otherDeductions?: boolean
    loanDeductions?: boolean
    totalDeductions?: boolean
    netSalary?: boolean
    status?: boolean
    paymentMethod?: boolean
    reference?: boolean
    notes?: boolean
    createdAt?: boolean
  }

  export type SalaryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    loanPayments?: boolean | Salary$loanPaymentsArgs<ExtArgs>
    _count?: boolean | SalaryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SalaryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }

  export type $SalaryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Salary"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
      loanPayments: Prisma.$LoanPaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      employeeId: number
      paymentDate: Date
      workingDays: number
      baseSalary: number
      overtime: number
      bonuses: number
      allowances: number
      paidLeave: number
      grossSalary: number
      socialContributions: number
      cnpsEmployee: number
      cnamEmployee: number
      fdfpEmployee: number
      taxes: number
      nonTaxableAmount: number
      otherDeductions: number
      loanDeductions: number
      totalDeductions: number
      netSalary: number
      status: $Enums.SalaryStatus
      paymentMethod: $Enums.PaymentMethod | null
      reference: string | null
      notes: string | null
      createdAt: Date
    }, ExtArgs["result"]["salary"]>
    composites: {}
  }

  type SalaryGetPayload<S extends boolean | null | undefined | SalaryDefaultArgs> = $Result.GetResult<Prisma.$SalaryPayload, S>

  type SalaryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SalaryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SalaryCountAggregateInputType | true
    }

  export interface SalaryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Salary'], meta: { name: 'Salary' } }
    /**
     * Find zero or one Salary that matches the filter.
     * @param {SalaryFindUniqueArgs} args - Arguments to find a Salary
     * @example
     * // Get one Salary
     * const salary = await prisma.salary.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SalaryFindUniqueArgs>(args: SelectSubset<T, SalaryFindUniqueArgs<ExtArgs>>): Prisma__SalaryClient<$Result.GetResult<Prisma.$SalaryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Salary that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SalaryFindUniqueOrThrowArgs} args - Arguments to find a Salary
     * @example
     * // Get one Salary
     * const salary = await prisma.salary.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SalaryFindUniqueOrThrowArgs>(args: SelectSubset<T, SalaryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SalaryClient<$Result.GetResult<Prisma.$SalaryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Salary that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryFindFirstArgs} args - Arguments to find a Salary
     * @example
     * // Get one Salary
     * const salary = await prisma.salary.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SalaryFindFirstArgs>(args?: SelectSubset<T, SalaryFindFirstArgs<ExtArgs>>): Prisma__SalaryClient<$Result.GetResult<Prisma.$SalaryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Salary that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryFindFirstOrThrowArgs} args - Arguments to find a Salary
     * @example
     * // Get one Salary
     * const salary = await prisma.salary.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SalaryFindFirstOrThrowArgs>(args?: SelectSubset<T, SalaryFindFirstOrThrowArgs<ExtArgs>>): Prisma__SalaryClient<$Result.GetResult<Prisma.$SalaryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Salaries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Salaries
     * const salaries = await prisma.salary.findMany()
     * 
     * // Get first 10 Salaries
     * const salaries = await prisma.salary.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const salaryWithIdOnly = await prisma.salary.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SalaryFindManyArgs>(args?: SelectSubset<T, SalaryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalaryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Salary.
     * @param {SalaryCreateArgs} args - Arguments to create a Salary.
     * @example
     * // Create one Salary
     * const Salary = await prisma.salary.create({
     *   data: {
     *     // ... data to create a Salary
     *   }
     * })
     * 
     */
    create<T extends SalaryCreateArgs>(args: SelectSubset<T, SalaryCreateArgs<ExtArgs>>): Prisma__SalaryClient<$Result.GetResult<Prisma.$SalaryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Salaries.
     * @param {SalaryCreateManyArgs} args - Arguments to create many Salaries.
     * @example
     * // Create many Salaries
     * const salary = await prisma.salary.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SalaryCreateManyArgs>(args?: SelectSubset<T, SalaryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Salaries and returns the data saved in the database.
     * @param {SalaryCreateManyAndReturnArgs} args - Arguments to create many Salaries.
     * @example
     * // Create many Salaries
     * const salary = await prisma.salary.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Salaries and only return the `id`
     * const salaryWithIdOnly = await prisma.salary.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SalaryCreateManyAndReturnArgs>(args?: SelectSubset<T, SalaryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalaryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Salary.
     * @param {SalaryDeleteArgs} args - Arguments to delete one Salary.
     * @example
     * // Delete one Salary
     * const Salary = await prisma.salary.delete({
     *   where: {
     *     // ... filter to delete one Salary
     *   }
     * })
     * 
     */
    delete<T extends SalaryDeleteArgs>(args: SelectSubset<T, SalaryDeleteArgs<ExtArgs>>): Prisma__SalaryClient<$Result.GetResult<Prisma.$SalaryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Salary.
     * @param {SalaryUpdateArgs} args - Arguments to update one Salary.
     * @example
     * // Update one Salary
     * const salary = await prisma.salary.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SalaryUpdateArgs>(args: SelectSubset<T, SalaryUpdateArgs<ExtArgs>>): Prisma__SalaryClient<$Result.GetResult<Prisma.$SalaryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Salaries.
     * @param {SalaryDeleteManyArgs} args - Arguments to filter Salaries to delete.
     * @example
     * // Delete a few Salaries
     * const { count } = await prisma.salary.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SalaryDeleteManyArgs>(args?: SelectSubset<T, SalaryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Salaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Salaries
     * const salary = await prisma.salary.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SalaryUpdateManyArgs>(args: SelectSubset<T, SalaryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Salary.
     * @param {SalaryUpsertArgs} args - Arguments to update or create a Salary.
     * @example
     * // Update or create a Salary
     * const salary = await prisma.salary.upsert({
     *   create: {
     *     // ... data to create a Salary
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Salary we want to update
     *   }
     * })
     */
    upsert<T extends SalaryUpsertArgs>(args: SelectSubset<T, SalaryUpsertArgs<ExtArgs>>): Prisma__SalaryClient<$Result.GetResult<Prisma.$SalaryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Salaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryCountArgs} args - Arguments to filter Salaries to count.
     * @example
     * // Count the number of Salaries
     * const count = await prisma.salary.count({
     *   where: {
     *     // ... the filter for the Salaries we want to count
     *   }
     * })
    **/
    count<T extends SalaryCountArgs>(
      args?: Subset<T, SalaryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SalaryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Salary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SalaryAggregateArgs>(args: Subset<T, SalaryAggregateArgs>): Prisma.PrismaPromise<GetSalaryAggregateType<T>>

    /**
     * Group by Salary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SalaryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SalaryGroupByArgs['orderBy'] }
        : { orderBy?: SalaryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SalaryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSalaryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Salary model
   */
  readonly fields: SalaryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Salary.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SalaryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    loanPayments<T extends Salary$loanPaymentsArgs<ExtArgs> = {}>(args?: Subset<T, Salary$loanPaymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoanPaymentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Salary model
   */ 
  interface SalaryFieldRefs {
    readonly id: FieldRef<"Salary", 'Int'>
    readonly employeeId: FieldRef<"Salary", 'Int'>
    readonly paymentDate: FieldRef<"Salary", 'DateTime'>
    readonly workingDays: FieldRef<"Salary", 'Int'>
    readonly baseSalary: FieldRef<"Salary", 'Float'>
    readonly overtime: FieldRef<"Salary", 'Float'>
    readonly bonuses: FieldRef<"Salary", 'Float'>
    readonly allowances: FieldRef<"Salary", 'Float'>
    readonly paidLeave: FieldRef<"Salary", 'Float'>
    readonly grossSalary: FieldRef<"Salary", 'Float'>
    readonly socialContributions: FieldRef<"Salary", 'Float'>
    readonly cnpsEmployee: FieldRef<"Salary", 'Float'>
    readonly cnamEmployee: FieldRef<"Salary", 'Float'>
    readonly fdfpEmployee: FieldRef<"Salary", 'Float'>
    readonly taxes: FieldRef<"Salary", 'Float'>
    readonly nonTaxableAmount: FieldRef<"Salary", 'Float'>
    readonly otherDeductions: FieldRef<"Salary", 'Float'>
    readonly loanDeductions: FieldRef<"Salary", 'Float'>
    readonly totalDeductions: FieldRef<"Salary", 'Float'>
    readonly netSalary: FieldRef<"Salary", 'Float'>
    readonly status: FieldRef<"Salary", 'SalaryStatus'>
    readonly paymentMethod: FieldRef<"Salary", 'PaymentMethod'>
    readonly reference: FieldRef<"Salary", 'String'>
    readonly notes: FieldRef<"Salary", 'String'>
    readonly createdAt: FieldRef<"Salary", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Salary findUnique
   */
  export type SalaryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salary
     */
    select?: SalarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryInclude<ExtArgs> | null
    /**
     * Filter, which Salary to fetch.
     */
    where: SalaryWhereUniqueInput
  }

  /**
   * Salary findUniqueOrThrow
   */
  export type SalaryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salary
     */
    select?: SalarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryInclude<ExtArgs> | null
    /**
     * Filter, which Salary to fetch.
     */
    where: SalaryWhereUniqueInput
  }

  /**
   * Salary findFirst
   */
  export type SalaryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salary
     */
    select?: SalarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryInclude<ExtArgs> | null
    /**
     * Filter, which Salary to fetch.
     */
    where?: SalaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Salaries to fetch.
     */
    orderBy?: SalaryOrderByWithRelationInput | SalaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Salaries.
     */
    cursor?: SalaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Salaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Salaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Salaries.
     */
    distinct?: SalaryScalarFieldEnum | SalaryScalarFieldEnum[]
  }

  /**
   * Salary findFirstOrThrow
   */
  export type SalaryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salary
     */
    select?: SalarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryInclude<ExtArgs> | null
    /**
     * Filter, which Salary to fetch.
     */
    where?: SalaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Salaries to fetch.
     */
    orderBy?: SalaryOrderByWithRelationInput | SalaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Salaries.
     */
    cursor?: SalaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Salaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Salaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Salaries.
     */
    distinct?: SalaryScalarFieldEnum | SalaryScalarFieldEnum[]
  }

  /**
   * Salary findMany
   */
  export type SalaryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salary
     */
    select?: SalarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryInclude<ExtArgs> | null
    /**
     * Filter, which Salaries to fetch.
     */
    where?: SalaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Salaries to fetch.
     */
    orderBy?: SalaryOrderByWithRelationInput | SalaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Salaries.
     */
    cursor?: SalaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Salaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Salaries.
     */
    skip?: number
    distinct?: SalaryScalarFieldEnum | SalaryScalarFieldEnum[]
  }

  /**
   * Salary create
   */
  export type SalaryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salary
     */
    select?: SalarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryInclude<ExtArgs> | null
    /**
     * The data needed to create a Salary.
     */
    data: XOR<SalaryCreateInput, SalaryUncheckedCreateInput>
  }

  /**
   * Salary createMany
   */
  export type SalaryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Salaries.
     */
    data: SalaryCreateManyInput | SalaryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Salary createManyAndReturn
   */
  export type SalaryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salary
     */
    select?: SalarySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Salaries.
     */
    data: SalaryCreateManyInput | SalaryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Salary update
   */
  export type SalaryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salary
     */
    select?: SalarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryInclude<ExtArgs> | null
    /**
     * The data needed to update a Salary.
     */
    data: XOR<SalaryUpdateInput, SalaryUncheckedUpdateInput>
    /**
     * Choose, which Salary to update.
     */
    where: SalaryWhereUniqueInput
  }

  /**
   * Salary updateMany
   */
  export type SalaryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Salaries.
     */
    data: XOR<SalaryUpdateManyMutationInput, SalaryUncheckedUpdateManyInput>
    /**
     * Filter which Salaries to update
     */
    where?: SalaryWhereInput
  }

  /**
   * Salary upsert
   */
  export type SalaryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salary
     */
    select?: SalarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryInclude<ExtArgs> | null
    /**
     * The filter to search for the Salary to update in case it exists.
     */
    where: SalaryWhereUniqueInput
    /**
     * In case the Salary found by the `where` argument doesn't exist, create a new Salary with this data.
     */
    create: XOR<SalaryCreateInput, SalaryUncheckedCreateInput>
    /**
     * In case the Salary was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SalaryUpdateInput, SalaryUncheckedUpdateInput>
  }

  /**
   * Salary delete
   */
  export type SalaryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salary
     */
    select?: SalarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryInclude<ExtArgs> | null
    /**
     * Filter which Salary to delete.
     */
    where: SalaryWhereUniqueInput
  }

  /**
   * Salary deleteMany
   */
  export type SalaryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Salaries to delete
     */
    where?: SalaryWhereInput
  }

  /**
   * Salary.loanPayments
   */
  export type Salary$loanPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanPayment
     */
    select?: LoanPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanPaymentInclude<ExtArgs> | null
    where?: LoanPaymentWhereInput
    orderBy?: LoanPaymentOrderByWithRelationInput | LoanPaymentOrderByWithRelationInput[]
    cursor?: LoanPaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LoanPaymentScalarFieldEnum | LoanPaymentScalarFieldEnum[]
  }

  /**
   * Salary without action
   */
  export type SalaryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salary
     */
    select?: SalarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryInclude<ExtArgs> | null
  }


  /**
   * Model LoanPayment
   */

  export type AggregateLoanPayment = {
    _count: LoanPaymentCountAggregateOutputType | null
    _avg: LoanPaymentAvgAggregateOutputType | null
    _sum: LoanPaymentSumAggregateOutputType | null
    _min: LoanPaymentMinAggregateOutputType | null
    _max: LoanPaymentMaxAggregateOutputType | null
  }

  export type LoanPaymentAvgAggregateOutputType = {
    id: number | null
    loanId: number | null
    salaryId: number | null
    amount: number | null
    principal: number | null
    interest: number | null
  }

  export type LoanPaymentSumAggregateOutputType = {
    id: number | null
    loanId: number | null
    salaryId: number | null
    amount: number | null
    principal: number | null
    interest: number | null
  }

  export type LoanPaymentMinAggregateOutputType = {
    id: number | null
    loanId: number | null
    salaryId: number | null
    amount: number | null
    paymentDate: Date | null
    principal: number | null
    interest: number | null
    notes: string | null
    createdAt: Date | null
  }

  export type LoanPaymentMaxAggregateOutputType = {
    id: number | null
    loanId: number | null
    salaryId: number | null
    amount: number | null
    paymentDate: Date | null
    principal: number | null
    interest: number | null
    notes: string | null
    createdAt: Date | null
  }

  export type LoanPaymentCountAggregateOutputType = {
    id: number
    loanId: number
    salaryId: number
    amount: number
    paymentDate: number
    principal: number
    interest: number
    notes: number
    createdAt: number
    _all: number
  }


  export type LoanPaymentAvgAggregateInputType = {
    id?: true
    loanId?: true
    salaryId?: true
    amount?: true
    principal?: true
    interest?: true
  }

  export type LoanPaymentSumAggregateInputType = {
    id?: true
    loanId?: true
    salaryId?: true
    amount?: true
    principal?: true
    interest?: true
  }

  export type LoanPaymentMinAggregateInputType = {
    id?: true
    loanId?: true
    salaryId?: true
    amount?: true
    paymentDate?: true
    principal?: true
    interest?: true
    notes?: true
    createdAt?: true
  }

  export type LoanPaymentMaxAggregateInputType = {
    id?: true
    loanId?: true
    salaryId?: true
    amount?: true
    paymentDate?: true
    principal?: true
    interest?: true
    notes?: true
    createdAt?: true
  }

  export type LoanPaymentCountAggregateInputType = {
    id?: true
    loanId?: true
    salaryId?: true
    amount?: true
    paymentDate?: true
    principal?: true
    interest?: true
    notes?: true
    createdAt?: true
    _all?: true
  }

  export type LoanPaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LoanPayment to aggregate.
     */
    where?: LoanPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoanPayments to fetch.
     */
    orderBy?: LoanPaymentOrderByWithRelationInput | LoanPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LoanPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoanPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoanPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LoanPayments
    **/
    _count?: true | LoanPaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LoanPaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LoanPaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LoanPaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LoanPaymentMaxAggregateInputType
  }

  export type GetLoanPaymentAggregateType<T extends LoanPaymentAggregateArgs> = {
        [P in keyof T & keyof AggregateLoanPayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLoanPayment[P]>
      : GetScalarType<T[P], AggregateLoanPayment[P]>
  }




  export type LoanPaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LoanPaymentWhereInput
    orderBy?: LoanPaymentOrderByWithAggregationInput | LoanPaymentOrderByWithAggregationInput[]
    by: LoanPaymentScalarFieldEnum[] | LoanPaymentScalarFieldEnum
    having?: LoanPaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LoanPaymentCountAggregateInputType | true
    _avg?: LoanPaymentAvgAggregateInputType
    _sum?: LoanPaymentSumAggregateInputType
    _min?: LoanPaymentMinAggregateInputType
    _max?: LoanPaymentMaxAggregateInputType
  }

  export type LoanPaymentGroupByOutputType = {
    id: number
    loanId: number
    salaryId: number | null
    amount: number
    paymentDate: Date
    principal: number
    interest: number
    notes: string | null
    createdAt: Date
    _count: LoanPaymentCountAggregateOutputType | null
    _avg: LoanPaymentAvgAggregateOutputType | null
    _sum: LoanPaymentSumAggregateOutputType | null
    _min: LoanPaymentMinAggregateOutputType | null
    _max: LoanPaymentMaxAggregateOutputType | null
  }

  type GetLoanPaymentGroupByPayload<T extends LoanPaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LoanPaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LoanPaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LoanPaymentGroupByOutputType[P]>
            : GetScalarType<T[P], LoanPaymentGroupByOutputType[P]>
        }
      >
    >


  export type LoanPaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    loanId?: boolean
    salaryId?: boolean
    amount?: boolean
    paymentDate?: boolean
    principal?: boolean
    interest?: boolean
    notes?: boolean
    createdAt?: boolean
    loan?: boolean | LoanDefaultArgs<ExtArgs>
    salary?: boolean | LoanPayment$salaryArgs<ExtArgs>
  }, ExtArgs["result"]["loanPayment"]>

  export type LoanPaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    loanId?: boolean
    salaryId?: boolean
    amount?: boolean
    paymentDate?: boolean
    principal?: boolean
    interest?: boolean
    notes?: boolean
    createdAt?: boolean
    loan?: boolean | LoanDefaultArgs<ExtArgs>
    salary?: boolean | LoanPayment$salaryArgs<ExtArgs>
  }, ExtArgs["result"]["loanPayment"]>

  export type LoanPaymentSelectScalar = {
    id?: boolean
    loanId?: boolean
    salaryId?: boolean
    amount?: boolean
    paymentDate?: boolean
    principal?: boolean
    interest?: boolean
    notes?: boolean
    createdAt?: boolean
  }

  export type LoanPaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    loan?: boolean | LoanDefaultArgs<ExtArgs>
    salary?: boolean | LoanPayment$salaryArgs<ExtArgs>
  }
  export type LoanPaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    loan?: boolean | LoanDefaultArgs<ExtArgs>
    salary?: boolean | LoanPayment$salaryArgs<ExtArgs>
  }

  export type $LoanPaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LoanPayment"
    objects: {
      loan: Prisma.$LoanPayload<ExtArgs>
      salary: Prisma.$SalaryPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      loanId: number
      salaryId: number | null
      amount: number
      paymentDate: Date
      principal: number
      interest: number
      notes: string | null
      createdAt: Date
    }, ExtArgs["result"]["loanPayment"]>
    composites: {}
  }

  type LoanPaymentGetPayload<S extends boolean | null | undefined | LoanPaymentDefaultArgs> = $Result.GetResult<Prisma.$LoanPaymentPayload, S>

  type LoanPaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LoanPaymentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LoanPaymentCountAggregateInputType | true
    }

  export interface LoanPaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LoanPayment'], meta: { name: 'LoanPayment' } }
    /**
     * Find zero or one LoanPayment that matches the filter.
     * @param {LoanPaymentFindUniqueArgs} args - Arguments to find a LoanPayment
     * @example
     * // Get one LoanPayment
     * const loanPayment = await prisma.loanPayment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LoanPaymentFindUniqueArgs>(args: SelectSubset<T, LoanPaymentFindUniqueArgs<ExtArgs>>): Prisma__LoanPaymentClient<$Result.GetResult<Prisma.$LoanPaymentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LoanPayment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LoanPaymentFindUniqueOrThrowArgs} args - Arguments to find a LoanPayment
     * @example
     * // Get one LoanPayment
     * const loanPayment = await prisma.loanPayment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LoanPaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, LoanPaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LoanPaymentClient<$Result.GetResult<Prisma.$LoanPaymentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LoanPayment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanPaymentFindFirstArgs} args - Arguments to find a LoanPayment
     * @example
     * // Get one LoanPayment
     * const loanPayment = await prisma.loanPayment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LoanPaymentFindFirstArgs>(args?: SelectSubset<T, LoanPaymentFindFirstArgs<ExtArgs>>): Prisma__LoanPaymentClient<$Result.GetResult<Prisma.$LoanPaymentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LoanPayment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanPaymentFindFirstOrThrowArgs} args - Arguments to find a LoanPayment
     * @example
     * // Get one LoanPayment
     * const loanPayment = await prisma.loanPayment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LoanPaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, LoanPaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__LoanPaymentClient<$Result.GetResult<Prisma.$LoanPaymentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LoanPayments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanPaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LoanPayments
     * const loanPayments = await prisma.loanPayment.findMany()
     * 
     * // Get first 10 LoanPayments
     * const loanPayments = await prisma.loanPayment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const loanPaymentWithIdOnly = await prisma.loanPayment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LoanPaymentFindManyArgs>(args?: SelectSubset<T, LoanPaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoanPaymentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LoanPayment.
     * @param {LoanPaymentCreateArgs} args - Arguments to create a LoanPayment.
     * @example
     * // Create one LoanPayment
     * const LoanPayment = await prisma.loanPayment.create({
     *   data: {
     *     // ... data to create a LoanPayment
     *   }
     * })
     * 
     */
    create<T extends LoanPaymentCreateArgs>(args: SelectSubset<T, LoanPaymentCreateArgs<ExtArgs>>): Prisma__LoanPaymentClient<$Result.GetResult<Prisma.$LoanPaymentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LoanPayments.
     * @param {LoanPaymentCreateManyArgs} args - Arguments to create many LoanPayments.
     * @example
     * // Create many LoanPayments
     * const loanPayment = await prisma.loanPayment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LoanPaymentCreateManyArgs>(args?: SelectSubset<T, LoanPaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LoanPayments and returns the data saved in the database.
     * @param {LoanPaymentCreateManyAndReturnArgs} args - Arguments to create many LoanPayments.
     * @example
     * // Create many LoanPayments
     * const loanPayment = await prisma.loanPayment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LoanPayments and only return the `id`
     * const loanPaymentWithIdOnly = await prisma.loanPayment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LoanPaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, LoanPaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoanPaymentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LoanPayment.
     * @param {LoanPaymentDeleteArgs} args - Arguments to delete one LoanPayment.
     * @example
     * // Delete one LoanPayment
     * const LoanPayment = await prisma.loanPayment.delete({
     *   where: {
     *     // ... filter to delete one LoanPayment
     *   }
     * })
     * 
     */
    delete<T extends LoanPaymentDeleteArgs>(args: SelectSubset<T, LoanPaymentDeleteArgs<ExtArgs>>): Prisma__LoanPaymentClient<$Result.GetResult<Prisma.$LoanPaymentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LoanPayment.
     * @param {LoanPaymentUpdateArgs} args - Arguments to update one LoanPayment.
     * @example
     * // Update one LoanPayment
     * const loanPayment = await prisma.loanPayment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LoanPaymentUpdateArgs>(args: SelectSubset<T, LoanPaymentUpdateArgs<ExtArgs>>): Prisma__LoanPaymentClient<$Result.GetResult<Prisma.$LoanPaymentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LoanPayments.
     * @param {LoanPaymentDeleteManyArgs} args - Arguments to filter LoanPayments to delete.
     * @example
     * // Delete a few LoanPayments
     * const { count } = await prisma.loanPayment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LoanPaymentDeleteManyArgs>(args?: SelectSubset<T, LoanPaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LoanPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanPaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LoanPayments
     * const loanPayment = await prisma.loanPayment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LoanPaymentUpdateManyArgs>(args: SelectSubset<T, LoanPaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LoanPayment.
     * @param {LoanPaymentUpsertArgs} args - Arguments to update or create a LoanPayment.
     * @example
     * // Update or create a LoanPayment
     * const loanPayment = await prisma.loanPayment.upsert({
     *   create: {
     *     // ... data to create a LoanPayment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LoanPayment we want to update
     *   }
     * })
     */
    upsert<T extends LoanPaymentUpsertArgs>(args: SelectSubset<T, LoanPaymentUpsertArgs<ExtArgs>>): Prisma__LoanPaymentClient<$Result.GetResult<Prisma.$LoanPaymentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LoanPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanPaymentCountArgs} args - Arguments to filter LoanPayments to count.
     * @example
     * // Count the number of LoanPayments
     * const count = await prisma.loanPayment.count({
     *   where: {
     *     // ... the filter for the LoanPayments we want to count
     *   }
     * })
    **/
    count<T extends LoanPaymentCountArgs>(
      args?: Subset<T, LoanPaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LoanPaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LoanPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanPaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LoanPaymentAggregateArgs>(args: Subset<T, LoanPaymentAggregateArgs>): Prisma.PrismaPromise<GetLoanPaymentAggregateType<T>>

    /**
     * Group by LoanPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanPaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LoanPaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LoanPaymentGroupByArgs['orderBy'] }
        : { orderBy?: LoanPaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LoanPaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLoanPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LoanPayment model
   */
  readonly fields: LoanPaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LoanPayment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LoanPaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    loan<T extends LoanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LoanDefaultArgs<ExtArgs>>): Prisma__LoanClient<$Result.GetResult<Prisma.$LoanPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    salary<T extends LoanPayment$salaryArgs<ExtArgs> = {}>(args?: Subset<T, LoanPayment$salaryArgs<ExtArgs>>): Prisma__SalaryClient<$Result.GetResult<Prisma.$SalaryPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LoanPayment model
   */ 
  interface LoanPaymentFieldRefs {
    readonly id: FieldRef<"LoanPayment", 'Int'>
    readonly loanId: FieldRef<"LoanPayment", 'Int'>
    readonly salaryId: FieldRef<"LoanPayment", 'Int'>
    readonly amount: FieldRef<"LoanPayment", 'Float'>
    readonly paymentDate: FieldRef<"LoanPayment", 'DateTime'>
    readonly principal: FieldRef<"LoanPayment", 'Float'>
    readonly interest: FieldRef<"LoanPayment", 'Float'>
    readonly notes: FieldRef<"LoanPayment", 'String'>
    readonly createdAt: FieldRef<"LoanPayment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LoanPayment findUnique
   */
  export type LoanPaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanPayment
     */
    select?: LoanPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanPaymentInclude<ExtArgs> | null
    /**
     * Filter, which LoanPayment to fetch.
     */
    where: LoanPaymentWhereUniqueInput
  }

  /**
   * LoanPayment findUniqueOrThrow
   */
  export type LoanPaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanPayment
     */
    select?: LoanPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanPaymentInclude<ExtArgs> | null
    /**
     * Filter, which LoanPayment to fetch.
     */
    where: LoanPaymentWhereUniqueInput
  }

  /**
   * LoanPayment findFirst
   */
  export type LoanPaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanPayment
     */
    select?: LoanPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanPaymentInclude<ExtArgs> | null
    /**
     * Filter, which LoanPayment to fetch.
     */
    where?: LoanPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoanPayments to fetch.
     */
    orderBy?: LoanPaymentOrderByWithRelationInput | LoanPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LoanPayments.
     */
    cursor?: LoanPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoanPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoanPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LoanPayments.
     */
    distinct?: LoanPaymentScalarFieldEnum | LoanPaymentScalarFieldEnum[]
  }

  /**
   * LoanPayment findFirstOrThrow
   */
  export type LoanPaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanPayment
     */
    select?: LoanPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanPaymentInclude<ExtArgs> | null
    /**
     * Filter, which LoanPayment to fetch.
     */
    where?: LoanPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoanPayments to fetch.
     */
    orderBy?: LoanPaymentOrderByWithRelationInput | LoanPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LoanPayments.
     */
    cursor?: LoanPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoanPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoanPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LoanPayments.
     */
    distinct?: LoanPaymentScalarFieldEnum | LoanPaymentScalarFieldEnum[]
  }

  /**
   * LoanPayment findMany
   */
  export type LoanPaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanPayment
     */
    select?: LoanPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanPaymentInclude<ExtArgs> | null
    /**
     * Filter, which LoanPayments to fetch.
     */
    where?: LoanPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoanPayments to fetch.
     */
    orderBy?: LoanPaymentOrderByWithRelationInput | LoanPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LoanPayments.
     */
    cursor?: LoanPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoanPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoanPayments.
     */
    skip?: number
    distinct?: LoanPaymentScalarFieldEnum | LoanPaymentScalarFieldEnum[]
  }

  /**
   * LoanPayment create
   */
  export type LoanPaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanPayment
     */
    select?: LoanPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanPaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a LoanPayment.
     */
    data: XOR<LoanPaymentCreateInput, LoanPaymentUncheckedCreateInput>
  }

  /**
   * LoanPayment createMany
   */
  export type LoanPaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LoanPayments.
     */
    data: LoanPaymentCreateManyInput | LoanPaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LoanPayment createManyAndReturn
   */
  export type LoanPaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanPayment
     */
    select?: LoanPaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LoanPayments.
     */
    data: LoanPaymentCreateManyInput | LoanPaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanPaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LoanPayment update
   */
  export type LoanPaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanPayment
     */
    select?: LoanPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanPaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a LoanPayment.
     */
    data: XOR<LoanPaymentUpdateInput, LoanPaymentUncheckedUpdateInput>
    /**
     * Choose, which LoanPayment to update.
     */
    where: LoanPaymentWhereUniqueInput
  }

  /**
   * LoanPayment updateMany
   */
  export type LoanPaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LoanPayments.
     */
    data: XOR<LoanPaymentUpdateManyMutationInput, LoanPaymentUncheckedUpdateManyInput>
    /**
     * Filter which LoanPayments to update
     */
    where?: LoanPaymentWhereInput
  }

  /**
   * LoanPayment upsert
   */
  export type LoanPaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanPayment
     */
    select?: LoanPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanPaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the LoanPayment to update in case it exists.
     */
    where: LoanPaymentWhereUniqueInput
    /**
     * In case the LoanPayment found by the `where` argument doesn't exist, create a new LoanPayment with this data.
     */
    create: XOR<LoanPaymentCreateInput, LoanPaymentUncheckedCreateInput>
    /**
     * In case the LoanPayment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LoanPaymentUpdateInput, LoanPaymentUncheckedUpdateInput>
  }

  /**
   * LoanPayment delete
   */
  export type LoanPaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanPayment
     */
    select?: LoanPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanPaymentInclude<ExtArgs> | null
    /**
     * Filter which LoanPayment to delete.
     */
    where: LoanPaymentWhereUniqueInput
  }

  /**
   * LoanPayment deleteMany
   */
  export type LoanPaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LoanPayments to delete
     */
    where?: LoanPaymentWhereInput
  }

  /**
   * LoanPayment.salary
   */
  export type LoanPayment$salaryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salary
     */
    select?: SalarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryInclude<ExtArgs> | null
    where?: SalaryWhereInput
  }

  /**
   * LoanPayment without action
   */
  export type LoanPaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanPayment
     */
    select?: LoanPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanPaymentInclude<ExtArgs> | null
  }


  /**
   * Model LeaveRequest
   */

  export type AggregateLeaveRequest = {
    _count: LeaveRequestCountAggregateOutputType | null
    _avg: LeaveRequestAvgAggregateOutputType | null
    _sum: LeaveRequestSumAggregateOutputType | null
    _min: LeaveRequestMinAggregateOutputType | null
    _max: LeaveRequestMaxAggregateOutputType | null
  }

  export type LeaveRequestAvgAggregateOutputType = {
    id: number | null
    employeeId: number | null
    days: number | null
    approvedById: number | null
  }

  export type LeaveRequestSumAggregateOutputType = {
    id: number | null
    employeeId: number | null
    days: number | null
    approvedById: number | null
  }

  export type LeaveRequestMinAggregateOutputType = {
    id: number | null
    employeeId: number | null
    leaveType: $Enums.LeaveType | null
    startDate: Date | null
    endDate: Date | null
    days: number | null
    reason: string | null
    notes: string | null
    status: $Enums.LeaveStatus | null
    approvedById: number | null
    approvedAt: Date | null
    comments: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LeaveRequestMaxAggregateOutputType = {
    id: number | null
    employeeId: number | null
    leaveType: $Enums.LeaveType | null
    startDate: Date | null
    endDate: Date | null
    days: number | null
    reason: string | null
    notes: string | null
    status: $Enums.LeaveStatus | null
    approvedById: number | null
    approvedAt: Date | null
    comments: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LeaveRequestCountAggregateOutputType = {
    id: number
    employeeId: number
    leaveType: number
    startDate: number
    endDate: number
    days: number
    reason: number
    notes: number
    status: number
    approvedById: number
    approvedAt: number
    comments: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LeaveRequestAvgAggregateInputType = {
    id?: true
    employeeId?: true
    days?: true
    approvedById?: true
  }

  export type LeaveRequestSumAggregateInputType = {
    id?: true
    employeeId?: true
    days?: true
    approvedById?: true
  }

  export type LeaveRequestMinAggregateInputType = {
    id?: true
    employeeId?: true
    leaveType?: true
    startDate?: true
    endDate?: true
    days?: true
    reason?: true
    notes?: true
    status?: true
    approvedById?: true
    approvedAt?: true
    comments?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LeaveRequestMaxAggregateInputType = {
    id?: true
    employeeId?: true
    leaveType?: true
    startDate?: true
    endDate?: true
    days?: true
    reason?: true
    notes?: true
    status?: true
    approvedById?: true
    approvedAt?: true
    comments?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LeaveRequestCountAggregateInputType = {
    id?: true
    employeeId?: true
    leaveType?: true
    startDate?: true
    endDate?: true
    days?: true
    reason?: true
    notes?: true
    status?: true
    approvedById?: true
    approvedAt?: true
    comments?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LeaveRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeaveRequest to aggregate.
     */
    where?: LeaveRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveRequests to fetch.
     */
    orderBy?: LeaveRequestOrderByWithRelationInput | LeaveRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeaveRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LeaveRequests
    **/
    _count?: true | LeaveRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LeaveRequestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LeaveRequestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeaveRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeaveRequestMaxAggregateInputType
  }

  export type GetLeaveRequestAggregateType<T extends LeaveRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateLeaveRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeaveRequest[P]>
      : GetScalarType<T[P], AggregateLeaveRequest[P]>
  }




  export type LeaveRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveRequestWhereInput
    orderBy?: LeaveRequestOrderByWithAggregationInput | LeaveRequestOrderByWithAggregationInput[]
    by: LeaveRequestScalarFieldEnum[] | LeaveRequestScalarFieldEnum
    having?: LeaveRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeaveRequestCountAggregateInputType | true
    _avg?: LeaveRequestAvgAggregateInputType
    _sum?: LeaveRequestSumAggregateInputType
    _min?: LeaveRequestMinAggregateInputType
    _max?: LeaveRequestMaxAggregateInputType
  }

  export type LeaveRequestGroupByOutputType = {
    id: number
    employeeId: number
    leaveType: $Enums.LeaveType
    startDate: Date
    endDate: Date
    days: number
    reason: string
    notes: string | null
    status: $Enums.LeaveStatus
    approvedById: number | null
    approvedAt: Date | null
    comments: string | null
    createdAt: Date
    updatedAt: Date
    _count: LeaveRequestCountAggregateOutputType | null
    _avg: LeaveRequestAvgAggregateOutputType | null
    _sum: LeaveRequestSumAggregateOutputType | null
    _min: LeaveRequestMinAggregateOutputType | null
    _max: LeaveRequestMaxAggregateOutputType | null
  }

  type GetLeaveRequestGroupByPayload<T extends LeaveRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeaveRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeaveRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeaveRequestGroupByOutputType[P]>
            : GetScalarType<T[P], LeaveRequestGroupByOutputType[P]>
        }
      >
    >


  export type LeaveRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    leaveType?: boolean
    startDate?: boolean
    endDate?: boolean
    days?: boolean
    reason?: boolean
    notes?: boolean
    status?: boolean
    approvedById?: boolean
    approvedAt?: boolean
    comments?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    approvedBy?: boolean | LeaveRequest$approvedByArgs<ExtArgs>
  }, ExtArgs["result"]["leaveRequest"]>

  export type LeaveRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    leaveType?: boolean
    startDate?: boolean
    endDate?: boolean
    days?: boolean
    reason?: boolean
    notes?: boolean
    status?: boolean
    approvedById?: boolean
    approvedAt?: boolean
    comments?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    approvedBy?: boolean | LeaveRequest$approvedByArgs<ExtArgs>
  }, ExtArgs["result"]["leaveRequest"]>

  export type LeaveRequestSelectScalar = {
    id?: boolean
    employeeId?: boolean
    leaveType?: boolean
    startDate?: boolean
    endDate?: boolean
    days?: boolean
    reason?: boolean
    notes?: boolean
    status?: boolean
    approvedById?: boolean
    approvedAt?: boolean
    comments?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LeaveRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    approvedBy?: boolean | LeaveRequest$approvedByArgs<ExtArgs>
  }
  export type LeaveRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    approvedBy?: boolean | LeaveRequest$approvedByArgs<ExtArgs>
  }

  export type $LeaveRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LeaveRequest"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
      approvedBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      employeeId: number
      leaveType: $Enums.LeaveType
      startDate: Date
      endDate: Date
      days: number
      reason: string
      notes: string | null
      status: $Enums.LeaveStatus
      approvedById: number | null
      approvedAt: Date | null
      comments: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["leaveRequest"]>
    composites: {}
  }

  type LeaveRequestGetPayload<S extends boolean | null | undefined | LeaveRequestDefaultArgs> = $Result.GetResult<Prisma.$LeaveRequestPayload, S>

  type LeaveRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LeaveRequestFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LeaveRequestCountAggregateInputType | true
    }

  export interface LeaveRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LeaveRequest'], meta: { name: 'LeaveRequest' } }
    /**
     * Find zero or one LeaveRequest that matches the filter.
     * @param {LeaveRequestFindUniqueArgs} args - Arguments to find a LeaveRequest
     * @example
     * // Get one LeaveRequest
     * const leaveRequest = await prisma.leaveRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeaveRequestFindUniqueArgs>(args: SelectSubset<T, LeaveRequestFindUniqueArgs<ExtArgs>>): Prisma__LeaveRequestClient<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LeaveRequest that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LeaveRequestFindUniqueOrThrowArgs} args - Arguments to find a LeaveRequest
     * @example
     * // Get one LeaveRequest
     * const leaveRequest = await prisma.leaveRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeaveRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, LeaveRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeaveRequestClient<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LeaveRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveRequestFindFirstArgs} args - Arguments to find a LeaveRequest
     * @example
     * // Get one LeaveRequest
     * const leaveRequest = await prisma.leaveRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeaveRequestFindFirstArgs>(args?: SelectSubset<T, LeaveRequestFindFirstArgs<ExtArgs>>): Prisma__LeaveRequestClient<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LeaveRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveRequestFindFirstOrThrowArgs} args - Arguments to find a LeaveRequest
     * @example
     * // Get one LeaveRequest
     * const leaveRequest = await prisma.leaveRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeaveRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, LeaveRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeaveRequestClient<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LeaveRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LeaveRequests
     * const leaveRequests = await prisma.leaveRequest.findMany()
     * 
     * // Get first 10 LeaveRequests
     * const leaveRequests = await prisma.leaveRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leaveRequestWithIdOnly = await prisma.leaveRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeaveRequestFindManyArgs>(args?: SelectSubset<T, LeaveRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LeaveRequest.
     * @param {LeaveRequestCreateArgs} args - Arguments to create a LeaveRequest.
     * @example
     * // Create one LeaveRequest
     * const LeaveRequest = await prisma.leaveRequest.create({
     *   data: {
     *     // ... data to create a LeaveRequest
     *   }
     * })
     * 
     */
    create<T extends LeaveRequestCreateArgs>(args: SelectSubset<T, LeaveRequestCreateArgs<ExtArgs>>): Prisma__LeaveRequestClient<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LeaveRequests.
     * @param {LeaveRequestCreateManyArgs} args - Arguments to create many LeaveRequests.
     * @example
     * // Create many LeaveRequests
     * const leaveRequest = await prisma.leaveRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeaveRequestCreateManyArgs>(args?: SelectSubset<T, LeaveRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LeaveRequests and returns the data saved in the database.
     * @param {LeaveRequestCreateManyAndReturnArgs} args - Arguments to create many LeaveRequests.
     * @example
     * // Create many LeaveRequests
     * const leaveRequest = await prisma.leaveRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LeaveRequests and only return the `id`
     * const leaveRequestWithIdOnly = await prisma.leaveRequest.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LeaveRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, LeaveRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LeaveRequest.
     * @param {LeaveRequestDeleteArgs} args - Arguments to delete one LeaveRequest.
     * @example
     * // Delete one LeaveRequest
     * const LeaveRequest = await prisma.leaveRequest.delete({
     *   where: {
     *     // ... filter to delete one LeaveRequest
     *   }
     * })
     * 
     */
    delete<T extends LeaveRequestDeleteArgs>(args: SelectSubset<T, LeaveRequestDeleteArgs<ExtArgs>>): Prisma__LeaveRequestClient<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LeaveRequest.
     * @param {LeaveRequestUpdateArgs} args - Arguments to update one LeaveRequest.
     * @example
     * // Update one LeaveRequest
     * const leaveRequest = await prisma.leaveRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeaveRequestUpdateArgs>(args: SelectSubset<T, LeaveRequestUpdateArgs<ExtArgs>>): Prisma__LeaveRequestClient<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LeaveRequests.
     * @param {LeaveRequestDeleteManyArgs} args - Arguments to filter LeaveRequests to delete.
     * @example
     * // Delete a few LeaveRequests
     * const { count } = await prisma.leaveRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeaveRequestDeleteManyArgs>(args?: SelectSubset<T, LeaveRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeaveRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LeaveRequests
     * const leaveRequest = await prisma.leaveRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeaveRequestUpdateManyArgs>(args: SelectSubset<T, LeaveRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LeaveRequest.
     * @param {LeaveRequestUpsertArgs} args - Arguments to update or create a LeaveRequest.
     * @example
     * // Update or create a LeaveRequest
     * const leaveRequest = await prisma.leaveRequest.upsert({
     *   create: {
     *     // ... data to create a LeaveRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LeaveRequest we want to update
     *   }
     * })
     */
    upsert<T extends LeaveRequestUpsertArgs>(args: SelectSubset<T, LeaveRequestUpsertArgs<ExtArgs>>): Prisma__LeaveRequestClient<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LeaveRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveRequestCountArgs} args - Arguments to filter LeaveRequests to count.
     * @example
     * // Count the number of LeaveRequests
     * const count = await prisma.leaveRequest.count({
     *   where: {
     *     // ... the filter for the LeaveRequests we want to count
     *   }
     * })
    **/
    count<T extends LeaveRequestCountArgs>(
      args?: Subset<T, LeaveRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeaveRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LeaveRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeaveRequestAggregateArgs>(args: Subset<T, LeaveRequestAggregateArgs>): Prisma.PrismaPromise<GetLeaveRequestAggregateType<T>>

    /**
     * Group by LeaveRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeaveRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeaveRequestGroupByArgs['orderBy'] }
        : { orderBy?: LeaveRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeaveRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeaveRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LeaveRequest model
   */
  readonly fields: LeaveRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LeaveRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeaveRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    approvedBy<T extends LeaveRequest$approvedByArgs<ExtArgs> = {}>(args?: Subset<T, LeaveRequest$approvedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LeaveRequest model
   */ 
  interface LeaveRequestFieldRefs {
    readonly id: FieldRef<"LeaveRequest", 'Int'>
    readonly employeeId: FieldRef<"LeaveRequest", 'Int'>
    readonly leaveType: FieldRef<"LeaveRequest", 'LeaveType'>
    readonly startDate: FieldRef<"LeaveRequest", 'DateTime'>
    readonly endDate: FieldRef<"LeaveRequest", 'DateTime'>
    readonly days: FieldRef<"LeaveRequest", 'Int'>
    readonly reason: FieldRef<"LeaveRequest", 'String'>
    readonly notes: FieldRef<"LeaveRequest", 'String'>
    readonly status: FieldRef<"LeaveRequest", 'LeaveStatus'>
    readonly approvedById: FieldRef<"LeaveRequest", 'Int'>
    readonly approvedAt: FieldRef<"LeaveRequest", 'DateTime'>
    readonly comments: FieldRef<"LeaveRequest", 'String'>
    readonly createdAt: FieldRef<"LeaveRequest", 'DateTime'>
    readonly updatedAt: FieldRef<"LeaveRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LeaveRequest findUnique
   */
  export type LeaveRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    /**
     * Filter, which LeaveRequest to fetch.
     */
    where: LeaveRequestWhereUniqueInput
  }

  /**
   * LeaveRequest findUniqueOrThrow
   */
  export type LeaveRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    /**
     * Filter, which LeaveRequest to fetch.
     */
    where: LeaveRequestWhereUniqueInput
  }

  /**
   * LeaveRequest findFirst
   */
  export type LeaveRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    /**
     * Filter, which LeaveRequest to fetch.
     */
    where?: LeaveRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveRequests to fetch.
     */
    orderBy?: LeaveRequestOrderByWithRelationInput | LeaveRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeaveRequests.
     */
    cursor?: LeaveRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeaveRequests.
     */
    distinct?: LeaveRequestScalarFieldEnum | LeaveRequestScalarFieldEnum[]
  }

  /**
   * LeaveRequest findFirstOrThrow
   */
  export type LeaveRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    /**
     * Filter, which LeaveRequest to fetch.
     */
    where?: LeaveRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveRequests to fetch.
     */
    orderBy?: LeaveRequestOrderByWithRelationInput | LeaveRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeaveRequests.
     */
    cursor?: LeaveRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeaveRequests.
     */
    distinct?: LeaveRequestScalarFieldEnum | LeaveRequestScalarFieldEnum[]
  }

  /**
   * LeaveRequest findMany
   */
  export type LeaveRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    /**
     * Filter, which LeaveRequests to fetch.
     */
    where?: LeaveRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveRequests to fetch.
     */
    orderBy?: LeaveRequestOrderByWithRelationInput | LeaveRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LeaveRequests.
     */
    cursor?: LeaveRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveRequests.
     */
    skip?: number
    distinct?: LeaveRequestScalarFieldEnum | LeaveRequestScalarFieldEnum[]
  }

  /**
   * LeaveRequest create
   */
  export type LeaveRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a LeaveRequest.
     */
    data: XOR<LeaveRequestCreateInput, LeaveRequestUncheckedCreateInput>
  }

  /**
   * LeaveRequest createMany
   */
  export type LeaveRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LeaveRequests.
     */
    data: LeaveRequestCreateManyInput | LeaveRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LeaveRequest createManyAndReturn
   */
  export type LeaveRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LeaveRequests.
     */
    data: LeaveRequestCreateManyInput | LeaveRequestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LeaveRequest update
   */
  export type LeaveRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a LeaveRequest.
     */
    data: XOR<LeaveRequestUpdateInput, LeaveRequestUncheckedUpdateInput>
    /**
     * Choose, which LeaveRequest to update.
     */
    where: LeaveRequestWhereUniqueInput
  }

  /**
   * LeaveRequest updateMany
   */
  export type LeaveRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LeaveRequests.
     */
    data: XOR<LeaveRequestUpdateManyMutationInput, LeaveRequestUncheckedUpdateManyInput>
    /**
     * Filter which LeaveRequests to update
     */
    where?: LeaveRequestWhereInput
  }

  /**
   * LeaveRequest upsert
   */
  export type LeaveRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the LeaveRequest to update in case it exists.
     */
    where: LeaveRequestWhereUniqueInput
    /**
     * In case the LeaveRequest found by the `where` argument doesn't exist, create a new LeaveRequest with this data.
     */
    create: XOR<LeaveRequestCreateInput, LeaveRequestUncheckedCreateInput>
    /**
     * In case the LeaveRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeaveRequestUpdateInput, LeaveRequestUncheckedUpdateInput>
  }

  /**
   * LeaveRequest delete
   */
  export type LeaveRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    /**
     * Filter which LeaveRequest to delete.
     */
    where: LeaveRequestWhereUniqueInput
  }

  /**
   * LeaveRequest deleteMany
   */
  export type LeaveRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeaveRequests to delete
     */
    where?: LeaveRequestWhereInput
  }

  /**
   * LeaveRequest.approvedBy
   */
  export type LeaveRequest$approvedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * LeaveRequest without action
   */
  export type LeaveRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
  }


  /**
   * Model Prospect
   */

  export type AggregateProspect = {
    _count: ProspectCountAggregateOutputType | null
    _avg: ProspectAvgAggregateOutputType | null
    _sum: ProspectSumAggregateOutputType | null
    _min: ProspectMinAggregateOutputType | null
    _max: ProspectMaxAggregateOutputType | null
  }

  export type ProspectAvgAggregateOutputType = {
    id: number | null
    estimatedValue: number | null
    assignedTo: number | null
    createdBy: number | null
  }

  export type ProspectSumAggregateOutputType = {
    id: number | null
    estimatedValue: number | null
    assignedTo: number | null
    createdBy: number | null
  }

  export type ProspectMinAggregateOutputType = {
    id: number | null
    companyName: string | null
    contactName: string | null
    position: string | null
    email: string | null
    phone: string | null
    address: string | null
    website: string | null
    industry: string | null
    companySize: string | null
    estimatedValue: number | null
    priority: string | null
    stage: string | null
    source: string | null
    notes: string | null
    hasBudget: boolean | null
    isDecisionMaker: boolean | null
    hasNeed: boolean | null
    timeline: string | null
    lastContact: Date | null
    nextAction: string | null
    nextActionDate: Date | null
    assignedTo: number | null
    createdBy: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProspectMaxAggregateOutputType = {
    id: number | null
    companyName: string | null
    contactName: string | null
    position: string | null
    email: string | null
    phone: string | null
    address: string | null
    website: string | null
    industry: string | null
    companySize: string | null
    estimatedValue: number | null
    priority: string | null
    stage: string | null
    source: string | null
    notes: string | null
    hasBudget: boolean | null
    isDecisionMaker: boolean | null
    hasNeed: boolean | null
    timeline: string | null
    lastContact: Date | null
    nextAction: string | null
    nextActionDate: Date | null
    assignedTo: number | null
    createdBy: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProspectCountAggregateOutputType = {
    id: number
    companyName: number
    contactName: number
    position: number
    email: number
    phone: number
    address: number
    website: number
    industry: number
    companySize: number
    estimatedValue: number
    priority: number
    stage: number
    source: number
    notes: number
    hasBudget: number
    isDecisionMaker: number
    hasNeed: number
    timeline: number
    lastContact: number
    nextAction: number
    nextActionDate: number
    assignedTo: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProspectAvgAggregateInputType = {
    id?: true
    estimatedValue?: true
    assignedTo?: true
    createdBy?: true
  }

  export type ProspectSumAggregateInputType = {
    id?: true
    estimatedValue?: true
    assignedTo?: true
    createdBy?: true
  }

  export type ProspectMinAggregateInputType = {
    id?: true
    companyName?: true
    contactName?: true
    position?: true
    email?: true
    phone?: true
    address?: true
    website?: true
    industry?: true
    companySize?: true
    estimatedValue?: true
    priority?: true
    stage?: true
    source?: true
    notes?: true
    hasBudget?: true
    isDecisionMaker?: true
    hasNeed?: true
    timeline?: true
    lastContact?: true
    nextAction?: true
    nextActionDate?: true
    assignedTo?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProspectMaxAggregateInputType = {
    id?: true
    companyName?: true
    contactName?: true
    position?: true
    email?: true
    phone?: true
    address?: true
    website?: true
    industry?: true
    companySize?: true
    estimatedValue?: true
    priority?: true
    stage?: true
    source?: true
    notes?: true
    hasBudget?: true
    isDecisionMaker?: true
    hasNeed?: true
    timeline?: true
    lastContact?: true
    nextAction?: true
    nextActionDate?: true
    assignedTo?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProspectCountAggregateInputType = {
    id?: true
    companyName?: true
    contactName?: true
    position?: true
    email?: true
    phone?: true
    address?: true
    website?: true
    industry?: true
    companySize?: true
    estimatedValue?: true
    priority?: true
    stage?: true
    source?: true
    notes?: true
    hasBudget?: true
    isDecisionMaker?: true
    hasNeed?: true
    timeline?: true
    lastContact?: true
    nextAction?: true
    nextActionDate?: true
    assignedTo?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProspectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Prospect to aggregate.
     */
    where?: ProspectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prospects to fetch.
     */
    orderBy?: ProspectOrderByWithRelationInput | ProspectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProspectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prospects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prospects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Prospects
    **/
    _count?: true | ProspectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProspectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProspectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProspectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProspectMaxAggregateInputType
  }

  export type GetProspectAggregateType<T extends ProspectAggregateArgs> = {
        [P in keyof T & keyof AggregateProspect]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProspect[P]>
      : GetScalarType<T[P], AggregateProspect[P]>
  }




  export type ProspectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProspectWhereInput
    orderBy?: ProspectOrderByWithAggregationInput | ProspectOrderByWithAggregationInput[]
    by: ProspectScalarFieldEnum[] | ProspectScalarFieldEnum
    having?: ProspectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProspectCountAggregateInputType | true
    _avg?: ProspectAvgAggregateInputType
    _sum?: ProspectSumAggregateInputType
    _min?: ProspectMinAggregateInputType
    _max?: ProspectMaxAggregateInputType
  }

  export type ProspectGroupByOutputType = {
    id: number
    companyName: string
    contactName: string
    position: string | null
    email: string | null
    phone: string | null
    address: string | null
    website: string | null
    industry: string | null
    companySize: string | null
    estimatedValue: number | null
    priority: string
    stage: string
    source: string | null
    notes: string | null
    hasBudget: boolean
    isDecisionMaker: boolean
    hasNeed: boolean
    timeline: string | null
    lastContact: Date
    nextAction: string | null
    nextActionDate: Date | null
    assignedTo: number | null
    createdBy: number
    createdAt: Date
    updatedAt: Date
    _count: ProspectCountAggregateOutputType | null
    _avg: ProspectAvgAggregateOutputType | null
    _sum: ProspectSumAggregateOutputType | null
    _min: ProspectMinAggregateOutputType | null
    _max: ProspectMaxAggregateOutputType | null
  }

  type GetProspectGroupByPayload<T extends ProspectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProspectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProspectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProspectGroupByOutputType[P]>
            : GetScalarType<T[P], ProspectGroupByOutputType[P]>
        }
      >
    >


  export type ProspectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyName?: boolean
    contactName?: boolean
    position?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    website?: boolean
    industry?: boolean
    companySize?: boolean
    estimatedValue?: boolean
    priority?: boolean
    stage?: boolean
    source?: boolean
    notes?: boolean
    hasBudget?: boolean
    isDecisionMaker?: boolean
    hasNeed?: boolean
    timeline?: boolean
    lastContact?: boolean
    nextAction?: boolean
    nextActionDate?: boolean
    assignedTo?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignedUser?: boolean | Prospect$assignedUserArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    activities?: boolean | Prospect$activitiesArgs<ExtArgs>
    _count?: boolean | ProspectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prospect"]>

  export type ProspectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyName?: boolean
    contactName?: boolean
    position?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    website?: boolean
    industry?: boolean
    companySize?: boolean
    estimatedValue?: boolean
    priority?: boolean
    stage?: boolean
    source?: boolean
    notes?: boolean
    hasBudget?: boolean
    isDecisionMaker?: boolean
    hasNeed?: boolean
    timeline?: boolean
    lastContact?: boolean
    nextAction?: boolean
    nextActionDate?: boolean
    assignedTo?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignedUser?: boolean | Prospect$assignedUserArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prospect"]>

  export type ProspectSelectScalar = {
    id?: boolean
    companyName?: boolean
    contactName?: boolean
    position?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    website?: boolean
    industry?: boolean
    companySize?: boolean
    estimatedValue?: boolean
    priority?: boolean
    stage?: boolean
    source?: boolean
    notes?: boolean
    hasBudget?: boolean
    isDecisionMaker?: boolean
    hasNeed?: boolean
    timeline?: boolean
    lastContact?: boolean
    nextAction?: boolean
    nextActionDate?: boolean
    assignedTo?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProspectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedUser?: boolean | Prospect$assignedUserArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    activities?: boolean | Prospect$activitiesArgs<ExtArgs>
    _count?: boolean | ProspectCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProspectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedUser?: boolean | Prospect$assignedUserArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProspectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Prospect"
    objects: {
      assignedUser: Prisma.$UserPayload<ExtArgs> | null
      creator: Prisma.$UserPayload<ExtArgs>
      activities: Prisma.$ProspectActivityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      companyName: string
      contactName: string
      position: string | null
      email: string | null
      phone: string | null
      address: string | null
      website: string | null
      industry: string | null
      companySize: string | null
      estimatedValue: number | null
      priority: string
      stage: string
      source: string | null
      notes: string | null
      hasBudget: boolean
      isDecisionMaker: boolean
      hasNeed: boolean
      timeline: string | null
      lastContact: Date
      nextAction: string | null
      nextActionDate: Date | null
      assignedTo: number | null
      createdBy: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["prospect"]>
    composites: {}
  }

  type ProspectGetPayload<S extends boolean | null | undefined | ProspectDefaultArgs> = $Result.GetResult<Prisma.$ProspectPayload, S>

  type ProspectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProspectFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProspectCountAggregateInputType | true
    }

  export interface ProspectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Prospect'], meta: { name: 'Prospect' } }
    /**
     * Find zero or one Prospect that matches the filter.
     * @param {ProspectFindUniqueArgs} args - Arguments to find a Prospect
     * @example
     * // Get one Prospect
     * const prospect = await prisma.prospect.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProspectFindUniqueArgs>(args: SelectSubset<T, ProspectFindUniqueArgs<ExtArgs>>): Prisma__ProspectClient<$Result.GetResult<Prisma.$ProspectPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Prospect that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProspectFindUniqueOrThrowArgs} args - Arguments to find a Prospect
     * @example
     * // Get one Prospect
     * const prospect = await prisma.prospect.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProspectFindUniqueOrThrowArgs>(args: SelectSubset<T, ProspectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProspectClient<$Result.GetResult<Prisma.$ProspectPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Prospect that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProspectFindFirstArgs} args - Arguments to find a Prospect
     * @example
     * // Get one Prospect
     * const prospect = await prisma.prospect.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProspectFindFirstArgs>(args?: SelectSubset<T, ProspectFindFirstArgs<ExtArgs>>): Prisma__ProspectClient<$Result.GetResult<Prisma.$ProspectPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Prospect that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProspectFindFirstOrThrowArgs} args - Arguments to find a Prospect
     * @example
     * // Get one Prospect
     * const prospect = await prisma.prospect.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProspectFindFirstOrThrowArgs>(args?: SelectSubset<T, ProspectFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProspectClient<$Result.GetResult<Prisma.$ProspectPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Prospects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProspectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Prospects
     * const prospects = await prisma.prospect.findMany()
     * 
     * // Get first 10 Prospects
     * const prospects = await prisma.prospect.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const prospectWithIdOnly = await prisma.prospect.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProspectFindManyArgs>(args?: SelectSubset<T, ProspectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProspectPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Prospect.
     * @param {ProspectCreateArgs} args - Arguments to create a Prospect.
     * @example
     * // Create one Prospect
     * const Prospect = await prisma.prospect.create({
     *   data: {
     *     // ... data to create a Prospect
     *   }
     * })
     * 
     */
    create<T extends ProspectCreateArgs>(args: SelectSubset<T, ProspectCreateArgs<ExtArgs>>): Prisma__ProspectClient<$Result.GetResult<Prisma.$ProspectPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Prospects.
     * @param {ProspectCreateManyArgs} args - Arguments to create many Prospects.
     * @example
     * // Create many Prospects
     * const prospect = await prisma.prospect.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProspectCreateManyArgs>(args?: SelectSubset<T, ProspectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Prospects and returns the data saved in the database.
     * @param {ProspectCreateManyAndReturnArgs} args - Arguments to create many Prospects.
     * @example
     * // Create many Prospects
     * const prospect = await prisma.prospect.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Prospects and only return the `id`
     * const prospectWithIdOnly = await prisma.prospect.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProspectCreateManyAndReturnArgs>(args?: SelectSubset<T, ProspectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProspectPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Prospect.
     * @param {ProspectDeleteArgs} args - Arguments to delete one Prospect.
     * @example
     * // Delete one Prospect
     * const Prospect = await prisma.prospect.delete({
     *   where: {
     *     // ... filter to delete one Prospect
     *   }
     * })
     * 
     */
    delete<T extends ProspectDeleteArgs>(args: SelectSubset<T, ProspectDeleteArgs<ExtArgs>>): Prisma__ProspectClient<$Result.GetResult<Prisma.$ProspectPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Prospect.
     * @param {ProspectUpdateArgs} args - Arguments to update one Prospect.
     * @example
     * // Update one Prospect
     * const prospect = await prisma.prospect.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProspectUpdateArgs>(args: SelectSubset<T, ProspectUpdateArgs<ExtArgs>>): Prisma__ProspectClient<$Result.GetResult<Prisma.$ProspectPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Prospects.
     * @param {ProspectDeleteManyArgs} args - Arguments to filter Prospects to delete.
     * @example
     * // Delete a few Prospects
     * const { count } = await prisma.prospect.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProspectDeleteManyArgs>(args?: SelectSubset<T, ProspectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Prospects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProspectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Prospects
     * const prospect = await prisma.prospect.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProspectUpdateManyArgs>(args: SelectSubset<T, ProspectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Prospect.
     * @param {ProspectUpsertArgs} args - Arguments to update or create a Prospect.
     * @example
     * // Update or create a Prospect
     * const prospect = await prisma.prospect.upsert({
     *   create: {
     *     // ... data to create a Prospect
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Prospect we want to update
     *   }
     * })
     */
    upsert<T extends ProspectUpsertArgs>(args: SelectSubset<T, ProspectUpsertArgs<ExtArgs>>): Prisma__ProspectClient<$Result.GetResult<Prisma.$ProspectPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Prospects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProspectCountArgs} args - Arguments to filter Prospects to count.
     * @example
     * // Count the number of Prospects
     * const count = await prisma.prospect.count({
     *   where: {
     *     // ... the filter for the Prospects we want to count
     *   }
     * })
    **/
    count<T extends ProspectCountArgs>(
      args?: Subset<T, ProspectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProspectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Prospect.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProspectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProspectAggregateArgs>(args: Subset<T, ProspectAggregateArgs>): Prisma.PrismaPromise<GetProspectAggregateType<T>>

    /**
     * Group by Prospect.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProspectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProspectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProspectGroupByArgs['orderBy'] }
        : { orderBy?: ProspectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProspectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProspectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Prospect model
   */
  readonly fields: ProspectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Prospect.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProspectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assignedUser<T extends Prospect$assignedUserArgs<ExtArgs> = {}>(args?: Subset<T, Prospect$assignedUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    activities<T extends Prospect$activitiesArgs<ExtArgs> = {}>(args?: Subset<T, Prospect$activitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProspectActivityPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Prospect model
   */ 
  interface ProspectFieldRefs {
    readonly id: FieldRef<"Prospect", 'Int'>
    readonly companyName: FieldRef<"Prospect", 'String'>
    readonly contactName: FieldRef<"Prospect", 'String'>
    readonly position: FieldRef<"Prospect", 'String'>
    readonly email: FieldRef<"Prospect", 'String'>
    readonly phone: FieldRef<"Prospect", 'String'>
    readonly address: FieldRef<"Prospect", 'String'>
    readonly website: FieldRef<"Prospect", 'String'>
    readonly industry: FieldRef<"Prospect", 'String'>
    readonly companySize: FieldRef<"Prospect", 'String'>
    readonly estimatedValue: FieldRef<"Prospect", 'Float'>
    readonly priority: FieldRef<"Prospect", 'String'>
    readonly stage: FieldRef<"Prospect", 'String'>
    readonly source: FieldRef<"Prospect", 'String'>
    readonly notes: FieldRef<"Prospect", 'String'>
    readonly hasBudget: FieldRef<"Prospect", 'Boolean'>
    readonly isDecisionMaker: FieldRef<"Prospect", 'Boolean'>
    readonly hasNeed: FieldRef<"Prospect", 'Boolean'>
    readonly timeline: FieldRef<"Prospect", 'String'>
    readonly lastContact: FieldRef<"Prospect", 'DateTime'>
    readonly nextAction: FieldRef<"Prospect", 'String'>
    readonly nextActionDate: FieldRef<"Prospect", 'DateTime'>
    readonly assignedTo: FieldRef<"Prospect", 'Int'>
    readonly createdBy: FieldRef<"Prospect", 'Int'>
    readonly createdAt: FieldRef<"Prospect", 'DateTime'>
    readonly updatedAt: FieldRef<"Prospect", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Prospect findUnique
   */
  export type ProspectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prospect
     */
    select?: ProspectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProspectInclude<ExtArgs> | null
    /**
     * Filter, which Prospect to fetch.
     */
    where: ProspectWhereUniqueInput
  }

  /**
   * Prospect findUniqueOrThrow
   */
  export type ProspectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prospect
     */
    select?: ProspectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProspectInclude<ExtArgs> | null
    /**
     * Filter, which Prospect to fetch.
     */
    where: ProspectWhereUniqueInput
  }

  /**
   * Prospect findFirst
   */
  export type ProspectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prospect
     */
    select?: ProspectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProspectInclude<ExtArgs> | null
    /**
     * Filter, which Prospect to fetch.
     */
    where?: ProspectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prospects to fetch.
     */
    orderBy?: ProspectOrderByWithRelationInput | ProspectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Prospects.
     */
    cursor?: ProspectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prospects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prospects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Prospects.
     */
    distinct?: ProspectScalarFieldEnum | ProspectScalarFieldEnum[]
  }

  /**
   * Prospect findFirstOrThrow
   */
  export type ProspectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prospect
     */
    select?: ProspectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProspectInclude<ExtArgs> | null
    /**
     * Filter, which Prospect to fetch.
     */
    where?: ProspectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prospects to fetch.
     */
    orderBy?: ProspectOrderByWithRelationInput | ProspectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Prospects.
     */
    cursor?: ProspectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prospects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prospects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Prospects.
     */
    distinct?: ProspectScalarFieldEnum | ProspectScalarFieldEnum[]
  }

  /**
   * Prospect findMany
   */
  export type ProspectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prospect
     */
    select?: ProspectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProspectInclude<ExtArgs> | null
    /**
     * Filter, which Prospects to fetch.
     */
    where?: ProspectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prospects to fetch.
     */
    orderBy?: ProspectOrderByWithRelationInput | ProspectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Prospects.
     */
    cursor?: ProspectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prospects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prospects.
     */
    skip?: number
    distinct?: ProspectScalarFieldEnum | ProspectScalarFieldEnum[]
  }

  /**
   * Prospect create
   */
  export type ProspectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prospect
     */
    select?: ProspectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProspectInclude<ExtArgs> | null
    /**
     * The data needed to create a Prospect.
     */
    data: XOR<ProspectCreateInput, ProspectUncheckedCreateInput>
  }

  /**
   * Prospect createMany
   */
  export type ProspectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Prospects.
     */
    data: ProspectCreateManyInput | ProspectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Prospect createManyAndReturn
   */
  export type ProspectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prospect
     */
    select?: ProspectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Prospects.
     */
    data: ProspectCreateManyInput | ProspectCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProspectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Prospect update
   */
  export type ProspectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prospect
     */
    select?: ProspectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProspectInclude<ExtArgs> | null
    /**
     * The data needed to update a Prospect.
     */
    data: XOR<ProspectUpdateInput, ProspectUncheckedUpdateInput>
    /**
     * Choose, which Prospect to update.
     */
    where: ProspectWhereUniqueInput
  }

  /**
   * Prospect updateMany
   */
  export type ProspectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Prospects.
     */
    data: XOR<ProspectUpdateManyMutationInput, ProspectUncheckedUpdateManyInput>
    /**
     * Filter which Prospects to update
     */
    where?: ProspectWhereInput
  }

  /**
   * Prospect upsert
   */
  export type ProspectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prospect
     */
    select?: ProspectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProspectInclude<ExtArgs> | null
    /**
     * The filter to search for the Prospect to update in case it exists.
     */
    where: ProspectWhereUniqueInput
    /**
     * In case the Prospect found by the `where` argument doesn't exist, create a new Prospect with this data.
     */
    create: XOR<ProspectCreateInput, ProspectUncheckedCreateInput>
    /**
     * In case the Prospect was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProspectUpdateInput, ProspectUncheckedUpdateInput>
  }

  /**
   * Prospect delete
   */
  export type ProspectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prospect
     */
    select?: ProspectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProspectInclude<ExtArgs> | null
    /**
     * Filter which Prospect to delete.
     */
    where: ProspectWhereUniqueInput
  }

  /**
   * Prospect deleteMany
   */
  export type ProspectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Prospects to delete
     */
    where?: ProspectWhereInput
  }

  /**
   * Prospect.assignedUser
   */
  export type Prospect$assignedUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Prospect.activities
   */
  export type Prospect$activitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProspectActivity
     */
    select?: ProspectActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProspectActivityInclude<ExtArgs> | null
    where?: ProspectActivityWhereInput
    orderBy?: ProspectActivityOrderByWithRelationInput | ProspectActivityOrderByWithRelationInput[]
    cursor?: ProspectActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProspectActivityScalarFieldEnum | ProspectActivityScalarFieldEnum[]
  }

  /**
   * Prospect without action
   */
  export type ProspectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prospect
     */
    select?: ProspectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProspectInclude<ExtArgs> | null
  }


  /**
   * Model ProspectActivity
   */

  export type AggregateProspectActivity = {
    _count: ProspectActivityCountAggregateOutputType | null
    _avg: ProspectActivityAvgAggregateOutputType | null
    _sum: ProspectActivitySumAggregateOutputType | null
    _min: ProspectActivityMinAggregateOutputType | null
    _max: ProspectActivityMaxAggregateOutputType | null
  }

  export type ProspectActivityAvgAggregateOutputType = {
    id: number | null
    prospectId: number | null
    createdBy: number | null
  }

  export type ProspectActivitySumAggregateOutputType = {
    id: number | null
    prospectId: number | null
    createdBy: number | null
  }

  export type ProspectActivityMinAggregateOutputType = {
    id: number | null
    prospectId: number | null
    type: string | null
    subject: string | null
    description: string | null
    scheduledAt: Date | null
    completedAt: Date | null
    outcome: string | null
    nextAction: string | null
    createdBy: number | null
    createdAt: Date | null
  }

  export type ProspectActivityMaxAggregateOutputType = {
    id: number | null
    prospectId: number | null
    type: string | null
    subject: string | null
    description: string | null
    scheduledAt: Date | null
    completedAt: Date | null
    outcome: string | null
    nextAction: string | null
    createdBy: number | null
    createdAt: Date | null
  }

  export type ProspectActivityCountAggregateOutputType = {
    id: number
    prospectId: number
    type: number
    subject: number
    description: number
    scheduledAt: number
    completedAt: number
    outcome: number
    nextAction: number
    createdBy: number
    createdAt: number
    _all: number
  }


  export type ProspectActivityAvgAggregateInputType = {
    id?: true
    prospectId?: true
    createdBy?: true
  }

  export type ProspectActivitySumAggregateInputType = {
    id?: true
    prospectId?: true
    createdBy?: true
  }

  export type ProspectActivityMinAggregateInputType = {
    id?: true
    prospectId?: true
    type?: true
    subject?: true
    description?: true
    scheduledAt?: true
    completedAt?: true
    outcome?: true
    nextAction?: true
    createdBy?: true
    createdAt?: true
  }

  export type ProspectActivityMaxAggregateInputType = {
    id?: true
    prospectId?: true
    type?: true
    subject?: true
    description?: true
    scheduledAt?: true
    completedAt?: true
    outcome?: true
    nextAction?: true
    createdBy?: true
    createdAt?: true
  }

  export type ProspectActivityCountAggregateInputType = {
    id?: true
    prospectId?: true
    type?: true
    subject?: true
    description?: true
    scheduledAt?: true
    completedAt?: true
    outcome?: true
    nextAction?: true
    createdBy?: true
    createdAt?: true
    _all?: true
  }

  export type ProspectActivityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProspectActivity to aggregate.
     */
    where?: ProspectActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProspectActivities to fetch.
     */
    orderBy?: ProspectActivityOrderByWithRelationInput | ProspectActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProspectActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProspectActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProspectActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProspectActivities
    **/
    _count?: true | ProspectActivityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProspectActivityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProspectActivitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProspectActivityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProspectActivityMaxAggregateInputType
  }

  export type GetProspectActivityAggregateType<T extends ProspectActivityAggregateArgs> = {
        [P in keyof T & keyof AggregateProspectActivity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProspectActivity[P]>
      : GetScalarType<T[P], AggregateProspectActivity[P]>
  }




  export type ProspectActivityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProspectActivityWhereInput
    orderBy?: ProspectActivityOrderByWithAggregationInput | ProspectActivityOrderByWithAggregationInput[]
    by: ProspectActivityScalarFieldEnum[] | ProspectActivityScalarFieldEnum
    having?: ProspectActivityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProspectActivityCountAggregateInputType | true
    _avg?: ProspectActivityAvgAggregateInputType
    _sum?: ProspectActivitySumAggregateInputType
    _min?: ProspectActivityMinAggregateInputType
    _max?: ProspectActivityMaxAggregateInputType
  }

  export type ProspectActivityGroupByOutputType = {
    id: number
    prospectId: number
    type: string
    subject: string | null
    description: string | null
    scheduledAt: Date | null
    completedAt: Date | null
    outcome: string | null
    nextAction: string | null
    createdBy: number
    createdAt: Date
    _count: ProspectActivityCountAggregateOutputType | null
    _avg: ProspectActivityAvgAggregateOutputType | null
    _sum: ProspectActivitySumAggregateOutputType | null
    _min: ProspectActivityMinAggregateOutputType | null
    _max: ProspectActivityMaxAggregateOutputType | null
  }

  type GetProspectActivityGroupByPayload<T extends ProspectActivityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProspectActivityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProspectActivityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProspectActivityGroupByOutputType[P]>
            : GetScalarType<T[P], ProspectActivityGroupByOutputType[P]>
        }
      >
    >


  export type ProspectActivitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    prospectId?: boolean
    type?: boolean
    subject?: boolean
    description?: boolean
    scheduledAt?: boolean
    completedAt?: boolean
    outcome?: boolean
    nextAction?: boolean
    createdBy?: boolean
    createdAt?: boolean
    prospect?: boolean | ProspectDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prospectActivity"]>

  export type ProspectActivitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    prospectId?: boolean
    type?: boolean
    subject?: boolean
    description?: boolean
    scheduledAt?: boolean
    completedAt?: boolean
    outcome?: boolean
    nextAction?: boolean
    createdBy?: boolean
    createdAt?: boolean
    prospect?: boolean | ProspectDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prospectActivity"]>

  export type ProspectActivitySelectScalar = {
    id?: boolean
    prospectId?: boolean
    type?: boolean
    subject?: boolean
    description?: boolean
    scheduledAt?: boolean
    completedAt?: boolean
    outcome?: boolean
    nextAction?: boolean
    createdBy?: boolean
    createdAt?: boolean
  }

  export type ProspectActivityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prospect?: boolean | ProspectDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProspectActivityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prospect?: boolean | ProspectDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProspectActivityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProspectActivity"
    objects: {
      prospect: Prisma.$ProspectPayload<ExtArgs>
      creator: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      prospectId: number
      type: string
      subject: string | null
      description: string | null
      scheduledAt: Date | null
      completedAt: Date | null
      outcome: string | null
      nextAction: string | null
      createdBy: number
      createdAt: Date
    }, ExtArgs["result"]["prospectActivity"]>
    composites: {}
  }

  type ProspectActivityGetPayload<S extends boolean | null | undefined | ProspectActivityDefaultArgs> = $Result.GetResult<Prisma.$ProspectActivityPayload, S>

  type ProspectActivityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProspectActivityFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProspectActivityCountAggregateInputType | true
    }

  export interface ProspectActivityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProspectActivity'], meta: { name: 'ProspectActivity' } }
    /**
     * Find zero or one ProspectActivity that matches the filter.
     * @param {ProspectActivityFindUniqueArgs} args - Arguments to find a ProspectActivity
     * @example
     * // Get one ProspectActivity
     * const prospectActivity = await prisma.prospectActivity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProspectActivityFindUniqueArgs>(args: SelectSubset<T, ProspectActivityFindUniqueArgs<ExtArgs>>): Prisma__ProspectActivityClient<$Result.GetResult<Prisma.$ProspectActivityPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProspectActivity that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProspectActivityFindUniqueOrThrowArgs} args - Arguments to find a ProspectActivity
     * @example
     * // Get one ProspectActivity
     * const prospectActivity = await prisma.prospectActivity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProspectActivityFindUniqueOrThrowArgs>(args: SelectSubset<T, ProspectActivityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProspectActivityClient<$Result.GetResult<Prisma.$ProspectActivityPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProspectActivity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProspectActivityFindFirstArgs} args - Arguments to find a ProspectActivity
     * @example
     * // Get one ProspectActivity
     * const prospectActivity = await prisma.prospectActivity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProspectActivityFindFirstArgs>(args?: SelectSubset<T, ProspectActivityFindFirstArgs<ExtArgs>>): Prisma__ProspectActivityClient<$Result.GetResult<Prisma.$ProspectActivityPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProspectActivity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProspectActivityFindFirstOrThrowArgs} args - Arguments to find a ProspectActivity
     * @example
     * // Get one ProspectActivity
     * const prospectActivity = await prisma.prospectActivity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProspectActivityFindFirstOrThrowArgs>(args?: SelectSubset<T, ProspectActivityFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProspectActivityClient<$Result.GetResult<Prisma.$ProspectActivityPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProspectActivities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProspectActivityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProspectActivities
     * const prospectActivities = await prisma.prospectActivity.findMany()
     * 
     * // Get first 10 ProspectActivities
     * const prospectActivities = await prisma.prospectActivity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const prospectActivityWithIdOnly = await prisma.prospectActivity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProspectActivityFindManyArgs>(args?: SelectSubset<T, ProspectActivityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProspectActivityPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProspectActivity.
     * @param {ProspectActivityCreateArgs} args - Arguments to create a ProspectActivity.
     * @example
     * // Create one ProspectActivity
     * const ProspectActivity = await prisma.prospectActivity.create({
     *   data: {
     *     // ... data to create a ProspectActivity
     *   }
     * })
     * 
     */
    create<T extends ProspectActivityCreateArgs>(args: SelectSubset<T, ProspectActivityCreateArgs<ExtArgs>>): Prisma__ProspectActivityClient<$Result.GetResult<Prisma.$ProspectActivityPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProspectActivities.
     * @param {ProspectActivityCreateManyArgs} args - Arguments to create many ProspectActivities.
     * @example
     * // Create many ProspectActivities
     * const prospectActivity = await prisma.prospectActivity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProspectActivityCreateManyArgs>(args?: SelectSubset<T, ProspectActivityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProspectActivities and returns the data saved in the database.
     * @param {ProspectActivityCreateManyAndReturnArgs} args - Arguments to create many ProspectActivities.
     * @example
     * // Create many ProspectActivities
     * const prospectActivity = await prisma.prospectActivity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProspectActivities and only return the `id`
     * const prospectActivityWithIdOnly = await prisma.prospectActivity.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProspectActivityCreateManyAndReturnArgs>(args?: SelectSubset<T, ProspectActivityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProspectActivityPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProspectActivity.
     * @param {ProspectActivityDeleteArgs} args - Arguments to delete one ProspectActivity.
     * @example
     * // Delete one ProspectActivity
     * const ProspectActivity = await prisma.prospectActivity.delete({
     *   where: {
     *     // ... filter to delete one ProspectActivity
     *   }
     * })
     * 
     */
    delete<T extends ProspectActivityDeleteArgs>(args: SelectSubset<T, ProspectActivityDeleteArgs<ExtArgs>>): Prisma__ProspectActivityClient<$Result.GetResult<Prisma.$ProspectActivityPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProspectActivity.
     * @param {ProspectActivityUpdateArgs} args - Arguments to update one ProspectActivity.
     * @example
     * // Update one ProspectActivity
     * const prospectActivity = await prisma.prospectActivity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProspectActivityUpdateArgs>(args: SelectSubset<T, ProspectActivityUpdateArgs<ExtArgs>>): Prisma__ProspectActivityClient<$Result.GetResult<Prisma.$ProspectActivityPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProspectActivities.
     * @param {ProspectActivityDeleteManyArgs} args - Arguments to filter ProspectActivities to delete.
     * @example
     * // Delete a few ProspectActivities
     * const { count } = await prisma.prospectActivity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProspectActivityDeleteManyArgs>(args?: SelectSubset<T, ProspectActivityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProspectActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProspectActivityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProspectActivities
     * const prospectActivity = await prisma.prospectActivity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProspectActivityUpdateManyArgs>(args: SelectSubset<T, ProspectActivityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProspectActivity.
     * @param {ProspectActivityUpsertArgs} args - Arguments to update or create a ProspectActivity.
     * @example
     * // Update or create a ProspectActivity
     * const prospectActivity = await prisma.prospectActivity.upsert({
     *   create: {
     *     // ... data to create a ProspectActivity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProspectActivity we want to update
     *   }
     * })
     */
    upsert<T extends ProspectActivityUpsertArgs>(args: SelectSubset<T, ProspectActivityUpsertArgs<ExtArgs>>): Prisma__ProspectActivityClient<$Result.GetResult<Prisma.$ProspectActivityPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProspectActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProspectActivityCountArgs} args - Arguments to filter ProspectActivities to count.
     * @example
     * // Count the number of ProspectActivities
     * const count = await prisma.prospectActivity.count({
     *   where: {
     *     // ... the filter for the ProspectActivities we want to count
     *   }
     * })
    **/
    count<T extends ProspectActivityCountArgs>(
      args?: Subset<T, ProspectActivityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProspectActivityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProspectActivity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProspectActivityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProspectActivityAggregateArgs>(args: Subset<T, ProspectActivityAggregateArgs>): Prisma.PrismaPromise<GetProspectActivityAggregateType<T>>

    /**
     * Group by ProspectActivity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProspectActivityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProspectActivityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProspectActivityGroupByArgs['orderBy'] }
        : { orderBy?: ProspectActivityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProspectActivityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProspectActivityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProspectActivity model
   */
  readonly fields: ProspectActivityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProspectActivity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProspectActivityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    prospect<T extends ProspectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProspectDefaultArgs<ExtArgs>>): Prisma__ProspectClient<$Result.GetResult<Prisma.$ProspectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProspectActivity model
   */ 
  interface ProspectActivityFieldRefs {
    readonly id: FieldRef<"ProspectActivity", 'Int'>
    readonly prospectId: FieldRef<"ProspectActivity", 'Int'>
    readonly type: FieldRef<"ProspectActivity", 'String'>
    readonly subject: FieldRef<"ProspectActivity", 'String'>
    readonly description: FieldRef<"ProspectActivity", 'String'>
    readonly scheduledAt: FieldRef<"ProspectActivity", 'DateTime'>
    readonly completedAt: FieldRef<"ProspectActivity", 'DateTime'>
    readonly outcome: FieldRef<"ProspectActivity", 'String'>
    readonly nextAction: FieldRef<"ProspectActivity", 'String'>
    readonly createdBy: FieldRef<"ProspectActivity", 'Int'>
    readonly createdAt: FieldRef<"ProspectActivity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProspectActivity findUnique
   */
  export type ProspectActivityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProspectActivity
     */
    select?: ProspectActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProspectActivityInclude<ExtArgs> | null
    /**
     * Filter, which ProspectActivity to fetch.
     */
    where: ProspectActivityWhereUniqueInput
  }

  /**
   * ProspectActivity findUniqueOrThrow
   */
  export type ProspectActivityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProspectActivity
     */
    select?: ProspectActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProspectActivityInclude<ExtArgs> | null
    /**
     * Filter, which ProspectActivity to fetch.
     */
    where: ProspectActivityWhereUniqueInput
  }

  /**
   * ProspectActivity findFirst
   */
  export type ProspectActivityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProspectActivity
     */
    select?: ProspectActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProspectActivityInclude<ExtArgs> | null
    /**
     * Filter, which ProspectActivity to fetch.
     */
    where?: ProspectActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProspectActivities to fetch.
     */
    orderBy?: ProspectActivityOrderByWithRelationInput | ProspectActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProspectActivities.
     */
    cursor?: ProspectActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProspectActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProspectActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProspectActivities.
     */
    distinct?: ProspectActivityScalarFieldEnum | ProspectActivityScalarFieldEnum[]
  }

  /**
   * ProspectActivity findFirstOrThrow
   */
  export type ProspectActivityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProspectActivity
     */
    select?: ProspectActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProspectActivityInclude<ExtArgs> | null
    /**
     * Filter, which ProspectActivity to fetch.
     */
    where?: ProspectActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProspectActivities to fetch.
     */
    orderBy?: ProspectActivityOrderByWithRelationInput | ProspectActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProspectActivities.
     */
    cursor?: ProspectActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProspectActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProspectActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProspectActivities.
     */
    distinct?: ProspectActivityScalarFieldEnum | ProspectActivityScalarFieldEnum[]
  }

  /**
   * ProspectActivity findMany
   */
  export type ProspectActivityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProspectActivity
     */
    select?: ProspectActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProspectActivityInclude<ExtArgs> | null
    /**
     * Filter, which ProspectActivities to fetch.
     */
    where?: ProspectActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProspectActivities to fetch.
     */
    orderBy?: ProspectActivityOrderByWithRelationInput | ProspectActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProspectActivities.
     */
    cursor?: ProspectActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProspectActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProspectActivities.
     */
    skip?: number
    distinct?: ProspectActivityScalarFieldEnum | ProspectActivityScalarFieldEnum[]
  }

  /**
   * ProspectActivity create
   */
  export type ProspectActivityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProspectActivity
     */
    select?: ProspectActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProspectActivityInclude<ExtArgs> | null
    /**
     * The data needed to create a ProspectActivity.
     */
    data: XOR<ProspectActivityCreateInput, ProspectActivityUncheckedCreateInput>
  }

  /**
   * ProspectActivity createMany
   */
  export type ProspectActivityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProspectActivities.
     */
    data: ProspectActivityCreateManyInput | ProspectActivityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProspectActivity createManyAndReturn
   */
  export type ProspectActivityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProspectActivity
     */
    select?: ProspectActivitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProspectActivities.
     */
    data: ProspectActivityCreateManyInput | ProspectActivityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProspectActivityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProspectActivity update
   */
  export type ProspectActivityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProspectActivity
     */
    select?: ProspectActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProspectActivityInclude<ExtArgs> | null
    /**
     * The data needed to update a ProspectActivity.
     */
    data: XOR<ProspectActivityUpdateInput, ProspectActivityUncheckedUpdateInput>
    /**
     * Choose, which ProspectActivity to update.
     */
    where: ProspectActivityWhereUniqueInput
  }

  /**
   * ProspectActivity updateMany
   */
  export type ProspectActivityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProspectActivities.
     */
    data: XOR<ProspectActivityUpdateManyMutationInput, ProspectActivityUncheckedUpdateManyInput>
    /**
     * Filter which ProspectActivities to update
     */
    where?: ProspectActivityWhereInput
  }

  /**
   * ProspectActivity upsert
   */
  export type ProspectActivityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProspectActivity
     */
    select?: ProspectActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProspectActivityInclude<ExtArgs> | null
    /**
     * The filter to search for the ProspectActivity to update in case it exists.
     */
    where: ProspectActivityWhereUniqueInput
    /**
     * In case the ProspectActivity found by the `where` argument doesn't exist, create a new ProspectActivity with this data.
     */
    create: XOR<ProspectActivityCreateInput, ProspectActivityUncheckedCreateInput>
    /**
     * In case the ProspectActivity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProspectActivityUpdateInput, ProspectActivityUncheckedUpdateInput>
  }

  /**
   * ProspectActivity delete
   */
  export type ProspectActivityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProspectActivity
     */
    select?: ProspectActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProspectActivityInclude<ExtArgs> | null
    /**
     * Filter which ProspectActivity to delete.
     */
    where: ProspectActivityWhereUniqueInput
  }

  /**
   * ProspectActivity deleteMany
   */
  export type ProspectActivityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProspectActivities to delete
     */
    where?: ProspectActivityWhereInput
  }

  /**
   * ProspectActivity without action
   */
  export type ProspectActivityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProspectActivity
     */
    select?: ProspectActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProspectActivityInclude<ExtArgs> | null
  }


  /**
   * Model Loan
   */

  export type AggregateLoan = {
    _count: LoanCountAggregateOutputType | null
    _avg: LoanAvgAggregateOutputType | null
    _sum: LoanSumAggregateOutputType | null
    _min: LoanMinAggregateOutputType | null
    _max: LoanMaxAggregateOutputType | null
  }

  export type LoanAvgAggregateOutputType = {
    id: number | null
    employeeId: number | null
    amount: number | null
    interestRate: number | null
    monthlyPayment: number | null
    remainingAmount: number | null
    createdBy: number | null
  }

  export type LoanSumAggregateOutputType = {
    id: number | null
    employeeId: number | null
    amount: number | null
    interestRate: number | null
    monthlyPayment: number | null
    remainingAmount: number | null
    createdBy: number | null
  }

  export type LoanMinAggregateOutputType = {
    id: number | null
    loanNumber: string | null
    employeeId: number | null
    amount: number | null
    interestRate: number | null
    monthlyPayment: number | null
    remainingAmount: number | null
    startDate: Date | null
    endDate: Date | null
    purpose: string | null
    status: $Enums.LoanStatus | null
    notes: string | null
    createdBy: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LoanMaxAggregateOutputType = {
    id: number | null
    loanNumber: string | null
    employeeId: number | null
    amount: number | null
    interestRate: number | null
    monthlyPayment: number | null
    remainingAmount: number | null
    startDate: Date | null
    endDate: Date | null
    purpose: string | null
    status: $Enums.LoanStatus | null
    notes: string | null
    createdBy: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LoanCountAggregateOutputType = {
    id: number
    loanNumber: number
    employeeId: number
    amount: number
    interestRate: number
    monthlyPayment: number
    remainingAmount: number
    startDate: number
    endDate: number
    purpose: number
    status: number
    notes: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LoanAvgAggregateInputType = {
    id?: true
    employeeId?: true
    amount?: true
    interestRate?: true
    monthlyPayment?: true
    remainingAmount?: true
    createdBy?: true
  }

  export type LoanSumAggregateInputType = {
    id?: true
    employeeId?: true
    amount?: true
    interestRate?: true
    monthlyPayment?: true
    remainingAmount?: true
    createdBy?: true
  }

  export type LoanMinAggregateInputType = {
    id?: true
    loanNumber?: true
    employeeId?: true
    amount?: true
    interestRate?: true
    monthlyPayment?: true
    remainingAmount?: true
    startDate?: true
    endDate?: true
    purpose?: true
    status?: true
    notes?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LoanMaxAggregateInputType = {
    id?: true
    loanNumber?: true
    employeeId?: true
    amount?: true
    interestRate?: true
    monthlyPayment?: true
    remainingAmount?: true
    startDate?: true
    endDate?: true
    purpose?: true
    status?: true
    notes?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LoanCountAggregateInputType = {
    id?: true
    loanNumber?: true
    employeeId?: true
    amount?: true
    interestRate?: true
    monthlyPayment?: true
    remainingAmount?: true
    startDate?: true
    endDate?: true
    purpose?: true
    status?: true
    notes?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LoanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Loan to aggregate.
     */
    where?: LoanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Loans to fetch.
     */
    orderBy?: LoanOrderByWithRelationInput | LoanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LoanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Loans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Loans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Loans
    **/
    _count?: true | LoanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LoanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LoanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LoanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LoanMaxAggregateInputType
  }

  export type GetLoanAggregateType<T extends LoanAggregateArgs> = {
        [P in keyof T & keyof AggregateLoan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLoan[P]>
      : GetScalarType<T[P], AggregateLoan[P]>
  }




  export type LoanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LoanWhereInput
    orderBy?: LoanOrderByWithAggregationInput | LoanOrderByWithAggregationInput[]
    by: LoanScalarFieldEnum[] | LoanScalarFieldEnum
    having?: LoanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LoanCountAggregateInputType | true
    _avg?: LoanAvgAggregateInputType
    _sum?: LoanSumAggregateInputType
    _min?: LoanMinAggregateInputType
    _max?: LoanMaxAggregateInputType
  }

  export type LoanGroupByOutputType = {
    id: number
    loanNumber: string
    employeeId: number
    amount: number
    interestRate: number
    monthlyPayment: number
    remainingAmount: number
    startDate: Date
    endDate: Date
    purpose: string | null
    status: $Enums.LoanStatus
    notes: string | null
    createdBy: number
    createdAt: Date
    updatedAt: Date
    _count: LoanCountAggregateOutputType | null
    _avg: LoanAvgAggregateOutputType | null
    _sum: LoanSumAggregateOutputType | null
    _min: LoanMinAggregateOutputType | null
    _max: LoanMaxAggregateOutputType | null
  }

  type GetLoanGroupByPayload<T extends LoanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LoanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LoanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LoanGroupByOutputType[P]>
            : GetScalarType<T[P], LoanGroupByOutputType[P]>
        }
      >
    >


  export type LoanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    loanNumber?: boolean
    employeeId?: boolean
    amount?: boolean
    interestRate?: boolean
    monthlyPayment?: boolean
    remainingAmount?: boolean
    startDate?: boolean
    endDate?: boolean
    purpose?: boolean
    status?: boolean
    notes?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    payments?: boolean | Loan$paymentsArgs<ExtArgs>
    _count?: boolean | LoanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["loan"]>

  export type LoanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    loanNumber?: boolean
    employeeId?: boolean
    amount?: boolean
    interestRate?: boolean
    monthlyPayment?: boolean
    remainingAmount?: boolean
    startDate?: boolean
    endDate?: boolean
    purpose?: boolean
    status?: boolean
    notes?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["loan"]>

  export type LoanSelectScalar = {
    id?: boolean
    loanNumber?: boolean
    employeeId?: boolean
    amount?: boolean
    interestRate?: boolean
    monthlyPayment?: boolean
    remainingAmount?: boolean
    startDate?: boolean
    endDate?: boolean
    purpose?: boolean
    status?: boolean
    notes?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LoanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    payments?: boolean | Loan$paymentsArgs<ExtArgs>
    _count?: boolean | LoanCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LoanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }

  export type $LoanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Loan"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
      payments: Prisma.$LoanPaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      loanNumber: string
      employeeId: number
      amount: number
      interestRate: number
      monthlyPayment: number
      remainingAmount: number
      startDate: Date
      endDate: Date
      purpose: string | null
      status: $Enums.LoanStatus
      notes: string | null
      createdBy: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["loan"]>
    composites: {}
  }

  type LoanGetPayload<S extends boolean | null | undefined | LoanDefaultArgs> = $Result.GetResult<Prisma.$LoanPayload, S>

  type LoanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LoanFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LoanCountAggregateInputType | true
    }

  export interface LoanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Loan'], meta: { name: 'Loan' } }
    /**
     * Find zero or one Loan that matches the filter.
     * @param {LoanFindUniqueArgs} args - Arguments to find a Loan
     * @example
     * // Get one Loan
     * const loan = await prisma.loan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LoanFindUniqueArgs>(args: SelectSubset<T, LoanFindUniqueArgs<ExtArgs>>): Prisma__LoanClient<$Result.GetResult<Prisma.$LoanPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Loan that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LoanFindUniqueOrThrowArgs} args - Arguments to find a Loan
     * @example
     * // Get one Loan
     * const loan = await prisma.loan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LoanFindUniqueOrThrowArgs>(args: SelectSubset<T, LoanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LoanClient<$Result.GetResult<Prisma.$LoanPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Loan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanFindFirstArgs} args - Arguments to find a Loan
     * @example
     * // Get one Loan
     * const loan = await prisma.loan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LoanFindFirstArgs>(args?: SelectSubset<T, LoanFindFirstArgs<ExtArgs>>): Prisma__LoanClient<$Result.GetResult<Prisma.$LoanPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Loan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanFindFirstOrThrowArgs} args - Arguments to find a Loan
     * @example
     * // Get one Loan
     * const loan = await prisma.loan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LoanFindFirstOrThrowArgs>(args?: SelectSubset<T, LoanFindFirstOrThrowArgs<ExtArgs>>): Prisma__LoanClient<$Result.GetResult<Prisma.$LoanPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Loans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Loans
     * const loans = await prisma.loan.findMany()
     * 
     * // Get first 10 Loans
     * const loans = await prisma.loan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const loanWithIdOnly = await prisma.loan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LoanFindManyArgs>(args?: SelectSubset<T, LoanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoanPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Loan.
     * @param {LoanCreateArgs} args - Arguments to create a Loan.
     * @example
     * // Create one Loan
     * const Loan = await prisma.loan.create({
     *   data: {
     *     // ... data to create a Loan
     *   }
     * })
     * 
     */
    create<T extends LoanCreateArgs>(args: SelectSubset<T, LoanCreateArgs<ExtArgs>>): Prisma__LoanClient<$Result.GetResult<Prisma.$LoanPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Loans.
     * @param {LoanCreateManyArgs} args - Arguments to create many Loans.
     * @example
     * // Create many Loans
     * const loan = await prisma.loan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LoanCreateManyArgs>(args?: SelectSubset<T, LoanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Loans and returns the data saved in the database.
     * @param {LoanCreateManyAndReturnArgs} args - Arguments to create many Loans.
     * @example
     * // Create many Loans
     * const loan = await prisma.loan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Loans and only return the `id`
     * const loanWithIdOnly = await prisma.loan.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LoanCreateManyAndReturnArgs>(args?: SelectSubset<T, LoanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoanPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Loan.
     * @param {LoanDeleteArgs} args - Arguments to delete one Loan.
     * @example
     * // Delete one Loan
     * const Loan = await prisma.loan.delete({
     *   where: {
     *     // ... filter to delete one Loan
     *   }
     * })
     * 
     */
    delete<T extends LoanDeleteArgs>(args: SelectSubset<T, LoanDeleteArgs<ExtArgs>>): Prisma__LoanClient<$Result.GetResult<Prisma.$LoanPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Loan.
     * @param {LoanUpdateArgs} args - Arguments to update one Loan.
     * @example
     * // Update one Loan
     * const loan = await prisma.loan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LoanUpdateArgs>(args: SelectSubset<T, LoanUpdateArgs<ExtArgs>>): Prisma__LoanClient<$Result.GetResult<Prisma.$LoanPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Loans.
     * @param {LoanDeleteManyArgs} args - Arguments to filter Loans to delete.
     * @example
     * // Delete a few Loans
     * const { count } = await prisma.loan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LoanDeleteManyArgs>(args?: SelectSubset<T, LoanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Loans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Loans
     * const loan = await prisma.loan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LoanUpdateManyArgs>(args: SelectSubset<T, LoanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Loan.
     * @param {LoanUpsertArgs} args - Arguments to update or create a Loan.
     * @example
     * // Update or create a Loan
     * const loan = await prisma.loan.upsert({
     *   create: {
     *     // ... data to create a Loan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Loan we want to update
     *   }
     * })
     */
    upsert<T extends LoanUpsertArgs>(args: SelectSubset<T, LoanUpsertArgs<ExtArgs>>): Prisma__LoanClient<$Result.GetResult<Prisma.$LoanPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Loans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanCountArgs} args - Arguments to filter Loans to count.
     * @example
     * // Count the number of Loans
     * const count = await prisma.loan.count({
     *   where: {
     *     // ... the filter for the Loans we want to count
     *   }
     * })
    **/
    count<T extends LoanCountArgs>(
      args?: Subset<T, LoanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LoanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Loan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LoanAggregateArgs>(args: Subset<T, LoanAggregateArgs>): Prisma.PrismaPromise<GetLoanAggregateType<T>>

    /**
     * Group by Loan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LoanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LoanGroupByArgs['orderBy'] }
        : { orderBy?: LoanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LoanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLoanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Loan model
   */
  readonly fields: LoanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Loan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LoanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    payments<T extends Loan$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Loan$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoanPaymentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Loan model
   */ 
  interface LoanFieldRefs {
    readonly id: FieldRef<"Loan", 'Int'>
    readonly loanNumber: FieldRef<"Loan", 'String'>
    readonly employeeId: FieldRef<"Loan", 'Int'>
    readonly amount: FieldRef<"Loan", 'Float'>
    readonly interestRate: FieldRef<"Loan", 'Float'>
    readonly monthlyPayment: FieldRef<"Loan", 'Float'>
    readonly remainingAmount: FieldRef<"Loan", 'Float'>
    readonly startDate: FieldRef<"Loan", 'DateTime'>
    readonly endDate: FieldRef<"Loan", 'DateTime'>
    readonly purpose: FieldRef<"Loan", 'String'>
    readonly status: FieldRef<"Loan", 'LoanStatus'>
    readonly notes: FieldRef<"Loan", 'String'>
    readonly createdBy: FieldRef<"Loan", 'Int'>
    readonly createdAt: FieldRef<"Loan", 'DateTime'>
    readonly updatedAt: FieldRef<"Loan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Loan findUnique
   */
  export type LoanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loan
     */
    select?: LoanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanInclude<ExtArgs> | null
    /**
     * Filter, which Loan to fetch.
     */
    where: LoanWhereUniqueInput
  }

  /**
   * Loan findUniqueOrThrow
   */
  export type LoanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loan
     */
    select?: LoanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanInclude<ExtArgs> | null
    /**
     * Filter, which Loan to fetch.
     */
    where: LoanWhereUniqueInput
  }

  /**
   * Loan findFirst
   */
  export type LoanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loan
     */
    select?: LoanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanInclude<ExtArgs> | null
    /**
     * Filter, which Loan to fetch.
     */
    where?: LoanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Loans to fetch.
     */
    orderBy?: LoanOrderByWithRelationInput | LoanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Loans.
     */
    cursor?: LoanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Loans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Loans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Loans.
     */
    distinct?: LoanScalarFieldEnum | LoanScalarFieldEnum[]
  }

  /**
   * Loan findFirstOrThrow
   */
  export type LoanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loan
     */
    select?: LoanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanInclude<ExtArgs> | null
    /**
     * Filter, which Loan to fetch.
     */
    where?: LoanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Loans to fetch.
     */
    orderBy?: LoanOrderByWithRelationInput | LoanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Loans.
     */
    cursor?: LoanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Loans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Loans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Loans.
     */
    distinct?: LoanScalarFieldEnum | LoanScalarFieldEnum[]
  }

  /**
   * Loan findMany
   */
  export type LoanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loan
     */
    select?: LoanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanInclude<ExtArgs> | null
    /**
     * Filter, which Loans to fetch.
     */
    where?: LoanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Loans to fetch.
     */
    orderBy?: LoanOrderByWithRelationInput | LoanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Loans.
     */
    cursor?: LoanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Loans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Loans.
     */
    skip?: number
    distinct?: LoanScalarFieldEnum | LoanScalarFieldEnum[]
  }

  /**
   * Loan create
   */
  export type LoanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loan
     */
    select?: LoanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanInclude<ExtArgs> | null
    /**
     * The data needed to create a Loan.
     */
    data: XOR<LoanCreateInput, LoanUncheckedCreateInput>
  }

  /**
   * Loan createMany
   */
  export type LoanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Loans.
     */
    data: LoanCreateManyInput | LoanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Loan createManyAndReturn
   */
  export type LoanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loan
     */
    select?: LoanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Loans.
     */
    data: LoanCreateManyInput | LoanCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Loan update
   */
  export type LoanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loan
     */
    select?: LoanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanInclude<ExtArgs> | null
    /**
     * The data needed to update a Loan.
     */
    data: XOR<LoanUpdateInput, LoanUncheckedUpdateInput>
    /**
     * Choose, which Loan to update.
     */
    where: LoanWhereUniqueInput
  }

  /**
   * Loan updateMany
   */
  export type LoanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Loans.
     */
    data: XOR<LoanUpdateManyMutationInput, LoanUncheckedUpdateManyInput>
    /**
     * Filter which Loans to update
     */
    where?: LoanWhereInput
  }

  /**
   * Loan upsert
   */
  export type LoanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loan
     */
    select?: LoanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanInclude<ExtArgs> | null
    /**
     * The filter to search for the Loan to update in case it exists.
     */
    where: LoanWhereUniqueInput
    /**
     * In case the Loan found by the `where` argument doesn't exist, create a new Loan with this data.
     */
    create: XOR<LoanCreateInput, LoanUncheckedCreateInput>
    /**
     * In case the Loan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LoanUpdateInput, LoanUncheckedUpdateInput>
  }

  /**
   * Loan delete
   */
  export type LoanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loan
     */
    select?: LoanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanInclude<ExtArgs> | null
    /**
     * Filter which Loan to delete.
     */
    where: LoanWhereUniqueInput
  }

  /**
   * Loan deleteMany
   */
  export type LoanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Loans to delete
     */
    where?: LoanWhereInput
  }

  /**
   * Loan.payments
   */
  export type Loan$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanPayment
     */
    select?: LoanPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanPaymentInclude<ExtArgs> | null
    where?: LoanPaymentWhereInput
    orderBy?: LoanPaymentOrderByWithRelationInput | LoanPaymentOrderByWithRelationInput[]
    cursor?: LoanPaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LoanPaymentScalarFieldEnum | LoanPaymentScalarFieldEnum[]
  }

  /**
   * Loan without action
   */
  export type LoanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loan
     */
    select?: LoanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanInclude<ExtArgs> | null
  }


  /**
   * Model Specialite
   */

  export type AggregateSpecialite = {
    _count: SpecialiteCountAggregateOutputType | null
    _avg: SpecialiteAvgAggregateOutputType | null
    _sum: SpecialiteSumAggregateOutputType | null
    _min: SpecialiteMinAggregateOutputType | null
    _max: SpecialiteMaxAggregateOutputType | null
  }

  export type SpecialiteAvgAggregateOutputType = {
    id: number | null
  }

  export type SpecialiteSumAggregateOutputType = {
    id: number | null
  }

  export type SpecialiteMinAggregateOutputType = {
    id: number | null
    libelle: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SpecialiteMaxAggregateOutputType = {
    id: number | null
    libelle: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SpecialiteCountAggregateOutputType = {
    id: number
    libelle: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SpecialiteAvgAggregateInputType = {
    id?: true
  }

  export type SpecialiteSumAggregateInputType = {
    id?: true
  }

  export type SpecialiteMinAggregateInputType = {
    id?: true
    libelle?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SpecialiteMaxAggregateInputType = {
    id?: true
    libelle?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SpecialiteCountAggregateInputType = {
    id?: true
    libelle?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SpecialiteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Specialite to aggregate.
     */
    where?: SpecialiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Specialites to fetch.
     */
    orderBy?: SpecialiteOrderByWithRelationInput | SpecialiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SpecialiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Specialites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Specialites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Specialites
    **/
    _count?: true | SpecialiteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SpecialiteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SpecialiteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpecialiteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpecialiteMaxAggregateInputType
  }

  export type GetSpecialiteAggregateType<T extends SpecialiteAggregateArgs> = {
        [P in keyof T & keyof AggregateSpecialite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpecialite[P]>
      : GetScalarType<T[P], AggregateSpecialite[P]>
  }




  export type SpecialiteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpecialiteWhereInput
    orderBy?: SpecialiteOrderByWithAggregationInput | SpecialiteOrderByWithAggregationInput[]
    by: SpecialiteScalarFieldEnum[] | SpecialiteScalarFieldEnum
    having?: SpecialiteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpecialiteCountAggregateInputType | true
    _avg?: SpecialiteAvgAggregateInputType
    _sum?: SpecialiteSumAggregateInputType
    _min?: SpecialiteMinAggregateInputType
    _max?: SpecialiteMaxAggregateInputType
  }

  export type SpecialiteGroupByOutputType = {
    id: number
    libelle: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: SpecialiteCountAggregateOutputType | null
    _avg: SpecialiteAvgAggregateOutputType | null
    _sum: SpecialiteSumAggregateOutputType | null
    _min: SpecialiteMinAggregateOutputType | null
    _max: SpecialiteMaxAggregateOutputType | null
  }

  type GetSpecialiteGroupByPayload<T extends SpecialiteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SpecialiteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpecialiteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpecialiteGroupByOutputType[P]>
            : GetScalarType<T[P], SpecialiteGroupByOutputType[P]>
        }
      >
    >


  export type SpecialiteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    libelle?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    techniciens?: boolean | Specialite$techniciensArgs<ExtArgs>
    _count?: boolean | SpecialiteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["specialite"]>

  export type SpecialiteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    libelle?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["specialite"]>

  export type SpecialiteSelectScalar = {
    id?: boolean
    libelle?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SpecialiteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    techniciens?: boolean | Specialite$techniciensArgs<ExtArgs>
    _count?: boolean | SpecialiteCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SpecialiteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SpecialitePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Specialite"
    objects: {
      techniciens: Prisma.$TechnicienPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      libelle: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["specialite"]>
    composites: {}
  }

  type SpecialiteGetPayload<S extends boolean | null | undefined | SpecialiteDefaultArgs> = $Result.GetResult<Prisma.$SpecialitePayload, S>

  type SpecialiteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SpecialiteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SpecialiteCountAggregateInputType | true
    }

  export interface SpecialiteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Specialite'], meta: { name: 'Specialite' } }
    /**
     * Find zero or one Specialite that matches the filter.
     * @param {SpecialiteFindUniqueArgs} args - Arguments to find a Specialite
     * @example
     * // Get one Specialite
     * const specialite = await prisma.specialite.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SpecialiteFindUniqueArgs>(args: SelectSubset<T, SpecialiteFindUniqueArgs<ExtArgs>>): Prisma__SpecialiteClient<$Result.GetResult<Prisma.$SpecialitePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Specialite that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SpecialiteFindUniqueOrThrowArgs} args - Arguments to find a Specialite
     * @example
     * // Get one Specialite
     * const specialite = await prisma.specialite.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SpecialiteFindUniqueOrThrowArgs>(args: SelectSubset<T, SpecialiteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SpecialiteClient<$Result.GetResult<Prisma.$SpecialitePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Specialite that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialiteFindFirstArgs} args - Arguments to find a Specialite
     * @example
     * // Get one Specialite
     * const specialite = await prisma.specialite.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SpecialiteFindFirstArgs>(args?: SelectSubset<T, SpecialiteFindFirstArgs<ExtArgs>>): Prisma__SpecialiteClient<$Result.GetResult<Prisma.$SpecialitePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Specialite that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialiteFindFirstOrThrowArgs} args - Arguments to find a Specialite
     * @example
     * // Get one Specialite
     * const specialite = await prisma.specialite.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SpecialiteFindFirstOrThrowArgs>(args?: SelectSubset<T, SpecialiteFindFirstOrThrowArgs<ExtArgs>>): Prisma__SpecialiteClient<$Result.GetResult<Prisma.$SpecialitePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Specialites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialiteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Specialites
     * const specialites = await prisma.specialite.findMany()
     * 
     * // Get first 10 Specialites
     * const specialites = await prisma.specialite.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const specialiteWithIdOnly = await prisma.specialite.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SpecialiteFindManyArgs>(args?: SelectSubset<T, SpecialiteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpecialitePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Specialite.
     * @param {SpecialiteCreateArgs} args - Arguments to create a Specialite.
     * @example
     * // Create one Specialite
     * const Specialite = await prisma.specialite.create({
     *   data: {
     *     // ... data to create a Specialite
     *   }
     * })
     * 
     */
    create<T extends SpecialiteCreateArgs>(args: SelectSubset<T, SpecialiteCreateArgs<ExtArgs>>): Prisma__SpecialiteClient<$Result.GetResult<Prisma.$SpecialitePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Specialites.
     * @param {SpecialiteCreateManyArgs} args - Arguments to create many Specialites.
     * @example
     * // Create many Specialites
     * const specialite = await prisma.specialite.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SpecialiteCreateManyArgs>(args?: SelectSubset<T, SpecialiteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Specialites and returns the data saved in the database.
     * @param {SpecialiteCreateManyAndReturnArgs} args - Arguments to create many Specialites.
     * @example
     * // Create many Specialites
     * const specialite = await prisma.specialite.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Specialites and only return the `id`
     * const specialiteWithIdOnly = await prisma.specialite.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SpecialiteCreateManyAndReturnArgs>(args?: SelectSubset<T, SpecialiteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpecialitePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Specialite.
     * @param {SpecialiteDeleteArgs} args - Arguments to delete one Specialite.
     * @example
     * // Delete one Specialite
     * const Specialite = await prisma.specialite.delete({
     *   where: {
     *     // ... filter to delete one Specialite
     *   }
     * })
     * 
     */
    delete<T extends SpecialiteDeleteArgs>(args: SelectSubset<T, SpecialiteDeleteArgs<ExtArgs>>): Prisma__SpecialiteClient<$Result.GetResult<Prisma.$SpecialitePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Specialite.
     * @param {SpecialiteUpdateArgs} args - Arguments to update one Specialite.
     * @example
     * // Update one Specialite
     * const specialite = await prisma.specialite.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SpecialiteUpdateArgs>(args: SelectSubset<T, SpecialiteUpdateArgs<ExtArgs>>): Prisma__SpecialiteClient<$Result.GetResult<Prisma.$SpecialitePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Specialites.
     * @param {SpecialiteDeleteManyArgs} args - Arguments to filter Specialites to delete.
     * @example
     * // Delete a few Specialites
     * const { count } = await prisma.specialite.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SpecialiteDeleteManyArgs>(args?: SelectSubset<T, SpecialiteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Specialites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialiteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Specialites
     * const specialite = await prisma.specialite.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SpecialiteUpdateManyArgs>(args: SelectSubset<T, SpecialiteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Specialite.
     * @param {SpecialiteUpsertArgs} args - Arguments to update or create a Specialite.
     * @example
     * // Update or create a Specialite
     * const specialite = await prisma.specialite.upsert({
     *   create: {
     *     // ... data to create a Specialite
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Specialite we want to update
     *   }
     * })
     */
    upsert<T extends SpecialiteUpsertArgs>(args: SelectSubset<T, SpecialiteUpsertArgs<ExtArgs>>): Prisma__SpecialiteClient<$Result.GetResult<Prisma.$SpecialitePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Specialites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialiteCountArgs} args - Arguments to filter Specialites to count.
     * @example
     * // Count the number of Specialites
     * const count = await prisma.specialite.count({
     *   where: {
     *     // ... the filter for the Specialites we want to count
     *   }
     * })
    **/
    count<T extends SpecialiteCountArgs>(
      args?: Subset<T, SpecialiteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpecialiteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Specialite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialiteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpecialiteAggregateArgs>(args: Subset<T, SpecialiteAggregateArgs>): Prisma.PrismaPromise<GetSpecialiteAggregateType<T>>

    /**
     * Group by Specialite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialiteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpecialiteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpecialiteGroupByArgs['orderBy'] }
        : { orderBy?: SpecialiteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpecialiteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpecialiteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Specialite model
   */
  readonly fields: SpecialiteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Specialite.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SpecialiteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    techniciens<T extends Specialite$techniciensArgs<ExtArgs> = {}>(args?: Subset<T, Specialite$techniciensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TechnicienPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Specialite model
   */ 
  interface SpecialiteFieldRefs {
    readonly id: FieldRef<"Specialite", 'Int'>
    readonly libelle: FieldRef<"Specialite", 'String'>
    readonly description: FieldRef<"Specialite", 'String'>
    readonly createdAt: FieldRef<"Specialite", 'DateTime'>
    readonly updatedAt: FieldRef<"Specialite", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Specialite findUnique
   */
  export type SpecialiteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialite
     */
    select?: SpecialiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialiteInclude<ExtArgs> | null
    /**
     * Filter, which Specialite to fetch.
     */
    where: SpecialiteWhereUniqueInput
  }

  /**
   * Specialite findUniqueOrThrow
   */
  export type SpecialiteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialite
     */
    select?: SpecialiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialiteInclude<ExtArgs> | null
    /**
     * Filter, which Specialite to fetch.
     */
    where: SpecialiteWhereUniqueInput
  }

  /**
   * Specialite findFirst
   */
  export type SpecialiteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialite
     */
    select?: SpecialiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialiteInclude<ExtArgs> | null
    /**
     * Filter, which Specialite to fetch.
     */
    where?: SpecialiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Specialites to fetch.
     */
    orderBy?: SpecialiteOrderByWithRelationInput | SpecialiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Specialites.
     */
    cursor?: SpecialiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Specialites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Specialites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Specialites.
     */
    distinct?: SpecialiteScalarFieldEnum | SpecialiteScalarFieldEnum[]
  }

  /**
   * Specialite findFirstOrThrow
   */
  export type SpecialiteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialite
     */
    select?: SpecialiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialiteInclude<ExtArgs> | null
    /**
     * Filter, which Specialite to fetch.
     */
    where?: SpecialiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Specialites to fetch.
     */
    orderBy?: SpecialiteOrderByWithRelationInput | SpecialiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Specialites.
     */
    cursor?: SpecialiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Specialites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Specialites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Specialites.
     */
    distinct?: SpecialiteScalarFieldEnum | SpecialiteScalarFieldEnum[]
  }

  /**
   * Specialite findMany
   */
  export type SpecialiteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialite
     */
    select?: SpecialiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialiteInclude<ExtArgs> | null
    /**
     * Filter, which Specialites to fetch.
     */
    where?: SpecialiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Specialites to fetch.
     */
    orderBy?: SpecialiteOrderByWithRelationInput | SpecialiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Specialites.
     */
    cursor?: SpecialiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Specialites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Specialites.
     */
    skip?: number
    distinct?: SpecialiteScalarFieldEnum | SpecialiteScalarFieldEnum[]
  }

  /**
   * Specialite create
   */
  export type SpecialiteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialite
     */
    select?: SpecialiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialiteInclude<ExtArgs> | null
    /**
     * The data needed to create a Specialite.
     */
    data: XOR<SpecialiteCreateInput, SpecialiteUncheckedCreateInput>
  }

  /**
   * Specialite createMany
   */
  export type SpecialiteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Specialites.
     */
    data: SpecialiteCreateManyInput | SpecialiteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Specialite createManyAndReturn
   */
  export type SpecialiteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialite
     */
    select?: SpecialiteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Specialites.
     */
    data: SpecialiteCreateManyInput | SpecialiteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Specialite update
   */
  export type SpecialiteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialite
     */
    select?: SpecialiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialiteInclude<ExtArgs> | null
    /**
     * The data needed to update a Specialite.
     */
    data: XOR<SpecialiteUpdateInput, SpecialiteUncheckedUpdateInput>
    /**
     * Choose, which Specialite to update.
     */
    where: SpecialiteWhereUniqueInput
  }

  /**
   * Specialite updateMany
   */
  export type SpecialiteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Specialites.
     */
    data: XOR<SpecialiteUpdateManyMutationInput, SpecialiteUncheckedUpdateManyInput>
    /**
     * Filter which Specialites to update
     */
    where?: SpecialiteWhereInput
  }

  /**
   * Specialite upsert
   */
  export type SpecialiteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialite
     */
    select?: SpecialiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialiteInclude<ExtArgs> | null
    /**
     * The filter to search for the Specialite to update in case it exists.
     */
    where: SpecialiteWhereUniqueInput
    /**
     * In case the Specialite found by the `where` argument doesn't exist, create a new Specialite with this data.
     */
    create: XOR<SpecialiteCreateInput, SpecialiteUncheckedCreateInput>
    /**
     * In case the Specialite was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SpecialiteUpdateInput, SpecialiteUncheckedUpdateInput>
  }

  /**
   * Specialite delete
   */
  export type SpecialiteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialite
     */
    select?: SpecialiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialiteInclude<ExtArgs> | null
    /**
     * Filter which Specialite to delete.
     */
    where: SpecialiteWhereUniqueInput
  }

  /**
   * Specialite deleteMany
   */
  export type SpecialiteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Specialites to delete
     */
    where?: SpecialiteWhereInput
  }

  /**
   * Specialite.techniciens
   */
  export type Specialite$techniciensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Technicien
     */
    select?: TechnicienSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicienInclude<ExtArgs> | null
    where?: TechnicienWhereInput
    orderBy?: TechnicienOrderByWithRelationInput | TechnicienOrderByWithRelationInput[]
    cursor?: TechnicienWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TechnicienScalarFieldEnum | TechnicienScalarFieldEnum[]
  }

  /**
   * Specialite without action
   */
  export type SpecialiteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialite
     */
    select?: SpecialiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialiteInclude<ExtArgs> | null
  }


  /**
   * Model Technicien
   */

  export type AggregateTechnicien = {
    _count: TechnicienCountAggregateOutputType | null
    _avg: TechnicienAvgAggregateOutputType | null
    _sum: TechnicienSumAggregateOutputType | null
    _min: TechnicienMinAggregateOutputType | null
    _max: TechnicienMaxAggregateOutputType | null
  }

  export type TechnicienAvgAggregateOutputType = {
    id: number | null
    specialiteId: number | null
    utilisateurId: number | null
  }

  export type TechnicienSumAggregateOutputType = {
    id: number | null
    specialiteId: number | null
    utilisateurId: number | null
  }

  export type TechnicienMinAggregateOutputType = {
    id: number | null
    nom: string | null
    prenom: string | null
    contact: string | null
    specialiteId: number | null
    utilisateurId: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TechnicienMaxAggregateOutputType = {
    id: number | null
    nom: string | null
    prenom: string | null
    contact: string | null
    specialiteId: number | null
    utilisateurId: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TechnicienCountAggregateOutputType = {
    id: number
    nom: number
    prenom: number
    contact: number
    specialiteId: number
    utilisateurId: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TechnicienAvgAggregateInputType = {
    id?: true
    specialiteId?: true
    utilisateurId?: true
  }

  export type TechnicienSumAggregateInputType = {
    id?: true
    specialiteId?: true
    utilisateurId?: true
  }

  export type TechnicienMinAggregateInputType = {
    id?: true
    nom?: true
    prenom?: true
    contact?: true
    specialiteId?: true
    utilisateurId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TechnicienMaxAggregateInputType = {
    id?: true
    nom?: true
    prenom?: true
    contact?: true
    specialiteId?: true
    utilisateurId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TechnicienCountAggregateInputType = {
    id?: true
    nom?: true
    prenom?: true
    contact?: true
    specialiteId?: true
    utilisateurId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TechnicienAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Technicien to aggregate.
     */
    where?: TechnicienWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Techniciens to fetch.
     */
    orderBy?: TechnicienOrderByWithRelationInput | TechnicienOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TechnicienWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Techniciens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Techniciens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Techniciens
    **/
    _count?: true | TechnicienCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TechnicienAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TechnicienSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TechnicienMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TechnicienMaxAggregateInputType
  }

  export type GetTechnicienAggregateType<T extends TechnicienAggregateArgs> = {
        [P in keyof T & keyof AggregateTechnicien]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTechnicien[P]>
      : GetScalarType<T[P], AggregateTechnicien[P]>
  }




  export type TechnicienGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TechnicienWhereInput
    orderBy?: TechnicienOrderByWithAggregationInput | TechnicienOrderByWithAggregationInput[]
    by: TechnicienScalarFieldEnum[] | TechnicienScalarFieldEnum
    having?: TechnicienScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TechnicienCountAggregateInputType | true
    _avg?: TechnicienAvgAggregateInputType
    _sum?: TechnicienSumAggregateInputType
    _min?: TechnicienMinAggregateInputType
    _max?: TechnicienMaxAggregateInputType
  }

  export type TechnicienGroupByOutputType = {
    id: number
    nom: string
    prenom: string
    contact: string
    specialiteId: number
    utilisateurId: number | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: TechnicienCountAggregateOutputType | null
    _avg: TechnicienAvgAggregateOutputType | null
    _sum: TechnicienSumAggregateOutputType | null
    _min: TechnicienMinAggregateOutputType | null
    _max: TechnicienMaxAggregateOutputType | null
  }

  type GetTechnicienGroupByPayload<T extends TechnicienGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TechnicienGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TechnicienGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TechnicienGroupByOutputType[P]>
            : GetScalarType<T[P], TechnicienGroupByOutputType[P]>
        }
      >
    >


  export type TechnicienSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    prenom?: boolean
    contact?: boolean
    specialiteId?: boolean
    utilisateurId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    specialite?: boolean | SpecialiteDefaultArgs<ExtArgs>
    utilisateur?: boolean | Technicien$utilisateurArgs<ExtArgs>
    interventions?: boolean | Technicien$interventionsArgs<ExtArgs>
    rapports?: boolean | Technicien$rapportsArgs<ExtArgs>
    sortiesMateriels?: boolean | Technicien$sortiesMaterielsArgs<ExtArgs>
    _count?: boolean | TechnicienCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["technicien"]>

  export type TechnicienSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    prenom?: boolean
    contact?: boolean
    specialiteId?: boolean
    utilisateurId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    specialite?: boolean | SpecialiteDefaultArgs<ExtArgs>
    utilisateur?: boolean | Technicien$utilisateurArgs<ExtArgs>
  }, ExtArgs["result"]["technicien"]>

  export type TechnicienSelectScalar = {
    id?: boolean
    nom?: boolean
    prenom?: boolean
    contact?: boolean
    specialiteId?: boolean
    utilisateurId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TechnicienInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    specialite?: boolean | SpecialiteDefaultArgs<ExtArgs>
    utilisateur?: boolean | Technicien$utilisateurArgs<ExtArgs>
    interventions?: boolean | Technicien$interventionsArgs<ExtArgs>
    rapports?: boolean | Technicien$rapportsArgs<ExtArgs>
    sortiesMateriels?: boolean | Technicien$sortiesMaterielsArgs<ExtArgs>
    _count?: boolean | TechnicienCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TechnicienIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    specialite?: boolean | SpecialiteDefaultArgs<ExtArgs>
    utilisateur?: boolean | Technicien$utilisateurArgs<ExtArgs>
  }

  export type $TechnicienPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Technicien"
    objects: {
      specialite: Prisma.$SpecialitePayload<ExtArgs>
      utilisateur: Prisma.$UserPayload<ExtArgs> | null
      interventions: Prisma.$TechnicienInterventionPayload<ExtArgs>[]
      rapports: Prisma.$RapportMissionPayload<ExtArgs>[]
      sortiesMateriels: Prisma.$SortieMaterielPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nom: string
      prenom: string
      contact: string
      specialiteId: number
      utilisateurId: number | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["technicien"]>
    composites: {}
  }

  type TechnicienGetPayload<S extends boolean | null | undefined | TechnicienDefaultArgs> = $Result.GetResult<Prisma.$TechnicienPayload, S>

  type TechnicienCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TechnicienFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TechnicienCountAggregateInputType | true
    }

  export interface TechnicienDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Technicien'], meta: { name: 'Technicien' } }
    /**
     * Find zero or one Technicien that matches the filter.
     * @param {TechnicienFindUniqueArgs} args - Arguments to find a Technicien
     * @example
     * // Get one Technicien
     * const technicien = await prisma.technicien.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TechnicienFindUniqueArgs>(args: SelectSubset<T, TechnicienFindUniqueArgs<ExtArgs>>): Prisma__TechnicienClient<$Result.GetResult<Prisma.$TechnicienPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Technicien that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TechnicienFindUniqueOrThrowArgs} args - Arguments to find a Technicien
     * @example
     * // Get one Technicien
     * const technicien = await prisma.technicien.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TechnicienFindUniqueOrThrowArgs>(args: SelectSubset<T, TechnicienFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TechnicienClient<$Result.GetResult<Prisma.$TechnicienPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Technicien that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnicienFindFirstArgs} args - Arguments to find a Technicien
     * @example
     * // Get one Technicien
     * const technicien = await prisma.technicien.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TechnicienFindFirstArgs>(args?: SelectSubset<T, TechnicienFindFirstArgs<ExtArgs>>): Prisma__TechnicienClient<$Result.GetResult<Prisma.$TechnicienPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Technicien that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnicienFindFirstOrThrowArgs} args - Arguments to find a Technicien
     * @example
     * // Get one Technicien
     * const technicien = await prisma.technicien.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TechnicienFindFirstOrThrowArgs>(args?: SelectSubset<T, TechnicienFindFirstOrThrowArgs<ExtArgs>>): Prisma__TechnicienClient<$Result.GetResult<Prisma.$TechnicienPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Techniciens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnicienFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Techniciens
     * const techniciens = await prisma.technicien.findMany()
     * 
     * // Get first 10 Techniciens
     * const techniciens = await prisma.technicien.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const technicienWithIdOnly = await prisma.technicien.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TechnicienFindManyArgs>(args?: SelectSubset<T, TechnicienFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TechnicienPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Technicien.
     * @param {TechnicienCreateArgs} args - Arguments to create a Technicien.
     * @example
     * // Create one Technicien
     * const Technicien = await prisma.technicien.create({
     *   data: {
     *     // ... data to create a Technicien
     *   }
     * })
     * 
     */
    create<T extends TechnicienCreateArgs>(args: SelectSubset<T, TechnicienCreateArgs<ExtArgs>>): Prisma__TechnicienClient<$Result.GetResult<Prisma.$TechnicienPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Techniciens.
     * @param {TechnicienCreateManyArgs} args - Arguments to create many Techniciens.
     * @example
     * // Create many Techniciens
     * const technicien = await prisma.technicien.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TechnicienCreateManyArgs>(args?: SelectSubset<T, TechnicienCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Techniciens and returns the data saved in the database.
     * @param {TechnicienCreateManyAndReturnArgs} args - Arguments to create many Techniciens.
     * @example
     * // Create many Techniciens
     * const technicien = await prisma.technicien.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Techniciens and only return the `id`
     * const technicienWithIdOnly = await prisma.technicien.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TechnicienCreateManyAndReturnArgs>(args?: SelectSubset<T, TechnicienCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TechnicienPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Technicien.
     * @param {TechnicienDeleteArgs} args - Arguments to delete one Technicien.
     * @example
     * // Delete one Technicien
     * const Technicien = await prisma.technicien.delete({
     *   where: {
     *     // ... filter to delete one Technicien
     *   }
     * })
     * 
     */
    delete<T extends TechnicienDeleteArgs>(args: SelectSubset<T, TechnicienDeleteArgs<ExtArgs>>): Prisma__TechnicienClient<$Result.GetResult<Prisma.$TechnicienPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Technicien.
     * @param {TechnicienUpdateArgs} args - Arguments to update one Technicien.
     * @example
     * // Update one Technicien
     * const technicien = await prisma.technicien.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TechnicienUpdateArgs>(args: SelectSubset<T, TechnicienUpdateArgs<ExtArgs>>): Prisma__TechnicienClient<$Result.GetResult<Prisma.$TechnicienPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Techniciens.
     * @param {TechnicienDeleteManyArgs} args - Arguments to filter Techniciens to delete.
     * @example
     * // Delete a few Techniciens
     * const { count } = await prisma.technicien.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TechnicienDeleteManyArgs>(args?: SelectSubset<T, TechnicienDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Techniciens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnicienUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Techniciens
     * const technicien = await prisma.technicien.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TechnicienUpdateManyArgs>(args: SelectSubset<T, TechnicienUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Technicien.
     * @param {TechnicienUpsertArgs} args - Arguments to update or create a Technicien.
     * @example
     * // Update or create a Technicien
     * const technicien = await prisma.technicien.upsert({
     *   create: {
     *     // ... data to create a Technicien
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Technicien we want to update
     *   }
     * })
     */
    upsert<T extends TechnicienUpsertArgs>(args: SelectSubset<T, TechnicienUpsertArgs<ExtArgs>>): Prisma__TechnicienClient<$Result.GetResult<Prisma.$TechnicienPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Techniciens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnicienCountArgs} args - Arguments to filter Techniciens to count.
     * @example
     * // Count the number of Techniciens
     * const count = await prisma.technicien.count({
     *   where: {
     *     // ... the filter for the Techniciens we want to count
     *   }
     * })
    **/
    count<T extends TechnicienCountArgs>(
      args?: Subset<T, TechnicienCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TechnicienCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Technicien.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnicienAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TechnicienAggregateArgs>(args: Subset<T, TechnicienAggregateArgs>): Prisma.PrismaPromise<GetTechnicienAggregateType<T>>

    /**
     * Group by Technicien.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnicienGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TechnicienGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TechnicienGroupByArgs['orderBy'] }
        : { orderBy?: TechnicienGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TechnicienGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTechnicienGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Technicien model
   */
  readonly fields: TechnicienFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Technicien.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TechnicienClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    specialite<T extends SpecialiteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SpecialiteDefaultArgs<ExtArgs>>): Prisma__SpecialiteClient<$Result.GetResult<Prisma.$SpecialitePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    utilisateur<T extends Technicien$utilisateurArgs<ExtArgs> = {}>(args?: Subset<T, Technicien$utilisateurArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    interventions<T extends Technicien$interventionsArgs<ExtArgs> = {}>(args?: Subset<T, Technicien$interventionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TechnicienInterventionPayload<ExtArgs>, T, "findMany"> | Null>
    rapports<T extends Technicien$rapportsArgs<ExtArgs> = {}>(args?: Subset<T, Technicien$rapportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RapportMissionPayload<ExtArgs>, T, "findMany"> | Null>
    sortiesMateriels<T extends Technicien$sortiesMaterielsArgs<ExtArgs> = {}>(args?: Subset<T, Technicien$sortiesMaterielsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SortieMaterielPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Technicien model
   */ 
  interface TechnicienFieldRefs {
    readonly id: FieldRef<"Technicien", 'Int'>
    readonly nom: FieldRef<"Technicien", 'String'>
    readonly prenom: FieldRef<"Technicien", 'String'>
    readonly contact: FieldRef<"Technicien", 'String'>
    readonly specialiteId: FieldRef<"Technicien", 'Int'>
    readonly utilisateurId: FieldRef<"Technicien", 'Int'>
    readonly isActive: FieldRef<"Technicien", 'Boolean'>
    readonly createdAt: FieldRef<"Technicien", 'DateTime'>
    readonly updatedAt: FieldRef<"Technicien", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Technicien findUnique
   */
  export type TechnicienFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Technicien
     */
    select?: TechnicienSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicienInclude<ExtArgs> | null
    /**
     * Filter, which Technicien to fetch.
     */
    where: TechnicienWhereUniqueInput
  }

  /**
   * Technicien findUniqueOrThrow
   */
  export type TechnicienFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Technicien
     */
    select?: TechnicienSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicienInclude<ExtArgs> | null
    /**
     * Filter, which Technicien to fetch.
     */
    where: TechnicienWhereUniqueInput
  }

  /**
   * Technicien findFirst
   */
  export type TechnicienFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Technicien
     */
    select?: TechnicienSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicienInclude<ExtArgs> | null
    /**
     * Filter, which Technicien to fetch.
     */
    where?: TechnicienWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Techniciens to fetch.
     */
    orderBy?: TechnicienOrderByWithRelationInput | TechnicienOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Techniciens.
     */
    cursor?: TechnicienWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Techniciens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Techniciens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Techniciens.
     */
    distinct?: TechnicienScalarFieldEnum | TechnicienScalarFieldEnum[]
  }

  /**
   * Technicien findFirstOrThrow
   */
  export type TechnicienFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Technicien
     */
    select?: TechnicienSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicienInclude<ExtArgs> | null
    /**
     * Filter, which Technicien to fetch.
     */
    where?: TechnicienWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Techniciens to fetch.
     */
    orderBy?: TechnicienOrderByWithRelationInput | TechnicienOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Techniciens.
     */
    cursor?: TechnicienWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Techniciens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Techniciens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Techniciens.
     */
    distinct?: TechnicienScalarFieldEnum | TechnicienScalarFieldEnum[]
  }

  /**
   * Technicien findMany
   */
  export type TechnicienFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Technicien
     */
    select?: TechnicienSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicienInclude<ExtArgs> | null
    /**
     * Filter, which Techniciens to fetch.
     */
    where?: TechnicienWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Techniciens to fetch.
     */
    orderBy?: TechnicienOrderByWithRelationInput | TechnicienOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Techniciens.
     */
    cursor?: TechnicienWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Techniciens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Techniciens.
     */
    skip?: number
    distinct?: TechnicienScalarFieldEnum | TechnicienScalarFieldEnum[]
  }

  /**
   * Technicien create
   */
  export type TechnicienCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Technicien
     */
    select?: TechnicienSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicienInclude<ExtArgs> | null
    /**
     * The data needed to create a Technicien.
     */
    data: XOR<TechnicienCreateInput, TechnicienUncheckedCreateInput>
  }

  /**
   * Technicien createMany
   */
  export type TechnicienCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Techniciens.
     */
    data: TechnicienCreateManyInput | TechnicienCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Technicien createManyAndReturn
   */
  export type TechnicienCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Technicien
     */
    select?: TechnicienSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Techniciens.
     */
    data: TechnicienCreateManyInput | TechnicienCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicienIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Technicien update
   */
  export type TechnicienUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Technicien
     */
    select?: TechnicienSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicienInclude<ExtArgs> | null
    /**
     * The data needed to update a Technicien.
     */
    data: XOR<TechnicienUpdateInput, TechnicienUncheckedUpdateInput>
    /**
     * Choose, which Technicien to update.
     */
    where: TechnicienWhereUniqueInput
  }

  /**
   * Technicien updateMany
   */
  export type TechnicienUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Techniciens.
     */
    data: XOR<TechnicienUpdateManyMutationInput, TechnicienUncheckedUpdateManyInput>
    /**
     * Filter which Techniciens to update
     */
    where?: TechnicienWhereInput
  }

  /**
   * Technicien upsert
   */
  export type TechnicienUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Technicien
     */
    select?: TechnicienSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicienInclude<ExtArgs> | null
    /**
     * The filter to search for the Technicien to update in case it exists.
     */
    where: TechnicienWhereUniqueInput
    /**
     * In case the Technicien found by the `where` argument doesn't exist, create a new Technicien with this data.
     */
    create: XOR<TechnicienCreateInput, TechnicienUncheckedCreateInput>
    /**
     * In case the Technicien was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TechnicienUpdateInput, TechnicienUncheckedUpdateInput>
  }

  /**
   * Technicien delete
   */
  export type TechnicienDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Technicien
     */
    select?: TechnicienSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicienInclude<ExtArgs> | null
    /**
     * Filter which Technicien to delete.
     */
    where: TechnicienWhereUniqueInput
  }

  /**
   * Technicien deleteMany
   */
  export type TechnicienDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Techniciens to delete
     */
    where?: TechnicienWhereInput
  }

  /**
   * Technicien.utilisateur
   */
  export type Technicien$utilisateurArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Technicien.interventions
   */
  export type Technicien$interventionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicienIntervention
     */
    select?: TechnicienInterventionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicienInterventionInclude<ExtArgs> | null
    where?: TechnicienInterventionWhereInput
    orderBy?: TechnicienInterventionOrderByWithRelationInput | TechnicienInterventionOrderByWithRelationInput[]
    cursor?: TechnicienInterventionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TechnicienInterventionScalarFieldEnum | TechnicienInterventionScalarFieldEnum[]
  }

  /**
   * Technicien.rapports
   */
  export type Technicien$rapportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RapportMission
     */
    select?: RapportMissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RapportMissionInclude<ExtArgs> | null
    where?: RapportMissionWhereInput
    orderBy?: RapportMissionOrderByWithRelationInput | RapportMissionOrderByWithRelationInput[]
    cursor?: RapportMissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RapportMissionScalarFieldEnum | RapportMissionScalarFieldEnum[]
  }

  /**
   * Technicien.sortiesMateriels
   */
  export type Technicien$sortiesMaterielsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SortieMateriel
     */
    select?: SortieMaterielSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SortieMaterielInclude<ExtArgs> | null
    where?: SortieMaterielWhereInput
    orderBy?: SortieMaterielOrderByWithRelationInput | SortieMaterielOrderByWithRelationInput[]
    cursor?: SortieMaterielWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SortieMaterielScalarFieldEnum | SortieMaterielScalarFieldEnum[]
  }

  /**
   * Technicien without action
   */
  export type TechnicienDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Technicien
     */
    select?: TechnicienSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicienInclude<ExtArgs> | null
  }


  /**
   * Model Mission
   */

  export type AggregateMission = {
    _count: MissionCountAggregateOutputType | null
    _avg: MissionAvgAggregateOutputType | null
    _sum: MissionSumAggregateOutputType | null
    _min: MissionMinAggregateOutputType | null
    _max: MissionMaxAggregateOutputType | null
  }

  export type MissionAvgAggregateOutputType = {
    clientId: number | null
  }

  export type MissionSumAggregateOutputType = {
    clientId: number | null
  }

  export type MissionMinAggregateOutputType = {
    numIntervention: string | null
    natureIntervention: string | null
    objectifDuContrat: string | null
    description: string | null
    priorite: string | null
    statut: string | null
    dateSortieFicheIntervention: Date | null
    clientId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MissionMaxAggregateOutputType = {
    numIntervention: string | null
    natureIntervention: string | null
    objectifDuContrat: string | null
    description: string | null
    priorite: string | null
    statut: string | null
    dateSortieFicheIntervention: Date | null
    clientId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MissionCountAggregateOutputType = {
    numIntervention: number
    natureIntervention: number
    objectifDuContrat: number
    description: number
    priorite: number
    statut: number
    dateSortieFicheIntervention: number
    clientId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MissionAvgAggregateInputType = {
    clientId?: true
  }

  export type MissionSumAggregateInputType = {
    clientId?: true
  }

  export type MissionMinAggregateInputType = {
    numIntervention?: true
    natureIntervention?: true
    objectifDuContrat?: true
    description?: true
    priorite?: true
    statut?: true
    dateSortieFicheIntervention?: true
    clientId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MissionMaxAggregateInputType = {
    numIntervention?: true
    natureIntervention?: true
    objectifDuContrat?: true
    description?: true
    priorite?: true
    statut?: true
    dateSortieFicheIntervention?: true
    clientId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MissionCountAggregateInputType = {
    numIntervention?: true
    natureIntervention?: true
    objectifDuContrat?: true
    description?: true
    priorite?: true
    statut?: true
    dateSortieFicheIntervention?: true
    clientId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Mission to aggregate.
     */
    where?: MissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Missions to fetch.
     */
    orderBy?: MissionOrderByWithRelationInput | MissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Missions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Missions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Missions
    **/
    _count?: true | MissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MissionMaxAggregateInputType
  }

  export type GetMissionAggregateType<T extends MissionAggregateArgs> = {
        [P in keyof T & keyof AggregateMission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMission[P]>
      : GetScalarType<T[P], AggregateMission[P]>
  }




  export type MissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MissionWhereInput
    orderBy?: MissionOrderByWithAggregationInput | MissionOrderByWithAggregationInput[]
    by: MissionScalarFieldEnum[] | MissionScalarFieldEnum
    having?: MissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MissionCountAggregateInputType | true
    _avg?: MissionAvgAggregateInputType
    _sum?: MissionSumAggregateInputType
    _min?: MissionMinAggregateInputType
    _max?: MissionMaxAggregateInputType
  }

  export type MissionGroupByOutputType = {
    numIntervention: string
    natureIntervention: string
    objectifDuContrat: string
    description: string | null
    priorite: string | null
    statut: string | null
    dateSortieFicheIntervention: Date
    clientId: number
    createdAt: Date
    updatedAt: Date
    _count: MissionCountAggregateOutputType | null
    _avg: MissionAvgAggregateOutputType | null
    _sum: MissionSumAggregateOutputType | null
    _min: MissionMinAggregateOutputType | null
    _max: MissionMaxAggregateOutputType | null
  }

  type GetMissionGroupByPayload<T extends MissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MissionGroupByOutputType[P]>
            : GetScalarType<T[P], MissionGroupByOutputType[P]>
        }
      >
    >


  export type MissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    numIntervention?: boolean
    natureIntervention?: boolean
    objectifDuContrat?: boolean
    description?: boolean
    priorite?: boolean
    statut?: boolean
    dateSortieFicheIntervention?: boolean
    clientId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | CustomerDefaultArgs<ExtArgs>
    interventions?: boolean | Mission$interventionsArgs<ExtArgs>
    rapports?: boolean | Mission$rapportsArgs<ExtArgs>
    devis?: boolean | Mission$devisArgs<ExtArgs>
    _count?: boolean | MissionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mission"]>

  export type MissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    numIntervention?: boolean
    natureIntervention?: boolean
    objectifDuContrat?: boolean
    description?: boolean
    priorite?: boolean
    statut?: boolean
    dateSortieFicheIntervention?: boolean
    clientId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mission"]>

  export type MissionSelectScalar = {
    numIntervention?: boolean
    natureIntervention?: boolean
    objectifDuContrat?: boolean
    description?: boolean
    priorite?: boolean
    statut?: boolean
    dateSortieFicheIntervention?: boolean
    clientId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | CustomerDefaultArgs<ExtArgs>
    interventions?: boolean | Mission$interventionsArgs<ExtArgs>
    rapports?: boolean | Mission$rapportsArgs<ExtArgs>
    devis?: boolean | Mission$devisArgs<ExtArgs>
    _count?: boolean | MissionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | CustomerDefaultArgs<ExtArgs>
  }

  export type $MissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Mission"
    objects: {
      client: Prisma.$CustomerPayload<ExtArgs>
      interventions: Prisma.$InterventionPayload<ExtArgs>[]
      rapports: Prisma.$RapportMissionPayload<ExtArgs>[]
      devis: Prisma.$QuotePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      numIntervention: string
      natureIntervention: string
      objectifDuContrat: string
      description: string | null
      priorite: string | null
      statut: string | null
      dateSortieFicheIntervention: Date
      clientId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["mission"]>
    composites: {}
  }

  type MissionGetPayload<S extends boolean | null | undefined | MissionDefaultArgs> = $Result.GetResult<Prisma.$MissionPayload, S>

  type MissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MissionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MissionCountAggregateInputType | true
    }

  export interface MissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Mission'], meta: { name: 'Mission' } }
    /**
     * Find zero or one Mission that matches the filter.
     * @param {MissionFindUniqueArgs} args - Arguments to find a Mission
     * @example
     * // Get one Mission
     * const mission = await prisma.mission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MissionFindUniqueArgs>(args: SelectSubset<T, MissionFindUniqueArgs<ExtArgs>>): Prisma__MissionClient<$Result.GetResult<Prisma.$MissionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Mission that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MissionFindUniqueOrThrowArgs} args - Arguments to find a Mission
     * @example
     * // Get one Mission
     * const mission = await prisma.mission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MissionFindUniqueOrThrowArgs>(args: SelectSubset<T, MissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MissionClient<$Result.GetResult<Prisma.$MissionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Mission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MissionFindFirstArgs} args - Arguments to find a Mission
     * @example
     * // Get one Mission
     * const mission = await prisma.mission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MissionFindFirstArgs>(args?: SelectSubset<T, MissionFindFirstArgs<ExtArgs>>): Prisma__MissionClient<$Result.GetResult<Prisma.$MissionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Mission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MissionFindFirstOrThrowArgs} args - Arguments to find a Mission
     * @example
     * // Get one Mission
     * const mission = await prisma.mission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MissionFindFirstOrThrowArgs>(args?: SelectSubset<T, MissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__MissionClient<$Result.GetResult<Prisma.$MissionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Missions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Missions
     * const missions = await prisma.mission.findMany()
     * 
     * // Get first 10 Missions
     * const missions = await prisma.mission.findMany({ take: 10 })
     * 
     * // Only select the `numIntervention`
     * const missionWithNumInterventionOnly = await prisma.mission.findMany({ select: { numIntervention: true } })
     * 
     */
    findMany<T extends MissionFindManyArgs>(args?: SelectSubset<T, MissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MissionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Mission.
     * @param {MissionCreateArgs} args - Arguments to create a Mission.
     * @example
     * // Create one Mission
     * const Mission = await prisma.mission.create({
     *   data: {
     *     // ... data to create a Mission
     *   }
     * })
     * 
     */
    create<T extends MissionCreateArgs>(args: SelectSubset<T, MissionCreateArgs<ExtArgs>>): Prisma__MissionClient<$Result.GetResult<Prisma.$MissionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Missions.
     * @param {MissionCreateManyArgs} args - Arguments to create many Missions.
     * @example
     * // Create many Missions
     * const mission = await prisma.mission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MissionCreateManyArgs>(args?: SelectSubset<T, MissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Missions and returns the data saved in the database.
     * @param {MissionCreateManyAndReturnArgs} args - Arguments to create many Missions.
     * @example
     * // Create many Missions
     * const mission = await prisma.mission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Missions and only return the `numIntervention`
     * const missionWithNumInterventionOnly = await prisma.mission.createManyAndReturn({ 
     *   select: { numIntervention: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MissionCreateManyAndReturnArgs>(args?: SelectSubset<T, MissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MissionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Mission.
     * @param {MissionDeleteArgs} args - Arguments to delete one Mission.
     * @example
     * // Delete one Mission
     * const Mission = await prisma.mission.delete({
     *   where: {
     *     // ... filter to delete one Mission
     *   }
     * })
     * 
     */
    delete<T extends MissionDeleteArgs>(args: SelectSubset<T, MissionDeleteArgs<ExtArgs>>): Prisma__MissionClient<$Result.GetResult<Prisma.$MissionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Mission.
     * @param {MissionUpdateArgs} args - Arguments to update one Mission.
     * @example
     * // Update one Mission
     * const mission = await prisma.mission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MissionUpdateArgs>(args: SelectSubset<T, MissionUpdateArgs<ExtArgs>>): Prisma__MissionClient<$Result.GetResult<Prisma.$MissionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Missions.
     * @param {MissionDeleteManyArgs} args - Arguments to filter Missions to delete.
     * @example
     * // Delete a few Missions
     * const { count } = await prisma.mission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MissionDeleteManyArgs>(args?: SelectSubset<T, MissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Missions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Missions
     * const mission = await prisma.mission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MissionUpdateManyArgs>(args: SelectSubset<T, MissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Mission.
     * @param {MissionUpsertArgs} args - Arguments to update or create a Mission.
     * @example
     * // Update or create a Mission
     * const mission = await prisma.mission.upsert({
     *   create: {
     *     // ... data to create a Mission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Mission we want to update
     *   }
     * })
     */
    upsert<T extends MissionUpsertArgs>(args: SelectSubset<T, MissionUpsertArgs<ExtArgs>>): Prisma__MissionClient<$Result.GetResult<Prisma.$MissionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Missions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MissionCountArgs} args - Arguments to filter Missions to count.
     * @example
     * // Count the number of Missions
     * const count = await prisma.mission.count({
     *   where: {
     *     // ... the filter for the Missions we want to count
     *   }
     * })
    **/
    count<T extends MissionCountArgs>(
      args?: Subset<T, MissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Mission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MissionAggregateArgs>(args: Subset<T, MissionAggregateArgs>): Prisma.PrismaPromise<GetMissionAggregateType<T>>

    /**
     * Group by Mission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MissionGroupByArgs['orderBy'] }
        : { orderBy?: MissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Mission model
   */
  readonly fields: MissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Mission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    interventions<T extends Mission$interventionsArgs<ExtArgs> = {}>(args?: Subset<T, Mission$interventionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterventionPayload<ExtArgs>, T, "findMany"> | Null>
    rapports<T extends Mission$rapportsArgs<ExtArgs> = {}>(args?: Subset<T, Mission$rapportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RapportMissionPayload<ExtArgs>, T, "findMany"> | Null>
    devis<T extends Mission$devisArgs<ExtArgs> = {}>(args?: Subset<T, Mission$devisArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Mission model
   */ 
  interface MissionFieldRefs {
    readonly numIntervention: FieldRef<"Mission", 'String'>
    readonly natureIntervention: FieldRef<"Mission", 'String'>
    readonly objectifDuContrat: FieldRef<"Mission", 'String'>
    readonly description: FieldRef<"Mission", 'String'>
    readonly priorite: FieldRef<"Mission", 'String'>
    readonly statut: FieldRef<"Mission", 'String'>
    readonly dateSortieFicheIntervention: FieldRef<"Mission", 'DateTime'>
    readonly clientId: FieldRef<"Mission", 'Int'>
    readonly createdAt: FieldRef<"Mission", 'DateTime'>
    readonly updatedAt: FieldRef<"Mission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Mission findUnique
   */
  export type MissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mission
     */
    select?: MissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionInclude<ExtArgs> | null
    /**
     * Filter, which Mission to fetch.
     */
    where: MissionWhereUniqueInput
  }

  /**
   * Mission findUniqueOrThrow
   */
  export type MissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mission
     */
    select?: MissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionInclude<ExtArgs> | null
    /**
     * Filter, which Mission to fetch.
     */
    where: MissionWhereUniqueInput
  }

  /**
   * Mission findFirst
   */
  export type MissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mission
     */
    select?: MissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionInclude<ExtArgs> | null
    /**
     * Filter, which Mission to fetch.
     */
    where?: MissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Missions to fetch.
     */
    orderBy?: MissionOrderByWithRelationInput | MissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Missions.
     */
    cursor?: MissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Missions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Missions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Missions.
     */
    distinct?: MissionScalarFieldEnum | MissionScalarFieldEnum[]
  }

  /**
   * Mission findFirstOrThrow
   */
  export type MissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mission
     */
    select?: MissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionInclude<ExtArgs> | null
    /**
     * Filter, which Mission to fetch.
     */
    where?: MissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Missions to fetch.
     */
    orderBy?: MissionOrderByWithRelationInput | MissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Missions.
     */
    cursor?: MissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Missions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Missions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Missions.
     */
    distinct?: MissionScalarFieldEnum | MissionScalarFieldEnum[]
  }

  /**
   * Mission findMany
   */
  export type MissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mission
     */
    select?: MissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionInclude<ExtArgs> | null
    /**
     * Filter, which Missions to fetch.
     */
    where?: MissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Missions to fetch.
     */
    orderBy?: MissionOrderByWithRelationInput | MissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Missions.
     */
    cursor?: MissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Missions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Missions.
     */
    skip?: number
    distinct?: MissionScalarFieldEnum | MissionScalarFieldEnum[]
  }

  /**
   * Mission create
   */
  export type MissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mission
     */
    select?: MissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionInclude<ExtArgs> | null
    /**
     * The data needed to create a Mission.
     */
    data: XOR<MissionCreateInput, MissionUncheckedCreateInput>
  }

  /**
   * Mission createMany
   */
  export type MissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Missions.
     */
    data: MissionCreateManyInput | MissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Mission createManyAndReturn
   */
  export type MissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mission
     */
    select?: MissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Missions.
     */
    data: MissionCreateManyInput | MissionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Mission update
   */
  export type MissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mission
     */
    select?: MissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionInclude<ExtArgs> | null
    /**
     * The data needed to update a Mission.
     */
    data: XOR<MissionUpdateInput, MissionUncheckedUpdateInput>
    /**
     * Choose, which Mission to update.
     */
    where: MissionWhereUniqueInput
  }

  /**
   * Mission updateMany
   */
  export type MissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Missions.
     */
    data: XOR<MissionUpdateManyMutationInput, MissionUncheckedUpdateManyInput>
    /**
     * Filter which Missions to update
     */
    where?: MissionWhereInput
  }

  /**
   * Mission upsert
   */
  export type MissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mission
     */
    select?: MissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionInclude<ExtArgs> | null
    /**
     * The filter to search for the Mission to update in case it exists.
     */
    where: MissionWhereUniqueInput
    /**
     * In case the Mission found by the `where` argument doesn't exist, create a new Mission with this data.
     */
    create: XOR<MissionCreateInput, MissionUncheckedCreateInput>
    /**
     * In case the Mission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MissionUpdateInput, MissionUncheckedUpdateInput>
  }

  /**
   * Mission delete
   */
  export type MissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mission
     */
    select?: MissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionInclude<ExtArgs> | null
    /**
     * Filter which Mission to delete.
     */
    where: MissionWhereUniqueInput
  }

  /**
   * Mission deleteMany
   */
  export type MissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Missions to delete
     */
    where?: MissionWhereInput
  }

  /**
   * Mission.interventions
   */
  export type Mission$interventionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intervention
     */
    select?: InterventionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionInclude<ExtArgs> | null
    where?: InterventionWhereInput
    orderBy?: InterventionOrderByWithRelationInput | InterventionOrderByWithRelationInput[]
    cursor?: InterventionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InterventionScalarFieldEnum | InterventionScalarFieldEnum[]
  }

  /**
   * Mission.rapports
   */
  export type Mission$rapportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RapportMission
     */
    select?: RapportMissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RapportMissionInclude<ExtArgs> | null
    where?: RapportMissionWhereInput
    orderBy?: RapportMissionOrderByWithRelationInput | RapportMissionOrderByWithRelationInput[]
    cursor?: RapportMissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RapportMissionScalarFieldEnum | RapportMissionScalarFieldEnum[]
  }

  /**
   * Mission.devis
   */
  export type Mission$devisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    where?: QuoteWhereInput
    orderBy?: QuoteOrderByWithRelationInput | QuoteOrderByWithRelationInput[]
    cursor?: QuoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuoteScalarFieldEnum | QuoteScalarFieldEnum[]
  }

  /**
   * Mission without action
   */
  export type MissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mission
     */
    select?: MissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionInclude<ExtArgs> | null
  }


  /**
   * Model Intervention
   */

  export type AggregateIntervention = {
    _count: InterventionCountAggregateOutputType | null
    _avg: InterventionAvgAggregateOutputType | null
    _sum: InterventionSumAggregateOutputType | null
    _min: InterventionMinAggregateOutputType | null
    _max: InterventionMaxAggregateOutputType | null
  }

  export type InterventionAvgAggregateOutputType = {
    id: number | null
    duree: number | null
  }

  export type InterventionSumAggregateOutputType = {
    id: number | null
    duree: number | null
  }

  export type InterventionMinAggregateOutputType = {
    id: number | null
    dateHeureDebut: Date | null
    dateHeureFin: Date | null
    duree: number | null
    missionId: string | null
    statut: string | null
    commentaire: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InterventionMaxAggregateOutputType = {
    id: number | null
    dateHeureDebut: Date | null
    dateHeureFin: Date | null
    duree: number | null
    missionId: string | null
    statut: string | null
    commentaire: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InterventionCountAggregateOutputType = {
    id: number
    dateHeureDebut: number
    dateHeureFin: number
    duree: number
    missionId: number
    statut: number
    commentaire: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InterventionAvgAggregateInputType = {
    id?: true
    duree?: true
  }

  export type InterventionSumAggregateInputType = {
    id?: true
    duree?: true
  }

  export type InterventionMinAggregateInputType = {
    id?: true
    dateHeureDebut?: true
    dateHeureFin?: true
    duree?: true
    missionId?: true
    statut?: true
    commentaire?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InterventionMaxAggregateInputType = {
    id?: true
    dateHeureDebut?: true
    dateHeureFin?: true
    duree?: true
    missionId?: true
    statut?: true
    commentaire?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InterventionCountAggregateInputType = {
    id?: true
    dateHeureDebut?: true
    dateHeureFin?: true
    duree?: true
    missionId?: true
    statut?: true
    commentaire?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InterventionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Intervention to aggregate.
     */
    where?: InterventionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interventions to fetch.
     */
    orderBy?: InterventionOrderByWithRelationInput | InterventionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InterventionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interventions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interventions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Interventions
    **/
    _count?: true | InterventionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InterventionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InterventionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InterventionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InterventionMaxAggregateInputType
  }

  export type GetInterventionAggregateType<T extends InterventionAggregateArgs> = {
        [P in keyof T & keyof AggregateIntervention]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIntervention[P]>
      : GetScalarType<T[P], AggregateIntervention[P]>
  }




  export type InterventionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InterventionWhereInput
    orderBy?: InterventionOrderByWithAggregationInput | InterventionOrderByWithAggregationInput[]
    by: InterventionScalarFieldEnum[] | InterventionScalarFieldEnum
    having?: InterventionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InterventionCountAggregateInputType | true
    _avg?: InterventionAvgAggregateInputType
    _sum?: InterventionSumAggregateInputType
    _min?: InterventionMinAggregateInputType
    _max?: InterventionMaxAggregateInputType
  }

  export type InterventionGroupByOutputType = {
    id: number
    dateHeureDebut: Date
    dateHeureFin: Date | null
    duree: number | null
    missionId: string
    statut: string
    commentaire: string | null
    createdAt: Date
    updatedAt: Date
    _count: InterventionCountAggregateOutputType | null
    _avg: InterventionAvgAggregateOutputType | null
    _sum: InterventionSumAggregateOutputType | null
    _min: InterventionMinAggregateOutputType | null
    _max: InterventionMaxAggregateOutputType | null
  }

  type GetInterventionGroupByPayload<T extends InterventionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InterventionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InterventionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InterventionGroupByOutputType[P]>
            : GetScalarType<T[P], InterventionGroupByOutputType[P]>
        }
      >
    >


  export type InterventionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dateHeureDebut?: boolean
    dateHeureFin?: boolean
    duree?: boolean
    missionId?: boolean
    statut?: boolean
    commentaire?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    mission?: boolean | MissionDefaultArgs<ExtArgs>
    techniciens?: boolean | Intervention$techniciensArgs<ExtArgs>
    rapports?: boolean | Intervention$rapportsArgs<ExtArgs>
    sortiesMateriels?: boolean | Intervention$sortiesMaterielsArgs<ExtArgs>
    _count?: boolean | InterventionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["intervention"]>

  export type InterventionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dateHeureDebut?: boolean
    dateHeureFin?: boolean
    duree?: boolean
    missionId?: boolean
    statut?: boolean
    commentaire?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    mission?: boolean | MissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["intervention"]>

  export type InterventionSelectScalar = {
    id?: boolean
    dateHeureDebut?: boolean
    dateHeureFin?: boolean
    duree?: boolean
    missionId?: boolean
    statut?: boolean
    commentaire?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InterventionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mission?: boolean | MissionDefaultArgs<ExtArgs>
    techniciens?: boolean | Intervention$techniciensArgs<ExtArgs>
    rapports?: boolean | Intervention$rapportsArgs<ExtArgs>
    sortiesMateriels?: boolean | Intervention$sortiesMaterielsArgs<ExtArgs>
    _count?: boolean | InterventionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InterventionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mission?: boolean | MissionDefaultArgs<ExtArgs>
  }

  export type $InterventionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Intervention"
    objects: {
      mission: Prisma.$MissionPayload<ExtArgs>
      techniciens: Prisma.$TechnicienInterventionPayload<ExtArgs>[]
      rapports: Prisma.$RapportMissionPayload<ExtArgs>[]
      sortiesMateriels: Prisma.$SortieMaterielPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      dateHeureDebut: Date
      dateHeureFin: Date | null
      duree: number | null
      missionId: string
      statut: string
      commentaire: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["intervention"]>
    composites: {}
  }

  type InterventionGetPayload<S extends boolean | null | undefined | InterventionDefaultArgs> = $Result.GetResult<Prisma.$InterventionPayload, S>

  type InterventionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InterventionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InterventionCountAggregateInputType | true
    }

  export interface InterventionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Intervention'], meta: { name: 'Intervention' } }
    /**
     * Find zero or one Intervention that matches the filter.
     * @param {InterventionFindUniqueArgs} args - Arguments to find a Intervention
     * @example
     * // Get one Intervention
     * const intervention = await prisma.intervention.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InterventionFindUniqueArgs>(args: SelectSubset<T, InterventionFindUniqueArgs<ExtArgs>>): Prisma__InterventionClient<$Result.GetResult<Prisma.$InterventionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Intervention that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InterventionFindUniqueOrThrowArgs} args - Arguments to find a Intervention
     * @example
     * // Get one Intervention
     * const intervention = await prisma.intervention.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InterventionFindUniqueOrThrowArgs>(args: SelectSubset<T, InterventionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InterventionClient<$Result.GetResult<Prisma.$InterventionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Intervention that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterventionFindFirstArgs} args - Arguments to find a Intervention
     * @example
     * // Get one Intervention
     * const intervention = await prisma.intervention.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InterventionFindFirstArgs>(args?: SelectSubset<T, InterventionFindFirstArgs<ExtArgs>>): Prisma__InterventionClient<$Result.GetResult<Prisma.$InterventionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Intervention that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterventionFindFirstOrThrowArgs} args - Arguments to find a Intervention
     * @example
     * // Get one Intervention
     * const intervention = await prisma.intervention.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InterventionFindFirstOrThrowArgs>(args?: SelectSubset<T, InterventionFindFirstOrThrowArgs<ExtArgs>>): Prisma__InterventionClient<$Result.GetResult<Prisma.$InterventionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Interventions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterventionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Interventions
     * const interventions = await prisma.intervention.findMany()
     * 
     * // Get first 10 Interventions
     * const interventions = await prisma.intervention.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const interventionWithIdOnly = await prisma.intervention.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InterventionFindManyArgs>(args?: SelectSubset<T, InterventionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterventionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Intervention.
     * @param {InterventionCreateArgs} args - Arguments to create a Intervention.
     * @example
     * // Create one Intervention
     * const Intervention = await prisma.intervention.create({
     *   data: {
     *     // ... data to create a Intervention
     *   }
     * })
     * 
     */
    create<T extends InterventionCreateArgs>(args: SelectSubset<T, InterventionCreateArgs<ExtArgs>>): Prisma__InterventionClient<$Result.GetResult<Prisma.$InterventionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Interventions.
     * @param {InterventionCreateManyArgs} args - Arguments to create many Interventions.
     * @example
     * // Create many Interventions
     * const intervention = await prisma.intervention.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InterventionCreateManyArgs>(args?: SelectSubset<T, InterventionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Interventions and returns the data saved in the database.
     * @param {InterventionCreateManyAndReturnArgs} args - Arguments to create many Interventions.
     * @example
     * // Create many Interventions
     * const intervention = await prisma.intervention.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Interventions and only return the `id`
     * const interventionWithIdOnly = await prisma.intervention.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InterventionCreateManyAndReturnArgs>(args?: SelectSubset<T, InterventionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterventionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Intervention.
     * @param {InterventionDeleteArgs} args - Arguments to delete one Intervention.
     * @example
     * // Delete one Intervention
     * const Intervention = await prisma.intervention.delete({
     *   where: {
     *     // ... filter to delete one Intervention
     *   }
     * })
     * 
     */
    delete<T extends InterventionDeleteArgs>(args: SelectSubset<T, InterventionDeleteArgs<ExtArgs>>): Prisma__InterventionClient<$Result.GetResult<Prisma.$InterventionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Intervention.
     * @param {InterventionUpdateArgs} args - Arguments to update one Intervention.
     * @example
     * // Update one Intervention
     * const intervention = await prisma.intervention.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InterventionUpdateArgs>(args: SelectSubset<T, InterventionUpdateArgs<ExtArgs>>): Prisma__InterventionClient<$Result.GetResult<Prisma.$InterventionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Interventions.
     * @param {InterventionDeleteManyArgs} args - Arguments to filter Interventions to delete.
     * @example
     * // Delete a few Interventions
     * const { count } = await prisma.intervention.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InterventionDeleteManyArgs>(args?: SelectSubset<T, InterventionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Interventions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterventionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Interventions
     * const intervention = await prisma.intervention.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InterventionUpdateManyArgs>(args: SelectSubset<T, InterventionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Intervention.
     * @param {InterventionUpsertArgs} args - Arguments to update or create a Intervention.
     * @example
     * // Update or create a Intervention
     * const intervention = await prisma.intervention.upsert({
     *   create: {
     *     // ... data to create a Intervention
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Intervention we want to update
     *   }
     * })
     */
    upsert<T extends InterventionUpsertArgs>(args: SelectSubset<T, InterventionUpsertArgs<ExtArgs>>): Prisma__InterventionClient<$Result.GetResult<Prisma.$InterventionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Interventions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterventionCountArgs} args - Arguments to filter Interventions to count.
     * @example
     * // Count the number of Interventions
     * const count = await prisma.intervention.count({
     *   where: {
     *     // ... the filter for the Interventions we want to count
     *   }
     * })
    **/
    count<T extends InterventionCountArgs>(
      args?: Subset<T, InterventionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InterventionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Intervention.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterventionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InterventionAggregateArgs>(args: Subset<T, InterventionAggregateArgs>): Prisma.PrismaPromise<GetInterventionAggregateType<T>>

    /**
     * Group by Intervention.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterventionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InterventionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InterventionGroupByArgs['orderBy'] }
        : { orderBy?: InterventionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InterventionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInterventionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Intervention model
   */
  readonly fields: InterventionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Intervention.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InterventionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mission<T extends MissionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MissionDefaultArgs<ExtArgs>>): Prisma__MissionClient<$Result.GetResult<Prisma.$MissionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    techniciens<T extends Intervention$techniciensArgs<ExtArgs> = {}>(args?: Subset<T, Intervention$techniciensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TechnicienInterventionPayload<ExtArgs>, T, "findMany"> | Null>
    rapports<T extends Intervention$rapportsArgs<ExtArgs> = {}>(args?: Subset<T, Intervention$rapportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RapportMissionPayload<ExtArgs>, T, "findMany"> | Null>
    sortiesMateriels<T extends Intervention$sortiesMaterielsArgs<ExtArgs> = {}>(args?: Subset<T, Intervention$sortiesMaterielsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SortieMaterielPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Intervention model
   */ 
  interface InterventionFieldRefs {
    readonly id: FieldRef<"Intervention", 'Int'>
    readonly dateHeureDebut: FieldRef<"Intervention", 'DateTime'>
    readonly dateHeureFin: FieldRef<"Intervention", 'DateTime'>
    readonly duree: FieldRef<"Intervention", 'Int'>
    readonly missionId: FieldRef<"Intervention", 'String'>
    readonly statut: FieldRef<"Intervention", 'String'>
    readonly commentaire: FieldRef<"Intervention", 'String'>
    readonly createdAt: FieldRef<"Intervention", 'DateTime'>
    readonly updatedAt: FieldRef<"Intervention", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Intervention findUnique
   */
  export type InterventionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intervention
     */
    select?: InterventionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionInclude<ExtArgs> | null
    /**
     * Filter, which Intervention to fetch.
     */
    where: InterventionWhereUniqueInput
  }

  /**
   * Intervention findUniqueOrThrow
   */
  export type InterventionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intervention
     */
    select?: InterventionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionInclude<ExtArgs> | null
    /**
     * Filter, which Intervention to fetch.
     */
    where: InterventionWhereUniqueInput
  }

  /**
   * Intervention findFirst
   */
  export type InterventionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intervention
     */
    select?: InterventionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionInclude<ExtArgs> | null
    /**
     * Filter, which Intervention to fetch.
     */
    where?: InterventionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interventions to fetch.
     */
    orderBy?: InterventionOrderByWithRelationInput | InterventionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Interventions.
     */
    cursor?: InterventionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interventions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interventions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Interventions.
     */
    distinct?: InterventionScalarFieldEnum | InterventionScalarFieldEnum[]
  }

  /**
   * Intervention findFirstOrThrow
   */
  export type InterventionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intervention
     */
    select?: InterventionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionInclude<ExtArgs> | null
    /**
     * Filter, which Intervention to fetch.
     */
    where?: InterventionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interventions to fetch.
     */
    orderBy?: InterventionOrderByWithRelationInput | InterventionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Interventions.
     */
    cursor?: InterventionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interventions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interventions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Interventions.
     */
    distinct?: InterventionScalarFieldEnum | InterventionScalarFieldEnum[]
  }

  /**
   * Intervention findMany
   */
  export type InterventionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intervention
     */
    select?: InterventionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionInclude<ExtArgs> | null
    /**
     * Filter, which Interventions to fetch.
     */
    where?: InterventionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interventions to fetch.
     */
    orderBy?: InterventionOrderByWithRelationInput | InterventionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Interventions.
     */
    cursor?: InterventionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interventions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interventions.
     */
    skip?: number
    distinct?: InterventionScalarFieldEnum | InterventionScalarFieldEnum[]
  }

  /**
   * Intervention create
   */
  export type InterventionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intervention
     */
    select?: InterventionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionInclude<ExtArgs> | null
    /**
     * The data needed to create a Intervention.
     */
    data: XOR<InterventionCreateInput, InterventionUncheckedCreateInput>
  }

  /**
   * Intervention createMany
   */
  export type InterventionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Interventions.
     */
    data: InterventionCreateManyInput | InterventionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Intervention createManyAndReturn
   */
  export type InterventionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intervention
     */
    select?: InterventionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Interventions.
     */
    data: InterventionCreateManyInput | InterventionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Intervention update
   */
  export type InterventionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intervention
     */
    select?: InterventionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionInclude<ExtArgs> | null
    /**
     * The data needed to update a Intervention.
     */
    data: XOR<InterventionUpdateInput, InterventionUncheckedUpdateInput>
    /**
     * Choose, which Intervention to update.
     */
    where: InterventionWhereUniqueInput
  }

  /**
   * Intervention updateMany
   */
  export type InterventionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Interventions.
     */
    data: XOR<InterventionUpdateManyMutationInput, InterventionUncheckedUpdateManyInput>
    /**
     * Filter which Interventions to update
     */
    where?: InterventionWhereInput
  }

  /**
   * Intervention upsert
   */
  export type InterventionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intervention
     */
    select?: InterventionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionInclude<ExtArgs> | null
    /**
     * The filter to search for the Intervention to update in case it exists.
     */
    where: InterventionWhereUniqueInput
    /**
     * In case the Intervention found by the `where` argument doesn't exist, create a new Intervention with this data.
     */
    create: XOR<InterventionCreateInput, InterventionUncheckedCreateInput>
    /**
     * In case the Intervention was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InterventionUpdateInput, InterventionUncheckedUpdateInput>
  }

  /**
   * Intervention delete
   */
  export type InterventionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intervention
     */
    select?: InterventionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionInclude<ExtArgs> | null
    /**
     * Filter which Intervention to delete.
     */
    where: InterventionWhereUniqueInput
  }

  /**
   * Intervention deleteMany
   */
  export type InterventionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Interventions to delete
     */
    where?: InterventionWhereInput
  }

  /**
   * Intervention.techniciens
   */
  export type Intervention$techniciensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicienIntervention
     */
    select?: TechnicienInterventionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicienInterventionInclude<ExtArgs> | null
    where?: TechnicienInterventionWhereInput
    orderBy?: TechnicienInterventionOrderByWithRelationInput | TechnicienInterventionOrderByWithRelationInput[]
    cursor?: TechnicienInterventionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TechnicienInterventionScalarFieldEnum | TechnicienInterventionScalarFieldEnum[]
  }

  /**
   * Intervention.rapports
   */
  export type Intervention$rapportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RapportMission
     */
    select?: RapportMissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RapportMissionInclude<ExtArgs> | null
    where?: RapportMissionWhereInput
    orderBy?: RapportMissionOrderByWithRelationInput | RapportMissionOrderByWithRelationInput[]
    cursor?: RapportMissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RapportMissionScalarFieldEnum | RapportMissionScalarFieldEnum[]
  }

  /**
   * Intervention.sortiesMateriels
   */
  export type Intervention$sortiesMaterielsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SortieMateriel
     */
    select?: SortieMaterielSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SortieMaterielInclude<ExtArgs> | null
    where?: SortieMaterielWhereInput
    orderBy?: SortieMaterielOrderByWithRelationInput | SortieMaterielOrderByWithRelationInput[]
    cursor?: SortieMaterielWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SortieMaterielScalarFieldEnum | SortieMaterielScalarFieldEnum[]
  }

  /**
   * Intervention without action
   */
  export type InterventionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intervention
     */
    select?: InterventionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionInclude<ExtArgs> | null
  }


  /**
   * Model TechnicienIntervention
   */

  export type AggregateTechnicienIntervention = {
    _count: TechnicienInterventionCountAggregateOutputType | null
    _avg: TechnicienInterventionAvgAggregateOutputType | null
    _sum: TechnicienInterventionSumAggregateOutputType | null
    _min: TechnicienInterventionMinAggregateOutputType | null
    _max: TechnicienInterventionMaxAggregateOutputType | null
  }

  export type TechnicienInterventionAvgAggregateOutputType = {
    id: number | null
    technicienId: number | null
    interventionId: number | null
  }

  export type TechnicienInterventionSumAggregateOutputType = {
    id: number | null
    technicienId: number | null
    interventionId: number | null
  }

  export type TechnicienInterventionMinAggregateOutputType = {
    id: number | null
    technicienId: number | null
    interventionId: number | null
    role: string | null
    commentaire: string | null
    createdAt: Date | null
  }

  export type TechnicienInterventionMaxAggregateOutputType = {
    id: number | null
    technicienId: number | null
    interventionId: number | null
    role: string | null
    commentaire: string | null
    createdAt: Date | null
  }

  export type TechnicienInterventionCountAggregateOutputType = {
    id: number
    technicienId: number
    interventionId: number
    role: number
    commentaire: number
    createdAt: number
    _all: number
  }


  export type TechnicienInterventionAvgAggregateInputType = {
    id?: true
    technicienId?: true
    interventionId?: true
  }

  export type TechnicienInterventionSumAggregateInputType = {
    id?: true
    technicienId?: true
    interventionId?: true
  }

  export type TechnicienInterventionMinAggregateInputType = {
    id?: true
    technicienId?: true
    interventionId?: true
    role?: true
    commentaire?: true
    createdAt?: true
  }

  export type TechnicienInterventionMaxAggregateInputType = {
    id?: true
    technicienId?: true
    interventionId?: true
    role?: true
    commentaire?: true
    createdAt?: true
  }

  export type TechnicienInterventionCountAggregateInputType = {
    id?: true
    technicienId?: true
    interventionId?: true
    role?: true
    commentaire?: true
    createdAt?: true
    _all?: true
  }

  export type TechnicienInterventionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TechnicienIntervention to aggregate.
     */
    where?: TechnicienInterventionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TechnicienInterventions to fetch.
     */
    orderBy?: TechnicienInterventionOrderByWithRelationInput | TechnicienInterventionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TechnicienInterventionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TechnicienInterventions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TechnicienInterventions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TechnicienInterventions
    **/
    _count?: true | TechnicienInterventionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TechnicienInterventionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TechnicienInterventionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TechnicienInterventionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TechnicienInterventionMaxAggregateInputType
  }

  export type GetTechnicienInterventionAggregateType<T extends TechnicienInterventionAggregateArgs> = {
        [P in keyof T & keyof AggregateTechnicienIntervention]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTechnicienIntervention[P]>
      : GetScalarType<T[P], AggregateTechnicienIntervention[P]>
  }




  export type TechnicienInterventionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TechnicienInterventionWhereInput
    orderBy?: TechnicienInterventionOrderByWithAggregationInput | TechnicienInterventionOrderByWithAggregationInput[]
    by: TechnicienInterventionScalarFieldEnum[] | TechnicienInterventionScalarFieldEnum
    having?: TechnicienInterventionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TechnicienInterventionCountAggregateInputType | true
    _avg?: TechnicienInterventionAvgAggregateInputType
    _sum?: TechnicienInterventionSumAggregateInputType
    _min?: TechnicienInterventionMinAggregateInputType
    _max?: TechnicienInterventionMaxAggregateInputType
  }

  export type TechnicienInterventionGroupByOutputType = {
    id: number
    technicienId: number
    interventionId: number
    role: string
    commentaire: string | null
    createdAt: Date
    _count: TechnicienInterventionCountAggregateOutputType | null
    _avg: TechnicienInterventionAvgAggregateOutputType | null
    _sum: TechnicienInterventionSumAggregateOutputType | null
    _min: TechnicienInterventionMinAggregateOutputType | null
    _max: TechnicienInterventionMaxAggregateOutputType | null
  }

  type GetTechnicienInterventionGroupByPayload<T extends TechnicienInterventionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TechnicienInterventionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TechnicienInterventionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TechnicienInterventionGroupByOutputType[P]>
            : GetScalarType<T[P], TechnicienInterventionGroupByOutputType[P]>
        }
      >
    >


  export type TechnicienInterventionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    technicienId?: boolean
    interventionId?: boolean
    role?: boolean
    commentaire?: boolean
    createdAt?: boolean
    technicien?: boolean | TechnicienDefaultArgs<ExtArgs>
    intervention?: boolean | InterventionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["technicienIntervention"]>

  export type TechnicienInterventionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    technicienId?: boolean
    interventionId?: boolean
    role?: boolean
    commentaire?: boolean
    createdAt?: boolean
    technicien?: boolean | TechnicienDefaultArgs<ExtArgs>
    intervention?: boolean | InterventionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["technicienIntervention"]>

  export type TechnicienInterventionSelectScalar = {
    id?: boolean
    technicienId?: boolean
    interventionId?: boolean
    role?: boolean
    commentaire?: boolean
    createdAt?: boolean
  }

  export type TechnicienInterventionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    technicien?: boolean | TechnicienDefaultArgs<ExtArgs>
    intervention?: boolean | InterventionDefaultArgs<ExtArgs>
  }
  export type TechnicienInterventionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    technicien?: boolean | TechnicienDefaultArgs<ExtArgs>
    intervention?: boolean | InterventionDefaultArgs<ExtArgs>
  }

  export type $TechnicienInterventionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TechnicienIntervention"
    objects: {
      technicien: Prisma.$TechnicienPayload<ExtArgs>
      intervention: Prisma.$InterventionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      technicienId: number
      interventionId: number
      role: string
      commentaire: string | null
      createdAt: Date
    }, ExtArgs["result"]["technicienIntervention"]>
    composites: {}
  }

  type TechnicienInterventionGetPayload<S extends boolean | null | undefined | TechnicienInterventionDefaultArgs> = $Result.GetResult<Prisma.$TechnicienInterventionPayload, S>

  type TechnicienInterventionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TechnicienInterventionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TechnicienInterventionCountAggregateInputType | true
    }

  export interface TechnicienInterventionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TechnicienIntervention'], meta: { name: 'TechnicienIntervention' } }
    /**
     * Find zero or one TechnicienIntervention that matches the filter.
     * @param {TechnicienInterventionFindUniqueArgs} args - Arguments to find a TechnicienIntervention
     * @example
     * // Get one TechnicienIntervention
     * const technicienIntervention = await prisma.technicienIntervention.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TechnicienInterventionFindUniqueArgs>(args: SelectSubset<T, TechnicienInterventionFindUniqueArgs<ExtArgs>>): Prisma__TechnicienInterventionClient<$Result.GetResult<Prisma.$TechnicienInterventionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TechnicienIntervention that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TechnicienInterventionFindUniqueOrThrowArgs} args - Arguments to find a TechnicienIntervention
     * @example
     * // Get one TechnicienIntervention
     * const technicienIntervention = await prisma.technicienIntervention.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TechnicienInterventionFindUniqueOrThrowArgs>(args: SelectSubset<T, TechnicienInterventionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TechnicienInterventionClient<$Result.GetResult<Prisma.$TechnicienInterventionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TechnicienIntervention that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnicienInterventionFindFirstArgs} args - Arguments to find a TechnicienIntervention
     * @example
     * // Get one TechnicienIntervention
     * const technicienIntervention = await prisma.technicienIntervention.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TechnicienInterventionFindFirstArgs>(args?: SelectSubset<T, TechnicienInterventionFindFirstArgs<ExtArgs>>): Prisma__TechnicienInterventionClient<$Result.GetResult<Prisma.$TechnicienInterventionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TechnicienIntervention that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnicienInterventionFindFirstOrThrowArgs} args - Arguments to find a TechnicienIntervention
     * @example
     * // Get one TechnicienIntervention
     * const technicienIntervention = await prisma.technicienIntervention.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TechnicienInterventionFindFirstOrThrowArgs>(args?: SelectSubset<T, TechnicienInterventionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TechnicienInterventionClient<$Result.GetResult<Prisma.$TechnicienInterventionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TechnicienInterventions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnicienInterventionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TechnicienInterventions
     * const technicienInterventions = await prisma.technicienIntervention.findMany()
     * 
     * // Get first 10 TechnicienInterventions
     * const technicienInterventions = await prisma.technicienIntervention.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const technicienInterventionWithIdOnly = await prisma.technicienIntervention.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TechnicienInterventionFindManyArgs>(args?: SelectSubset<T, TechnicienInterventionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TechnicienInterventionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TechnicienIntervention.
     * @param {TechnicienInterventionCreateArgs} args - Arguments to create a TechnicienIntervention.
     * @example
     * // Create one TechnicienIntervention
     * const TechnicienIntervention = await prisma.technicienIntervention.create({
     *   data: {
     *     // ... data to create a TechnicienIntervention
     *   }
     * })
     * 
     */
    create<T extends TechnicienInterventionCreateArgs>(args: SelectSubset<T, TechnicienInterventionCreateArgs<ExtArgs>>): Prisma__TechnicienInterventionClient<$Result.GetResult<Prisma.$TechnicienInterventionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TechnicienInterventions.
     * @param {TechnicienInterventionCreateManyArgs} args - Arguments to create many TechnicienInterventions.
     * @example
     * // Create many TechnicienInterventions
     * const technicienIntervention = await prisma.technicienIntervention.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TechnicienInterventionCreateManyArgs>(args?: SelectSubset<T, TechnicienInterventionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TechnicienInterventions and returns the data saved in the database.
     * @param {TechnicienInterventionCreateManyAndReturnArgs} args - Arguments to create many TechnicienInterventions.
     * @example
     * // Create many TechnicienInterventions
     * const technicienIntervention = await prisma.technicienIntervention.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TechnicienInterventions and only return the `id`
     * const technicienInterventionWithIdOnly = await prisma.technicienIntervention.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TechnicienInterventionCreateManyAndReturnArgs>(args?: SelectSubset<T, TechnicienInterventionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TechnicienInterventionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TechnicienIntervention.
     * @param {TechnicienInterventionDeleteArgs} args - Arguments to delete one TechnicienIntervention.
     * @example
     * // Delete one TechnicienIntervention
     * const TechnicienIntervention = await prisma.technicienIntervention.delete({
     *   where: {
     *     // ... filter to delete one TechnicienIntervention
     *   }
     * })
     * 
     */
    delete<T extends TechnicienInterventionDeleteArgs>(args: SelectSubset<T, TechnicienInterventionDeleteArgs<ExtArgs>>): Prisma__TechnicienInterventionClient<$Result.GetResult<Prisma.$TechnicienInterventionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TechnicienIntervention.
     * @param {TechnicienInterventionUpdateArgs} args - Arguments to update one TechnicienIntervention.
     * @example
     * // Update one TechnicienIntervention
     * const technicienIntervention = await prisma.technicienIntervention.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TechnicienInterventionUpdateArgs>(args: SelectSubset<T, TechnicienInterventionUpdateArgs<ExtArgs>>): Prisma__TechnicienInterventionClient<$Result.GetResult<Prisma.$TechnicienInterventionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TechnicienInterventions.
     * @param {TechnicienInterventionDeleteManyArgs} args - Arguments to filter TechnicienInterventions to delete.
     * @example
     * // Delete a few TechnicienInterventions
     * const { count } = await prisma.technicienIntervention.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TechnicienInterventionDeleteManyArgs>(args?: SelectSubset<T, TechnicienInterventionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TechnicienInterventions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnicienInterventionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TechnicienInterventions
     * const technicienIntervention = await prisma.technicienIntervention.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TechnicienInterventionUpdateManyArgs>(args: SelectSubset<T, TechnicienInterventionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TechnicienIntervention.
     * @param {TechnicienInterventionUpsertArgs} args - Arguments to update or create a TechnicienIntervention.
     * @example
     * // Update or create a TechnicienIntervention
     * const technicienIntervention = await prisma.technicienIntervention.upsert({
     *   create: {
     *     // ... data to create a TechnicienIntervention
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TechnicienIntervention we want to update
     *   }
     * })
     */
    upsert<T extends TechnicienInterventionUpsertArgs>(args: SelectSubset<T, TechnicienInterventionUpsertArgs<ExtArgs>>): Prisma__TechnicienInterventionClient<$Result.GetResult<Prisma.$TechnicienInterventionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TechnicienInterventions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnicienInterventionCountArgs} args - Arguments to filter TechnicienInterventions to count.
     * @example
     * // Count the number of TechnicienInterventions
     * const count = await prisma.technicienIntervention.count({
     *   where: {
     *     // ... the filter for the TechnicienInterventions we want to count
     *   }
     * })
    **/
    count<T extends TechnicienInterventionCountArgs>(
      args?: Subset<T, TechnicienInterventionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TechnicienInterventionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TechnicienIntervention.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnicienInterventionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TechnicienInterventionAggregateArgs>(args: Subset<T, TechnicienInterventionAggregateArgs>): Prisma.PrismaPromise<GetTechnicienInterventionAggregateType<T>>

    /**
     * Group by TechnicienIntervention.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnicienInterventionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TechnicienInterventionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TechnicienInterventionGroupByArgs['orderBy'] }
        : { orderBy?: TechnicienInterventionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TechnicienInterventionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTechnicienInterventionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TechnicienIntervention model
   */
  readonly fields: TechnicienInterventionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TechnicienIntervention.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TechnicienInterventionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    technicien<T extends TechnicienDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TechnicienDefaultArgs<ExtArgs>>): Prisma__TechnicienClient<$Result.GetResult<Prisma.$TechnicienPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    intervention<T extends InterventionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InterventionDefaultArgs<ExtArgs>>): Prisma__InterventionClient<$Result.GetResult<Prisma.$InterventionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TechnicienIntervention model
   */ 
  interface TechnicienInterventionFieldRefs {
    readonly id: FieldRef<"TechnicienIntervention", 'Int'>
    readonly technicienId: FieldRef<"TechnicienIntervention", 'Int'>
    readonly interventionId: FieldRef<"TechnicienIntervention", 'Int'>
    readonly role: FieldRef<"TechnicienIntervention", 'String'>
    readonly commentaire: FieldRef<"TechnicienIntervention", 'String'>
    readonly createdAt: FieldRef<"TechnicienIntervention", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TechnicienIntervention findUnique
   */
  export type TechnicienInterventionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicienIntervention
     */
    select?: TechnicienInterventionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicienInterventionInclude<ExtArgs> | null
    /**
     * Filter, which TechnicienIntervention to fetch.
     */
    where: TechnicienInterventionWhereUniqueInput
  }

  /**
   * TechnicienIntervention findUniqueOrThrow
   */
  export type TechnicienInterventionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicienIntervention
     */
    select?: TechnicienInterventionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicienInterventionInclude<ExtArgs> | null
    /**
     * Filter, which TechnicienIntervention to fetch.
     */
    where: TechnicienInterventionWhereUniqueInput
  }

  /**
   * TechnicienIntervention findFirst
   */
  export type TechnicienInterventionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicienIntervention
     */
    select?: TechnicienInterventionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicienInterventionInclude<ExtArgs> | null
    /**
     * Filter, which TechnicienIntervention to fetch.
     */
    where?: TechnicienInterventionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TechnicienInterventions to fetch.
     */
    orderBy?: TechnicienInterventionOrderByWithRelationInput | TechnicienInterventionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TechnicienInterventions.
     */
    cursor?: TechnicienInterventionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TechnicienInterventions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TechnicienInterventions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TechnicienInterventions.
     */
    distinct?: TechnicienInterventionScalarFieldEnum | TechnicienInterventionScalarFieldEnum[]
  }

  /**
   * TechnicienIntervention findFirstOrThrow
   */
  export type TechnicienInterventionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicienIntervention
     */
    select?: TechnicienInterventionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicienInterventionInclude<ExtArgs> | null
    /**
     * Filter, which TechnicienIntervention to fetch.
     */
    where?: TechnicienInterventionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TechnicienInterventions to fetch.
     */
    orderBy?: TechnicienInterventionOrderByWithRelationInput | TechnicienInterventionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TechnicienInterventions.
     */
    cursor?: TechnicienInterventionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TechnicienInterventions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TechnicienInterventions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TechnicienInterventions.
     */
    distinct?: TechnicienInterventionScalarFieldEnum | TechnicienInterventionScalarFieldEnum[]
  }

  /**
   * TechnicienIntervention findMany
   */
  export type TechnicienInterventionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicienIntervention
     */
    select?: TechnicienInterventionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicienInterventionInclude<ExtArgs> | null
    /**
     * Filter, which TechnicienInterventions to fetch.
     */
    where?: TechnicienInterventionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TechnicienInterventions to fetch.
     */
    orderBy?: TechnicienInterventionOrderByWithRelationInput | TechnicienInterventionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TechnicienInterventions.
     */
    cursor?: TechnicienInterventionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TechnicienInterventions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TechnicienInterventions.
     */
    skip?: number
    distinct?: TechnicienInterventionScalarFieldEnum | TechnicienInterventionScalarFieldEnum[]
  }

  /**
   * TechnicienIntervention create
   */
  export type TechnicienInterventionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicienIntervention
     */
    select?: TechnicienInterventionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicienInterventionInclude<ExtArgs> | null
    /**
     * The data needed to create a TechnicienIntervention.
     */
    data: XOR<TechnicienInterventionCreateInput, TechnicienInterventionUncheckedCreateInput>
  }

  /**
   * TechnicienIntervention createMany
   */
  export type TechnicienInterventionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TechnicienInterventions.
     */
    data: TechnicienInterventionCreateManyInput | TechnicienInterventionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TechnicienIntervention createManyAndReturn
   */
  export type TechnicienInterventionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicienIntervention
     */
    select?: TechnicienInterventionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TechnicienInterventions.
     */
    data: TechnicienInterventionCreateManyInput | TechnicienInterventionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicienInterventionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TechnicienIntervention update
   */
  export type TechnicienInterventionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicienIntervention
     */
    select?: TechnicienInterventionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicienInterventionInclude<ExtArgs> | null
    /**
     * The data needed to update a TechnicienIntervention.
     */
    data: XOR<TechnicienInterventionUpdateInput, TechnicienInterventionUncheckedUpdateInput>
    /**
     * Choose, which TechnicienIntervention to update.
     */
    where: TechnicienInterventionWhereUniqueInput
  }

  /**
   * TechnicienIntervention updateMany
   */
  export type TechnicienInterventionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TechnicienInterventions.
     */
    data: XOR<TechnicienInterventionUpdateManyMutationInput, TechnicienInterventionUncheckedUpdateManyInput>
    /**
     * Filter which TechnicienInterventions to update
     */
    where?: TechnicienInterventionWhereInput
  }

  /**
   * TechnicienIntervention upsert
   */
  export type TechnicienInterventionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicienIntervention
     */
    select?: TechnicienInterventionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicienInterventionInclude<ExtArgs> | null
    /**
     * The filter to search for the TechnicienIntervention to update in case it exists.
     */
    where: TechnicienInterventionWhereUniqueInput
    /**
     * In case the TechnicienIntervention found by the `where` argument doesn't exist, create a new TechnicienIntervention with this data.
     */
    create: XOR<TechnicienInterventionCreateInput, TechnicienInterventionUncheckedCreateInput>
    /**
     * In case the TechnicienIntervention was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TechnicienInterventionUpdateInput, TechnicienInterventionUncheckedUpdateInput>
  }

  /**
   * TechnicienIntervention delete
   */
  export type TechnicienInterventionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicienIntervention
     */
    select?: TechnicienInterventionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicienInterventionInclude<ExtArgs> | null
    /**
     * Filter which TechnicienIntervention to delete.
     */
    where: TechnicienInterventionWhereUniqueInput
  }

  /**
   * TechnicienIntervention deleteMany
   */
  export type TechnicienInterventionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TechnicienInterventions to delete
     */
    where?: TechnicienInterventionWhereInput
  }

  /**
   * TechnicienIntervention without action
   */
  export type TechnicienInterventionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicienIntervention
     */
    select?: TechnicienInterventionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicienInterventionInclude<ExtArgs> | null
  }


  /**
   * Model RapportMission
   */

  export type AggregateRapportMission = {
    _count: RapportMissionCountAggregateOutputType | null
    _avg: RapportMissionAvgAggregateOutputType | null
    _sum: RapportMissionSumAggregateOutputType | null
    _min: RapportMissionMinAggregateOutputType | null
    _max: RapportMissionMaxAggregateOutputType | null
  }

  export type RapportMissionAvgAggregateOutputType = {
    id: number | null
    interventionId: number | null
    technicienId: number | null
    createdById: number | null
  }

  export type RapportMissionSumAggregateOutputType = {
    id: number | null
    interventionId: number | null
    technicienId: number | null
    createdById: number | null
  }

  export type RapportMissionMinAggregateOutputType = {
    id: number | null
    titre: string | null
    contenu: string | null
    interventionId: number | null
    technicienId: number | null
    missionId: string | null
    createdById: number | null
    statut: string | null
    dateValidation: Date | null
    commentaire: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RapportMissionMaxAggregateOutputType = {
    id: number | null
    titre: string | null
    contenu: string | null
    interventionId: number | null
    technicienId: number | null
    missionId: string | null
    createdById: number | null
    statut: string | null
    dateValidation: Date | null
    commentaire: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RapportMissionCountAggregateOutputType = {
    id: number
    titre: number
    contenu: number
    interventionId: number
    technicienId: number
    missionId: number
    createdById: number
    statut: number
    dateValidation: number
    commentaire: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RapportMissionAvgAggregateInputType = {
    id?: true
    interventionId?: true
    technicienId?: true
    createdById?: true
  }

  export type RapportMissionSumAggregateInputType = {
    id?: true
    interventionId?: true
    technicienId?: true
    createdById?: true
  }

  export type RapportMissionMinAggregateInputType = {
    id?: true
    titre?: true
    contenu?: true
    interventionId?: true
    technicienId?: true
    missionId?: true
    createdById?: true
    statut?: true
    dateValidation?: true
    commentaire?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RapportMissionMaxAggregateInputType = {
    id?: true
    titre?: true
    contenu?: true
    interventionId?: true
    technicienId?: true
    missionId?: true
    createdById?: true
    statut?: true
    dateValidation?: true
    commentaire?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RapportMissionCountAggregateInputType = {
    id?: true
    titre?: true
    contenu?: true
    interventionId?: true
    technicienId?: true
    missionId?: true
    createdById?: true
    statut?: true
    dateValidation?: true
    commentaire?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RapportMissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RapportMission to aggregate.
     */
    where?: RapportMissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RapportMissions to fetch.
     */
    orderBy?: RapportMissionOrderByWithRelationInput | RapportMissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RapportMissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RapportMissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RapportMissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RapportMissions
    **/
    _count?: true | RapportMissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RapportMissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RapportMissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RapportMissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RapportMissionMaxAggregateInputType
  }

  export type GetRapportMissionAggregateType<T extends RapportMissionAggregateArgs> = {
        [P in keyof T & keyof AggregateRapportMission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRapportMission[P]>
      : GetScalarType<T[P], AggregateRapportMission[P]>
  }




  export type RapportMissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RapportMissionWhereInput
    orderBy?: RapportMissionOrderByWithAggregationInput | RapportMissionOrderByWithAggregationInput[]
    by: RapportMissionScalarFieldEnum[] | RapportMissionScalarFieldEnum
    having?: RapportMissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RapportMissionCountAggregateInputType | true
    _avg?: RapportMissionAvgAggregateInputType
    _sum?: RapportMissionSumAggregateInputType
    _min?: RapportMissionMinAggregateInputType
    _max?: RapportMissionMaxAggregateInputType
  }

  export type RapportMissionGroupByOutputType = {
    id: number
    titre: string
    contenu: string
    interventionId: number | null
    technicienId: number
    missionId: string
    createdById: number | null
    statut: string
    dateValidation: Date | null
    commentaire: string | null
    createdAt: Date
    updatedAt: Date
    _count: RapportMissionCountAggregateOutputType | null
    _avg: RapportMissionAvgAggregateOutputType | null
    _sum: RapportMissionSumAggregateOutputType | null
    _min: RapportMissionMinAggregateOutputType | null
    _max: RapportMissionMaxAggregateOutputType | null
  }

  type GetRapportMissionGroupByPayload<T extends RapportMissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RapportMissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RapportMissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RapportMissionGroupByOutputType[P]>
            : GetScalarType<T[P], RapportMissionGroupByOutputType[P]>
        }
      >
    >


  export type RapportMissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    titre?: boolean
    contenu?: boolean
    interventionId?: boolean
    technicienId?: boolean
    missionId?: boolean
    createdById?: boolean
    statut?: boolean
    dateValidation?: boolean
    commentaire?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    intervention?: boolean | RapportMission$interventionArgs<ExtArgs>
    technicien?: boolean | TechnicienDefaultArgs<ExtArgs>
    mission?: boolean | MissionDefaultArgs<ExtArgs>
    images?: boolean | RapportMission$imagesArgs<ExtArgs>
    _count?: boolean | RapportMissionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rapportMission"]>

  export type RapportMissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    titre?: boolean
    contenu?: boolean
    interventionId?: boolean
    technicienId?: boolean
    missionId?: boolean
    createdById?: boolean
    statut?: boolean
    dateValidation?: boolean
    commentaire?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    intervention?: boolean | RapportMission$interventionArgs<ExtArgs>
    technicien?: boolean | TechnicienDefaultArgs<ExtArgs>
    mission?: boolean | MissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rapportMission"]>

  export type RapportMissionSelectScalar = {
    id?: boolean
    titre?: boolean
    contenu?: boolean
    interventionId?: boolean
    technicienId?: boolean
    missionId?: boolean
    createdById?: boolean
    statut?: boolean
    dateValidation?: boolean
    commentaire?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RapportMissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    intervention?: boolean | RapportMission$interventionArgs<ExtArgs>
    technicien?: boolean | TechnicienDefaultArgs<ExtArgs>
    mission?: boolean | MissionDefaultArgs<ExtArgs>
    images?: boolean | RapportMission$imagesArgs<ExtArgs>
    _count?: boolean | RapportMissionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RapportMissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    intervention?: boolean | RapportMission$interventionArgs<ExtArgs>
    technicien?: boolean | TechnicienDefaultArgs<ExtArgs>
    mission?: boolean | MissionDefaultArgs<ExtArgs>
  }

  export type $RapportMissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RapportMission"
    objects: {
      intervention: Prisma.$InterventionPayload<ExtArgs> | null
      technicien: Prisma.$TechnicienPayload<ExtArgs>
      mission: Prisma.$MissionPayload<ExtArgs>
      images: Prisma.$RapportImagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      titre: string
      contenu: string
      interventionId: number | null
      technicienId: number
      missionId: string
      createdById: number | null
      statut: string
      dateValidation: Date | null
      commentaire: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["rapportMission"]>
    composites: {}
  }

  type RapportMissionGetPayload<S extends boolean | null | undefined | RapportMissionDefaultArgs> = $Result.GetResult<Prisma.$RapportMissionPayload, S>

  type RapportMissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RapportMissionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RapportMissionCountAggregateInputType | true
    }

  export interface RapportMissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RapportMission'], meta: { name: 'RapportMission' } }
    /**
     * Find zero or one RapportMission that matches the filter.
     * @param {RapportMissionFindUniqueArgs} args - Arguments to find a RapportMission
     * @example
     * // Get one RapportMission
     * const rapportMission = await prisma.rapportMission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RapportMissionFindUniqueArgs>(args: SelectSubset<T, RapportMissionFindUniqueArgs<ExtArgs>>): Prisma__RapportMissionClient<$Result.GetResult<Prisma.$RapportMissionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RapportMission that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RapportMissionFindUniqueOrThrowArgs} args - Arguments to find a RapportMission
     * @example
     * // Get one RapportMission
     * const rapportMission = await prisma.rapportMission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RapportMissionFindUniqueOrThrowArgs>(args: SelectSubset<T, RapportMissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RapportMissionClient<$Result.GetResult<Prisma.$RapportMissionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RapportMission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RapportMissionFindFirstArgs} args - Arguments to find a RapportMission
     * @example
     * // Get one RapportMission
     * const rapportMission = await prisma.rapportMission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RapportMissionFindFirstArgs>(args?: SelectSubset<T, RapportMissionFindFirstArgs<ExtArgs>>): Prisma__RapportMissionClient<$Result.GetResult<Prisma.$RapportMissionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RapportMission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RapportMissionFindFirstOrThrowArgs} args - Arguments to find a RapportMission
     * @example
     * // Get one RapportMission
     * const rapportMission = await prisma.rapportMission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RapportMissionFindFirstOrThrowArgs>(args?: SelectSubset<T, RapportMissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__RapportMissionClient<$Result.GetResult<Prisma.$RapportMissionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RapportMissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RapportMissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RapportMissions
     * const rapportMissions = await prisma.rapportMission.findMany()
     * 
     * // Get first 10 RapportMissions
     * const rapportMissions = await prisma.rapportMission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rapportMissionWithIdOnly = await prisma.rapportMission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RapportMissionFindManyArgs>(args?: SelectSubset<T, RapportMissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RapportMissionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RapportMission.
     * @param {RapportMissionCreateArgs} args - Arguments to create a RapportMission.
     * @example
     * // Create one RapportMission
     * const RapportMission = await prisma.rapportMission.create({
     *   data: {
     *     // ... data to create a RapportMission
     *   }
     * })
     * 
     */
    create<T extends RapportMissionCreateArgs>(args: SelectSubset<T, RapportMissionCreateArgs<ExtArgs>>): Prisma__RapportMissionClient<$Result.GetResult<Prisma.$RapportMissionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RapportMissions.
     * @param {RapportMissionCreateManyArgs} args - Arguments to create many RapportMissions.
     * @example
     * // Create many RapportMissions
     * const rapportMission = await prisma.rapportMission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RapportMissionCreateManyArgs>(args?: SelectSubset<T, RapportMissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RapportMissions and returns the data saved in the database.
     * @param {RapportMissionCreateManyAndReturnArgs} args - Arguments to create many RapportMissions.
     * @example
     * // Create many RapportMissions
     * const rapportMission = await prisma.rapportMission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RapportMissions and only return the `id`
     * const rapportMissionWithIdOnly = await prisma.rapportMission.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RapportMissionCreateManyAndReturnArgs>(args?: SelectSubset<T, RapportMissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RapportMissionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RapportMission.
     * @param {RapportMissionDeleteArgs} args - Arguments to delete one RapportMission.
     * @example
     * // Delete one RapportMission
     * const RapportMission = await prisma.rapportMission.delete({
     *   where: {
     *     // ... filter to delete one RapportMission
     *   }
     * })
     * 
     */
    delete<T extends RapportMissionDeleteArgs>(args: SelectSubset<T, RapportMissionDeleteArgs<ExtArgs>>): Prisma__RapportMissionClient<$Result.GetResult<Prisma.$RapportMissionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RapportMission.
     * @param {RapportMissionUpdateArgs} args - Arguments to update one RapportMission.
     * @example
     * // Update one RapportMission
     * const rapportMission = await prisma.rapportMission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RapportMissionUpdateArgs>(args: SelectSubset<T, RapportMissionUpdateArgs<ExtArgs>>): Prisma__RapportMissionClient<$Result.GetResult<Prisma.$RapportMissionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RapportMissions.
     * @param {RapportMissionDeleteManyArgs} args - Arguments to filter RapportMissions to delete.
     * @example
     * // Delete a few RapportMissions
     * const { count } = await prisma.rapportMission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RapportMissionDeleteManyArgs>(args?: SelectSubset<T, RapportMissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RapportMissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RapportMissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RapportMissions
     * const rapportMission = await prisma.rapportMission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RapportMissionUpdateManyArgs>(args: SelectSubset<T, RapportMissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RapportMission.
     * @param {RapportMissionUpsertArgs} args - Arguments to update or create a RapportMission.
     * @example
     * // Update or create a RapportMission
     * const rapportMission = await prisma.rapportMission.upsert({
     *   create: {
     *     // ... data to create a RapportMission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RapportMission we want to update
     *   }
     * })
     */
    upsert<T extends RapportMissionUpsertArgs>(args: SelectSubset<T, RapportMissionUpsertArgs<ExtArgs>>): Prisma__RapportMissionClient<$Result.GetResult<Prisma.$RapportMissionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RapportMissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RapportMissionCountArgs} args - Arguments to filter RapportMissions to count.
     * @example
     * // Count the number of RapportMissions
     * const count = await prisma.rapportMission.count({
     *   where: {
     *     // ... the filter for the RapportMissions we want to count
     *   }
     * })
    **/
    count<T extends RapportMissionCountArgs>(
      args?: Subset<T, RapportMissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RapportMissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RapportMission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RapportMissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RapportMissionAggregateArgs>(args: Subset<T, RapportMissionAggregateArgs>): Prisma.PrismaPromise<GetRapportMissionAggregateType<T>>

    /**
     * Group by RapportMission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RapportMissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RapportMissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RapportMissionGroupByArgs['orderBy'] }
        : { orderBy?: RapportMissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RapportMissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRapportMissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RapportMission model
   */
  readonly fields: RapportMissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RapportMission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RapportMissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    intervention<T extends RapportMission$interventionArgs<ExtArgs> = {}>(args?: Subset<T, RapportMission$interventionArgs<ExtArgs>>): Prisma__InterventionClient<$Result.GetResult<Prisma.$InterventionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    technicien<T extends TechnicienDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TechnicienDefaultArgs<ExtArgs>>): Prisma__TechnicienClient<$Result.GetResult<Prisma.$TechnicienPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    mission<T extends MissionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MissionDefaultArgs<ExtArgs>>): Prisma__MissionClient<$Result.GetResult<Prisma.$MissionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    images<T extends RapportMission$imagesArgs<ExtArgs> = {}>(args?: Subset<T, RapportMission$imagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RapportImagePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RapportMission model
   */ 
  interface RapportMissionFieldRefs {
    readonly id: FieldRef<"RapportMission", 'Int'>
    readonly titre: FieldRef<"RapportMission", 'String'>
    readonly contenu: FieldRef<"RapportMission", 'String'>
    readonly interventionId: FieldRef<"RapportMission", 'Int'>
    readonly technicienId: FieldRef<"RapportMission", 'Int'>
    readonly missionId: FieldRef<"RapportMission", 'String'>
    readonly createdById: FieldRef<"RapportMission", 'Int'>
    readonly statut: FieldRef<"RapportMission", 'String'>
    readonly dateValidation: FieldRef<"RapportMission", 'DateTime'>
    readonly commentaire: FieldRef<"RapportMission", 'String'>
    readonly createdAt: FieldRef<"RapportMission", 'DateTime'>
    readonly updatedAt: FieldRef<"RapportMission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RapportMission findUnique
   */
  export type RapportMissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RapportMission
     */
    select?: RapportMissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RapportMissionInclude<ExtArgs> | null
    /**
     * Filter, which RapportMission to fetch.
     */
    where: RapportMissionWhereUniqueInput
  }

  /**
   * RapportMission findUniqueOrThrow
   */
  export type RapportMissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RapportMission
     */
    select?: RapportMissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RapportMissionInclude<ExtArgs> | null
    /**
     * Filter, which RapportMission to fetch.
     */
    where: RapportMissionWhereUniqueInput
  }

  /**
   * RapportMission findFirst
   */
  export type RapportMissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RapportMission
     */
    select?: RapportMissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RapportMissionInclude<ExtArgs> | null
    /**
     * Filter, which RapportMission to fetch.
     */
    where?: RapportMissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RapportMissions to fetch.
     */
    orderBy?: RapportMissionOrderByWithRelationInput | RapportMissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RapportMissions.
     */
    cursor?: RapportMissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RapportMissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RapportMissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RapportMissions.
     */
    distinct?: RapportMissionScalarFieldEnum | RapportMissionScalarFieldEnum[]
  }

  /**
   * RapportMission findFirstOrThrow
   */
  export type RapportMissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RapportMission
     */
    select?: RapportMissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RapportMissionInclude<ExtArgs> | null
    /**
     * Filter, which RapportMission to fetch.
     */
    where?: RapportMissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RapportMissions to fetch.
     */
    orderBy?: RapportMissionOrderByWithRelationInput | RapportMissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RapportMissions.
     */
    cursor?: RapportMissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RapportMissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RapportMissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RapportMissions.
     */
    distinct?: RapportMissionScalarFieldEnum | RapportMissionScalarFieldEnum[]
  }

  /**
   * RapportMission findMany
   */
  export type RapportMissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RapportMission
     */
    select?: RapportMissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RapportMissionInclude<ExtArgs> | null
    /**
     * Filter, which RapportMissions to fetch.
     */
    where?: RapportMissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RapportMissions to fetch.
     */
    orderBy?: RapportMissionOrderByWithRelationInput | RapportMissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RapportMissions.
     */
    cursor?: RapportMissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RapportMissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RapportMissions.
     */
    skip?: number
    distinct?: RapportMissionScalarFieldEnum | RapportMissionScalarFieldEnum[]
  }

  /**
   * RapportMission create
   */
  export type RapportMissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RapportMission
     */
    select?: RapportMissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RapportMissionInclude<ExtArgs> | null
    /**
     * The data needed to create a RapportMission.
     */
    data: XOR<RapportMissionCreateInput, RapportMissionUncheckedCreateInput>
  }

  /**
   * RapportMission createMany
   */
  export type RapportMissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RapportMissions.
     */
    data: RapportMissionCreateManyInput | RapportMissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RapportMission createManyAndReturn
   */
  export type RapportMissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RapportMission
     */
    select?: RapportMissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RapportMissions.
     */
    data: RapportMissionCreateManyInput | RapportMissionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RapportMissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RapportMission update
   */
  export type RapportMissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RapportMission
     */
    select?: RapportMissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RapportMissionInclude<ExtArgs> | null
    /**
     * The data needed to update a RapportMission.
     */
    data: XOR<RapportMissionUpdateInput, RapportMissionUncheckedUpdateInput>
    /**
     * Choose, which RapportMission to update.
     */
    where: RapportMissionWhereUniqueInput
  }

  /**
   * RapportMission updateMany
   */
  export type RapportMissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RapportMissions.
     */
    data: XOR<RapportMissionUpdateManyMutationInput, RapportMissionUncheckedUpdateManyInput>
    /**
     * Filter which RapportMissions to update
     */
    where?: RapportMissionWhereInput
  }

  /**
   * RapportMission upsert
   */
  export type RapportMissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RapportMission
     */
    select?: RapportMissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RapportMissionInclude<ExtArgs> | null
    /**
     * The filter to search for the RapportMission to update in case it exists.
     */
    where: RapportMissionWhereUniqueInput
    /**
     * In case the RapportMission found by the `where` argument doesn't exist, create a new RapportMission with this data.
     */
    create: XOR<RapportMissionCreateInput, RapportMissionUncheckedCreateInput>
    /**
     * In case the RapportMission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RapportMissionUpdateInput, RapportMissionUncheckedUpdateInput>
  }

  /**
   * RapportMission delete
   */
  export type RapportMissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RapportMission
     */
    select?: RapportMissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RapportMissionInclude<ExtArgs> | null
    /**
     * Filter which RapportMission to delete.
     */
    where: RapportMissionWhereUniqueInput
  }

  /**
   * RapportMission deleteMany
   */
  export type RapportMissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RapportMissions to delete
     */
    where?: RapportMissionWhereInput
  }

  /**
   * RapportMission.intervention
   */
  export type RapportMission$interventionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intervention
     */
    select?: InterventionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionInclude<ExtArgs> | null
    where?: InterventionWhereInput
  }

  /**
   * RapportMission.images
   */
  export type RapportMission$imagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RapportImage
     */
    select?: RapportImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RapportImageInclude<ExtArgs> | null
    where?: RapportImageWhereInput
    orderBy?: RapportImageOrderByWithRelationInput | RapportImageOrderByWithRelationInput[]
    cursor?: RapportImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RapportImageScalarFieldEnum | RapportImageScalarFieldEnum[]
  }

  /**
   * RapportMission without action
   */
  export type RapportMissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RapportMission
     */
    select?: RapportMissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RapportMissionInclude<ExtArgs> | null
  }


  /**
   * Model RapportImage
   */

  export type AggregateRapportImage = {
    _count: RapportImageCountAggregateOutputType | null
    _avg: RapportImageAvgAggregateOutputType | null
    _sum: RapportImageSumAggregateOutputType | null
    _min: RapportImageMinAggregateOutputType | null
    _max: RapportImageMaxAggregateOutputType | null
  }

  export type RapportImageAvgAggregateOutputType = {
    id: number | null
    rapportId: number | null
    ordre: number | null
  }

  export type RapportImageSumAggregateOutputType = {
    id: number | null
    rapportId: number | null
    ordre: number | null
  }

  export type RapportImageMinAggregateOutputType = {
    id: number | null
    rapportId: number | null
    url: string | null
    description: string | null
    ordre: number | null
    createdAt: Date | null
  }

  export type RapportImageMaxAggregateOutputType = {
    id: number | null
    rapportId: number | null
    url: string | null
    description: string | null
    ordre: number | null
    createdAt: Date | null
  }

  export type RapportImageCountAggregateOutputType = {
    id: number
    rapportId: number
    url: number
    description: number
    ordre: number
    createdAt: number
    _all: number
  }


  export type RapportImageAvgAggregateInputType = {
    id?: true
    rapportId?: true
    ordre?: true
  }

  export type RapportImageSumAggregateInputType = {
    id?: true
    rapportId?: true
    ordre?: true
  }

  export type RapportImageMinAggregateInputType = {
    id?: true
    rapportId?: true
    url?: true
    description?: true
    ordre?: true
    createdAt?: true
  }

  export type RapportImageMaxAggregateInputType = {
    id?: true
    rapportId?: true
    url?: true
    description?: true
    ordre?: true
    createdAt?: true
  }

  export type RapportImageCountAggregateInputType = {
    id?: true
    rapportId?: true
    url?: true
    description?: true
    ordre?: true
    createdAt?: true
    _all?: true
  }

  export type RapportImageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RapportImage to aggregate.
     */
    where?: RapportImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RapportImages to fetch.
     */
    orderBy?: RapportImageOrderByWithRelationInput | RapportImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RapportImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RapportImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RapportImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RapportImages
    **/
    _count?: true | RapportImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RapportImageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RapportImageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RapportImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RapportImageMaxAggregateInputType
  }

  export type GetRapportImageAggregateType<T extends RapportImageAggregateArgs> = {
        [P in keyof T & keyof AggregateRapportImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRapportImage[P]>
      : GetScalarType<T[P], AggregateRapportImage[P]>
  }




  export type RapportImageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RapportImageWhereInput
    orderBy?: RapportImageOrderByWithAggregationInput | RapportImageOrderByWithAggregationInput[]
    by: RapportImageScalarFieldEnum[] | RapportImageScalarFieldEnum
    having?: RapportImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RapportImageCountAggregateInputType | true
    _avg?: RapportImageAvgAggregateInputType
    _sum?: RapportImageSumAggregateInputType
    _min?: RapportImageMinAggregateInputType
    _max?: RapportImageMaxAggregateInputType
  }

  export type RapportImageGroupByOutputType = {
    id: number
    rapportId: number
    url: string
    description: string | null
    ordre: number
    createdAt: Date
    _count: RapportImageCountAggregateOutputType | null
    _avg: RapportImageAvgAggregateOutputType | null
    _sum: RapportImageSumAggregateOutputType | null
    _min: RapportImageMinAggregateOutputType | null
    _max: RapportImageMaxAggregateOutputType | null
  }

  type GetRapportImageGroupByPayload<T extends RapportImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RapportImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RapportImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RapportImageGroupByOutputType[P]>
            : GetScalarType<T[P], RapportImageGroupByOutputType[P]>
        }
      >
    >


  export type RapportImageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rapportId?: boolean
    url?: boolean
    description?: boolean
    ordre?: boolean
    createdAt?: boolean
    rapport?: boolean | RapportMissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rapportImage"]>

  export type RapportImageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rapportId?: boolean
    url?: boolean
    description?: boolean
    ordre?: boolean
    createdAt?: boolean
    rapport?: boolean | RapportMissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rapportImage"]>

  export type RapportImageSelectScalar = {
    id?: boolean
    rapportId?: boolean
    url?: boolean
    description?: boolean
    ordre?: boolean
    createdAt?: boolean
  }

  export type RapportImageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rapport?: boolean | RapportMissionDefaultArgs<ExtArgs>
  }
  export type RapportImageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rapport?: boolean | RapportMissionDefaultArgs<ExtArgs>
  }

  export type $RapportImagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RapportImage"
    objects: {
      rapport: Prisma.$RapportMissionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      rapportId: number
      url: string
      description: string | null
      ordre: number
      createdAt: Date
    }, ExtArgs["result"]["rapportImage"]>
    composites: {}
  }

  type RapportImageGetPayload<S extends boolean | null | undefined | RapportImageDefaultArgs> = $Result.GetResult<Prisma.$RapportImagePayload, S>

  type RapportImageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RapportImageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RapportImageCountAggregateInputType | true
    }

  export interface RapportImageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RapportImage'], meta: { name: 'RapportImage' } }
    /**
     * Find zero or one RapportImage that matches the filter.
     * @param {RapportImageFindUniqueArgs} args - Arguments to find a RapportImage
     * @example
     * // Get one RapportImage
     * const rapportImage = await prisma.rapportImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RapportImageFindUniqueArgs>(args: SelectSubset<T, RapportImageFindUniqueArgs<ExtArgs>>): Prisma__RapportImageClient<$Result.GetResult<Prisma.$RapportImagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RapportImage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RapportImageFindUniqueOrThrowArgs} args - Arguments to find a RapportImage
     * @example
     * // Get one RapportImage
     * const rapportImage = await prisma.rapportImage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RapportImageFindUniqueOrThrowArgs>(args: SelectSubset<T, RapportImageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RapportImageClient<$Result.GetResult<Prisma.$RapportImagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RapportImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RapportImageFindFirstArgs} args - Arguments to find a RapportImage
     * @example
     * // Get one RapportImage
     * const rapportImage = await prisma.rapportImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RapportImageFindFirstArgs>(args?: SelectSubset<T, RapportImageFindFirstArgs<ExtArgs>>): Prisma__RapportImageClient<$Result.GetResult<Prisma.$RapportImagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RapportImage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RapportImageFindFirstOrThrowArgs} args - Arguments to find a RapportImage
     * @example
     * // Get one RapportImage
     * const rapportImage = await prisma.rapportImage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RapportImageFindFirstOrThrowArgs>(args?: SelectSubset<T, RapportImageFindFirstOrThrowArgs<ExtArgs>>): Prisma__RapportImageClient<$Result.GetResult<Prisma.$RapportImagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RapportImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RapportImageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RapportImages
     * const rapportImages = await prisma.rapportImage.findMany()
     * 
     * // Get first 10 RapportImages
     * const rapportImages = await prisma.rapportImage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rapportImageWithIdOnly = await prisma.rapportImage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RapportImageFindManyArgs>(args?: SelectSubset<T, RapportImageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RapportImagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RapportImage.
     * @param {RapportImageCreateArgs} args - Arguments to create a RapportImage.
     * @example
     * // Create one RapportImage
     * const RapportImage = await prisma.rapportImage.create({
     *   data: {
     *     // ... data to create a RapportImage
     *   }
     * })
     * 
     */
    create<T extends RapportImageCreateArgs>(args: SelectSubset<T, RapportImageCreateArgs<ExtArgs>>): Prisma__RapportImageClient<$Result.GetResult<Prisma.$RapportImagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RapportImages.
     * @param {RapportImageCreateManyArgs} args - Arguments to create many RapportImages.
     * @example
     * // Create many RapportImages
     * const rapportImage = await prisma.rapportImage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RapportImageCreateManyArgs>(args?: SelectSubset<T, RapportImageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RapportImages and returns the data saved in the database.
     * @param {RapportImageCreateManyAndReturnArgs} args - Arguments to create many RapportImages.
     * @example
     * // Create many RapportImages
     * const rapportImage = await prisma.rapportImage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RapportImages and only return the `id`
     * const rapportImageWithIdOnly = await prisma.rapportImage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RapportImageCreateManyAndReturnArgs>(args?: SelectSubset<T, RapportImageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RapportImagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RapportImage.
     * @param {RapportImageDeleteArgs} args - Arguments to delete one RapportImage.
     * @example
     * // Delete one RapportImage
     * const RapportImage = await prisma.rapportImage.delete({
     *   where: {
     *     // ... filter to delete one RapportImage
     *   }
     * })
     * 
     */
    delete<T extends RapportImageDeleteArgs>(args: SelectSubset<T, RapportImageDeleteArgs<ExtArgs>>): Prisma__RapportImageClient<$Result.GetResult<Prisma.$RapportImagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RapportImage.
     * @param {RapportImageUpdateArgs} args - Arguments to update one RapportImage.
     * @example
     * // Update one RapportImage
     * const rapportImage = await prisma.rapportImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RapportImageUpdateArgs>(args: SelectSubset<T, RapportImageUpdateArgs<ExtArgs>>): Prisma__RapportImageClient<$Result.GetResult<Prisma.$RapportImagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RapportImages.
     * @param {RapportImageDeleteManyArgs} args - Arguments to filter RapportImages to delete.
     * @example
     * // Delete a few RapportImages
     * const { count } = await prisma.rapportImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RapportImageDeleteManyArgs>(args?: SelectSubset<T, RapportImageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RapportImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RapportImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RapportImages
     * const rapportImage = await prisma.rapportImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RapportImageUpdateManyArgs>(args: SelectSubset<T, RapportImageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RapportImage.
     * @param {RapportImageUpsertArgs} args - Arguments to update or create a RapportImage.
     * @example
     * // Update or create a RapportImage
     * const rapportImage = await prisma.rapportImage.upsert({
     *   create: {
     *     // ... data to create a RapportImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RapportImage we want to update
     *   }
     * })
     */
    upsert<T extends RapportImageUpsertArgs>(args: SelectSubset<T, RapportImageUpsertArgs<ExtArgs>>): Prisma__RapportImageClient<$Result.GetResult<Prisma.$RapportImagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RapportImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RapportImageCountArgs} args - Arguments to filter RapportImages to count.
     * @example
     * // Count the number of RapportImages
     * const count = await prisma.rapportImage.count({
     *   where: {
     *     // ... the filter for the RapportImages we want to count
     *   }
     * })
    **/
    count<T extends RapportImageCountArgs>(
      args?: Subset<T, RapportImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RapportImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RapportImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RapportImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RapportImageAggregateArgs>(args: Subset<T, RapportImageAggregateArgs>): Prisma.PrismaPromise<GetRapportImageAggregateType<T>>

    /**
     * Group by RapportImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RapportImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RapportImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RapportImageGroupByArgs['orderBy'] }
        : { orderBy?: RapportImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RapportImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRapportImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RapportImage model
   */
  readonly fields: RapportImageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RapportImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RapportImageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    rapport<T extends RapportMissionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RapportMissionDefaultArgs<ExtArgs>>): Prisma__RapportMissionClient<$Result.GetResult<Prisma.$RapportMissionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RapportImage model
   */ 
  interface RapportImageFieldRefs {
    readonly id: FieldRef<"RapportImage", 'Int'>
    readonly rapportId: FieldRef<"RapportImage", 'Int'>
    readonly url: FieldRef<"RapportImage", 'String'>
    readonly description: FieldRef<"RapportImage", 'String'>
    readonly ordre: FieldRef<"RapportImage", 'Int'>
    readonly createdAt: FieldRef<"RapportImage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RapportImage findUnique
   */
  export type RapportImageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RapportImage
     */
    select?: RapportImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RapportImageInclude<ExtArgs> | null
    /**
     * Filter, which RapportImage to fetch.
     */
    where: RapportImageWhereUniqueInput
  }

  /**
   * RapportImage findUniqueOrThrow
   */
  export type RapportImageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RapportImage
     */
    select?: RapportImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RapportImageInclude<ExtArgs> | null
    /**
     * Filter, which RapportImage to fetch.
     */
    where: RapportImageWhereUniqueInput
  }

  /**
   * RapportImage findFirst
   */
  export type RapportImageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RapportImage
     */
    select?: RapportImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RapportImageInclude<ExtArgs> | null
    /**
     * Filter, which RapportImage to fetch.
     */
    where?: RapportImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RapportImages to fetch.
     */
    orderBy?: RapportImageOrderByWithRelationInput | RapportImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RapportImages.
     */
    cursor?: RapportImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RapportImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RapportImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RapportImages.
     */
    distinct?: RapportImageScalarFieldEnum | RapportImageScalarFieldEnum[]
  }

  /**
   * RapportImage findFirstOrThrow
   */
  export type RapportImageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RapportImage
     */
    select?: RapportImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RapportImageInclude<ExtArgs> | null
    /**
     * Filter, which RapportImage to fetch.
     */
    where?: RapportImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RapportImages to fetch.
     */
    orderBy?: RapportImageOrderByWithRelationInput | RapportImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RapportImages.
     */
    cursor?: RapportImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RapportImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RapportImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RapportImages.
     */
    distinct?: RapportImageScalarFieldEnum | RapportImageScalarFieldEnum[]
  }

  /**
   * RapportImage findMany
   */
  export type RapportImageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RapportImage
     */
    select?: RapportImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RapportImageInclude<ExtArgs> | null
    /**
     * Filter, which RapportImages to fetch.
     */
    where?: RapportImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RapportImages to fetch.
     */
    orderBy?: RapportImageOrderByWithRelationInput | RapportImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RapportImages.
     */
    cursor?: RapportImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RapportImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RapportImages.
     */
    skip?: number
    distinct?: RapportImageScalarFieldEnum | RapportImageScalarFieldEnum[]
  }

  /**
   * RapportImage create
   */
  export type RapportImageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RapportImage
     */
    select?: RapportImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RapportImageInclude<ExtArgs> | null
    /**
     * The data needed to create a RapportImage.
     */
    data: XOR<RapportImageCreateInput, RapportImageUncheckedCreateInput>
  }

  /**
   * RapportImage createMany
   */
  export type RapportImageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RapportImages.
     */
    data: RapportImageCreateManyInput | RapportImageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RapportImage createManyAndReturn
   */
  export type RapportImageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RapportImage
     */
    select?: RapportImageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RapportImages.
     */
    data: RapportImageCreateManyInput | RapportImageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RapportImageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RapportImage update
   */
  export type RapportImageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RapportImage
     */
    select?: RapportImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RapportImageInclude<ExtArgs> | null
    /**
     * The data needed to update a RapportImage.
     */
    data: XOR<RapportImageUpdateInput, RapportImageUncheckedUpdateInput>
    /**
     * Choose, which RapportImage to update.
     */
    where: RapportImageWhereUniqueInput
  }

  /**
   * RapportImage updateMany
   */
  export type RapportImageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RapportImages.
     */
    data: XOR<RapportImageUpdateManyMutationInput, RapportImageUncheckedUpdateManyInput>
    /**
     * Filter which RapportImages to update
     */
    where?: RapportImageWhereInput
  }

  /**
   * RapportImage upsert
   */
  export type RapportImageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RapportImage
     */
    select?: RapportImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RapportImageInclude<ExtArgs> | null
    /**
     * The filter to search for the RapportImage to update in case it exists.
     */
    where: RapportImageWhereUniqueInput
    /**
     * In case the RapportImage found by the `where` argument doesn't exist, create a new RapportImage with this data.
     */
    create: XOR<RapportImageCreateInput, RapportImageUncheckedCreateInput>
    /**
     * In case the RapportImage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RapportImageUpdateInput, RapportImageUncheckedUpdateInput>
  }

  /**
   * RapportImage delete
   */
  export type RapportImageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RapportImage
     */
    select?: RapportImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RapportImageInclude<ExtArgs> | null
    /**
     * Filter which RapportImage to delete.
     */
    where: RapportImageWhereUniqueInput
  }

  /**
   * RapportImage deleteMany
   */
  export type RapportImageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RapportImages to delete
     */
    where?: RapportImageWhereInput
  }

  /**
   * RapportImage without action
   */
  export type RapportImageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RapportImage
     */
    select?: RapportImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RapportImageInclude<ExtArgs> | null
  }


  /**
   * Model Materiel
   */

  export type AggregateMateriel = {
    _count: MaterielCountAggregateOutputType | null
    _avg: MaterielAvgAggregateOutputType | null
    _sum: MaterielSumAggregateOutputType | null
    _min: MaterielMinAggregateOutputType | null
    _max: MaterielMaxAggregateOutputType | null
  }

  export type MaterielAvgAggregateOutputType = {
    id: number | null
    quantiteTotale: number | null
    quantiteDisponible: number | null
    seuilAlerte: number | null
    prixUnitaire: number | null
  }

  export type MaterielSumAggregateOutputType = {
    id: number | null
    quantiteTotale: number | null
    quantiteDisponible: number | null
    seuilAlerte: number | null
    prixUnitaire: number | null
  }

  export type MaterielMinAggregateOutputType = {
    id: number | null
    reference: string | null
    designation: string | null
    description: string | null
    quantiteTotale: number | null
    quantiteDisponible: number | null
    seuilAlerte: number | null
    emplacement: string | null
    categorie: string | null
    prixUnitaire: number | null
    fournisseur: string | null
    dateAchat: Date | null
    garantie: string | null
    statut: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MaterielMaxAggregateOutputType = {
    id: number | null
    reference: string | null
    designation: string | null
    description: string | null
    quantiteTotale: number | null
    quantiteDisponible: number | null
    seuilAlerte: number | null
    emplacement: string | null
    categorie: string | null
    prixUnitaire: number | null
    fournisseur: string | null
    dateAchat: Date | null
    garantie: string | null
    statut: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MaterielCountAggregateOutputType = {
    id: number
    reference: number
    designation: number
    description: number
    quantiteTotale: number
    quantiteDisponible: number
    seuilAlerte: number
    emplacement: number
    categorie: number
    prixUnitaire: number
    fournisseur: number
    dateAchat: number
    garantie: number
    statut: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MaterielAvgAggregateInputType = {
    id?: true
    quantiteTotale?: true
    quantiteDisponible?: true
    seuilAlerte?: true
    prixUnitaire?: true
  }

  export type MaterielSumAggregateInputType = {
    id?: true
    quantiteTotale?: true
    quantiteDisponible?: true
    seuilAlerte?: true
    prixUnitaire?: true
  }

  export type MaterielMinAggregateInputType = {
    id?: true
    reference?: true
    designation?: true
    description?: true
    quantiteTotale?: true
    quantiteDisponible?: true
    seuilAlerte?: true
    emplacement?: true
    categorie?: true
    prixUnitaire?: true
    fournisseur?: true
    dateAchat?: true
    garantie?: true
    statut?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MaterielMaxAggregateInputType = {
    id?: true
    reference?: true
    designation?: true
    description?: true
    quantiteTotale?: true
    quantiteDisponible?: true
    seuilAlerte?: true
    emplacement?: true
    categorie?: true
    prixUnitaire?: true
    fournisseur?: true
    dateAchat?: true
    garantie?: true
    statut?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MaterielCountAggregateInputType = {
    id?: true
    reference?: true
    designation?: true
    description?: true
    quantiteTotale?: true
    quantiteDisponible?: true
    seuilAlerte?: true
    emplacement?: true
    categorie?: true
    prixUnitaire?: true
    fournisseur?: true
    dateAchat?: true
    garantie?: true
    statut?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MaterielAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Materiel to aggregate.
     */
    where?: MaterielWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materiels to fetch.
     */
    orderBy?: MaterielOrderByWithRelationInput | MaterielOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MaterielWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materiels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materiels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Materiels
    **/
    _count?: true | MaterielCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MaterielAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MaterielSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaterielMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaterielMaxAggregateInputType
  }

  export type GetMaterielAggregateType<T extends MaterielAggregateArgs> = {
        [P in keyof T & keyof AggregateMateriel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMateriel[P]>
      : GetScalarType<T[P], AggregateMateriel[P]>
  }




  export type MaterielGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterielWhereInput
    orderBy?: MaterielOrderByWithAggregationInput | MaterielOrderByWithAggregationInput[]
    by: MaterielScalarFieldEnum[] | MaterielScalarFieldEnum
    having?: MaterielScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaterielCountAggregateInputType | true
    _avg?: MaterielAvgAggregateInputType
    _sum?: MaterielSumAggregateInputType
    _min?: MaterielMinAggregateInputType
    _max?: MaterielMaxAggregateInputType
  }

  export type MaterielGroupByOutputType = {
    id: number
    reference: string
    designation: string
    description: string | null
    quantiteTotale: number
    quantiteDisponible: number
    seuilAlerte: number
    emplacement: string | null
    categorie: string
    prixUnitaire: number | null
    fournisseur: string | null
    dateAchat: Date | null
    garantie: string | null
    statut: string
    createdAt: Date
    updatedAt: Date
    _count: MaterielCountAggregateOutputType | null
    _avg: MaterielAvgAggregateOutputType | null
    _sum: MaterielSumAggregateOutputType | null
    _min: MaterielMinAggregateOutputType | null
    _max: MaterielMaxAggregateOutputType | null
  }

  type GetMaterielGroupByPayload<T extends MaterielGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MaterielGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MaterielGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MaterielGroupByOutputType[P]>
            : GetScalarType<T[P], MaterielGroupByOutputType[P]>
        }
      >
    >


  export type MaterielSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reference?: boolean
    designation?: boolean
    description?: boolean
    quantiteTotale?: boolean
    quantiteDisponible?: boolean
    seuilAlerte?: boolean
    emplacement?: boolean
    categorie?: boolean
    prixUnitaire?: boolean
    fournisseur?: boolean
    dateAchat?: boolean
    garantie?: boolean
    statut?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sorties?: boolean | Materiel$sortiesArgs<ExtArgs>
    entrees?: boolean | Materiel$entreesArgs<ExtArgs>
    _count?: boolean | MaterielCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["materiel"]>

  export type MaterielSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reference?: boolean
    designation?: boolean
    description?: boolean
    quantiteTotale?: boolean
    quantiteDisponible?: boolean
    seuilAlerte?: boolean
    emplacement?: boolean
    categorie?: boolean
    prixUnitaire?: boolean
    fournisseur?: boolean
    dateAchat?: boolean
    garantie?: boolean
    statut?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["materiel"]>

  export type MaterielSelectScalar = {
    id?: boolean
    reference?: boolean
    designation?: boolean
    description?: boolean
    quantiteTotale?: boolean
    quantiteDisponible?: boolean
    seuilAlerte?: boolean
    emplacement?: boolean
    categorie?: boolean
    prixUnitaire?: boolean
    fournisseur?: boolean
    dateAchat?: boolean
    garantie?: boolean
    statut?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MaterielInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sorties?: boolean | Materiel$sortiesArgs<ExtArgs>
    entrees?: boolean | Materiel$entreesArgs<ExtArgs>
    _count?: boolean | MaterielCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MaterielIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MaterielPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Materiel"
    objects: {
      sorties: Prisma.$SortieMaterielPayload<ExtArgs>[]
      entrees: Prisma.$EntreeMaterielPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      reference: string
      designation: string
      description: string | null
      quantiteTotale: number
      quantiteDisponible: number
      seuilAlerte: number
      emplacement: string | null
      categorie: string
      prixUnitaire: number | null
      fournisseur: string | null
      dateAchat: Date | null
      garantie: string | null
      statut: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["materiel"]>
    composites: {}
  }

  type MaterielGetPayload<S extends boolean | null | undefined | MaterielDefaultArgs> = $Result.GetResult<Prisma.$MaterielPayload, S>

  type MaterielCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MaterielFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MaterielCountAggregateInputType | true
    }

  export interface MaterielDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Materiel'], meta: { name: 'Materiel' } }
    /**
     * Find zero or one Materiel that matches the filter.
     * @param {MaterielFindUniqueArgs} args - Arguments to find a Materiel
     * @example
     * // Get one Materiel
     * const materiel = await prisma.materiel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MaterielFindUniqueArgs>(args: SelectSubset<T, MaterielFindUniqueArgs<ExtArgs>>): Prisma__MaterielClient<$Result.GetResult<Prisma.$MaterielPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Materiel that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MaterielFindUniqueOrThrowArgs} args - Arguments to find a Materiel
     * @example
     * // Get one Materiel
     * const materiel = await prisma.materiel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MaterielFindUniqueOrThrowArgs>(args: SelectSubset<T, MaterielFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MaterielClient<$Result.GetResult<Prisma.$MaterielPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Materiel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterielFindFirstArgs} args - Arguments to find a Materiel
     * @example
     * // Get one Materiel
     * const materiel = await prisma.materiel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MaterielFindFirstArgs>(args?: SelectSubset<T, MaterielFindFirstArgs<ExtArgs>>): Prisma__MaterielClient<$Result.GetResult<Prisma.$MaterielPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Materiel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterielFindFirstOrThrowArgs} args - Arguments to find a Materiel
     * @example
     * // Get one Materiel
     * const materiel = await prisma.materiel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MaterielFindFirstOrThrowArgs>(args?: SelectSubset<T, MaterielFindFirstOrThrowArgs<ExtArgs>>): Prisma__MaterielClient<$Result.GetResult<Prisma.$MaterielPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Materiels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterielFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Materiels
     * const materiels = await prisma.materiel.findMany()
     * 
     * // Get first 10 Materiels
     * const materiels = await prisma.materiel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const materielWithIdOnly = await prisma.materiel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MaterielFindManyArgs>(args?: SelectSubset<T, MaterielFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterielPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Materiel.
     * @param {MaterielCreateArgs} args - Arguments to create a Materiel.
     * @example
     * // Create one Materiel
     * const Materiel = await prisma.materiel.create({
     *   data: {
     *     // ... data to create a Materiel
     *   }
     * })
     * 
     */
    create<T extends MaterielCreateArgs>(args: SelectSubset<T, MaterielCreateArgs<ExtArgs>>): Prisma__MaterielClient<$Result.GetResult<Prisma.$MaterielPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Materiels.
     * @param {MaterielCreateManyArgs} args - Arguments to create many Materiels.
     * @example
     * // Create many Materiels
     * const materiel = await prisma.materiel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MaterielCreateManyArgs>(args?: SelectSubset<T, MaterielCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Materiels and returns the data saved in the database.
     * @param {MaterielCreateManyAndReturnArgs} args - Arguments to create many Materiels.
     * @example
     * // Create many Materiels
     * const materiel = await prisma.materiel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Materiels and only return the `id`
     * const materielWithIdOnly = await prisma.materiel.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MaterielCreateManyAndReturnArgs>(args?: SelectSubset<T, MaterielCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterielPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Materiel.
     * @param {MaterielDeleteArgs} args - Arguments to delete one Materiel.
     * @example
     * // Delete one Materiel
     * const Materiel = await prisma.materiel.delete({
     *   where: {
     *     // ... filter to delete one Materiel
     *   }
     * })
     * 
     */
    delete<T extends MaterielDeleteArgs>(args: SelectSubset<T, MaterielDeleteArgs<ExtArgs>>): Prisma__MaterielClient<$Result.GetResult<Prisma.$MaterielPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Materiel.
     * @param {MaterielUpdateArgs} args - Arguments to update one Materiel.
     * @example
     * // Update one Materiel
     * const materiel = await prisma.materiel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MaterielUpdateArgs>(args: SelectSubset<T, MaterielUpdateArgs<ExtArgs>>): Prisma__MaterielClient<$Result.GetResult<Prisma.$MaterielPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Materiels.
     * @param {MaterielDeleteManyArgs} args - Arguments to filter Materiels to delete.
     * @example
     * // Delete a few Materiels
     * const { count } = await prisma.materiel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MaterielDeleteManyArgs>(args?: SelectSubset<T, MaterielDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Materiels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterielUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Materiels
     * const materiel = await prisma.materiel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MaterielUpdateManyArgs>(args: SelectSubset<T, MaterielUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Materiel.
     * @param {MaterielUpsertArgs} args - Arguments to update or create a Materiel.
     * @example
     * // Update or create a Materiel
     * const materiel = await prisma.materiel.upsert({
     *   create: {
     *     // ... data to create a Materiel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Materiel we want to update
     *   }
     * })
     */
    upsert<T extends MaterielUpsertArgs>(args: SelectSubset<T, MaterielUpsertArgs<ExtArgs>>): Prisma__MaterielClient<$Result.GetResult<Prisma.$MaterielPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Materiels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterielCountArgs} args - Arguments to filter Materiels to count.
     * @example
     * // Count the number of Materiels
     * const count = await prisma.materiel.count({
     *   where: {
     *     // ... the filter for the Materiels we want to count
     *   }
     * })
    **/
    count<T extends MaterielCountArgs>(
      args?: Subset<T, MaterielCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaterielCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Materiel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterielAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaterielAggregateArgs>(args: Subset<T, MaterielAggregateArgs>): Prisma.PrismaPromise<GetMaterielAggregateType<T>>

    /**
     * Group by Materiel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterielGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MaterielGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MaterielGroupByArgs['orderBy'] }
        : { orderBy?: MaterielGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MaterielGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaterielGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Materiel model
   */
  readonly fields: MaterielFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Materiel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MaterielClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sorties<T extends Materiel$sortiesArgs<ExtArgs> = {}>(args?: Subset<T, Materiel$sortiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SortieMaterielPayload<ExtArgs>, T, "findMany"> | Null>
    entrees<T extends Materiel$entreesArgs<ExtArgs> = {}>(args?: Subset<T, Materiel$entreesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EntreeMaterielPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Materiel model
   */ 
  interface MaterielFieldRefs {
    readonly id: FieldRef<"Materiel", 'Int'>
    readonly reference: FieldRef<"Materiel", 'String'>
    readonly designation: FieldRef<"Materiel", 'String'>
    readonly description: FieldRef<"Materiel", 'String'>
    readonly quantiteTotale: FieldRef<"Materiel", 'Int'>
    readonly quantiteDisponible: FieldRef<"Materiel", 'Int'>
    readonly seuilAlerte: FieldRef<"Materiel", 'Int'>
    readonly emplacement: FieldRef<"Materiel", 'String'>
    readonly categorie: FieldRef<"Materiel", 'String'>
    readonly prixUnitaire: FieldRef<"Materiel", 'Float'>
    readonly fournisseur: FieldRef<"Materiel", 'String'>
    readonly dateAchat: FieldRef<"Materiel", 'DateTime'>
    readonly garantie: FieldRef<"Materiel", 'String'>
    readonly statut: FieldRef<"Materiel", 'String'>
    readonly createdAt: FieldRef<"Materiel", 'DateTime'>
    readonly updatedAt: FieldRef<"Materiel", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Materiel findUnique
   */
  export type MaterielFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materiel
     */
    select?: MaterielSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterielInclude<ExtArgs> | null
    /**
     * Filter, which Materiel to fetch.
     */
    where: MaterielWhereUniqueInput
  }

  /**
   * Materiel findUniqueOrThrow
   */
  export type MaterielFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materiel
     */
    select?: MaterielSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterielInclude<ExtArgs> | null
    /**
     * Filter, which Materiel to fetch.
     */
    where: MaterielWhereUniqueInput
  }

  /**
   * Materiel findFirst
   */
  export type MaterielFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materiel
     */
    select?: MaterielSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterielInclude<ExtArgs> | null
    /**
     * Filter, which Materiel to fetch.
     */
    where?: MaterielWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materiels to fetch.
     */
    orderBy?: MaterielOrderByWithRelationInput | MaterielOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Materiels.
     */
    cursor?: MaterielWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materiels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materiels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Materiels.
     */
    distinct?: MaterielScalarFieldEnum | MaterielScalarFieldEnum[]
  }

  /**
   * Materiel findFirstOrThrow
   */
  export type MaterielFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materiel
     */
    select?: MaterielSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterielInclude<ExtArgs> | null
    /**
     * Filter, which Materiel to fetch.
     */
    where?: MaterielWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materiels to fetch.
     */
    orderBy?: MaterielOrderByWithRelationInput | MaterielOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Materiels.
     */
    cursor?: MaterielWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materiels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materiels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Materiels.
     */
    distinct?: MaterielScalarFieldEnum | MaterielScalarFieldEnum[]
  }

  /**
   * Materiel findMany
   */
  export type MaterielFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materiel
     */
    select?: MaterielSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterielInclude<ExtArgs> | null
    /**
     * Filter, which Materiels to fetch.
     */
    where?: MaterielWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materiels to fetch.
     */
    orderBy?: MaterielOrderByWithRelationInput | MaterielOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Materiels.
     */
    cursor?: MaterielWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materiels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materiels.
     */
    skip?: number
    distinct?: MaterielScalarFieldEnum | MaterielScalarFieldEnum[]
  }

  /**
   * Materiel create
   */
  export type MaterielCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materiel
     */
    select?: MaterielSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterielInclude<ExtArgs> | null
    /**
     * The data needed to create a Materiel.
     */
    data: XOR<MaterielCreateInput, MaterielUncheckedCreateInput>
  }

  /**
   * Materiel createMany
   */
  export type MaterielCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Materiels.
     */
    data: MaterielCreateManyInput | MaterielCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Materiel createManyAndReturn
   */
  export type MaterielCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materiel
     */
    select?: MaterielSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Materiels.
     */
    data: MaterielCreateManyInput | MaterielCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Materiel update
   */
  export type MaterielUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materiel
     */
    select?: MaterielSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterielInclude<ExtArgs> | null
    /**
     * The data needed to update a Materiel.
     */
    data: XOR<MaterielUpdateInput, MaterielUncheckedUpdateInput>
    /**
     * Choose, which Materiel to update.
     */
    where: MaterielWhereUniqueInput
  }

  /**
   * Materiel updateMany
   */
  export type MaterielUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Materiels.
     */
    data: XOR<MaterielUpdateManyMutationInput, MaterielUncheckedUpdateManyInput>
    /**
     * Filter which Materiels to update
     */
    where?: MaterielWhereInput
  }

  /**
   * Materiel upsert
   */
  export type MaterielUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materiel
     */
    select?: MaterielSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterielInclude<ExtArgs> | null
    /**
     * The filter to search for the Materiel to update in case it exists.
     */
    where: MaterielWhereUniqueInput
    /**
     * In case the Materiel found by the `where` argument doesn't exist, create a new Materiel with this data.
     */
    create: XOR<MaterielCreateInput, MaterielUncheckedCreateInput>
    /**
     * In case the Materiel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MaterielUpdateInput, MaterielUncheckedUpdateInput>
  }

  /**
   * Materiel delete
   */
  export type MaterielDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materiel
     */
    select?: MaterielSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterielInclude<ExtArgs> | null
    /**
     * Filter which Materiel to delete.
     */
    where: MaterielWhereUniqueInput
  }

  /**
   * Materiel deleteMany
   */
  export type MaterielDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Materiels to delete
     */
    where?: MaterielWhereInput
  }

  /**
   * Materiel.sorties
   */
  export type Materiel$sortiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SortieMateriel
     */
    select?: SortieMaterielSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SortieMaterielInclude<ExtArgs> | null
    where?: SortieMaterielWhereInput
    orderBy?: SortieMaterielOrderByWithRelationInput | SortieMaterielOrderByWithRelationInput[]
    cursor?: SortieMaterielWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SortieMaterielScalarFieldEnum | SortieMaterielScalarFieldEnum[]
  }

  /**
   * Materiel.entrees
   */
  export type Materiel$entreesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntreeMateriel
     */
    select?: EntreeMaterielSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntreeMaterielInclude<ExtArgs> | null
    where?: EntreeMaterielWhereInput
    orderBy?: EntreeMaterielOrderByWithRelationInput | EntreeMaterielOrderByWithRelationInput[]
    cursor?: EntreeMaterielWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EntreeMaterielScalarFieldEnum | EntreeMaterielScalarFieldEnum[]
  }

  /**
   * Materiel without action
   */
  export type MaterielDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materiel
     */
    select?: MaterielSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterielInclude<ExtArgs> | null
  }


  /**
   * Model SortieMateriel
   */

  export type AggregateSortieMateriel = {
    _count: SortieMaterielCountAggregateOutputType | null
    _avg: SortieMaterielAvgAggregateOutputType | null
    _sum: SortieMaterielSumAggregateOutputType | null
    _min: SortieMaterielMinAggregateOutputType | null
    _max: SortieMaterielMaxAggregateOutputType | null
  }

  export type SortieMaterielAvgAggregateOutputType = {
    id: number | null
    materielId: number | null
    interventionId: number | null
    technicienId: number | null
    quantite: number | null
    quantiteRetour: number | null
  }

  export type SortieMaterielSumAggregateOutputType = {
    id: number | null
    materielId: number | null
    interventionId: number | null
    technicienId: number | null
    quantite: number | null
    quantiteRetour: number | null
  }

  export type SortieMaterielMinAggregateOutputType = {
    id: number | null
    materielId: number | null
    interventionId: number | null
    technicienId: number | null
    quantite: number | null
    dateSortie: Date | null
    motif: string | null
    retourne: boolean | null
    dateRetour: Date | null
    quantiteRetour: number | null
    commentaire: string | null
    createdAt: Date | null
  }

  export type SortieMaterielMaxAggregateOutputType = {
    id: number | null
    materielId: number | null
    interventionId: number | null
    technicienId: number | null
    quantite: number | null
    dateSortie: Date | null
    motif: string | null
    retourne: boolean | null
    dateRetour: Date | null
    quantiteRetour: number | null
    commentaire: string | null
    createdAt: Date | null
  }

  export type SortieMaterielCountAggregateOutputType = {
    id: number
    materielId: number
    interventionId: number
    technicienId: number
    quantite: number
    dateSortie: number
    motif: number
    retourne: number
    dateRetour: number
    quantiteRetour: number
    commentaire: number
    createdAt: number
    _all: number
  }


  export type SortieMaterielAvgAggregateInputType = {
    id?: true
    materielId?: true
    interventionId?: true
    technicienId?: true
    quantite?: true
    quantiteRetour?: true
  }

  export type SortieMaterielSumAggregateInputType = {
    id?: true
    materielId?: true
    interventionId?: true
    technicienId?: true
    quantite?: true
    quantiteRetour?: true
  }

  export type SortieMaterielMinAggregateInputType = {
    id?: true
    materielId?: true
    interventionId?: true
    technicienId?: true
    quantite?: true
    dateSortie?: true
    motif?: true
    retourne?: true
    dateRetour?: true
    quantiteRetour?: true
    commentaire?: true
    createdAt?: true
  }

  export type SortieMaterielMaxAggregateInputType = {
    id?: true
    materielId?: true
    interventionId?: true
    technicienId?: true
    quantite?: true
    dateSortie?: true
    motif?: true
    retourne?: true
    dateRetour?: true
    quantiteRetour?: true
    commentaire?: true
    createdAt?: true
  }

  export type SortieMaterielCountAggregateInputType = {
    id?: true
    materielId?: true
    interventionId?: true
    technicienId?: true
    quantite?: true
    dateSortie?: true
    motif?: true
    retourne?: true
    dateRetour?: true
    quantiteRetour?: true
    commentaire?: true
    createdAt?: true
    _all?: true
  }

  export type SortieMaterielAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SortieMateriel to aggregate.
     */
    where?: SortieMaterielWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SortieMateriels to fetch.
     */
    orderBy?: SortieMaterielOrderByWithRelationInput | SortieMaterielOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SortieMaterielWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SortieMateriels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SortieMateriels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SortieMateriels
    **/
    _count?: true | SortieMaterielCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SortieMaterielAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SortieMaterielSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SortieMaterielMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SortieMaterielMaxAggregateInputType
  }

  export type GetSortieMaterielAggregateType<T extends SortieMaterielAggregateArgs> = {
        [P in keyof T & keyof AggregateSortieMateriel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSortieMateriel[P]>
      : GetScalarType<T[P], AggregateSortieMateriel[P]>
  }




  export type SortieMaterielGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SortieMaterielWhereInput
    orderBy?: SortieMaterielOrderByWithAggregationInput | SortieMaterielOrderByWithAggregationInput[]
    by: SortieMaterielScalarFieldEnum[] | SortieMaterielScalarFieldEnum
    having?: SortieMaterielScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SortieMaterielCountAggregateInputType | true
    _avg?: SortieMaterielAvgAggregateInputType
    _sum?: SortieMaterielSumAggregateInputType
    _min?: SortieMaterielMinAggregateInputType
    _max?: SortieMaterielMaxAggregateInputType
  }

  export type SortieMaterielGroupByOutputType = {
    id: number
    materielId: number
    interventionId: number
    technicienId: number
    quantite: number
    dateSortie: Date
    motif: string | null
    retourne: boolean
    dateRetour: Date | null
    quantiteRetour: number | null
    commentaire: string | null
    createdAt: Date
    _count: SortieMaterielCountAggregateOutputType | null
    _avg: SortieMaterielAvgAggregateOutputType | null
    _sum: SortieMaterielSumAggregateOutputType | null
    _min: SortieMaterielMinAggregateOutputType | null
    _max: SortieMaterielMaxAggregateOutputType | null
  }

  type GetSortieMaterielGroupByPayload<T extends SortieMaterielGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SortieMaterielGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SortieMaterielGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SortieMaterielGroupByOutputType[P]>
            : GetScalarType<T[P], SortieMaterielGroupByOutputType[P]>
        }
      >
    >


  export type SortieMaterielSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    materielId?: boolean
    interventionId?: boolean
    technicienId?: boolean
    quantite?: boolean
    dateSortie?: boolean
    motif?: boolean
    retourne?: boolean
    dateRetour?: boolean
    quantiteRetour?: boolean
    commentaire?: boolean
    createdAt?: boolean
    materiel?: boolean | MaterielDefaultArgs<ExtArgs>
    intervention?: boolean | InterventionDefaultArgs<ExtArgs>
    technicien?: boolean | TechnicienDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sortieMateriel"]>

  export type SortieMaterielSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    materielId?: boolean
    interventionId?: boolean
    technicienId?: boolean
    quantite?: boolean
    dateSortie?: boolean
    motif?: boolean
    retourne?: boolean
    dateRetour?: boolean
    quantiteRetour?: boolean
    commentaire?: boolean
    createdAt?: boolean
    materiel?: boolean | MaterielDefaultArgs<ExtArgs>
    intervention?: boolean | InterventionDefaultArgs<ExtArgs>
    technicien?: boolean | TechnicienDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sortieMateriel"]>

  export type SortieMaterielSelectScalar = {
    id?: boolean
    materielId?: boolean
    interventionId?: boolean
    technicienId?: boolean
    quantite?: boolean
    dateSortie?: boolean
    motif?: boolean
    retourne?: boolean
    dateRetour?: boolean
    quantiteRetour?: boolean
    commentaire?: boolean
    createdAt?: boolean
  }

  export type SortieMaterielInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    materiel?: boolean | MaterielDefaultArgs<ExtArgs>
    intervention?: boolean | InterventionDefaultArgs<ExtArgs>
    technicien?: boolean | TechnicienDefaultArgs<ExtArgs>
  }
  export type SortieMaterielIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    materiel?: boolean | MaterielDefaultArgs<ExtArgs>
    intervention?: boolean | InterventionDefaultArgs<ExtArgs>
    technicien?: boolean | TechnicienDefaultArgs<ExtArgs>
  }

  export type $SortieMaterielPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SortieMateriel"
    objects: {
      materiel: Prisma.$MaterielPayload<ExtArgs>
      intervention: Prisma.$InterventionPayload<ExtArgs>
      technicien: Prisma.$TechnicienPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      materielId: number
      interventionId: number
      technicienId: number
      quantite: number
      dateSortie: Date
      motif: string | null
      retourne: boolean
      dateRetour: Date | null
      quantiteRetour: number | null
      commentaire: string | null
      createdAt: Date
    }, ExtArgs["result"]["sortieMateriel"]>
    composites: {}
  }

  type SortieMaterielGetPayload<S extends boolean | null | undefined | SortieMaterielDefaultArgs> = $Result.GetResult<Prisma.$SortieMaterielPayload, S>

  type SortieMaterielCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SortieMaterielFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SortieMaterielCountAggregateInputType | true
    }

  export interface SortieMaterielDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SortieMateriel'], meta: { name: 'SortieMateriel' } }
    /**
     * Find zero or one SortieMateriel that matches the filter.
     * @param {SortieMaterielFindUniqueArgs} args - Arguments to find a SortieMateriel
     * @example
     * // Get one SortieMateriel
     * const sortieMateriel = await prisma.sortieMateriel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SortieMaterielFindUniqueArgs>(args: SelectSubset<T, SortieMaterielFindUniqueArgs<ExtArgs>>): Prisma__SortieMaterielClient<$Result.GetResult<Prisma.$SortieMaterielPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SortieMateriel that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SortieMaterielFindUniqueOrThrowArgs} args - Arguments to find a SortieMateriel
     * @example
     * // Get one SortieMateriel
     * const sortieMateriel = await prisma.sortieMateriel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SortieMaterielFindUniqueOrThrowArgs>(args: SelectSubset<T, SortieMaterielFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SortieMaterielClient<$Result.GetResult<Prisma.$SortieMaterielPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SortieMateriel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SortieMaterielFindFirstArgs} args - Arguments to find a SortieMateriel
     * @example
     * // Get one SortieMateriel
     * const sortieMateriel = await prisma.sortieMateriel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SortieMaterielFindFirstArgs>(args?: SelectSubset<T, SortieMaterielFindFirstArgs<ExtArgs>>): Prisma__SortieMaterielClient<$Result.GetResult<Prisma.$SortieMaterielPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SortieMateriel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SortieMaterielFindFirstOrThrowArgs} args - Arguments to find a SortieMateriel
     * @example
     * // Get one SortieMateriel
     * const sortieMateriel = await prisma.sortieMateriel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SortieMaterielFindFirstOrThrowArgs>(args?: SelectSubset<T, SortieMaterielFindFirstOrThrowArgs<ExtArgs>>): Prisma__SortieMaterielClient<$Result.GetResult<Prisma.$SortieMaterielPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SortieMateriels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SortieMaterielFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SortieMateriels
     * const sortieMateriels = await prisma.sortieMateriel.findMany()
     * 
     * // Get first 10 SortieMateriels
     * const sortieMateriels = await prisma.sortieMateriel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sortieMaterielWithIdOnly = await prisma.sortieMateriel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SortieMaterielFindManyArgs>(args?: SelectSubset<T, SortieMaterielFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SortieMaterielPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SortieMateriel.
     * @param {SortieMaterielCreateArgs} args - Arguments to create a SortieMateriel.
     * @example
     * // Create one SortieMateriel
     * const SortieMateriel = await prisma.sortieMateriel.create({
     *   data: {
     *     // ... data to create a SortieMateriel
     *   }
     * })
     * 
     */
    create<T extends SortieMaterielCreateArgs>(args: SelectSubset<T, SortieMaterielCreateArgs<ExtArgs>>): Prisma__SortieMaterielClient<$Result.GetResult<Prisma.$SortieMaterielPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SortieMateriels.
     * @param {SortieMaterielCreateManyArgs} args - Arguments to create many SortieMateriels.
     * @example
     * // Create many SortieMateriels
     * const sortieMateriel = await prisma.sortieMateriel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SortieMaterielCreateManyArgs>(args?: SelectSubset<T, SortieMaterielCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SortieMateriels and returns the data saved in the database.
     * @param {SortieMaterielCreateManyAndReturnArgs} args - Arguments to create many SortieMateriels.
     * @example
     * // Create many SortieMateriels
     * const sortieMateriel = await prisma.sortieMateriel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SortieMateriels and only return the `id`
     * const sortieMaterielWithIdOnly = await prisma.sortieMateriel.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SortieMaterielCreateManyAndReturnArgs>(args?: SelectSubset<T, SortieMaterielCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SortieMaterielPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SortieMateriel.
     * @param {SortieMaterielDeleteArgs} args - Arguments to delete one SortieMateriel.
     * @example
     * // Delete one SortieMateriel
     * const SortieMateriel = await prisma.sortieMateriel.delete({
     *   where: {
     *     // ... filter to delete one SortieMateriel
     *   }
     * })
     * 
     */
    delete<T extends SortieMaterielDeleteArgs>(args: SelectSubset<T, SortieMaterielDeleteArgs<ExtArgs>>): Prisma__SortieMaterielClient<$Result.GetResult<Prisma.$SortieMaterielPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SortieMateriel.
     * @param {SortieMaterielUpdateArgs} args - Arguments to update one SortieMateriel.
     * @example
     * // Update one SortieMateriel
     * const sortieMateriel = await prisma.sortieMateriel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SortieMaterielUpdateArgs>(args: SelectSubset<T, SortieMaterielUpdateArgs<ExtArgs>>): Prisma__SortieMaterielClient<$Result.GetResult<Prisma.$SortieMaterielPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SortieMateriels.
     * @param {SortieMaterielDeleteManyArgs} args - Arguments to filter SortieMateriels to delete.
     * @example
     * // Delete a few SortieMateriels
     * const { count } = await prisma.sortieMateriel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SortieMaterielDeleteManyArgs>(args?: SelectSubset<T, SortieMaterielDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SortieMateriels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SortieMaterielUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SortieMateriels
     * const sortieMateriel = await prisma.sortieMateriel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SortieMaterielUpdateManyArgs>(args: SelectSubset<T, SortieMaterielUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SortieMateriel.
     * @param {SortieMaterielUpsertArgs} args - Arguments to update or create a SortieMateriel.
     * @example
     * // Update or create a SortieMateriel
     * const sortieMateriel = await prisma.sortieMateriel.upsert({
     *   create: {
     *     // ... data to create a SortieMateriel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SortieMateriel we want to update
     *   }
     * })
     */
    upsert<T extends SortieMaterielUpsertArgs>(args: SelectSubset<T, SortieMaterielUpsertArgs<ExtArgs>>): Prisma__SortieMaterielClient<$Result.GetResult<Prisma.$SortieMaterielPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SortieMateriels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SortieMaterielCountArgs} args - Arguments to filter SortieMateriels to count.
     * @example
     * // Count the number of SortieMateriels
     * const count = await prisma.sortieMateriel.count({
     *   where: {
     *     // ... the filter for the SortieMateriels we want to count
     *   }
     * })
    **/
    count<T extends SortieMaterielCountArgs>(
      args?: Subset<T, SortieMaterielCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SortieMaterielCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SortieMateriel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SortieMaterielAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SortieMaterielAggregateArgs>(args: Subset<T, SortieMaterielAggregateArgs>): Prisma.PrismaPromise<GetSortieMaterielAggregateType<T>>

    /**
     * Group by SortieMateriel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SortieMaterielGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SortieMaterielGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SortieMaterielGroupByArgs['orderBy'] }
        : { orderBy?: SortieMaterielGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SortieMaterielGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSortieMaterielGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SortieMateriel model
   */
  readonly fields: SortieMaterielFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SortieMateriel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SortieMaterielClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    materiel<T extends MaterielDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MaterielDefaultArgs<ExtArgs>>): Prisma__MaterielClient<$Result.GetResult<Prisma.$MaterielPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    intervention<T extends InterventionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InterventionDefaultArgs<ExtArgs>>): Prisma__InterventionClient<$Result.GetResult<Prisma.$InterventionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    technicien<T extends TechnicienDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TechnicienDefaultArgs<ExtArgs>>): Prisma__TechnicienClient<$Result.GetResult<Prisma.$TechnicienPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SortieMateriel model
   */ 
  interface SortieMaterielFieldRefs {
    readonly id: FieldRef<"SortieMateriel", 'Int'>
    readonly materielId: FieldRef<"SortieMateriel", 'Int'>
    readonly interventionId: FieldRef<"SortieMateriel", 'Int'>
    readonly technicienId: FieldRef<"SortieMateriel", 'Int'>
    readonly quantite: FieldRef<"SortieMateriel", 'Int'>
    readonly dateSortie: FieldRef<"SortieMateriel", 'DateTime'>
    readonly motif: FieldRef<"SortieMateriel", 'String'>
    readonly retourne: FieldRef<"SortieMateriel", 'Boolean'>
    readonly dateRetour: FieldRef<"SortieMateriel", 'DateTime'>
    readonly quantiteRetour: FieldRef<"SortieMateriel", 'Int'>
    readonly commentaire: FieldRef<"SortieMateriel", 'String'>
    readonly createdAt: FieldRef<"SortieMateriel", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SortieMateriel findUnique
   */
  export type SortieMaterielFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SortieMateriel
     */
    select?: SortieMaterielSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SortieMaterielInclude<ExtArgs> | null
    /**
     * Filter, which SortieMateriel to fetch.
     */
    where: SortieMaterielWhereUniqueInput
  }

  /**
   * SortieMateriel findUniqueOrThrow
   */
  export type SortieMaterielFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SortieMateriel
     */
    select?: SortieMaterielSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SortieMaterielInclude<ExtArgs> | null
    /**
     * Filter, which SortieMateriel to fetch.
     */
    where: SortieMaterielWhereUniqueInput
  }

  /**
   * SortieMateriel findFirst
   */
  export type SortieMaterielFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SortieMateriel
     */
    select?: SortieMaterielSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SortieMaterielInclude<ExtArgs> | null
    /**
     * Filter, which SortieMateriel to fetch.
     */
    where?: SortieMaterielWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SortieMateriels to fetch.
     */
    orderBy?: SortieMaterielOrderByWithRelationInput | SortieMaterielOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SortieMateriels.
     */
    cursor?: SortieMaterielWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SortieMateriels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SortieMateriels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SortieMateriels.
     */
    distinct?: SortieMaterielScalarFieldEnum | SortieMaterielScalarFieldEnum[]
  }

  /**
   * SortieMateriel findFirstOrThrow
   */
  export type SortieMaterielFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SortieMateriel
     */
    select?: SortieMaterielSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SortieMaterielInclude<ExtArgs> | null
    /**
     * Filter, which SortieMateriel to fetch.
     */
    where?: SortieMaterielWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SortieMateriels to fetch.
     */
    orderBy?: SortieMaterielOrderByWithRelationInput | SortieMaterielOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SortieMateriels.
     */
    cursor?: SortieMaterielWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SortieMateriels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SortieMateriels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SortieMateriels.
     */
    distinct?: SortieMaterielScalarFieldEnum | SortieMaterielScalarFieldEnum[]
  }

  /**
   * SortieMateriel findMany
   */
  export type SortieMaterielFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SortieMateriel
     */
    select?: SortieMaterielSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SortieMaterielInclude<ExtArgs> | null
    /**
     * Filter, which SortieMateriels to fetch.
     */
    where?: SortieMaterielWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SortieMateriels to fetch.
     */
    orderBy?: SortieMaterielOrderByWithRelationInput | SortieMaterielOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SortieMateriels.
     */
    cursor?: SortieMaterielWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SortieMateriels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SortieMateriels.
     */
    skip?: number
    distinct?: SortieMaterielScalarFieldEnum | SortieMaterielScalarFieldEnum[]
  }

  /**
   * SortieMateriel create
   */
  export type SortieMaterielCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SortieMateriel
     */
    select?: SortieMaterielSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SortieMaterielInclude<ExtArgs> | null
    /**
     * The data needed to create a SortieMateriel.
     */
    data: XOR<SortieMaterielCreateInput, SortieMaterielUncheckedCreateInput>
  }

  /**
   * SortieMateriel createMany
   */
  export type SortieMaterielCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SortieMateriels.
     */
    data: SortieMaterielCreateManyInput | SortieMaterielCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SortieMateriel createManyAndReturn
   */
  export type SortieMaterielCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SortieMateriel
     */
    select?: SortieMaterielSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SortieMateriels.
     */
    data: SortieMaterielCreateManyInput | SortieMaterielCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SortieMaterielIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SortieMateriel update
   */
  export type SortieMaterielUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SortieMateriel
     */
    select?: SortieMaterielSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SortieMaterielInclude<ExtArgs> | null
    /**
     * The data needed to update a SortieMateriel.
     */
    data: XOR<SortieMaterielUpdateInput, SortieMaterielUncheckedUpdateInput>
    /**
     * Choose, which SortieMateriel to update.
     */
    where: SortieMaterielWhereUniqueInput
  }

  /**
   * SortieMateriel updateMany
   */
  export type SortieMaterielUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SortieMateriels.
     */
    data: XOR<SortieMaterielUpdateManyMutationInput, SortieMaterielUncheckedUpdateManyInput>
    /**
     * Filter which SortieMateriels to update
     */
    where?: SortieMaterielWhereInput
  }

  /**
   * SortieMateriel upsert
   */
  export type SortieMaterielUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SortieMateriel
     */
    select?: SortieMaterielSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SortieMaterielInclude<ExtArgs> | null
    /**
     * The filter to search for the SortieMateriel to update in case it exists.
     */
    where: SortieMaterielWhereUniqueInput
    /**
     * In case the SortieMateriel found by the `where` argument doesn't exist, create a new SortieMateriel with this data.
     */
    create: XOR<SortieMaterielCreateInput, SortieMaterielUncheckedCreateInput>
    /**
     * In case the SortieMateriel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SortieMaterielUpdateInput, SortieMaterielUncheckedUpdateInput>
  }

  /**
   * SortieMateriel delete
   */
  export type SortieMaterielDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SortieMateriel
     */
    select?: SortieMaterielSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SortieMaterielInclude<ExtArgs> | null
    /**
     * Filter which SortieMateriel to delete.
     */
    where: SortieMaterielWhereUniqueInput
  }

  /**
   * SortieMateriel deleteMany
   */
  export type SortieMaterielDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SortieMateriels to delete
     */
    where?: SortieMaterielWhereInput
  }

  /**
   * SortieMateriel without action
   */
  export type SortieMaterielDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SortieMateriel
     */
    select?: SortieMaterielSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SortieMaterielInclude<ExtArgs> | null
  }


  /**
   * Model EntreeMateriel
   */

  export type AggregateEntreeMateriel = {
    _count: EntreeMaterielCountAggregateOutputType | null
    _avg: EntreeMaterielAvgAggregateOutputType | null
    _sum: EntreeMaterielSumAggregateOutputType | null
    _min: EntreeMaterielMinAggregateOutputType | null
    _max: EntreeMaterielMaxAggregateOutputType | null
  }

  export type EntreeMaterielAvgAggregateOutputType = {
    id: number | null
    materielId: number | null
    quantite: number | null
    prixTotal: number | null
  }

  export type EntreeMaterielSumAggregateOutputType = {
    id: number | null
    materielId: number | null
    quantite: number | null
    prixTotal: number | null
  }

  export type EntreeMaterielMinAggregateOutputType = {
    id: number | null
    materielId: number | null
    quantite: number | null
    dateEntree: Date | null
    source: string | null
    prixTotal: number | null
    fournisseur: string | null
    facture: string | null
    commentaire: string | null
    createdAt: Date | null
  }

  export type EntreeMaterielMaxAggregateOutputType = {
    id: number | null
    materielId: number | null
    quantite: number | null
    dateEntree: Date | null
    source: string | null
    prixTotal: number | null
    fournisseur: string | null
    facture: string | null
    commentaire: string | null
    createdAt: Date | null
  }

  export type EntreeMaterielCountAggregateOutputType = {
    id: number
    materielId: number
    quantite: number
    dateEntree: number
    source: number
    prixTotal: number
    fournisseur: number
    facture: number
    commentaire: number
    createdAt: number
    _all: number
  }


  export type EntreeMaterielAvgAggregateInputType = {
    id?: true
    materielId?: true
    quantite?: true
    prixTotal?: true
  }

  export type EntreeMaterielSumAggregateInputType = {
    id?: true
    materielId?: true
    quantite?: true
    prixTotal?: true
  }

  export type EntreeMaterielMinAggregateInputType = {
    id?: true
    materielId?: true
    quantite?: true
    dateEntree?: true
    source?: true
    prixTotal?: true
    fournisseur?: true
    facture?: true
    commentaire?: true
    createdAt?: true
  }

  export type EntreeMaterielMaxAggregateInputType = {
    id?: true
    materielId?: true
    quantite?: true
    dateEntree?: true
    source?: true
    prixTotal?: true
    fournisseur?: true
    facture?: true
    commentaire?: true
    createdAt?: true
  }

  export type EntreeMaterielCountAggregateInputType = {
    id?: true
    materielId?: true
    quantite?: true
    dateEntree?: true
    source?: true
    prixTotal?: true
    fournisseur?: true
    facture?: true
    commentaire?: true
    createdAt?: true
    _all?: true
  }

  export type EntreeMaterielAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EntreeMateriel to aggregate.
     */
    where?: EntreeMaterielWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EntreeMateriels to fetch.
     */
    orderBy?: EntreeMaterielOrderByWithRelationInput | EntreeMaterielOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EntreeMaterielWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EntreeMateriels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EntreeMateriels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EntreeMateriels
    **/
    _count?: true | EntreeMaterielCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EntreeMaterielAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EntreeMaterielSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EntreeMaterielMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EntreeMaterielMaxAggregateInputType
  }

  export type GetEntreeMaterielAggregateType<T extends EntreeMaterielAggregateArgs> = {
        [P in keyof T & keyof AggregateEntreeMateriel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEntreeMateriel[P]>
      : GetScalarType<T[P], AggregateEntreeMateriel[P]>
  }




  export type EntreeMaterielGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EntreeMaterielWhereInput
    orderBy?: EntreeMaterielOrderByWithAggregationInput | EntreeMaterielOrderByWithAggregationInput[]
    by: EntreeMaterielScalarFieldEnum[] | EntreeMaterielScalarFieldEnum
    having?: EntreeMaterielScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EntreeMaterielCountAggregateInputType | true
    _avg?: EntreeMaterielAvgAggregateInputType
    _sum?: EntreeMaterielSumAggregateInputType
    _min?: EntreeMaterielMinAggregateInputType
    _max?: EntreeMaterielMaxAggregateInputType
  }

  export type EntreeMaterielGroupByOutputType = {
    id: number
    materielId: number
    quantite: number
    dateEntree: Date
    source: string
    prixTotal: number | null
    fournisseur: string | null
    facture: string | null
    commentaire: string | null
    createdAt: Date
    _count: EntreeMaterielCountAggregateOutputType | null
    _avg: EntreeMaterielAvgAggregateOutputType | null
    _sum: EntreeMaterielSumAggregateOutputType | null
    _min: EntreeMaterielMinAggregateOutputType | null
    _max: EntreeMaterielMaxAggregateOutputType | null
  }

  type GetEntreeMaterielGroupByPayload<T extends EntreeMaterielGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EntreeMaterielGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EntreeMaterielGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EntreeMaterielGroupByOutputType[P]>
            : GetScalarType<T[P], EntreeMaterielGroupByOutputType[P]>
        }
      >
    >


  export type EntreeMaterielSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    materielId?: boolean
    quantite?: boolean
    dateEntree?: boolean
    source?: boolean
    prixTotal?: boolean
    fournisseur?: boolean
    facture?: boolean
    commentaire?: boolean
    createdAt?: boolean
    materiel?: boolean | MaterielDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["entreeMateriel"]>

  export type EntreeMaterielSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    materielId?: boolean
    quantite?: boolean
    dateEntree?: boolean
    source?: boolean
    prixTotal?: boolean
    fournisseur?: boolean
    facture?: boolean
    commentaire?: boolean
    createdAt?: boolean
    materiel?: boolean | MaterielDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["entreeMateriel"]>

  export type EntreeMaterielSelectScalar = {
    id?: boolean
    materielId?: boolean
    quantite?: boolean
    dateEntree?: boolean
    source?: boolean
    prixTotal?: boolean
    fournisseur?: boolean
    facture?: boolean
    commentaire?: boolean
    createdAt?: boolean
  }

  export type EntreeMaterielInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    materiel?: boolean | MaterielDefaultArgs<ExtArgs>
  }
  export type EntreeMaterielIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    materiel?: boolean | MaterielDefaultArgs<ExtArgs>
  }

  export type $EntreeMaterielPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EntreeMateriel"
    objects: {
      materiel: Prisma.$MaterielPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      materielId: number
      quantite: number
      dateEntree: Date
      source: string
      prixTotal: number | null
      fournisseur: string | null
      facture: string | null
      commentaire: string | null
      createdAt: Date
    }, ExtArgs["result"]["entreeMateriel"]>
    composites: {}
  }

  type EntreeMaterielGetPayload<S extends boolean | null | undefined | EntreeMaterielDefaultArgs> = $Result.GetResult<Prisma.$EntreeMaterielPayload, S>

  type EntreeMaterielCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EntreeMaterielFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EntreeMaterielCountAggregateInputType | true
    }

  export interface EntreeMaterielDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EntreeMateriel'], meta: { name: 'EntreeMateriel' } }
    /**
     * Find zero or one EntreeMateriel that matches the filter.
     * @param {EntreeMaterielFindUniqueArgs} args - Arguments to find a EntreeMateriel
     * @example
     * // Get one EntreeMateriel
     * const entreeMateriel = await prisma.entreeMateriel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EntreeMaterielFindUniqueArgs>(args: SelectSubset<T, EntreeMaterielFindUniqueArgs<ExtArgs>>): Prisma__EntreeMaterielClient<$Result.GetResult<Prisma.$EntreeMaterielPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EntreeMateriel that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EntreeMaterielFindUniqueOrThrowArgs} args - Arguments to find a EntreeMateriel
     * @example
     * // Get one EntreeMateriel
     * const entreeMateriel = await prisma.entreeMateriel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EntreeMaterielFindUniqueOrThrowArgs>(args: SelectSubset<T, EntreeMaterielFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EntreeMaterielClient<$Result.GetResult<Prisma.$EntreeMaterielPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EntreeMateriel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntreeMaterielFindFirstArgs} args - Arguments to find a EntreeMateriel
     * @example
     * // Get one EntreeMateriel
     * const entreeMateriel = await prisma.entreeMateriel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EntreeMaterielFindFirstArgs>(args?: SelectSubset<T, EntreeMaterielFindFirstArgs<ExtArgs>>): Prisma__EntreeMaterielClient<$Result.GetResult<Prisma.$EntreeMaterielPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EntreeMateriel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntreeMaterielFindFirstOrThrowArgs} args - Arguments to find a EntreeMateriel
     * @example
     * // Get one EntreeMateriel
     * const entreeMateriel = await prisma.entreeMateriel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EntreeMaterielFindFirstOrThrowArgs>(args?: SelectSubset<T, EntreeMaterielFindFirstOrThrowArgs<ExtArgs>>): Prisma__EntreeMaterielClient<$Result.GetResult<Prisma.$EntreeMaterielPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EntreeMateriels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntreeMaterielFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EntreeMateriels
     * const entreeMateriels = await prisma.entreeMateriel.findMany()
     * 
     * // Get first 10 EntreeMateriels
     * const entreeMateriels = await prisma.entreeMateriel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const entreeMaterielWithIdOnly = await prisma.entreeMateriel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EntreeMaterielFindManyArgs>(args?: SelectSubset<T, EntreeMaterielFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EntreeMaterielPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EntreeMateriel.
     * @param {EntreeMaterielCreateArgs} args - Arguments to create a EntreeMateriel.
     * @example
     * // Create one EntreeMateriel
     * const EntreeMateriel = await prisma.entreeMateriel.create({
     *   data: {
     *     // ... data to create a EntreeMateriel
     *   }
     * })
     * 
     */
    create<T extends EntreeMaterielCreateArgs>(args: SelectSubset<T, EntreeMaterielCreateArgs<ExtArgs>>): Prisma__EntreeMaterielClient<$Result.GetResult<Prisma.$EntreeMaterielPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EntreeMateriels.
     * @param {EntreeMaterielCreateManyArgs} args - Arguments to create many EntreeMateriels.
     * @example
     * // Create many EntreeMateriels
     * const entreeMateriel = await prisma.entreeMateriel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EntreeMaterielCreateManyArgs>(args?: SelectSubset<T, EntreeMaterielCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EntreeMateriels and returns the data saved in the database.
     * @param {EntreeMaterielCreateManyAndReturnArgs} args - Arguments to create many EntreeMateriels.
     * @example
     * // Create many EntreeMateriels
     * const entreeMateriel = await prisma.entreeMateriel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EntreeMateriels and only return the `id`
     * const entreeMaterielWithIdOnly = await prisma.entreeMateriel.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EntreeMaterielCreateManyAndReturnArgs>(args?: SelectSubset<T, EntreeMaterielCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EntreeMaterielPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EntreeMateriel.
     * @param {EntreeMaterielDeleteArgs} args - Arguments to delete one EntreeMateriel.
     * @example
     * // Delete one EntreeMateriel
     * const EntreeMateriel = await prisma.entreeMateriel.delete({
     *   where: {
     *     // ... filter to delete one EntreeMateriel
     *   }
     * })
     * 
     */
    delete<T extends EntreeMaterielDeleteArgs>(args: SelectSubset<T, EntreeMaterielDeleteArgs<ExtArgs>>): Prisma__EntreeMaterielClient<$Result.GetResult<Prisma.$EntreeMaterielPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EntreeMateriel.
     * @param {EntreeMaterielUpdateArgs} args - Arguments to update one EntreeMateriel.
     * @example
     * // Update one EntreeMateriel
     * const entreeMateriel = await prisma.entreeMateriel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EntreeMaterielUpdateArgs>(args: SelectSubset<T, EntreeMaterielUpdateArgs<ExtArgs>>): Prisma__EntreeMaterielClient<$Result.GetResult<Prisma.$EntreeMaterielPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EntreeMateriels.
     * @param {EntreeMaterielDeleteManyArgs} args - Arguments to filter EntreeMateriels to delete.
     * @example
     * // Delete a few EntreeMateriels
     * const { count } = await prisma.entreeMateriel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EntreeMaterielDeleteManyArgs>(args?: SelectSubset<T, EntreeMaterielDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EntreeMateriels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntreeMaterielUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EntreeMateriels
     * const entreeMateriel = await prisma.entreeMateriel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EntreeMaterielUpdateManyArgs>(args: SelectSubset<T, EntreeMaterielUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EntreeMateriel.
     * @param {EntreeMaterielUpsertArgs} args - Arguments to update or create a EntreeMateriel.
     * @example
     * // Update or create a EntreeMateriel
     * const entreeMateriel = await prisma.entreeMateriel.upsert({
     *   create: {
     *     // ... data to create a EntreeMateriel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EntreeMateriel we want to update
     *   }
     * })
     */
    upsert<T extends EntreeMaterielUpsertArgs>(args: SelectSubset<T, EntreeMaterielUpsertArgs<ExtArgs>>): Prisma__EntreeMaterielClient<$Result.GetResult<Prisma.$EntreeMaterielPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EntreeMateriels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntreeMaterielCountArgs} args - Arguments to filter EntreeMateriels to count.
     * @example
     * // Count the number of EntreeMateriels
     * const count = await prisma.entreeMateriel.count({
     *   where: {
     *     // ... the filter for the EntreeMateriels we want to count
     *   }
     * })
    **/
    count<T extends EntreeMaterielCountArgs>(
      args?: Subset<T, EntreeMaterielCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EntreeMaterielCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EntreeMateriel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntreeMaterielAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EntreeMaterielAggregateArgs>(args: Subset<T, EntreeMaterielAggregateArgs>): Prisma.PrismaPromise<GetEntreeMaterielAggregateType<T>>

    /**
     * Group by EntreeMateriel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntreeMaterielGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EntreeMaterielGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EntreeMaterielGroupByArgs['orderBy'] }
        : { orderBy?: EntreeMaterielGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EntreeMaterielGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEntreeMaterielGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EntreeMateriel model
   */
  readonly fields: EntreeMaterielFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EntreeMateriel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EntreeMaterielClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    materiel<T extends MaterielDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MaterielDefaultArgs<ExtArgs>>): Prisma__MaterielClient<$Result.GetResult<Prisma.$MaterielPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EntreeMateriel model
   */ 
  interface EntreeMaterielFieldRefs {
    readonly id: FieldRef<"EntreeMateriel", 'Int'>
    readonly materielId: FieldRef<"EntreeMateriel", 'Int'>
    readonly quantite: FieldRef<"EntreeMateriel", 'Int'>
    readonly dateEntree: FieldRef<"EntreeMateriel", 'DateTime'>
    readonly source: FieldRef<"EntreeMateriel", 'String'>
    readonly prixTotal: FieldRef<"EntreeMateriel", 'Float'>
    readonly fournisseur: FieldRef<"EntreeMateriel", 'String'>
    readonly facture: FieldRef<"EntreeMateriel", 'String'>
    readonly commentaire: FieldRef<"EntreeMateriel", 'String'>
    readonly createdAt: FieldRef<"EntreeMateriel", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EntreeMateriel findUnique
   */
  export type EntreeMaterielFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntreeMateriel
     */
    select?: EntreeMaterielSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntreeMaterielInclude<ExtArgs> | null
    /**
     * Filter, which EntreeMateriel to fetch.
     */
    where: EntreeMaterielWhereUniqueInput
  }

  /**
   * EntreeMateriel findUniqueOrThrow
   */
  export type EntreeMaterielFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntreeMateriel
     */
    select?: EntreeMaterielSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntreeMaterielInclude<ExtArgs> | null
    /**
     * Filter, which EntreeMateriel to fetch.
     */
    where: EntreeMaterielWhereUniqueInput
  }

  /**
   * EntreeMateriel findFirst
   */
  export type EntreeMaterielFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntreeMateriel
     */
    select?: EntreeMaterielSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntreeMaterielInclude<ExtArgs> | null
    /**
     * Filter, which EntreeMateriel to fetch.
     */
    where?: EntreeMaterielWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EntreeMateriels to fetch.
     */
    orderBy?: EntreeMaterielOrderByWithRelationInput | EntreeMaterielOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EntreeMateriels.
     */
    cursor?: EntreeMaterielWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EntreeMateriels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EntreeMateriels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EntreeMateriels.
     */
    distinct?: EntreeMaterielScalarFieldEnum | EntreeMaterielScalarFieldEnum[]
  }

  /**
   * EntreeMateriel findFirstOrThrow
   */
  export type EntreeMaterielFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntreeMateriel
     */
    select?: EntreeMaterielSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntreeMaterielInclude<ExtArgs> | null
    /**
     * Filter, which EntreeMateriel to fetch.
     */
    where?: EntreeMaterielWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EntreeMateriels to fetch.
     */
    orderBy?: EntreeMaterielOrderByWithRelationInput | EntreeMaterielOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EntreeMateriels.
     */
    cursor?: EntreeMaterielWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EntreeMateriels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EntreeMateriels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EntreeMateriels.
     */
    distinct?: EntreeMaterielScalarFieldEnum | EntreeMaterielScalarFieldEnum[]
  }

  /**
   * EntreeMateriel findMany
   */
  export type EntreeMaterielFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntreeMateriel
     */
    select?: EntreeMaterielSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntreeMaterielInclude<ExtArgs> | null
    /**
     * Filter, which EntreeMateriels to fetch.
     */
    where?: EntreeMaterielWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EntreeMateriels to fetch.
     */
    orderBy?: EntreeMaterielOrderByWithRelationInput | EntreeMaterielOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EntreeMateriels.
     */
    cursor?: EntreeMaterielWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EntreeMateriels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EntreeMateriels.
     */
    skip?: number
    distinct?: EntreeMaterielScalarFieldEnum | EntreeMaterielScalarFieldEnum[]
  }

  /**
   * EntreeMateriel create
   */
  export type EntreeMaterielCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntreeMateriel
     */
    select?: EntreeMaterielSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntreeMaterielInclude<ExtArgs> | null
    /**
     * The data needed to create a EntreeMateriel.
     */
    data: XOR<EntreeMaterielCreateInput, EntreeMaterielUncheckedCreateInput>
  }

  /**
   * EntreeMateriel createMany
   */
  export type EntreeMaterielCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EntreeMateriels.
     */
    data: EntreeMaterielCreateManyInput | EntreeMaterielCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EntreeMateriel createManyAndReturn
   */
  export type EntreeMaterielCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntreeMateriel
     */
    select?: EntreeMaterielSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EntreeMateriels.
     */
    data: EntreeMaterielCreateManyInput | EntreeMaterielCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntreeMaterielIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EntreeMateriel update
   */
  export type EntreeMaterielUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntreeMateriel
     */
    select?: EntreeMaterielSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntreeMaterielInclude<ExtArgs> | null
    /**
     * The data needed to update a EntreeMateriel.
     */
    data: XOR<EntreeMaterielUpdateInput, EntreeMaterielUncheckedUpdateInput>
    /**
     * Choose, which EntreeMateriel to update.
     */
    where: EntreeMaterielWhereUniqueInput
  }

  /**
   * EntreeMateriel updateMany
   */
  export type EntreeMaterielUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EntreeMateriels.
     */
    data: XOR<EntreeMaterielUpdateManyMutationInput, EntreeMaterielUncheckedUpdateManyInput>
    /**
     * Filter which EntreeMateriels to update
     */
    where?: EntreeMaterielWhereInput
  }

  /**
   * EntreeMateriel upsert
   */
  export type EntreeMaterielUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntreeMateriel
     */
    select?: EntreeMaterielSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntreeMaterielInclude<ExtArgs> | null
    /**
     * The filter to search for the EntreeMateriel to update in case it exists.
     */
    where: EntreeMaterielWhereUniqueInput
    /**
     * In case the EntreeMateriel found by the `where` argument doesn't exist, create a new EntreeMateriel with this data.
     */
    create: XOR<EntreeMaterielCreateInput, EntreeMaterielUncheckedCreateInput>
    /**
     * In case the EntreeMateriel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EntreeMaterielUpdateInput, EntreeMaterielUncheckedUpdateInput>
  }

  /**
   * EntreeMateriel delete
   */
  export type EntreeMaterielDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntreeMateriel
     */
    select?: EntreeMaterielSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntreeMaterielInclude<ExtArgs> | null
    /**
     * Filter which EntreeMateriel to delete.
     */
    where: EntreeMaterielWhereUniqueInput
  }

  /**
   * EntreeMateriel deleteMany
   */
  export type EntreeMaterielDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EntreeMateriels to delete
     */
    where?: EntreeMaterielWhereInput
  }

  /**
   * EntreeMateriel without action
   */
  export type EntreeMaterielDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntreeMateriel
     */
    select?: EntreeMaterielSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntreeMaterielInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type NotificationSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type NotificationMinAggregateOutputType = {
    id: number | null
    type: string | null
    message: string | null
    data: string | null
    readAt: Date | null
    createdAt: Date | null
    userId: number | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: number | null
    type: string | null
    message: string | null
    data: string | null
    readAt: Date | null
    createdAt: Date | null
    userId: number | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    type: number
    message: number
    data: number
    readAt: number
    createdAt: number
    userId: number
    _all: number
  }


  export type NotificationAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type NotificationSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type NotificationMinAggregateInputType = {
    id?: true
    type?: true
    message?: true
    data?: true
    readAt?: true
    createdAt?: true
    userId?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    type?: true
    message?: true
    data?: true
    readAt?: true
    createdAt?: true
    userId?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    type?: true
    message?: true
    data?: true
    readAt?: true
    createdAt?: true
    userId?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _avg?: NotificationAvgAggregateInputType
    _sum?: NotificationSumAggregateInputType
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: number
    type: string
    message: string
    data: string | null
    readAt: Date | null
    createdAt: Date
    userId: number
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    message?: boolean
    data?: boolean
    readAt?: boolean
    createdAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    message?: boolean
    data?: boolean
    readAt?: boolean
    createdAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    type?: boolean
    message?: boolean
    data?: boolean
    readAt?: boolean
    createdAt?: boolean
    userId?: boolean
  }

  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      type: string
      message: string
      data: string | null
      readAt: Date | null
      createdAt: Date
      userId: number
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */ 
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'Int'>
    readonly type: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly data: FieldRef<"Notification", 'String'>
    readonly readAt: FieldRef<"Notification", 'DateTime'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly userId: FieldRef<"Notification", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const ServiceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ServiceScalarFieldEnum = (typeof ServiceScalarFieldEnum)[keyof typeof ServiceScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    passwordHash: 'passwordHash',
    firstName: 'firstName',
    lastName: 'lastName',
    role: 'role',
    serviceId: 'serviceId',
    isActive: 'isActive',
    lastLogin: 'lastLogin',
    preferences: 'preferences',
    permissions: 'permissions',
    avatarUrl: 'avatarUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const CustomerScalarFieldEnum: {
    id: 'id',
    customerNumber: 'customerNumber',
    type: 'type',
    name: 'name',
    legalName: 'legalName',
    siret: 'siret',
    vatNumber: 'vatNumber',
    email: 'email',
    phone: 'phone',
    mobile: 'mobile',
    website: 'website',
    paymentTerms: 'paymentTerms',
    paymentMethod: 'paymentMethod',
    creditLimit: 'creditLimit',
    discountRate: 'discountRate',
    category: 'category',
    tags: 'tags',
    notes: 'notes',
    isActive: 'isActive',
    serviceId: 'serviceId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const CustomerAddressScalarFieldEnum: {
    id: 'id',
    customerId: 'customerId',
    type: 'type',
    name: 'name',
    addressLine1: 'addressLine1',
    addressLine2: 'addressLine2',
    postalCode: 'postalCode',
    city: 'city',
    country: 'country',
    isDefault: 'isDefault',
    createdAt: 'createdAt'
  };

  export type CustomerAddressScalarFieldEnum = (typeof CustomerAddressScalarFieldEnum)[keyof typeof CustomerAddressScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    sku: 'sku',
    name: 'name',
    description: 'description',
    type: 'type',
    category: 'category',
    unit: 'unit',
    priceHt: 'priceHt',
    vatRate: 'vatRate',
    costPrice: 'costPrice',
    stockQuantity: 'stockQuantity',
    stockAlertThreshold: 'stockAlertThreshold',
    isActive: 'isActive',
    weight: 'weight',
    dimensions: 'dimensions',
    imageUrl: 'imageUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const ProductPriceScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    customerCategory: 'customerCategory',
    minQuantity: 'minQuantity',
    priceHt: 'priceHt',
    validFrom: 'validFrom',
    validUntil: 'validUntil',
    createdAt: 'createdAt'
  };

  export type ProductPriceScalarFieldEnum = (typeof ProductPriceScalarFieldEnum)[keyof typeof ProductPriceScalarFieldEnum]


  export const QuoteScalarFieldEnum: {
    id: 'id',
    quoteNumber: 'quoteNumber',
    customerId: 'customerId',
    customerAddressId: 'customerAddressId',
    status: 'status',
    quoteDate: 'quoteDate',
    validUntil: 'validUntil',
    subtotalHt: 'subtotalHt',
    discountAmount: 'discountAmount',
    totalVat: 'totalVat',
    totalTtc: 'totalTtc',
    terms: 'terms',
    notes: 'notes',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    sentAt: 'sentAt',
    submittedForServiceApprovalAt: 'submittedForServiceApprovalAt',
    serviceManagerApprovedBy: 'serviceManagerApprovedBy',
    serviceManagerApprovalDate: 'serviceManagerApprovalDate',
    serviceManagerComments: 'serviceManagerComments',
    dgApprovedBy: 'dgApprovedBy',
    dgApprovalDate: 'dgApprovalDate',
    dgComments: 'dgComments',
    acceptedAt: 'acceptedAt'
  };

  export type QuoteScalarFieldEnum = (typeof QuoteScalarFieldEnum)[keyof typeof QuoteScalarFieldEnum]


  export const QuoteItemScalarFieldEnum: {
    id: 'id',
    quoteId: 'quoteId',
    productId: 'productId',
    description: 'description',
    quantity: 'quantity',
    unitPriceHt: 'unitPriceHt',
    discountRate: 'discountRate',
    vatRate: 'vatRate',
    totalHt: 'totalHt',
    sortOrder: 'sortOrder'
  };

  export type QuoteItemScalarFieldEnum = (typeof QuoteItemScalarFieldEnum)[keyof typeof QuoteItemScalarFieldEnum]


  export const QuoteApprovalScalarFieldEnum: {
    id: 'id',
    quoteId: 'quoteId',
    approverId: 'approverId',
    approvalLevel: 'approvalLevel',
    status: 'status',
    approvalDate: 'approvalDate',
    comments: 'comments',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QuoteApprovalScalarFieldEnum = (typeof QuoteApprovalScalarFieldEnum)[keyof typeof QuoteApprovalScalarFieldEnum]


  export const InvoiceScalarFieldEnum: {
    id: 'id',
    invoiceNumber: 'invoiceNumber',
    customerId: 'customerId',
    customerAddressId: 'customerAddressId',
    quoteId: 'quoteId',
    type: 'type',
    status: 'status',
    invoiceDate: 'invoiceDate',
    dueDate: 'dueDate',
    subtotalHt: 'subtotalHt',
    discountAmount: 'discountAmount',
    totalVat: 'totalVat',
    totalTtc: 'totalTtc',
    paidAmount: 'paidAmount',
    balanceDue: 'balanceDue',
    paymentTerms: 'paymentTerms',
    lateFeeRate: 'lateFeeRate',
    terms: 'terms',
    notes: 'notes',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    sentAt: 'sentAt'
  };

  export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


  export const InvoiceItemScalarFieldEnum: {
    id: 'id',
    invoiceId: 'invoiceId',
    productId: 'productId',
    description: 'description',
    quantity: 'quantity',
    unitPriceHt: 'unitPriceHt',
    discountRate: 'discountRate',
    vatRate: 'vatRate',
    totalHt: 'totalHt',
    sortOrder: 'sortOrder'
  };

  export type InvoiceItemScalarFieldEnum = (typeof InvoiceItemScalarFieldEnum)[keyof typeof InvoiceItemScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    paymentNumber: 'paymentNumber',
    customerId: 'customerId',
    amount: 'amount',
    paymentDate: 'paymentDate',
    paymentMethod: 'paymentMethod',
    reference: 'reference',
    notes: 'notes',
    createdBy: 'createdBy',
    createdAt: 'createdAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const PaymentAllocationScalarFieldEnum: {
    id: 'id',
    paymentId: 'paymentId',
    invoiceId: 'invoiceId',
    amount: 'amount',
    createdAt: 'createdAt'
  };

  export type PaymentAllocationScalarFieldEnum = (typeof PaymentAllocationScalarFieldEnum)[keyof typeof PaymentAllocationScalarFieldEnum]


  export const RecurringInvoiceScalarFieldEnum: {
    id: 'id',
    customerId: 'customerId',
    templateName: 'templateName',
    frequency: 'frequency',
    startDate: 'startDate',
    endDate: 'endDate',
    nextInvoiceDate: 'nextInvoiceDate',
    isActive: 'isActive',
    subtotalHt: 'subtotalHt',
    totalVat: 'totalVat',
    totalTtc: 'totalTtc',
    terms: 'terms',
    notes: 'notes',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RecurringInvoiceScalarFieldEnum = (typeof RecurringInvoiceScalarFieldEnum)[keyof typeof RecurringInvoiceScalarFieldEnum]


  export const RecurringInvoiceItemScalarFieldEnum: {
    id: 'id',
    recurringInvoiceId: 'recurringInvoiceId',
    productId: 'productId',
    description: 'description',
    quantity: 'quantity',
    unitPriceHt: 'unitPriceHt',
    vatRate: 'vatRate',
    totalHt: 'totalHt',
    sortOrder: 'sortOrder'
  };

  export type RecurringInvoiceItemScalarFieldEnum = (typeof RecurringInvoiceItemScalarFieldEnum)[keyof typeof RecurringInvoiceItemScalarFieldEnum]


  export const ReminderScalarFieldEnum: {
    id: 'id',
    invoiceId: 'invoiceId',
    type: 'type',
    sentDate: 'sentDate',
    dueDate: 'dueDate',
    amountDue: 'amountDue',
    lateFees: 'lateFees',
    status: 'status',
    emailSubject: 'emailSubject',
    emailBody: 'emailBody',
    createdBy: 'createdBy',
    createdAt: 'createdAt'
  };

  export type ReminderScalarFieldEnum = (typeof ReminderScalarFieldEnum)[keyof typeof ReminderScalarFieldEnum]


  export const DocumentScalarFieldEnum: {
    id: 'id',
    type: 'type',
    referenceId: 'referenceId',
    filename: 'filename',
    filePath: 'filePath',
    fileSize: 'fileSize',
    mimeType: 'mimeType',
    generatedAt: 'generatedAt'
  };

  export type DocumentScalarFieldEnum = (typeof DocumentScalarFieldEnum)[keyof typeof DocumentScalarFieldEnum]


  export const ExpenseScalarFieldEnum: {
    id: 'id',
    expenseNumber: 'expenseNumber',
    supplierId: 'supplierId',
    category: 'category',
    description: 'description',
    amountHt: 'amountHt',
    vatAmount: 'vatAmount',
    totalTtc: 'totalTtc',
    expenseDate: 'expenseDate',
    paymentDate: 'paymentDate',
    paymentMethod: 'paymentMethod',
    status: 'status',
    receiptUrl: 'receiptUrl',
    notes: 'notes',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ExpenseScalarFieldEnum = (typeof ExpenseScalarFieldEnum)[keyof typeof ExpenseScalarFieldEnum]


  export const SupplierScalarFieldEnum: {
    id: 'id',
    name: 'name',
    contactPerson: 'contactPerson',
    email: 'email',
    phone: 'phone',
    addressLine1: 'addressLine1',
    city: 'city',
    postalCode: 'postalCode',
    country: 'country',
    vatNumber: 'vatNumber',
    bankName: 'bankName',
    bankIban: 'bankIban',
    bankBic: 'bankBic',
    paymentTerms: 'paymentTerms',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SupplierScalarFieldEnum = (typeof SupplierScalarFieldEnum)[keyof typeof SupplierScalarFieldEnum]


  export const AccountingEntryScalarFieldEnum: {
    id: 'id',
    entryDate: 'entryDate',
    accountNumber: 'accountNumber',
    debit: 'debit',
    credit: 'credit',
    description: 'description',
    sourceDocumentType: 'sourceDocumentType',
    sourceDocumentId: 'sourceDocumentId',
    createdBy: 'createdBy',
    createdAt: 'createdAt'
  };

  export type AccountingEntryScalarFieldEnum = (typeof AccountingEntryScalarFieldEnum)[keyof typeof AccountingEntryScalarFieldEnum]


  export const CashFlowScalarFieldEnum: {
    id: 'id',
    transactionDate: 'transactionDate',
    type: 'type',
    amount: 'amount',
    description: 'description',
    category: 'category',
    sourceDocumentType: 'sourceDocumentType',
    sourceDocumentId: 'sourceDocumentId',
    createdBy: 'createdBy',
    createdAt: 'createdAt'
  };

  export type CashFlowScalarFieldEnum = (typeof CashFlowScalarFieldEnum)[keyof typeof CashFlowScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    action: 'action',
    details: 'details',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const EmployeeScalarFieldEnum: {
    id: 'id',
    employeeNumber: 'employeeNumber',
    registrationNumber: 'registrationNumber',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    phone: 'phone',
    address: 'address',
    dateOfBirth: 'dateOfBirth',
    placeOfBirth: 'placeOfBirth',
    nationality: 'nationality',
    socialSecurityNumber: 'socialSecurityNumber',
    cnpsNumber: 'cnpsNumber',
    cnamNumber: 'cnamNumber',
    bankAccount: 'bankAccount',
    emergencyContact: 'emergencyContact',
    serviceId: 'serviceId',
    position: 'position',
    department: 'department',
    category: 'category',
    level: 'level',
    manager: 'manager',
    hireDate: 'hireDate',
    isActive: 'isActive',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmployeeScalarFieldEnum = (typeof EmployeeScalarFieldEnum)[keyof typeof EmployeeScalarFieldEnum]


  export const ContractScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    contractType: 'contractType',
    startDate: 'startDate',
    endDate: 'endDate',
    baseSalary: 'baseSalary',
    workingHours: 'workingHours',
    benefits: 'benefits',
    terms: 'terms',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContractScalarFieldEnum = (typeof ContractScalarFieldEnum)[keyof typeof ContractScalarFieldEnum]


  export const SalaryScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    paymentDate: 'paymentDate',
    workingDays: 'workingDays',
    baseSalary: 'baseSalary',
    overtime: 'overtime',
    bonuses: 'bonuses',
    allowances: 'allowances',
    paidLeave: 'paidLeave',
    grossSalary: 'grossSalary',
    socialContributions: 'socialContributions',
    cnpsEmployee: 'cnpsEmployee',
    cnamEmployee: 'cnamEmployee',
    fdfpEmployee: 'fdfpEmployee',
    taxes: 'taxes',
    nonTaxableAmount: 'nonTaxableAmount',
    otherDeductions: 'otherDeductions',
    loanDeductions: 'loanDeductions',
    totalDeductions: 'totalDeductions',
    netSalary: 'netSalary',
    status: 'status',
    paymentMethod: 'paymentMethod',
    reference: 'reference',
    notes: 'notes',
    createdAt: 'createdAt'
  };

  export type SalaryScalarFieldEnum = (typeof SalaryScalarFieldEnum)[keyof typeof SalaryScalarFieldEnum]


  export const LoanPaymentScalarFieldEnum: {
    id: 'id',
    loanId: 'loanId',
    salaryId: 'salaryId',
    amount: 'amount',
    paymentDate: 'paymentDate',
    principal: 'principal',
    interest: 'interest',
    notes: 'notes',
    createdAt: 'createdAt'
  };

  export type LoanPaymentScalarFieldEnum = (typeof LoanPaymentScalarFieldEnum)[keyof typeof LoanPaymentScalarFieldEnum]


  export const LeaveRequestScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    leaveType: 'leaveType',
    startDate: 'startDate',
    endDate: 'endDate',
    days: 'days',
    reason: 'reason',
    notes: 'notes',
    status: 'status',
    approvedById: 'approvedById',
    approvedAt: 'approvedAt',
    comments: 'comments',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LeaveRequestScalarFieldEnum = (typeof LeaveRequestScalarFieldEnum)[keyof typeof LeaveRequestScalarFieldEnum]


  export const ProspectScalarFieldEnum: {
    id: 'id',
    companyName: 'companyName',
    contactName: 'contactName',
    position: 'position',
    email: 'email',
    phone: 'phone',
    address: 'address',
    website: 'website',
    industry: 'industry',
    companySize: 'companySize',
    estimatedValue: 'estimatedValue',
    priority: 'priority',
    stage: 'stage',
    source: 'source',
    notes: 'notes',
    hasBudget: 'hasBudget',
    isDecisionMaker: 'isDecisionMaker',
    hasNeed: 'hasNeed',
    timeline: 'timeline',
    lastContact: 'lastContact',
    nextAction: 'nextAction',
    nextActionDate: 'nextActionDate',
    assignedTo: 'assignedTo',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProspectScalarFieldEnum = (typeof ProspectScalarFieldEnum)[keyof typeof ProspectScalarFieldEnum]


  export const ProspectActivityScalarFieldEnum: {
    id: 'id',
    prospectId: 'prospectId',
    type: 'type',
    subject: 'subject',
    description: 'description',
    scheduledAt: 'scheduledAt',
    completedAt: 'completedAt',
    outcome: 'outcome',
    nextAction: 'nextAction',
    createdBy: 'createdBy',
    createdAt: 'createdAt'
  };

  export type ProspectActivityScalarFieldEnum = (typeof ProspectActivityScalarFieldEnum)[keyof typeof ProspectActivityScalarFieldEnum]


  export const LoanScalarFieldEnum: {
    id: 'id',
    loanNumber: 'loanNumber',
    employeeId: 'employeeId',
    amount: 'amount',
    interestRate: 'interestRate',
    monthlyPayment: 'monthlyPayment',
    remainingAmount: 'remainingAmount',
    startDate: 'startDate',
    endDate: 'endDate',
    purpose: 'purpose',
    status: 'status',
    notes: 'notes',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LoanScalarFieldEnum = (typeof LoanScalarFieldEnum)[keyof typeof LoanScalarFieldEnum]


  export const SpecialiteScalarFieldEnum: {
    id: 'id',
    libelle: 'libelle',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SpecialiteScalarFieldEnum = (typeof SpecialiteScalarFieldEnum)[keyof typeof SpecialiteScalarFieldEnum]


  export const TechnicienScalarFieldEnum: {
    id: 'id',
    nom: 'nom',
    prenom: 'prenom',
    contact: 'contact',
    specialiteId: 'specialiteId',
    utilisateurId: 'utilisateurId',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TechnicienScalarFieldEnum = (typeof TechnicienScalarFieldEnum)[keyof typeof TechnicienScalarFieldEnum]


  export const MissionScalarFieldEnum: {
    numIntervention: 'numIntervention',
    natureIntervention: 'natureIntervention',
    objectifDuContrat: 'objectifDuContrat',
    description: 'description',
    priorite: 'priorite',
    statut: 'statut',
    dateSortieFicheIntervention: 'dateSortieFicheIntervention',
    clientId: 'clientId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MissionScalarFieldEnum = (typeof MissionScalarFieldEnum)[keyof typeof MissionScalarFieldEnum]


  export const InterventionScalarFieldEnum: {
    id: 'id',
    dateHeureDebut: 'dateHeureDebut',
    dateHeureFin: 'dateHeureFin',
    duree: 'duree',
    missionId: 'missionId',
    statut: 'statut',
    commentaire: 'commentaire',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InterventionScalarFieldEnum = (typeof InterventionScalarFieldEnum)[keyof typeof InterventionScalarFieldEnum]


  export const TechnicienInterventionScalarFieldEnum: {
    id: 'id',
    technicienId: 'technicienId',
    interventionId: 'interventionId',
    role: 'role',
    commentaire: 'commentaire',
    createdAt: 'createdAt'
  };

  export type TechnicienInterventionScalarFieldEnum = (typeof TechnicienInterventionScalarFieldEnum)[keyof typeof TechnicienInterventionScalarFieldEnum]


  export const RapportMissionScalarFieldEnum: {
    id: 'id',
    titre: 'titre',
    contenu: 'contenu',
    interventionId: 'interventionId',
    technicienId: 'technicienId',
    missionId: 'missionId',
    createdById: 'createdById',
    statut: 'statut',
    dateValidation: 'dateValidation',
    commentaire: 'commentaire',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RapportMissionScalarFieldEnum = (typeof RapportMissionScalarFieldEnum)[keyof typeof RapportMissionScalarFieldEnum]


  export const RapportImageScalarFieldEnum: {
    id: 'id',
    rapportId: 'rapportId',
    url: 'url',
    description: 'description',
    ordre: 'ordre',
    createdAt: 'createdAt'
  };

  export type RapportImageScalarFieldEnum = (typeof RapportImageScalarFieldEnum)[keyof typeof RapportImageScalarFieldEnum]


  export const MaterielScalarFieldEnum: {
    id: 'id',
    reference: 'reference',
    designation: 'designation',
    description: 'description',
    quantiteTotale: 'quantiteTotale',
    quantiteDisponible: 'quantiteDisponible',
    seuilAlerte: 'seuilAlerte',
    emplacement: 'emplacement',
    categorie: 'categorie',
    prixUnitaire: 'prixUnitaire',
    fournisseur: 'fournisseur',
    dateAchat: 'dateAchat',
    garantie: 'garantie',
    statut: 'statut',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MaterielScalarFieldEnum = (typeof MaterielScalarFieldEnum)[keyof typeof MaterielScalarFieldEnum]


  export const SortieMaterielScalarFieldEnum: {
    id: 'id',
    materielId: 'materielId',
    interventionId: 'interventionId',
    technicienId: 'technicienId',
    quantite: 'quantite',
    dateSortie: 'dateSortie',
    motif: 'motif',
    retourne: 'retourne',
    dateRetour: 'dateRetour',
    quantiteRetour: 'quantiteRetour',
    commentaire: 'commentaire',
    createdAt: 'createdAt'
  };

  export type SortieMaterielScalarFieldEnum = (typeof SortieMaterielScalarFieldEnum)[keyof typeof SortieMaterielScalarFieldEnum]


  export const EntreeMaterielScalarFieldEnum: {
    id: 'id',
    materielId: 'materielId',
    quantite: 'quantite',
    dateEntree: 'dateEntree',
    source: 'source',
    prixTotal: 'prixTotal',
    fournisseur: 'fournisseur',
    facture: 'facture',
    commentaire: 'commentaire',
    createdAt: 'createdAt'
  };

  export type EntreeMaterielScalarFieldEnum = (typeof EntreeMaterielScalarFieldEnum)[keyof typeof EntreeMaterielScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    type: 'type',
    message: 'message',
    data: 'data',
    readAt: 'readAt',
    createdAt: 'createdAt',
    userId: 'userId'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'CustomerType'
   */
  export type EnumCustomerTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CustomerType'>
    


  /**
   * Reference to a field of type 'CustomerType[]'
   */
  export type ListEnumCustomerTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CustomerType[]'>
    


  /**
   * Reference to a field of type 'PaymentMethod'
   */
  export type EnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod'>
    


  /**
   * Reference to a field of type 'PaymentMethod[]'
   */
  export type ListEnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'AddressType'
   */
  export type EnumAddressTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AddressType'>
    


  /**
   * Reference to a field of type 'AddressType[]'
   */
  export type ListEnumAddressTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AddressType[]'>
    


  /**
   * Reference to a field of type 'ProductType'
   */
  export type EnumProductTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProductType'>
    


  /**
   * Reference to a field of type 'ProductType[]'
   */
  export type ListEnumProductTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProductType[]'>
    


  /**
   * Reference to a field of type 'QuoteStatus'
   */
  export type EnumQuoteStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuoteStatus'>
    


  /**
   * Reference to a field of type 'QuoteStatus[]'
   */
  export type ListEnumQuoteStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuoteStatus[]'>
    


  /**
   * Reference to a field of type 'ApprovalLevel'
   */
  export type EnumApprovalLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApprovalLevel'>
    


  /**
   * Reference to a field of type 'ApprovalLevel[]'
   */
  export type ListEnumApprovalLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApprovalLevel[]'>
    


  /**
   * Reference to a field of type 'ApprovalStatus'
   */
  export type EnumApprovalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApprovalStatus'>
    


  /**
   * Reference to a field of type 'ApprovalStatus[]'
   */
  export type ListEnumApprovalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApprovalStatus[]'>
    


  /**
   * Reference to a field of type 'InvoiceType'
   */
  export type EnumInvoiceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceType'>
    


  /**
   * Reference to a field of type 'InvoiceType[]'
   */
  export type ListEnumInvoiceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceType[]'>
    


  /**
   * Reference to a field of type 'InvoiceStatus'
   */
  export type EnumInvoiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceStatus'>
    


  /**
   * Reference to a field of type 'InvoiceStatus[]'
   */
  export type ListEnumInvoiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceStatus[]'>
    


  /**
   * Reference to a field of type 'RecurringFrequency'
   */
  export type EnumRecurringFrequencyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RecurringFrequency'>
    


  /**
   * Reference to a field of type 'RecurringFrequency[]'
   */
  export type ListEnumRecurringFrequencyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RecurringFrequency[]'>
    


  /**
   * Reference to a field of type 'ReminderType'
   */
  export type EnumReminderTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReminderType'>
    


  /**
   * Reference to a field of type 'ReminderType[]'
   */
  export type ListEnumReminderTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReminderType[]'>
    


  /**
   * Reference to a field of type 'ReminderStatus'
   */
  export type EnumReminderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReminderStatus'>
    


  /**
   * Reference to a field of type 'ReminderStatus[]'
   */
  export type ListEnumReminderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReminderStatus[]'>
    


  /**
   * Reference to a field of type 'DocumentType'
   */
  export type EnumDocumentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentType'>
    


  /**
   * Reference to a field of type 'DocumentType[]'
   */
  export type ListEnumDocumentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentType[]'>
    


  /**
   * Reference to a field of type 'ExpenseStatus'
   */
  export type EnumExpenseStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExpenseStatus'>
    


  /**
   * Reference to a field of type 'ExpenseStatus[]'
   */
  export type ListEnumExpenseStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExpenseStatus[]'>
    


  /**
   * Reference to a field of type 'SourceDocumentType'
   */
  export type EnumSourceDocumentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SourceDocumentType'>
    


  /**
   * Reference to a field of type 'SourceDocumentType[]'
   */
  export type ListEnumSourceDocumentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SourceDocumentType[]'>
    


  /**
   * Reference to a field of type 'CashFlowType'
   */
  export type EnumCashFlowTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CashFlowType'>
    


  /**
   * Reference to a field of type 'CashFlowType[]'
   */
  export type ListEnumCashFlowTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CashFlowType[]'>
    


  /**
   * Reference to a field of type 'ContractType'
   */
  export type EnumContractTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContractType'>
    


  /**
   * Reference to a field of type 'ContractType[]'
   */
  export type ListEnumContractTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContractType[]'>
    


  /**
   * Reference to a field of type 'SalaryStatus'
   */
  export type EnumSalaryStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SalaryStatus'>
    


  /**
   * Reference to a field of type 'SalaryStatus[]'
   */
  export type ListEnumSalaryStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SalaryStatus[]'>
    


  /**
   * Reference to a field of type 'LeaveType'
   */
  export type EnumLeaveTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeaveType'>
    


  /**
   * Reference to a field of type 'LeaveType[]'
   */
  export type ListEnumLeaveTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeaveType[]'>
    


  /**
   * Reference to a field of type 'LeaveStatus'
   */
  export type EnumLeaveStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeaveStatus'>
    


  /**
   * Reference to a field of type 'LeaveStatus[]'
   */
  export type ListEnumLeaveStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeaveStatus[]'>
    


  /**
   * Reference to a field of type 'LoanStatus'
   */
  export type EnumLoanStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LoanStatus'>
    


  /**
   * Reference to a field of type 'LoanStatus[]'
   */
  export type ListEnumLoanStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LoanStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type ServiceWhereInput = {
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    id?: IntFilter<"Service"> | number
    name?: StringFilter<"Service"> | string
    description?: StringNullableFilter<"Service"> | string | null
    createdAt?: DateTimeFilter<"Service"> | Date | string
    updatedAt?: DateTimeFilter<"Service"> | Date | string
    users?: UserListRelationFilter
    customers?: CustomerListRelationFilter
    employees?: EmployeeListRelationFilter
  }

  export type ServiceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: UserOrderByRelationAggregateInput
    customers?: CustomerOrderByRelationAggregateInput
    employees?: EmployeeOrderByRelationAggregateInput
  }

  export type ServiceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    description?: StringNullableFilter<"Service"> | string | null
    createdAt?: DateTimeFilter<"Service"> | Date | string
    updatedAt?: DateTimeFilter<"Service"> | Date | string
    users?: UserListRelationFilter
    customers?: CustomerListRelationFilter
    employees?: EmployeeListRelationFilter
  }, "id" | "name">

  export type ServiceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ServiceCountOrderByAggregateInput
    _avg?: ServiceAvgOrderByAggregateInput
    _max?: ServiceMaxOrderByAggregateInput
    _min?: ServiceMinOrderByAggregateInput
    _sum?: ServiceSumOrderByAggregateInput
  }

  export type ServiceScalarWhereWithAggregatesInput = {
    AND?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    OR?: ServiceScalarWhereWithAggregatesInput[]
    NOT?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Service"> | number
    name?: StringWithAggregatesFilter<"Service"> | string
    description?: StringNullableWithAggregatesFilter<"Service"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Service"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Service"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    serviceId?: IntNullableFilter<"User"> | number | null
    isActive?: BoolFilter<"User"> | boolean
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    preferences?: StringNullableFilter<"User"> | string | null
    permissions?: StringNullableFilter<"User"> | string | null
    avatarUrl?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    service?: XOR<ServiceNullableRelationFilter, ServiceWhereInput> | null
    createdCustomers?: CustomerListRelationFilter
    createdQuotes?: QuoteListRelationFilter
    createdInvoices?: InvoiceListRelationFilter
    createdPayments?: PaymentListRelationFilter
    serviceApprovals?: QuoteListRelationFilter
    dgApprovals?: QuoteListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    quoteApprovals?: QuoteApprovalListRelationFilter
    createdExpenses?: ExpenseListRelationFilter
    accountingEntries?: AccountingEntryListRelationFilter
    cashFlowEntries?: CashFlowListRelationFilter
    createdReminders?: ReminderListRelationFilter
    createdRecurringInvoices?: RecurringInvoiceListRelationFilter
    employee?: XOR<EmployeeNullableRelationFilter, EmployeeWhereInput> | null
    leaveApprovals?: LeaveRequestListRelationFilter
    assignedProspects?: ProspectListRelationFilter
    createdProspects?: ProspectListRelationFilter
    createdProspectActivities?: ProspectActivityListRelationFilter
    technicien?: XOR<TechnicienNullableRelationFilter, TechnicienWhereInput> | null
    notifications?: NotificationListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    serviceId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    lastLogin?: SortOrderInput | SortOrder
    preferences?: SortOrderInput | SortOrder
    permissions?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    service?: ServiceOrderByWithRelationInput
    createdCustomers?: CustomerOrderByRelationAggregateInput
    createdQuotes?: QuoteOrderByRelationAggregateInput
    createdInvoices?: InvoiceOrderByRelationAggregateInput
    createdPayments?: PaymentOrderByRelationAggregateInput
    serviceApprovals?: QuoteOrderByRelationAggregateInput
    dgApprovals?: QuoteOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    quoteApprovals?: QuoteApprovalOrderByRelationAggregateInput
    createdExpenses?: ExpenseOrderByRelationAggregateInput
    accountingEntries?: AccountingEntryOrderByRelationAggregateInput
    cashFlowEntries?: CashFlowOrderByRelationAggregateInput
    createdReminders?: ReminderOrderByRelationAggregateInput
    createdRecurringInvoices?: RecurringInvoiceOrderByRelationAggregateInput
    employee?: EmployeeOrderByWithRelationInput
    leaveApprovals?: LeaveRequestOrderByRelationAggregateInput
    assignedProspects?: ProspectOrderByRelationAggregateInput
    createdProspects?: ProspectOrderByRelationAggregateInput
    createdProspectActivities?: ProspectActivityOrderByRelationAggregateInput
    technicien?: TechnicienOrderByWithRelationInput
    notifications?: NotificationOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    passwordHash?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    serviceId?: IntNullableFilter<"User"> | number | null
    isActive?: BoolFilter<"User"> | boolean
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    preferences?: StringNullableFilter<"User"> | string | null
    permissions?: StringNullableFilter<"User"> | string | null
    avatarUrl?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    service?: XOR<ServiceNullableRelationFilter, ServiceWhereInput> | null
    createdCustomers?: CustomerListRelationFilter
    createdQuotes?: QuoteListRelationFilter
    createdInvoices?: InvoiceListRelationFilter
    createdPayments?: PaymentListRelationFilter
    serviceApprovals?: QuoteListRelationFilter
    dgApprovals?: QuoteListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    quoteApprovals?: QuoteApprovalListRelationFilter
    createdExpenses?: ExpenseListRelationFilter
    accountingEntries?: AccountingEntryListRelationFilter
    cashFlowEntries?: CashFlowListRelationFilter
    createdReminders?: ReminderListRelationFilter
    createdRecurringInvoices?: RecurringInvoiceListRelationFilter
    employee?: XOR<EmployeeNullableRelationFilter, EmployeeWhereInput> | null
    leaveApprovals?: LeaveRequestListRelationFilter
    assignedProspects?: ProspectListRelationFilter
    createdProspects?: ProspectListRelationFilter
    createdProspectActivities?: ProspectActivityListRelationFilter
    technicien?: XOR<TechnicienNullableRelationFilter, TechnicienWhereInput> | null
    notifications?: NotificationListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    serviceId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    lastLogin?: SortOrderInput | SortOrder
    preferences?: SortOrderInput | SortOrder
    permissions?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    email?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    firstName?: StringWithAggregatesFilter<"User"> | string
    lastName?: StringWithAggregatesFilter<"User"> | string
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    serviceId?: IntNullableWithAggregatesFilter<"User"> | number | null
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    lastLogin?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    preferences?: StringNullableWithAggregatesFilter<"User"> | string | null
    permissions?: StringNullableWithAggregatesFilter<"User"> | string | null
    avatarUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type CustomerWhereInput = {
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    id?: IntFilter<"Customer"> | number
    customerNumber?: StringFilter<"Customer"> | string
    type?: EnumCustomerTypeFilter<"Customer"> | $Enums.CustomerType
    name?: StringFilter<"Customer"> | string
    legalName?: StringNullableFilter<"Customer"> | string | null
    siret?: StringNullableFilter<"Customer"> | string | null
    vatNumber?: StringNullableFilter<"Customer"> | string | null
    email?: StringNullableFilter<"Customer"> | string | null
    phone?: StringNullableFilter<"Customer"> | string | null
    mobile?: StringNullableFilter<"Customer"> | string | null
    website?: StringNullableFilter<"Customer"> | string | null
    paymentTerms?: IntFilter<"Customer"> | number
    paymentMethod?: EnumPaymentMethodFilter<"Customer"> | $Enums.PaymentMethod
    creditLimit?: FloatFilter<"Customer"> | number
    discountRate?: FloatFilter<"Customer"> | number
    category?: StringNullableFilter<"Customer"> | string | null
    tags?: StringNullableFilter<"Customer"> | string | null
    notes?: StringNullableFilter<"Customer"> | string | null
    isActive?: BoolFilter<"Customer"> | boolean
    serviceId?: IntNullableFilter<"Customer"> | number | null
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    createdBy?: IntFilter<"Customer"> | number
    service?: XOR<ServiceNullableRelationFilter, ServiceWhereInput> | null
    creator?: XOR<UserRelationFilter, UserWhereInput>
    addresses?: CustomerAddressListRelationFilter
    quotes?: QuoteListRelationFilter
    invoices?: InvoiceListRelationFilter
    payments?: PaymentListRelationFilter
    recurringInvoices?: RecurringInvoiceListRelationFilter
    missions?: MissionListRelationFilter
  }

  export type CustomerOrderByWithRelationInput = {
    id?: SortOrder
    customerNumber?: SortOrder
    type?: SortOrder
    name?: SortOrder
    legalName?: SortOrderInput | SortOrder
    siret?: SortOrderInput | SortOrder
    vatNumber?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    mobile?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    paymentTerms?: SortOrder
    paymentMethod?: SortOrder
    creditLimit?: SortOrder
    discountRate?: SortOrder
    category?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    isActive?: SortOrder
    serviceId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    service?: ServiceOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
    addresses?: CustomerAddressOrderByRelationAggregateInput
    quotes?: QuoteOrderByRelationAggregateInput
    invoices?: InvoiceOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
    recurringInvoices?: RecurringInvoiceOrderByRelationAggregateInput
    missions?: MissionOrderByRelationAggregateInput
  }

  export type CustomerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    customerNumber?: string
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    type?: EnumCustomerTypeFilter<"Customer"> | $Enums.CustomerType
    name?: StringFilter<"Customer"> | string
    legalName?: StringNullableFilter<"Customer"> | string | null
    siret?: StringNullableFilter<"Customer"> | string | null
    vatNumber?: StringNullableFilter<"Customer"> | string | null
    email?: StringNullableFilter<"Customer"> | string | null
    phone?: StringNullableFilter<"Customer"> | string | null
    mobile?: StringNullableFilter<"Customer"> | string | null
    website?: StringNullableFilter<"Customer"> | string | null
    paymentTerms?: IntFilter<"Customer"> | number
    paymentMethod?: EnumPaymentMethodFilter<"Customer"> | $Enums.PaymentMethod
    creditLimit?: FloatFilter<"Customer"> | number
    discountRate?: FloatFilter<"Customer"> | number
    category?: StringNullableFilter<"Customer"> | string | null
    tags?: StringNullableFilter<"Customer"> | string | null
    notes?: StringNullableFilter<"Customer"> | string | null
    isActive?: BoolFilter<"Customer"> | boolean
    serviceId?: IntNullableFilter<"Customer"> | number | null
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    createdBy?: IntFilter<"Customer"> | number
    service?: XOR<ServiceNullableRelationFilter, ServiceWhereInput> | null
    creator?: XOR<UserRelationFilter, UserWhereInput>
    addresses?: CustomerAddressListRelationFilter
    quotes?: QuoteListRelationFilter
    invoices?: InvoiceListRelationFilter
    payments?: PaymentListRelationFilter
    recurringInvoices?: RecurringInvoiceListRelationFilter
    missions?: MissionListRelationFilter
  }, "id" | "customerNumber">

  export type CustomerOrderByWithAggregationInput = {
    id?: SortOrder
    customerNumber?: SortOrder
    type?: SortOrder
    name?: SortOrder
    legalName?: SortOrderInput | SortOrder
    siret?: SortOrderInput | SortOrder
    vatNumber?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    mobile?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    paymentTerms?: SortOrder
    paymentMethod?: SortOrder
    creditLimit?: SortOrder
    discountRate?: SortOrder
    category?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    isActive?: SortOrder
    serviceId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    _count?: CustomerCountOrderByAggregateInput
    _avg?: CustomerAvgOrderByAggregateInput
    _max?: CustomerMaxOrderByAggregateInput
    _min?: CustomerMinOrderByAggregateInput
    _sum?: CustomerSumOrderByAggregateInput
  }

  export type CustomerScalarWhereWithAggregatesInput = {
    AND?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    OR?: CustomerScalarWhereWithAggregatesInput[]
    NOT?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Customer"> | number
    customerNumber?: StringWithAggregatesFilter<"Customer"> | string
    type?: EnumCustomerTypeWithAggregatesFilter<"Customer"> | $Enums.CustomerType
    name?: StringWithAggregatesFilter<"Customer"> | string
    legalName?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    siret?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    vatNumber?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    email?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    mobile?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    website?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    paymentTerms?: IntWithAggregatesFilter<"Customer"> | number
    paymentMethod?: EnumPaymentMethodWithAggregatesFilter<"Customer"> | $Enums.PaymentMethod
    creditLimit?: FloatWithAggregatesFilter<"Customer"> | number
    discountRate?: FloatWithAggregatesFilter<"Customer"> | number
    category?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    tags?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    isActive?: BoolWithAggregatesFilter<"Customer"> | boolean
    serviceId?: IntNullableWithAggregatesFilter<"Customer"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
    createdBy?: IntWithAggregatesFilter<"Customer"> | number
  }

  export type CustomerAddressWhereInput = {
    AND?: CustomerAddressWhereInput | CustomerAddressWhereInput[]
    OR?: CustomerAddressWhereInput[]
    NOT?: CustomerAddressWhereInput | CustomerAddressWhereInput[]
    id?: IntFilter<"CustomerAddress"> | number
    customerId?: IntFilter<"CustomerAddress"> | number
    type?: EnumAddressTypeFilter<"CustomerAddress"> | $Enums.AddressType
    name?: StringNullableFilter<"CustomerAddress"> | string | null
    addressLine1?: StringFilter<"CustomerAddress"> | string
    addressLine2?: StringNullableFilter<"CustomerAddress"> | string | null
    postalCode?: StringFilter<"CustomerAddress"> | string
    city?: StringFilter<"CustomerAddress"> | string
    country?: StringFilter<"CustomerAddress"> | string
    isDefault?: BoolFilter<"CustomerAddress"> | boolean
    createdAt?: DateTimeFilter<"CustomerAddress"> | Date | string
    customer?: XOR<CustomerRelationFilter, CustomerWhereInput>
    quotes?: QuoteListRelationFilter
    invoices?: InvoiceListRelationFilter
  }

  export type CustomerAddressOrderByWithRelationInput = {
    id?: SortOrder
    customerId?: SortOrder
    type?: SortOrder
    name?: SortOrderInput | SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrderInput | SortOrder
    postalCode?: SortOrder
    city?: SortOrder
    country?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    customer?: CustomerOrderByWithRelationInput
    quotes?: QuoteOrderByRelationAggregateInput
    invoices?: InvoiceOrderByRelationAggregateInput
  }

  export type CustomerAddressWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CustomerAddressWhereInput | CustomerAddressWhereInput[]
    OR?: CustomerAddressWhereInput[]
    NOT?: CustomerAddressWhereInput | CustomerAddressWhereInput[]
    customerId?: IntFilter<"CustomerAddress"> | number
    type?: EnumAddressTypeFilter<"CustomerAddress"> | $Enums.AddressType
    name?: StringNullableFilter<"CustomerAddress"> | string | null
    addressLine1?: StringFilter<"CustomerAddress"> | string
    addressLine2?: StringNullableFilter<"CustomerAddress"> | string | null
    postalCode?: StringFilter<"CustomerAddress"> | string
    city?: StringFilter<"CustomerAddress"> | string
    country?: StringFilter<"CustomerAddress"> | string
    isDefault?: BoolFilter<"CustomerAddress"> | boolean
    createdAt?: DateTimeFilter<"CustomerAddress"> | Date | string
    customer?: XOR<CustomerRelationFilter, CustomerWhereInput>
    quotes?: QuoteListRelationFilter
    invoices?: InvoiceListRelationFilter
  }, "id">

  export type CustomerAddressOrderByWithAggregationInput = {
    id?: SortOrder
    customerId?: SortOrder
    type?: SortOrder
    name?: SortOrderInput | SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrderInput | SortOrder
    postalCode?: SortOrder
    city?: SortOrder
    country?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    _count?: CustomerAddressCountOrderByAggregateInput
    _avg?: CustomerAddressAvgOrderByAggregateInput
    _max?: CustomerAddressMaxOrderByAggregateInput
    _min?: CustomerAddressMinOrderByAggregateInput
    _sum?: CustomerAddressSumOrderByAggregateInput
  }

  export type CustomerAddressScalarWhereWithAggregatesInput = {
    AND?: CustomerAddressScalarWhereWithAggregatesInput | CustomerAddressScalarWhereWithAggregatesInput[]
    OR?: CustomerAddressScalarWhereWithAggregatesInput[]
    NOT?: CustomerAddressScalarWhereWithAggregatesInput | CustomerAddressScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CustomerAddress"> | number
    customerId?: IntWithAggregatesFilter<"CustomerAddress"> | number
    type?: EnumAddressTypeWithAggregatesFilter<"CustomerAddress"> | $Enums.AddressType
    name?: StringNullableWithAggregatesFilter<"CustomerAddress"> | string | null
    addressLine1?: StringWithAggregatesFilter<"CustomerAddress"> | string
    addressLine2?: StringNullableWithAggregatesFilter<"CustomerAddress"> | string | null
    postalCode?: StringWithAggregatesFilter<"CustomerAddress"> | string
    city?: StringWithAggregatesFilter<"CustomerAddress"> | string
    country?: StringWithAggregatesFilter<"CustomerAddress"> | string
    isDefault?: BoolWithAggregatesFilter<"CustomerAddress"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"CustomerAddress"> | Date | string
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: IntFilter<"Product"> | number
    sku?: StringFilter<"Product"> | string
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    type?: EnumProductTypeFilter<"Product"> | $Enums.ProductType
    category?: StringNullableFilter<"Product"> | string | null
    unit?: StringFilter<"Product"> | string
    priceHt?: FloatFilter<"Product"> | number
    vatRate?: FloatFilter<"Product"> | number
    costPrice?: FloatNullableFilter<"Product"> | number | null
    stockQuantity?: IntFilter<"Product"> | number
    stockAlertThreshold?: IntFilter<"Product"> | number
    isActive?: BoolFilter<"Product"> | boolean
    weight?: FloatNullableFilter<"Product"> | number | null
    dimensions?: StringNullableFilter<"Product"> | string | null
    imageUrl?: StringNullableFilter<"Product"> | string | null
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    prices?: ProductPriceListRelationFilter
    quoteItems?: QuoteItemListRelationFilter
    invoiceItems?: InvoiceItemListRelationFilter
    recurringInvoiceItems?: RecurringInvoiceItemListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    category?: SortOrderInput | SortOrder
    unit?: SortOrder
    priceHt?: SortOrder
    vatRate?: SortOrder
    costPrice?: SortOrderInput | SortOrder
    stockQuantity?: SortOrder
    stockAlertThreshold?: SortOrder
    isActive?: SortOrder
    weight?: SortOrderInput | SortOrder
    dimensions?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    prices?: ProductPriceOrderByRelationAggregateInput
    quoteItems?: QuoteItemOrderByRelationAggregateInput
    invoiceItems?: InvoiceItemOrderByRelationAggregateInput
    recurringInvoiceItems?: RecurringInvoiceItemOrderByRelationAggregateInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    sku?: string
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    type?: EnumProductTypeFilter<"Product"> | $Enums.ProductType
    category?: StringNullableFilter<"Product"> | string | null
    unit?: StringFilter<"Product"> | string
    priceHt?: FloatFilter<"Product"> | number
    vatRate?: FloatFilter<"Product"> | number
    costPrice?: FloatNullableFilter<"Product"> | number | null
    stockQuantity?: IntFilter<"Product"> | number
    stockAlertThreshold?: IntFilter<"Product"> | number
    isActive?: BoolFilter<"Product"> | boolean
    weight?: FloatNullableFilter<"Product"> | number | null
    dimensions?: StringNullableFilter<"Product"> | string | null
    imageUrl?: StringNullableFilter<"Product"> | string | null
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    prices?: ProductPriceListRelationFilter
    quoteItems?: QuoteItemListRelationFilter
    invoiceItems?: InvoiceItemListRelationFilter
    recurringInvoiceItems?: RecurringInvoiceItemListRelationFilter
  }, "id" | "sku">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    category?: SortOrderInput | SortOrder
    unit?: SortOrder
    priceHt?: SortOrder
    vatRate?: SortOrder
    costPrice?: SortOrderInput | SortOrder
    stockQuantity?: SortOrder
    stockAlertThreshold?: SortOrder
    isActive?: SortOrder
    weight?: SortOrderInput | SortOrder
    dimensions?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Product"> | number
    sku?: StringWithAggregatesFilter<"Product"> | string
    name?: StringWithAggregatesFilter<"Product"> | string
    description?: StringNullableWithAggregatesFilter<"Product"> | string | null
    type?: EnumProductTypeWithAggregatesFilter<"Product"> | $Enums.ProductType
    category?: StringNullableWithAggregatesFilter<"Product"> | string | null
    unit?: StringWithAggregatesFilter<"Product"> | string
    priceHt?: FloatWithAggregatesFilter<"Product"> | number
    vatRate?: FloatWithAggregatesFilter<"Product"> | number
    costPrice?: FloatNullableWithAggregatesFilter<"Product"> | number | null
    stockQuantity?: IntWithAggregatesFilter<"Product"> | number
    stockAlertThreshold?: IntWithAggregatesFilter<"Product"> | number
    isActive?: BoolWithAggregatesFilter<"Product"> | boolean
    weight?: FloatNullableWithAggregatesFilter<"Product"> | number | null
    dimensions?: StringNullableWithAggregatesFilter<"Product"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"Product"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
  }

  export type ProductPriceWhereInput = {
    AND?: ProductPriceWhereInput | ProductPriceWhereInput[]
    OR?: ProductPriceWhereInput[]
    NOT?: ProductPriceWhereInput | ProductPriceWhereInput[]
    id?: IntFilter<"ProductPrice"> | number
    productId?: IntFilter<"ProductPrice"> | number
    customerCategory?: StringNullableFilter<"ProductPrice"> | string | null
    minQuantity?: IntFilter<"ProductPrice"> | number
    priceHt?: FloatFilter<"ProductPrice"> | number
    validFrom?: DateTimeNullableFilter<"ProductPrice"> | Date | string | null
    validUntil?: DateTimeNullableFilter<"ProductPrice"> | Date | string | null
    createdAt?: DateTimeFilter<"ProductPrice"> | Date | string
    product?: XOR<ProductRelationFilter, ProductWhereInput>
  }

  export type ProductPriceOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    customerCategory?: SortOrderInput | SortOrder
    minQuantity?: SortOrder
    priceHt?: SortOrder
    validFrom?: SortOrderInput | SortOrder
    validUntil?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    product?: ProductOrderByWithRelationInput
  }

  export type ProductPriceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProductPriceWhereInput | ProductPriceWhereInput[]
    OR?: ProductPriceWhereInput[]
    NOT?: ProductPriceWhereInput | ProductPriceWhereInput[]
    productId?: IntFilter<"ProductPrice"> | number
    customerCategory?: StringNullableFilter<"ProductPrice"> | string | null
    minQuantity?: IntFilter<"ProductPrice"> | number
    priceHt?: FloatFilter<"ProductPrice"> | number
    validFrom?: DateTimeNullableFilter<"ProductPrice"> | Date | string | null
    validUntil?: DateTimeNullableFilter<"ProductPrice"> | Date | string | null
    createdAt?: DateTimeFilter<"ProductPrice"> | Date | string
    product?: XOR<ProductRelationFilter, ProductWhereInput>
  }, "id">

  export type ProductPriceOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    customerCategory?: SortOrderInput | SortOrder
    minQuantity?: SortOrder
    priceHt?: SortOrder
    validFrom?: SortOrderInput | SortOrder
    validUntil?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ProductPriceCountOrderByAggregateInput
    _avg?: ProductPriceAvgOrderByAggregateInput
    _max?: ProductPriceMaxOrderByAggregateInput
    _min?: ProductPriceMinOrderByAggregateInput
    _sum?: ProductPriceSumOrderByAggregateInput
  }

  export type ProductPriceScalarWhereWithAggregatesInput = {
    AND?: ProductPriceScalarWhereWithAggregatesInput | ProductPriceScalarWhereWithAggregatesInput[]
    OR?: ProductPriceScalarWhereWithAggregatesInput[]
    NOT?: ProductPriceScalarWhereWithAggregatesInput | ProductPriceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProductPrice"> | number
    productId?: IntWithAggregatesFilter<"ProductPrice"> | number
    customerCategory?: StringNullableWithAggregatesFilter<"ProductPrice"> | string | null
    minQuantity?: IntWithAggregatesFilter<"ProductPrice"> | number
    priceHt?: FloatWithAggregatesFilter<"ProductPrice"> | number
    validFrom?: DateTimeNullableWithAggregatesFilter<"ProductPrice"> | Date | string | null
    validUntil?: DateTimeNullableWithAggregatesFilter<"ProductPrice"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ProductPrice"> | Date | string
  }

  export type QuoteWhereInput = {
    AND?: QuoteWhereInput | QuoteWhereInput[]
    OR?: QuoteWhereInput[]
    NOT?: QuoteWhereInput | QuoteWhereInput[]
    id?: IntFilter<"Quote"> | number
    quoteNumber?: StringFilter<"Quote"> | string
    customerId?: IntFilter<"Quote"> | number
    customerAddressId?: IntNullableFilter<"Quote"> | number | null
    status?: EnumQuoteStatusFilter<"Quote"> | $Enums.QuoteStatus
    quoteDate?: DateTimeFilter<"Quote"> | Date | string
    validUntil?: DateTimeFilter<"Quote"> | Date | string
    subtotalHt?: FloatFilter<"Quote"> | number
    discountAmount?: FloatFilter<"Quote"> | number
    totalVat?: FloatFilter<"Quote"> | number
    totalTtc?: FloatFilter<"Quote"> | number
    terms?: StringNullableFilter<"Quote"> | string | null
    notes?: StringNullableFilter<"Quote"> | string | null
    createdBy?: IntFilter<"Quote"> | number
    createdAt?: DateTimeFilter<"Quote"> | Date | string
    updatedAt?: DateTimeFilter<"Quote"> | Date | string
    sentAt?: DateTimeNullableFilter<"Quote"> | Date | string | null
    submittedForServiceApprovalAt?: DateTimeNullableFilter<"Quote"> | Date | string | null
    serviceManagerApprovedBy?: IntNullableFilter<"Quote"> | number | null
    serviceManagerApprovalDate?: DateTimeNullableFilter<"Quote"> | Date | string | null
    serviceManagerComments?: StringNullableFilter<"Quote"> | string | null
    dgApprovedBy?: IntNullableFilter<"Quote"> | number | null
    dgApprovalDate?: DateTimeNullableFilter<"Quote"> | Date | string | null
    dgComments?: StringNullableFilter<"Quote"> | string | null
    acceptedAt?: DateTimeNullableFilter<"Quote"> | Date | string | null
    customer?: XOR<CustomerRelationFilter, CustomerWhereInput>
    customerAddress?: XOR<CustomerAddressNullableRelationFilter, CustomerAddressWhereInput> | null
    creator?: XOR<UserRelationFilter, UserWhereInput>
    serviceManager?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    dgApprover?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    items?: QuoteItemListRelationFilter
    invoices?: InvoiceListRelationFilter
    approvals?: QuoteApprovalListRelationFilter
    missions?: MissionListRelationFilter
  }

  export type QuoteOrderByWithRelationInput = {
    id?: SortOrder
    quoteNumber?: SortOrder
    customerId?: SortOrder
    customerAddressId?: SortOrderInput | SortOrder
    status?: SortOrder
    quoteDate?: SortOrder
    validUntil?: SortOrder
    subtotalHt?: SortOrder
    discountAmount?: SortOrder
    totalVat?: SortOrder
    totalTtc?: SortOrder
    terms?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sentAt?: SortOrderInput | SortOrder
    submittedForServiceApprovalAt?: SortOrderInput | SortOrder
    serviceManagerApprovedBy?: SortOrderInput | SortOrder
    serviceManagerApprovalDate?: SortOrderInput | SortOrder
    serviceManagerComments?: SortOrderInput | SortOrder
    dgApprovedBy?: SortOrderInput | SortOrder
    dgApprovalDate?: SortOrderInput | SortOrder
    dgComments?: SortOrderInput | SortOrder
    acceptedAt?: SortOrderInput | SortOrder
    customer?: CustomerOrderByWithRelationInput
    customerAddress?: CustomerAddressOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
    serviceManager?: UserOrderByWithRelationInput
    dgApprover?: UserOrderByWithRelationInput
    items?: QuoteItemOrderByRelationAggregateInput
    invoices?: InvoiceOrderByRelationAggregateInput
    approvals?: QuoteApprovalOrderByRelationAggregateInput
    missions?: MissionOrderByRelationAggregateInput
  }

  export type QuoteWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    quoteNumber?: string
    AND?: QuoteWhereInput | QuoteWhereInput[]
    OR?: QuoteWhereInput[]
    NOT?: QuoteWhereInput | QuoteWhereInput[]
    customerId?: IntFilter<"Quote"> | number
    customerAddressId?: IntNullableFilter<"Quote"> | number | null
    status?: EnumQuoteStatusFilter<"Quote"> | $Enums.QuoteStatus
    quoteDate?: DateTimeFilter<"Quote"> | Date | string
    validUntil?: DateTimeFilter<"Quote"> | Date | string
    subtotalHt?: FloatFilter<"Quote"> | number
    discountAmount?: FloatFilter<"Quote"> | number
    totalVat?: FloatFilter<"Quote"> | number
    totalTtc?: FloatFilter<"Quote"> | number
    terms?: StringNullableFilter<"Quote"> | string | null
    notes?: StringNullableFilter<"Quote"> | string | null
    createdBy?: IntFilter<"Quote"> | number
    createdAt?: DateTimeFilter<"Quote"> | Date | string
    updatedAt?: DateTimeFilter<"Quote"> | Date | string
    sentAt?: DateTimeNullableFilter<"Quote"> | Date | string | null
    submittedForServiceApprovalAt?: DateTimeNullableFilter<"Quote"> | Date | string | null
    serviceManagerApprovedBy?: IntNullableFilter<"Quote"> | number | null
    serviceManagerApprovalDate?: DateTimeNullableFilter<"Quote"> | Date | string | null
    serviceManagerComments?: StringNullableFilter<"Quote"> | string | null
    dgApprovedBy?: IntNullableFilter<"Quote"> | number | null
    dgApprovalDate?: DateTimeNullableFilter<"Quote"> | Date | string | null
    dgComments?: StringNullableFilter<"Quote"> | string | null
    acceptedAt?: DateTimeNullableFilter<"Quote"> | Date | string | null
    customer?: XOR<CustomerRelationFilter, CustomerWhereInput>
    customerAddress?: XOR<CustomerAddressNullableRelationFilter, CustomerAddressWhereInput> | null
    creator?: XOR<UserRelationFilter, UserWhereInput>
    serviceManager?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    dgApprover?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    items?: QuoteItemListRelationFilter
    invoices?: InvoiceListRelationFilter
    approvals?: QuoteApprovalListRelationFilter
    missions?: MissionListRelationFilter
  }, "id" | "quoteNumber">

  export type QuoteOrderByWithAggregationInput = {
    id?: SortOrder
    quoteNumber?: SortOrder
    customerId?: SortOrder
    customerAddressId?: SortOrderInput | SortOrder
    status?: SortOrder
    quoteDate?: SortOrder
    validUntil?: SortOrder
    subtotalHt?: SortOrder
    discountAmount?: SortOrder
    totalVat?: SortOrder
    totalTtc?: SortOrder
    terms?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sentAt?: SortOrderInput | SortOrder
    submittedForServiceApprovalAt?: SortOrderInput | SortOrder
    serviceManagerApprovedBy?: SortOrderInput | SortOrder
    serviceManagerApprovalDate?: SortOrderInput | SortOrder
    serviceManagerComments?: SortOrderInput | SortOrder
    dgApprovedBy?: SortOrderInput | SortOrder
    dgApprovalDate?: SortOrderInput | SortOrder
    dgComments?: SortOrderInput | SortOrder
    acceptedAt?: SortOrderInput | SortOrder
    _count?: QuoteCountOrderByAggregateInput
    _avg?: QuoteAvgOrderByAggregateInput
    _max?: QuoteMaxOrderByAggregateInput
    _min?: QuoteMinOrderByAggregateInput
    _sum?: QuoteSumOrderByAggregateInput
  }

  export type QuoteScalarWhereWithAggregatesInput = {
    AND?: QuoteScalarWhereWithAggregatesInput | QuoteScalarWhereWithAggregatesInput[]
    OR?: QuoteScalarWhereWithAggregatesInput[]
    NOT?: QuoteScalarWhereWithAggregatesInput | QuoteScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Quote"> | number
    quoteNumber?: StringWithAggregatesFilter<"Quote"> | string
    customerId?: IntWithAggregatesFilter<"Quote"> | number
    customerAddressId?: IntNullableWithAggregatesFilter<"Quote"> | number | null
    status?: EnumQuoteStatusWithAggregatesFilter<"Quote"> | $Enums.QuoteStatus
    quoteDate?: DateTimeWithAggregatesFilter<"Quote"> | Date | string
    validUntil?: DateTimeWithAggregatesFilter<"Quote"> | Date | string
    subtotalHt?: FloatWithAggregatesFilter<"Quote"> | number
    discountAmount?: FloatWithAggregatesFilter<"Quote"> | number
    totalVat?: FloatWithAggregatesFilter<"Quote"> | number
    totalTtc?: FloatWithAggregatesFilter<"Quote"> | number
    terms?: StringNullableWithAggregatesFilter<"Quote"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Quote"> | string | null
    createdBy?: IntWithAggregatesFilter<"Quote"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Quote"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Quote"> | Date | string
    sentAt?: DateTimeNullableWithAggregatesFilter<"Quote"> | Date | string | null
    submittedForServiceApprovalAt?: DateTimeNullableWithAggregatesFilter<"Quote"> | Date | string | null
    serviceManagerApprovedBy?: IntNullableWithAggregatesFilter<"Quote"> | number | null
    serviceManagerApprovalDate?: DateTimeNullableWithAggregatesFilter<"Quote"> | Date | string | null
    serviceManagerComments?: StringNullableWithAggregatesFilter<"Quote"> | string | null
    dgApprovedBy?: IntNullableWithAggregatesFilter<"Quote"> | number | null
    dgApprovalDate?: DateTimeNullableWithAggregatesFilter<"Quote"> | Date | string | null
    dgComments?: StringNullableWithAggregatesFilter<"Quote"> | string | null
    acceptedAt?: DateTimeNullableWithAggregatesFilter<"Quote"> | Date | string | null
  }

  export type QuoteItemWhereInput = {
    AND?: QuoteItemWhereInput | QuoteItemWhereInput[]
    OR?: QuoteItemWhereInput[]
    NOT?: QuoteItemWhereInput | QuoteItemWhereInput[]
    id?: IntFilter<"QuoteItem"> | number
    quoteId?: IntFilter<"QuoteItem"> | number
    productId?: IntNullableFilter<"QuoteItem"> | number | null
    description?: StringFilter<"QuoteItem"> | string
    quantity?: FloatFilter<"QuoteItem"> | number
    unitPriceHt?: FloatFilter<"QuoteItem"> | number
    discountRate?: FloatFilter<"QuoteItem"> | number
    vatRate?: FloatFilter<"QuoteItem"> | number
    totalHt?: FloatFilter<"QuoteItem"> | number
    sortOrder?: IntFilter<"QuoteItem"> | number
    quote?: XOR<QuoteRelationFilter, QuoteWhereInput>
    product?: XOR<ProductNullableRelationFilter, ProductWhereInput> | null
  }

  export type QuoteItemOrderByWithRelationInput = {
    id?: SortOrder
    quoteId?: SortOrder
    productId?: SortOrderInput | SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPriceHt?: SortOrder
    discountRate?: SortOrder
    vatRate?: SortOrder
    totalHt?: SortOrder
    sortOrder?: SortOrder
    quote?: QuoteOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type QuoteItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: QuoteItemWhereInput | QuoteItemWhereInput[]
    OR?: QuoteItemWhereInput[]
    NOT?: QuoteItemWhereInput | QuoteItemWhereInput[]
    quoteId?: IntFilter<"QuoteItem"> | number
    productId?: IntNullableFilter<"QuoteItem"> | number | null
    description?: StringFilter<"QuoteItem"> | string
    quantity?: FloatFilter<"QuoteItem"> | number
    unitPriceHt?: FloatFilter<"QuoteItem"> | number
    discountRate?: FloatFilter<"QuoteItem"> | number
    vatRate?: FloatFilter<"QuoteItem"> | number
    totalHt?: FloatFilter<"QuoteItem"> | number
    sortOrder?: IntFilter<"QuoteItem"> | number
    quote?: XOR<QuoteRelationFilter, QuoteWhereInput>
    product?: XOR<ProductNullableRelationFilter, ProductWhereInput> | null
  }, "id">

  export type QuoteItemOrderByWithAggregationInput = {
    id?: SortOrder
    quoteId?: SortOrder
    productId?: SortOrderInput | SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPriceHt?: SortOrder
    discountRate?: SortOrder
    vatRate?: SortOrder
    totalHt?: SortOrder
    sortOrder?: SortOrder
    _count?: QuoteItemCountOrderByAggregateInput
    _avg?: QuoteItemAvgOrderByAggregateInput
    _max?: QuoteItemMaxOrderByAggregateInput
    _min?: QuoteItemMinOrderByAggregateInput
    _sum?: QuoteItemSumOrderByAggregateInput
  }

  export type QuoteItemScalarWhereWithAggregatesInput = {
    AND?: QuoteItemScalarWhereWithAggregatesInput | QuoteItemScalarWhereWithAggregatesInput[]
    OR?: QuoteItemScalarWhereWithAggregatesInput[]
    NOT?: QuoteItemScalarWhereWithAggregatesInput | QuoteItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"QuoteItem"> | number
    quoteId?: IntWithAggregatesFilter<"QuoteItem"> | number
    productId?: IntNullableWithAggregatesFilter<"QuoteItem"> | number | null
    description?: StringWithAggregatesFilter<"QuoteItem"> | string
    quantity?: FloatWithAggregatesFilter<"QuoteItem"> | number
    unitPriceHt?: FloatWithAggregatesFilter<"QuoteItem"> | number
    discountRate?: FloatWithAggregatesFilter<"QuoteItem"> | number
    vatRate?: FloatWithAggregatesFilter<"QuoteItem"> | number
    totalHt?: FloatWithAggregatesFilter<"QuoteItem"> | number
    sortOrder?: IntWithAggregatesFilter<"QuoteItem"> | number
  }

  export type QuoteApprovalWhereInput = {
    AND?: QuoteApprovalWhereInput | QuoteApprovalWhereInput[]
    OR?: QuoteApprovalWhereInput[]
    NOT?: QuoteApprovalWhereInput | QuoteApprovalWhereInput[]
    id?: IntFilter<"QuoteApproval"> | number
    quoteId?: IntFilter<"QuoteApproval"> | number
    approverId?: IntFilter<"QuoteApproval"> | number
    approvalLevel?: EnumApprovalLevelFilter<"QuoteApproval"> | $Enums.ApprovalLevel
    status?: EnumApprovalStatusFilter<"QuoteApproval"> | $Enums.ApprovalStatus
    approvalDate?: DateTimeNullableFilter<"QuoteApproval"> | Date | string | null
    comments?: StringNullableFilter<"QuoteApproval"> | string | null
    createdAt?: DateTimeFilter<"QuoteApproval"> | Date | string
    updatedAt?: DateTimeFilter<"QuoteApproval"> | Date | string
    quote?: XOR<QuoteRelationFilter, QuoteWhereInput>
    approver?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type QuoteApprovalOrderByWithRelationInput = {
    id?: SortOrder
    quoteId?: SortOrder
    approverId?: SortOrder
    approvalLevel?: SortOrder
    status?: SortOrder
    approvalDate?: SortOrderInput | SortOrder
    comments?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    quote?: QuoteOrderByWithRelationInput
    approver?: UserOrderByWithRelationInput
  }

  export type QuoteApprovalWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    quoteId_approvalLevel?: QuoteApprovalQuoteIdApprovalLevelCompoundUniqueInput
    AND?: QuoteApprovalWhereInput | QuoteApprovalWhereInput[]
    OR?: QuoteApprovalWhereInput[]
    NOT?: QuoteApprovalWhereInput | QuoteApprovalWhereInput[]
    quoteId?: IntFilter<"QuoteApproval"> | number
    approverId?: IntFilter<"QuoteApproval"> | number
    approvalLevel?: EnumApprovalLevelFilter<"QuoteApproval"> | $Enums.ApprovalLevel
    status?: EnumApprovalStatusFilter<"QuoteApproval"> | $Enums.ApprovalStatus
    approvalDate?: DateTimeNullableFilter<"QuoteApproval"> | Date | string | null
    comments?: StringNullableFilter<"QuoteApproval"> | string | null
    createdAt?: DateTimeFilter<"QuoteApproval"> | Date | string
    updatedAt?: DateTimeFilter<"QuoteApproval"> | Date | string
    quote?: XOR<QuoteRelationFilter, QuoteWhereInput>
    approver?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "quoteId_approvalLevel">

  export type QuoteApprovalOrderByWithAggregationInput = {
    id?: SortOrder
    quoteId?: SortOrder
    approverId?: SortOrder
    approvalLevel?: SortOrder
    status?: SortOrder
    approvalDate?: SortOrderInput | SortOrder
    comments?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QuoteApprovalCountOrderByAggregateInput
    _avg?: QuoteApprovalAvgOrderByAggregateInput
    _max?: QuoteApprovalMaxOrderByAggregateInput
    _min?: QuoteApprovalMinOrderByAggregateInput
    _sum?: QuoteApprovalSumOrderByAggregateInput
  }

  export type QuoteApprovalScalarWhereWithAggregatesInput = {
    AND?: QuoteApprovalScalarWhereWithAggregatesInput | QuoteApprovalScalarWhereWithAggregatesInput[]
    OR?: QuoteApprovalScalarWhereWithAggregatesInput[]
    NOT?: QuoteApprovalScalarWhereWithAggregatesInput | QuoteApprovalScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"QuoteApproval"> | number
    quoteId?: IntWithAggregatesFilter<"QuoteApproval"> | number
    approverId?: IntWithAggregatesFilter<"QuoteApproval"> | number
    approvalLevel?: EnumApprovalLevelWithAggregatesFilter<"QuoteApproval"> | $Enums.ApprovalLevel
    status?: EnumApprovalStatusWithAggregatesFilter<"QuoteApproval"> | $Enums.ApprovalStatus
    approvalDate?: DateTimeNullableWithAggregatesFilter<"QuoteApproval"> | Date | string | null
    comments?: StringNullableWithAggregatesFilter<"QuoteApproval"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"QuoteApproval"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"QuoteApproval"> | Date | string
  }

  export type InvoiceWhereInput = {
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    id?: IntFilter<"Invoice"> | number
    invoiceNumber?: StringFilter<"Invoice"> | string
    customerId?: IntFilter<"Invoice"> | number
    customerAddressId?: IntNullableFilter<"Invoice"> | number | null
    quoteId?: IntNullableFilter<"Invoice"> | number | null
    type?: EnumInvoiceTypeFilter<"Invoice"> | $Enums.InvoiceType
    status?: EnumInvoiceStatusFilter<"Invoice"> | $Enums.InvoiceStatus
    invoiceDate?: DateTimeFilter<"Invoice"> | Date | string
    dueDate?: DateTimeFilter<"Invoice"> | Date | string
    subtotalHt?: FloatFilter<"Invoice"> | number
    discountAmount?: FloatFilter<"Invoice"> | number
    totalVat?: FloatFilter<"Invoice"> | number
    totalTtc?: FloatFilter<"Invoice"> | number
    paidAmount?: FloatFilter<"Invoice"> | number
    balanceDue?: FloatFilter<"Invoice"> | number
    paymentTerms?: IntFilter<"Invoice"> | number
    lateFeeRate?: FloatFilter<"Invoice"> | number
    terms?: StringNullableFilter<"Invoice"> | string | null
    notes?: StringNullableFilter<"Invoice"> | string | null
    createdBy?: IntFilter<"Invoice"> | number
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    sentAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    customer?: XOR<CustomerRelationFilter, CustomerWhereInput>
    customerAddress?: XOR<CustomerAddressNullableRelationFilter, CustomerAddressWhereInput> | null
    quote?: XOR<QuoteNullableRelationFilter, QuoteWhereInput> | null
    creator?: XOR<UserRelationFilter, UserWhereInput>
    items?: InvoiceItemListRelationFilter
    paymentAllocations?: PaymentAllocationListRelationFilter
    reminders?: ReminderListRelationFilter
  }

  export type InvoiceOrderByWithRelationInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    customerId?: SortOrder
    customerAddressId?: SortOrderInput | SortOrder
    quoteId?: SortOrderInput | SortOrder
    type?: SortOrder
    status?: SortOrder
    invoiceDate?: SortOrder
    dueDate?: SortOrder
    subtotalHt?: SortOrder
    discountAmount?: SortOrder
    totalVat?: SortOrder
    totalTtc?: SortOrder
    paidAmount?: SortOrder
    balanceDue?: SortOrder
    paymentTerms?: SortOrder
    lateFeeRate?: SortOrder
    terms?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sentAt?: SortOrderInput | SortOrder
    customer?: CustomerOrderByWithRelationInput
    customerAddress?: CustomerAddressOrderByWithRelationInput
    quote?: QuoteOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
    items?: InvoiceItemOrderByRelationAggregateInput
    paymentAllocations?: PaymentAllocationOrderByRelationAggregateInput
    reminders?: ReminderOrderByRelationAggregateInput
  }

  export type InvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    invoiceNumber?: string
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    customerId?: IntFilter<"Invoice"> | number
    customerAddressId?: IntNullableFilter<"Invoice"> | number | null
    quoteId?: IntNullableFilter<"Invoice"> | number | null
    type?: EnumInvoiceTypeFilter<"Invoice"> | $Enums.InvoiceType
    status?: EnumInvoiceStatusFilter<"Invoice"> | $Enums.InvoiceStatus
    invoiceDate?: DateTimeFilter<"Invoice"> | Date | string
    dueDate?: DateTimeFilter<"Invoice"> | Date | string
    subtotalHt?: FloatFilter<"Invoice"> | number
    discountAmount?: FloatFilter<"Invoice"> | number
    totalVat?: FloatFilter<"Invoice"> | number
    totalTtc?: FloatFilter<"Invoice"> | number
    paidAmount?: FloatFilter<"Invoice"> | number
    balanceDue?: FloatFilter<"Invoice"> | number
    paymentTerms?: IntFilter<"Invoice"> | number
    lateFeeRate?: FloatFilter<"Invoice"> | number
    terms?: StringNullableFilter<"Invoice"> | string | null
    notes?: StringNullableFilter<"Invoice"> | string | null
    createdBy?: IntFilter<"Invoice"> | number
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    sentAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    customer?: XOR<CustomerRelationFilter, CustomerWhereInput>
    customerAddress?: XOR<CustomerAddressNullableRelationFilter, CustomerAddressWhereInput> | null
    quote?: XOR<QuoteNullableRelationFilter, QuoteWhereInput> | null
    creator?: XOR<UserRelationFilter, UserWhereInput>
    items?: InvoiceItemListRelationFilter
    paymentAllocations?: PaymentAllocationListRelationFilter
    reminders?: ReminderListRelationFilter
  }, "id" | "invoiceNumber">

  export type InvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    customerId?: SortOrder
    customerAddressId?: SortOrderInput | SortOrder
    quoteId?: SortOrderInput | SortOrder
    type?: SortOrder
    status?: SortOrder
    invoiceDate?: SortOrder
    dueDate?: SortOrder
    subtotalHt?: SortOrder
    discountAmount?: SortOrder
    totalVat?: SortOrder
    totalTtc?: SortOrder
    paidAmount?: SortOrder
    balanceDue?: SortOrder
    paymentTerms?: SortOrder
    lateFeeRate?: SortOrder
    terms?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sentAt?: SortOrderInput | SortOrder
    _count?: InvoiceCountOrderByAggregateInput
    _avg?: InvoiceAvgOrderByAggregateInput
    _max?: InvoiceMaxOrderByAggregateInput
    _min?: InvoiceMinOrderByAggregateInput
    _sum?: InvoiceSumOrderByAggregateInput
  }

  export type InvoiceScalarWhereWithAggregatesInput = {
    AND?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    OR?: InvoiceScalarWhereWithAggregatesInput[]
    NOT?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Invoice"> | number
    invoiceNumber?: StringWithAggregatesFilter<"Invoice"> | string
    customerId?: IntWithAggregatesFilter<"Invoice"> | number
    customerAddressId?: IntNullableWithAggregatesFilter<"Invoice"> | number | null
    quoteId?: IntNullableWithAggregatesFilter<"Invoice"> | number | null
    type?: EnumInvoiceTypeWithAggregatesFilter<"Invoice"> | $Enums.InvoiceType
    status?: EnumInvoiceStatusWithAggregatesFilter<"Invoice"> | $Enums.InvoiceStatus
    invoiceDate?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    dueDate?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    subtotalHt?: FloatWithAggregatesFilter<"Invoice"> | number
    discountAmount?: FloatWithAggregatesFilter<"Invoice"> | number
    totalVat?: FloatWithAggregatesFilter<"Invoice"> | number
    totalTtc?: FloatWithAggregatesFilter<"Invoice"> | number
    paidAmount?: FloatWithAggregatesFilter<"Invoice"> | number
    balanceDue?: FloatWithAggregatesFilter<"Invoice"> | number
    paymentTerms?: IntWithAggregatesFilter<"Invoice"> | number
    lateFeeRate?: FloatWithAggregatesFilter<"Invoice"> | number
    terms?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    createdBy?: IntWithAggregatesFilter<"Invoice"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    sentAt?: DateTimeNullableWithAggregatesFilter<"Invoice"> | Date | string | null
  }

  export type InvoiceItemWhereInput = {
    AND?: InvoiceItemWhereInput | InvoiceItemWhereInput[]
    OR?: InvoiceItemWhereInput[]
    NOT?: InvoiceItemWhereInput | InvoiceItemWhereInput[]
    id?: IntFilter<"InvoiceItem"> | number
    invoiceId?: IntFilter<"InvoiceItem"> | number
    productId?: IntNullableFilter<"InvoiceItem"> | number | null
    description?: StringFilter<"InvoiceItem"> | string
    quantity?: FloatFilter<"InvoiceItem"> | number
    unitPriceHt?: FloatFilter<"InvoiceItem"> | number
    discountRate?: FloatFilter<"InvoiceItem"> | number
    vatRate?: FloatFilter<"InvoiceItem"> | number
    totalHt?: FloatFilter<"InvoiceItem"> | number
    sortOrder?: IntFilter<"InvoiceItem"> | number
    invoice?: XOR<InvoiceRelationFilter, InvoiceWhereInput>
    product?: XOR<ProductNullableRelationFilter, ProductWhereInput> | null
  }

  export type InvoiceItemOrderByWithRelationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    productId?: SortOrderInput | SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPriceHt?: SortOrder
    discountRate?: SortOrder
    vatRate?: SortOrder
    totalHt?: SortOrder
    sortOrder?: SortOrder
    invoice?: InvoiceOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type InvoiceItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: InvoiceItemWhereInput | InvoiceItemWhereInput[]
    OR?: InvoiceItemWhereInput[]
    NOT?: InvoiceItemWhereInput | InvoiceItemWhereInput[]
    invoiceId?: IntFilter<"InvoiceItem"> | number
    productId?: IntNullableFilter<"InvoiceItem"> | number | null
    description?: StringFilter<"InvoiceItem"> | string
    quantity?: FloatFilter<"InvoiceItem"> | number
    unitPriceHt?: FloatFilter<"InvoiceItem"> | number
    discountRate?: FloatFilter<"InvoiceItem"> | number
    vatRate?: FloatFilter<"InvoiceItem"> | number
    totalHt?: FloatFilter<"InvoiceItem"> | number
    sortOrder?: IntFilter<"InvoiceItem"> | number
    invoice?: XOR<InvoiceRelationFilter, InvoiceWhereInput>
    product?: XOR<ProductNullableRelationFilter, ProductWhereInput> | null
  }, "id">

  export type InvoiceItemOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    productId?: SortOrderInput | SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPriceHt?: SortOrder
    discountRate?: SortOrder
    vatRate?: SortOrder
    totalHt?: SortOrder
    sortOrder?: SortOrder
    _count?: InvoiceItemCountOrderByAggregateInput
    _avg?: InvoiceItemAvgOrderByAggregateInput
    _max?: InvoiceItemMaxOrderByAggregateInput
    _min?: InvoiceItemMinOrderByAggregateInput
    _sum?: InvoiceItemSumOrderByAggregateInput
  }

  export type InvoiceItemScalarWhereWithAggregatesInput = {
    AND?: InvoiceItemScalarWhereWithAggregatesInput | InvoiceItemScalarWhereWithAggregatesInput[]
    OR?: InvoiceItemScalarWhereWithAggregatesInput[]
    NOT?: InvoiceItemScalarWhereWithAggregatesInput | InvoiceItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"InvoiceItem"> | number
    invoiceId?: IntWithAggregatesFilter<"InvoiceItem"> | number
    productId?: IntNullableWithAggregatesFilter<"InvoiceItem"> | number | null
    description?: StringWithAggregatesFilter<"InvoiceItem"> | string
    quantity?: FloatWithAggregatesFilter<"InvoiceItem"> | number
    unitPriceHt?: FloatWithAggregatesFilter<"InvoiceItem"> | number
    discountRate?: FloatWithAggregatesFilter<"InvoiceItem"> | number
    vatRate?: FloatWithAggregatesFilter<"InvoiceItem"> | number
    totalHt?: FloatWithAggregatesFilter<"InvoiceItem"> | number
    sortOrder?: IntWithAggregatesFilter<"InvoiceItem"> | number
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: IntFilter<"Payment"> | number
    paymentNumber?: StringFilter<"Payment"> | string
    customerId?: IntFilter<"Payment"> | number
    amount?: FloatFilter<"Payment"> | number
    paymentDate?: DateTimeFilter<"Payment"> | Date | string
    paymentMethod?: EnumPaymentMethodFilter<"Payment"> | $Enums.PaymentMethod
    reference?: StringNullableFilter<"Payment"> | string | null
    notes?: StringNullableFilter<"Payment"> | string | null
    createdBy?: IntFilter<"Payment"> | number
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    customer?: XOR<CustomerRelationFilter, CustomerWhereInput>
    creator?: XOR<UserRelationFilter, UserWhereInput>
    allocations?: PaymentAllocationListRelationFilter
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    paymentNumber?: SortOrder
    customerId?: SortOrder
    amount?: SortOrder
    paymentDate?: SortOrder
    paymentMethod?: SortOrder
    reference?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    customer?: CustomerOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
    allocations?: PaymentAllocationOrderByRelationAggregateInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    paymentNumber?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    customerId?: IntFilter<"Payment"> | number
    amount?: FloatFilter<"Payment"> | number
    paymentDate?: DateTimeFilter<"Payment"> | Date | string
    paymentMethod?: EnumPaymentMethodFilter<"Payment"> | $Enums.PaymentMethod
    reference?: StringNullableFilter<"Payment"> | string | null
    notes?: StringNullableFilter<"Payment"> | string | null
    createdBy?: IntFilter<"Payment"> | number
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    customer?: XOR<CustomerRelationFilter, CustomerWhereInput>
    creator?: XOR<UserRelationFilter, UserWhereInput>
    allocations?: PaymentAllocationListRelationFilter
  }, "id" | "paymentNumber">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    paymentNumber?: SortOrder
    customerId?: SortOrder
    amount?: SortOrder
    paymentDate?: SortOrder
    paymentMethod?: SortOrder
    reference?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Payment"> | number
    paymentNumber?: StringWithAggregatesFilter<"Payment"> | string
    customerId?: IntWithAggregatesFilter<"Payment"> | number
    amount?: FloatWithAggregatesFilter<"Payment"> | number
    paymentDate?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    paymentMethod?: EnumPaymentMethodWithAggregatesFilter<"Payment"> | $Enums.PaymentMethod
    reference?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    createdBy?: IntWithAggregatesFilter<"Payment"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
  }

  export type PaymentAllocationWhereInput = {
    AND?: PaymentAllocationWhereInput | PaymentAllocationWhereInput[]
    OR?: PaymentAllocationWhereInput[]
    NOT?: PaymentAllocationWhereInput | PaymentAllocationWhereInput[]
    id?: IntFilter<"PaymentAllocation"> | number
    paymentId?: IntFilter<"PaymentAllocation"> | number
    invoiceId?: IntFilter<"PaymentAllocation"> | number
    amount?: FloatFilter<"PaymentAllocation"> | number
    createdAt?: DateTimeFilter<"PaymentAllocation"> | Date | string
    payment?: XOR<PaymentRelationFilter, PaymentWhereInput>
    invoice?: XOR<InvoiceRelationFilter, InvoiceWhereInput>
  }

  export type PaymentAllocationOrderByWithRelationInput = {
    id?: SortOrder
    paymentId?: SortOrder
    invoiceId?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    payment?: PaymentOrderByWithRelationInput
    invoice?: InvoiceOrderByWithRelationInput
  }

  export type PaymentAllocationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PaymentAllocationWhereInput | PaymentAllocationWhereInput[]
    OR?: PaymentAllocationWhereInput[]
    NOT?: PaymentAllocationWhereInput | PaymentAllocationWhereInput[]
    paymentId?: IntFilter<"PaymentAllocation"> | number
    invoiceId?: IntFilter<"PaymentAllocation"> | number
    amount?: FloatFilter<"PaymentAllocation"> | number
    createdAt?: DateTimeFilter<"PaymentAllocation"> | Date | string
    payment?: XOR<PaymentRelationFilter, PaymentWhereInput>
    invoice?: XOR<InvoiceRelationFilter, InvoiceWhereInput>
  }, "id">

  export type PaymentAllocationOrderByWithAggregationInput = {
    id?: SortOrder
    paymentId?: SortOrder
    invoiceId?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    _count?: PaymentAllocationCountOrderByAggregateInput
    _avg?: PaymentAllocationAvgOrderByAggregateInput
    _max?: PaymentAllocationMaxOrderByAggregateInput
    _min?: PaymentAllocationMinOrderByAggregateInput
    _sum?: PaymentAllocationSumOrderByAggregateInput
  }

  export type PaymentAllocationScalarWhereWithAggregatesInput = {
    AND?: PaymentAllocationScalarWhereWithAggregatesInput | PaymentAllocationScalarWhereWithAggregatesInput[]
    OR?: PaymentAllocationScalarWhereWithAggregatesInput[]
    NOT?: PaymentAllocationScalarWhereWithAggregatesInput | PaymentAllocationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PaymentAllocation"> | number
    paymentId?: IntWithAggregatesFilter<"PaymentAllocation"> | number
    invoiceId?: IntWithAggregatesFilter<"PaymentAllocation"> | number
    amount?: FloatWithAggregatesFilter<"PaymentAllocation"> | number
    createdAt?: DateTimeWithAggregatesFilter<"PaymentAllocation"> | Date | string
  }

  export type RecurringInvoiceWhereInput = {
    AND?: RecurringInvoiceWhereInput | RecurringInvoiceWhereInput[]
    OR?: RecurringInvoiceWhereInput[]
    NOT?: RecurringInvoiceWhereInput | RecurringInvoiceWhereInput[]
    id?: IntFilter<"RecurringInvoice"> | number
    customerId?: IntFilter<"RecurringInvoice"> | number
    templateName?: StringFilter<"RecurringInvoice"> | string
    frequency?: EnumRecurringFrequencyFilter<"RecurringInvoice"> | $Enums.RecurringFrequency
    startDate?: DateTimeFilter<"RecurringInvoice"> | Date | string
    endDate?: DateTimeNullableFilter<"RecurringInvoice"> | Date | string | null
    nextInvoiceDate?: DateTimeFilter<"RecurringInvoice"> | Date | string
    isActive?: BoolFilter<"RecurringInvoice"> | boolean
    subtotalHt?: FloatFilter<"RecurringInvoice"> | number
    totalVat?: FloatFilter<"RecurringInvoice"> | number
    totalTtc?: FloatFilter<"RecurringInvoice"> | number
    terms?: StringNullableFilter<"RecurringInvoice"> | string | null
    notes?: StringNullableFilter<"RecurringInvoice"> | string | null
    createdBy?: IntFilter<"RecurringInvoice"> | number
    createdAt?: DateTimeFilter<"RecurringInvoice"> | Date | string
    updatedAt?: DateTimeFilter<"RecurringInvoice"> | Date | string
    customer?: XOR<CustomerRelationFilter, CustomerWhereInput>
    creator?: XOR<UserRelationFilter, UserWhereInput>
    items?: RecurringInvoiceItemListRelationFilter
  }

  export type RecurringInvoiceOrderByWithRelationInput = {
    id?: SortOrder
    customerId?: SortOrder
    templateName?: SortOrder
    frequency?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    nextInvoiceDate?: SortOrder
    isActive?: SortOrder
    subtotalHt?: SortOrder
    totalVat?: SortOrder
    totalTtc?: SortOrder
    terms?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customer?: CustomerOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
    items?: RecurringInvoiceItemOrderByRelationAggregateInput
  }

  export type RecurringInvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RecurringInvoiceWhereInput | RecurringInvoiceWhereInput[]
    OR?: RecurringInvoiceWhereInput[]
    NOT?: RecurringInvoiceWhereInput | RecurringInvoiceWhereInput[]
    customerId?: IntFilter<"RecurringInvoice"> | number
    templateName?: StringFilter<"RecurringInvoice"> | string
    frequency?: EnumRecurringFrequencyFilter<"RecurringInvoice"> | $Enums.RecurringFrequency
    startDate?: DateTimeFilter<"RecurringInvoice"> | Date | string
    endDate?: DateTimeNullableFilter<"RecurringInvoice"> | Date | string | null
    nextInvoiceDate?: DateTimeFilter<"RecurringInvoice"> | Date | string
    isActive?: BoolFilter<"RecurringInvoice"> | boolean
    subtotalHt?: FloatFilter<"RecurringInvoice"> | number
    totalVat?: FloatFilter<"RecurringInvoice"> | number
    totalTtc?: FloatFilter<"RecurringInvoice"> | number
    terms?: StringNullableFilter<"RecurringInvoice"> | string | null
    notes?: StringNullableFilter<"RecurringInvoice"> | string | null
    createdBy?: IntFilter<"RecurringInvoice"> | number
    createdAt?: DateTimeFilter<"RecurringInvoice"> | Date | string
    updatedAt?: DateTimeFilter<"RecurringInvoice"> | Date | string
    customer?: XOR<CustomerRelationFilter, CustomerWhereInput>
    creator?: XOR<UserRelationFilter, UserWhereInput>
    items?: RecurringInvoiceItemListRelationFilter
  }, "id">

  export type RecurringInvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    customerId?: SortOrder
    templateName?: SortOrder
    frequency?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    nextInvoiceDate?: SortOrder
    isActive?: SortOrder
    subtotalHt?: SortOrder
    totalVat?: SortOrder
    totalTtc?: SortOrder
    terms?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RecurringInvoiceCountOrderByAggregateInput
    _avg?: RecurringInvoiceAvgOrderByAggregateInput
    _max?: RecurringInvoiceMaxOrderByAggregateInput
    _min?: RecurringInvoiceMinOrderByAggregateInput
    _sum?: RecurringInvoiceSumOrderByAggregateInput
  }

  export type RecurringInvoiceScalarWhereWithAggregatesInput = {
    AND?: RecurringInvoiceScalarWhereWithAggregatesInput | RecurringInvoiceScalarWhereWithAggregatesInput[]
    OR?: RecurringInvoiceScalarWhereWithAggregatesInput[]
    NOT?: RecurringInvoiceScalarWhereWithAggregatesInput | RecurringInvoiceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RecurringInvoice"> | number
    customerId?: IntWithAggregatesFilter<"RecurringInvoice"> | number
    templateName?: StringWithAggregatesFilter<"RecurringInvoice"> | string
    frequency?: EnumRecurringFrequencyWithAggregatesFilter<"RecurringInvoice"> | $Enums.RecurringFrequency
    startDate?: DateTimeWithAggregatesFilter<"RecurringInvoice"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"RecurringInvoice"> | Date | string | null
    nextInvoiceDate?: DateTimeWithAggregatesFilter<"RecurringInvoice"> | Date | string
    isActive?: BoolWithAggregatesFilter<"RecurringInvoice"> | boolean
    subtotalHt?: FloatWithAggregatesFilter<"RecurringInvoice"> | number
    totalVat?: FloatWithAggregatesFilter<"RecurringInvoice"> | number
    totalTtc?: FloatWithAggregatesFilter<"RecurringInvoice"> | number
    terms?: StringNullableWithAggregatesFilter<"RecurringInvoice"> | string | null
    notes?: StringNullableWithAggregatesFilter<"RecurringInvoice"> | string | null
    createdBy?: IntWithAggregatesFilter<"RecurringInvoice"> | number
    createdAt?: DateTimeWithAggregatesFilter<"RecurringInvoice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RecurringInvoice"> | Date | string
  }

  export type RecurringInvoiceItemWhereInput = {
    AND?: RecurringInvoiceItemWhereInput | RecurringInvoiceItemWhereInput[]
    OR?: RecurringInvoiceItemWhereInput[]
    NOT?: RecurringInvoiceItemWhereInput | RecurringInvoiceItemWhereInput[]
    id?: IntFilter<"RecurringInvoiceItem"> | number
    recurringInvoiceId?: IntFilter<"RecurringInvoiceItem"> | number
    productId?: IntNullableFilter<"RecurringInvoiceItem"> | number | null
    description?: StringFilter<"RecurringInvoiceItem"> | string
    quantity?: FloatFilter<"RecurringInvoiceItem"> | number
    unitPriceHt?: FloatFilter<"RecurringInvoiceItem"> | number
    vatRate?: FloatFilter<"RecurringInvoiceItem"> | number
    totalHt?: FloatFilter<"RecurringInvoiceItem"> | number
    sortOrder?: IntFilter<"RecurringInvoiceItem"> | number
    recurringInvoice?: XOR<RecurringInvoiceRelationFilter, RecurringInvoiceWhereInput>
    product?: XOR<ProductNullableRelationFilter, ProductWhereInput> | null
  }

  export type RecurringInvoiceItemOrderByWithRelationInput = {
    id?: SortOrder
    recurringInvoiceId?: SortOrder
    productId?: SortOrderInput | SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPriceHt?: SortOrder
    vatRate?: SortOrder
    totalHt?: SortOrder
    sortOrder?: SortOrder
    recurringInvoice?: RecurringInvoiceOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type RecurringInvoiceItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RecurringInvoiceItemWhereInput | RecurringInvoiceItemWhereInput[]
    OR?: RecurringInvoiceItemWhereInput[]
    NOT?: RecurringInvoiceItemWhereInput | RecurringInvoiceItemWhereInput[]
    recurringInvoiceId?: IntFilter<"RecurringInvoiceItem"> | number
    productId?: IntNullableFilter<"RecurringInvoiceItem"> | number | null
    description?: StringFilter<"RecurringInvoiceItem"> | string
    quantity?: FloatFilter<"RecurringInvoiceItem"> | number
    unitPriceHt?: FloatFilter<"RecurringInvoiceItem"> | number
    vatRate?: FloatFilter<"RecurringInvoiceItem"> | number
    totalHt?: FloatFilter<"RecurringInvoiceItem"> | number
    sortOrder?: IntFilter<"RecurringInvoiceItem"> | number
    recurringInvoice?: XOR<RecurringInvoiceRelationFilter, RecurringInvoiceWhereInput>
    product?: XOR<ProductNullableRelationFilter, ProductWhereInput> | null
  }, "id">

  export type RecurringInvoiceItemOrderByWithAggregationInput = {
    id?: SortOrder
    recurringInvoiceId?: SortOrder
    productId?: SortOrderInput | SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPriceHt?: SortOrder
    vatRate?: SortOrder
    totalHt?: SortOrder
    sortOrder?: SortOrder
    _count?: RecurringInvoiceItemCountOrderByAggregateInput
    _avg?: RecurringInvoiceItemAvgOrderByAggregateInput
    _max?: RecurringInvoiceItemMaxOrderByAggregateInput
    _min?: RecurringInvoiceItemMinOrderByAggregateInput
    _sum?: RecurringInvoiceItemSumOrderByAggregateInput
  }

  export type RecurringInvoiceItemScalarWhereWithAggregatesInput = {
    AND?: RecurringInvoiceItemScalarWhereWithAggregatesInput | RecurringInvoiceItemScalarWhereWithAggregatesInput[]
    OR?: RecurringInvoiceItemScalarWhereWithAggregatesInput[]
    NOT?: RecurringInvoiceItemScalarWhereWithAggregatesInput | RecurringInvoiceItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RecurringInvoiceItem"> | number
    recurringInvoiceId?: IntWithAggregatesFilter<"RecurringInvoiceItem"> | number
    productId?: IntNullableWithAggregatesFilter<"RecurringInvoiceItem"> | number | null
    description?: StringWithAggregatesFilter<"RecurringInvoiceItem"> | string
    quantity?: FloatWithAggregatesFilter<"RecurringInvoiceItem"> | number
    unitPriceHt?: FloatWithAggregatesFilter<"RecurringInvoiceItem"> | number
    vatRate?: FloatWithAggregatesFilter<"RecurringInvoiceItem"> | number
    totalHt?: FloatWithAggregatesFilter<"RecurringInvoiceItem"> | number
    sortOrder?: IntWithAggregatesFilter<"RecurringInvoiceItem"> | number
  }

  export type ReminderWhereInput = {
    AND?: ReminderWhereInput | ReminderWhereInput[]
    OR?: ReminderWhereInput[]
    NOT?: ReminderWhereInput | ReminderWhereInput[]
    id?: IntFilter<"Reminder"> | number
    invoiceId?: IntFilter<"Reminder"> | number
    type?: EnumReminderTypeFilter<"Reminder"> | $Enums.ReminderType
    sentDate?: DateTimeFilter<"Reminder"> | Date | string
    dueDate?: DateTimeNullableFilter<"Reminder"> | Date | string | null
    amountDue?: FloatFilter<"Reminder"> | number
    lateFees?: FloatFilter<"Reminder"> | number
    status?: EnumReminderStatusFilter<"Reminder"> | $Enums.ReminderStatus
    emailSubject?: StringNullableFilter<"Reminder"> | string | null
    emailBody?: StringNullableFilter<"Reminder"> | string | null
    createdBy?: IntFilter<"Reminder"> | number
    createdAt?: DateTimeFilter<"Reminder"> | Date | string
    invoice?: XOR<InvoiceRelationFilter, InvoiceWhereInput>
    creator?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ReminderOrderByWithRelationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    type?: SortOrder
    sentDate?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    amountDue?: SortOrder
    lateFees?: SortOrder
    status?: SortOrder
    emailSubject?: SortOrderInput | SortOrder
    emailBody?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    invoice?: InvoiceOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
  }

  export type ReminderWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ReminderWhereInput | ReminderWhereInput[]
    OR?: ReminderWhereInput[]
    NOT?: ReminderWhereInput | ReminderWhereInput[]
    invoiceId?: IntFilter<"Reminder"> | number
    type?: EnumReminderTypeFilter<"Reminder"> | $Enums.ReminderType
    sentDate?: DateTimeFilter<"Reminder"> | Date | string
    dueDate?: DateTimeNullableFilter<"Reminder"> | Date | string | null
    amountDue?: FloatFilter<"Reminder"> | number
    lateFees?: FloatFilter<"Reminder"> | number
    status?: EnumReminderStatusFilter<"Reminder"> | $Enums.ReminderStatus
    emailSubject?: StringNullableFilter<"Reminder"> | string | null
    emailBody?: StringNullableFilter<"Reminder"> | string | null
    createdBy?: IntFilter<"Reminder"> | number
    createdAt?: DateTimeFilter<"Reminder"> | Date | string
    invoice?: XOR<InvoiceRelationFilter, InvoiceWhereInput>
    creator?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type ReminderOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    type?: SortOrder
    sentDate?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    amountDue?: SortOrder
    lateFees?: SortOrder
    status?: SortOrder
    emailSubject?: SortOrderInput | SortOrder
    emailBody?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    _count?: ReminderCountOrderByAggregateInput
    _avg?: ReminderAvgOrderByAggregateInput
    _max?: ReminderMaxOrderByAggregateInput
    _min?: ReminderMinOrderByAggregateInput
    _sum?: ReminderSumOrderByAggregateInput
  }

  export type ReminderScalarWhereWithAggregatesInput = {
    AND?: ReminderScalarWhereWithAggregatesInput | ReminderScalarWhereWithAggregatesInput[]
    OR?: ReminderScalarWhereWithAggregatesInput[]
    NOT?: ReminderScalarWhereWithAggregatesInput | ReminderScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Reminder"> | number
    invoiceId?: IntWithAggregatesFilter<"Reminder"> | number
    type?: EnumReminderTypeWithAggregatesFilter<"Reminder"> | $Enums.ReminderType
    sentDate?: DateTimeWithAggregatesFilter<"Reminder"> | Date | string
    dueDate?: DateTimeNullableWithAggregatesFilter<"Reminder"> | Date | string | null
    amountDue?: FloatWithAggregatesFilter<"Reminder"> | number
    lateFees?: FloatWithAggregatesFilter<"Reminder"> | number
    status?: EnumReminderStatusWithAggregatesFilter<"Reminder"> | $Enums.ReminderStatus
    emailSubject?: StringNullableWithAggregatesFilter<"Reminder"> | string | null
    emailBody?: StringNullableWithAggregatesFilter<"Reminder"> | string | null
    createdBy?: IntWithAggregatesFilter<"Reminder"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Reminder"> | Date | string
  }

  export type DocumentWhereInput = {
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    id?: IntFilter<"Document"> | number
    type?: EnumDocumentTypeFilter<"Document"> | $Enums.DocumentType
    referenceId?: IntFilter<"Document"> | number
    filename?: StringFilter<"Document"> | string
    filePath?: StringFilter<"Document"> | string
    fileSize?: IntNullableFilter<"Document"> | number | null
    mimeType?: StringNullableFilter<"Document"> | string | null
    generatedAt?: DateTimeFilter<"Document"> | Date | string
  }

  export type DocumentOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    referenceId?: SortOrder
    filename?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrderInput | SortOrder
    mimeType?: SortOrderInput | SortOrder
    generatedAt?: SortOrder
  }

  export type DocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    type?: EnumDocumentTypeFilter<"Document"> | $Enums.DocumentType
    referenceId?: IntFilter<"Document"> | number
    filename?: StringFilter<"Document"> | string
    filePath?: StringFilter<"Document"> | string
    fileSize?: IntNullableFilter<"Document"> | number | null
    mimeType?: StringNullableFilter<"Document"> | string | null
    generatedAt?: DateTimeFilter<"Document"> | Date | string
  }, "id">

  export type DocumentOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    referenceId?: SortOrder
    filename?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrderInput | SortOrder
    mimeType?: SortOrderInput | SortOrder
    generatedAt?: SortOrder
    _count?: DocumentCountOrderByAggregateInput
    _avg?: DocumentAvgOrderByAggregateInput
    _max?: DocumentMaxOrderByAggregateInput
    _min?: DocumentMinOrderByAggregateInput
    _sum?: DocumentSumOrderByAggregateInput
  }

  export type DocumentScalarWhereWithAggregatesInput = {
    AND?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    OR?: DocumentScalarWhereWithAggregatesInput[]
    NOT?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Document"> | number
    type?: EnumDocumentTypeWithAggregatesFilter<"Document"> | $Enums.DocumentType
    referenceId?: IntWithAggregatesFilter<"Document"> | number
    filename?: StringWithAggregatesFilter<"Document"> | string
    filePath?: StringWithAggregatesFilter<"Document"> | string
    fileSize?: IntNullableWithAggregatesFilter<"Document"> | number | null
    mimeType?: StringNullableWithAggregatesFilter<"Document"> | string | null
    generatedAt?: DateTimeWithAggregatesFilter<"Document"> | Date | string
  }

  export type ExpenseWhereInput = {
    AND?: ExpenseWhereInput | ExpenseWhereInput[]
    OR?: ExpenseWhereInput[]
    NOT?: ExpenseWhereInput | ExpenseWhereInput[]
    id?: IntFilter<"Expense"> | number
    expenseNumber?: StringFilter<"Expense"> | string
    supplierId?: IntNullableFilter<"Expense"> | number | null
    category?: StringFilter<"Expense"> | string
    description?: StringNullableFilter<"Expense"> | string | null
    amountHt?: FloatFilter<"Expense"> | number
    vatAmount?: FloatFilter<"Expense"> | number
    totalTtc?: FloatFilter<"Expense"> | number
    expenseDate?: DateTimeFilter<"Expense"> | Date | string
    paymentDate?: DateTimeNullableFilter<"Expense"> | Date | string | null
    paymentMethod?: EnumPaymentMethodFilter<"Expense"> | $Enums.PaymentMethod
    status?: EnumExpenseStatusFilter<"Expense"> | $Enums.ExpenseStatus
    receiptUrl?: StringNullableFilter<"Expense"> | string | null
    notes?: StringNullableFilter<"Expense"> | string | null
    createdBy?: IntFilter<"Expense"> | number
    createdAt?: DateTimeFilter<"Expense"> | Date | string
    updatedAt?: DateTimeFilter<"Expense"> | Date | string
    supplier?: XOR<SupplierNullableRelationFilter, SupplierWhereInput> | null
    creator?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ExpenseOrderByWithRelationInput = {
    id?: SortOrder
    expenseNumber?: SortOrder
    supplierId?: SortOrderInput | SortOrder
    category?: SortOrder
    description?: SortOrderInput | SortOrder
    amountHt?: SortOrder
    vatAmount?: SortOrder
    totalTtc?: SortOrder
    expenseDate?: SortOrder
    paymentDate?: SortOrderInput | SortOrder
    paymentMethod?: SortOrder
    status?: SortOrder
    receiptUrl?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    supplier?: SupplierOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
  }

  export type ExpenseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    expenseNumber?: string
    AND?: ExpenseWhereInput | ExpenseWhereInput[]
    OR?: ExpenseWhereInput[]
    NOT?: ExpenseWhereInput | ExpenseWhereInput[]
    supplierId?: IntNullableFilter<"Expense"> | number | null
    category?: StringFilter<"Expense"> | string
    description?: StringNullableFilter<"Expense"> | string | null
    amountHt?: FloatFilter<"Expense"> | number
    vatAmount?: FloatFilter<"Expense"> | number
    totalTtc?: FloatFilter<"Expense"> | number
    expenseDate?: DateTimeFilter<"Expense"> | Date | string
    paymentDate?: DateTimeNullableFilter<"Expense"> | Date | string | null
    paymentMethod?: EnumPaymentMethodFilter<"Expense"> | $Enums.PaymentMethod
    status?: EnumExpenseStatusFilter<"Expense"> | $Enums.ExpenseStatus
    receiptUrl?: StringNullableFilter<"Expense"> | string | null
    notes?: StringNullableFilter<"Expense"> | string | null
    createdBy?: IntFilter<"Expense"> | number
    createdAt?: DateTimeFilter<"Expense"> | Date | string
    updatedAt?: DateTimeFilter<"Expense"> | Date | string
    supplier?: XOR<SupplierNullableRelationFilter, SupplierWhereInput> | null
    creator?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "expenseNumber">

  export type ExpenseOrderByWithAggregationInput = {
    id?: SortOrder
    expenseNumber?: SortOrder
    supplierId?: SortOrderInput | SortOrder
    category?: SortOrder
    description?: SortOrderInput | SortOrder
    amountHt?: SortOrder
    vatAmount?: SortOrder
    totalTtc?: SortOrder
    expenseDate?: SortOrder
    paymentDate?: SortOrderInput | SortOrder
    paymentMethod?: SortOrder
    status?: SortOrder
    receiptUrl?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ExpenseCountOrderByAggregateInput
    _avg?: ExpenseAvgOrderByAggregateInput
    _max?: ExpenseMaxOrderByAggregateInput
    _min?: ExpenseMinOrderByAggregateInput
    _sum?: ExpenseSumOrderByAggregateInput
  }

  export type ExpenseScalarWhereWithAggregatesInput = {
    AND?: ExpenseScalarWhereWithAggregatesInput | ExpenseScalarWhereWithAggregatesInput[]
    OR?: ExpenseScalarWhereWithAggregatesInput[]
    NOT?: ExpenseScalarWhereWithAggregatesInput | ExpenseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Expense"> | number
    expenseNumber?: StringWithAggregatesFilter<"Expense"> | string
    supplierId?: IntNullableWithAggregatesFilter<"Expense"> | number | null
    category?: StringWithAggregatesFilter<"Expense"> | string
    description?: StringNullableWithAggregatesFilter<"Expense"> | string | null
    amountHt?: FloatWithAggregatesFilter<"Expense"> | number
    vatAmount?: FloatWithAggregatesFilter<"Expense"> | number
    totalTtc?: FloatWithAggregatesFilter<"Expense"> | number
    expenseDate?: DateTimeWithAggregatesFilter<"Expense"> | Date | string
    paymentDate?: DateTimeNullableWithAggregatesFilter<"Expense"> | Date | string | null
    paymentMethod?: EnumPaymentMethodWithAggregatesFilter<"Expense"> | $Enums.PaymentMethod
    status?: EnumExpenseStatusWithAggregatesFilter<"Expense"> | $Enums.ExpenseStatus
    receiptUrl?: StringNullableWithAggregatesFilter<"Expense"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Expense"> | string | null
    createdBy?: IntWithAggregatesFilter<"Expense"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Expense"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Expense"> | Date | string
  }

  export type SupplierWhereInput = {
    AND?: SupplierWhereInput | SupplierWhereInput[]
    OR?: SupplierWhereInput[]
    NOT?: SupplierWhereInput | SupplierWhereInput[]
    id?: IntFilter<"Supplier"> | number
    name?: StringFilter<"Supplier"> | string
    contactPerson?: StringNullableFilter<"Supplier"> | string | null
    email?: StringNullableFilter<"Supplier"> | string | null
    phone?: StringNullableFilter<"Supplier"> | string | null
    addressLine1?: StringNullableFilter<"Supplier"> | string | null
    city?: StringNullableFilter<"Supplier"> | string | null
    postalCode?: StringNullableFilter<"Supplier"> | string | null
    country?: StringNullableFilter<"Supplier"> | string | null
    vatNumber?: StringNullableFilter<"Supplier"> | string | null
    bankName?: StringNullableFilter<"Supplier"> | string | null
    bankIban?: StringNullableFilter<"Supplier"> | string | null
    bankBic?: StringNullableFilter<"Supplier"> | string | null
    paymentTerms?: IntFilter<"Supplier"> | number
    notes?: StringNullableFilter<"Supplier"> | string | null
    createdAt?: DateTimeFilter<"Supplier"> | Date | string
    updatedAt?: DateTimeFilter<"Supplier"> | Date | string
    expenses?: ExpenseListRelationFilter
  }

  export type SupplierOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    contactPerson?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    addressLine1?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    postalCode?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    vatNumber?: SortOrderInput | SortOrder
    bankName?: SortOrderInput | SortOrder
    bankIban?: SortOrderInput | SortOrder
    bankBic?: SortOrderInput | SortOrder
    paymentTerms?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expenses?: ExpenseOrderByRelationAggregateInput
  }

  export type SupplierWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SupplierWhereInput | SupplierWhereInput[]
    OR?: SupplierWhereInput[]
    NOT?: SupplierWhereInput | SupplierWhereInput[]
    name?: StringFilter<"Supplier"> | string
    contactPerson?: StringNullableFilter<"Supplier"> | string | null
    email?: StringNullableFilter<"Supplier"> | string | null
    phone?: StringNullableFilter<"Supplier"> | string | null
    addressLine1?: StringNullableFilter<"Supplier"> | string | null
    city?: StringNullableFilter<"Supplier"> | string | null
    postalCode?: StringNullableFilter<"Supplier"> | string | null
    country?: StringNullableFilter<"Supplier"> | string | null
    vatNumber?: StringNullableFilter<"Supplier"> | string | null
    bankName?: StringNullableFilter<"Supplier"> | string | null
    bankIban?: StringNullableFilter<"Supplier"> | string | null
    bankBic?: StringNullableFilter<"Supplier"> | string | null
    paymentTerms?: IntFilter<"Supplier"> | number
    notes?: StringNullableFilter<"Supplier"> | string | null
    createdAt?: DateTimeFilter<"Supplier"> | Date | string
    updatedAt?: DateTimeFilter<"Supplier"> | Date | string
    expenses?: ExpenseListRelationFilter
  }, "id">

  export type SupplierOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    contactPerson?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    addressLine1?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    postalCode?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    vatNumber?: SortOrderInput | SortOrder
    bankName?: SortOrderInput | SortOrder
    bankIban?: SortOrderInput | SortOrder
    bankBic?: SortOrderInput | SortOrder
    paymentTerms?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SupplierCountOrderByAggregateInput
    _avg?: SupplierAvgOrderByAggregateInput
    _max?: SupplierMaxOrderByAggregateInput
    _min?: SupplierMinOrderByAggregateInput
    _sum?: SupplierSumOrderByAggregateInput
  }

  export type SupplierScalarWhereWithAggregatesInput = {
    AND?: SupplierScalarWhereWithAggregatesInput | SupplierScalarWhereWithAggregatesInput[]
    OR?: SupplierScalarWhereWithAggregatesInput[]
    NOT?: SupplierScalarWhereWithAggregatesInput | SupplierScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Supplier"> | number
    name?: StringWithAggregatesFilter<"Supplier"> | string
    contactPerson?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    email?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    addressLine1?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    city?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    postalCode?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    country?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    vatNumber?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    bankName?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    bankIban?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    bankBic?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    paymentTerms?: IntWithAggregatesFilter<"Supplier"> | number
    notes?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Supplier"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Supplier"> | Date | string
  }

  export type AccountingEntryWhereInput = {
    AND?: AccountingEntryWhereInput | AccountingEntryWhereInput[]
    OR?: AccountingEntryWhereInput[]
    NOT?: AccountingEntryWhereInput | AccountingEntryWhereInput[]
    id?: IntFilter<"AccountingEntry"> | number
    entryDate?: DateTimeFilter<"AccountingEntry"> | Date | string
    accountNumber?: StringFilter<"AccountingEntry"> | string
    debit?: FloatFilter<"AccountingEntry"> | number
    credit?: FloatFilter<"AccountingEntry"> | number
    description?: StringNullableFilter<"AccountingEntry"> | string | null
    sourceDocumentType?: EnumSourceDocumentTypeFilter<"AccountingEntry"> | $Enums.SourceDocumentType
    sourceDocumentId?: IntFilter<"AccountingEntry"> | number
    createdBy?: IntFilter<"AccountingEntry"> | number
    createdAt?: DateTimeFilter<"AccountingEntry"> | Date | string
    creator?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type AccountingEntryOrderByWithRelationInput = {
    id?: SortOrder
    entryDate?: SortOrder
    accountNumber?: SortOrder
    debit?: SortOrder
    credit?: SortOrder
    description?: SortOrderInput | SortOrder
    sourceDocumentType?: SortOrder
    sourceDocumentId?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    creator?: UserOrderByWithRelationInput
  }

  export type AccountingEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AccountingEntryWhereInput | AccountingEntryWhereInput[]
    OR?: AccountingEntryWhereInput[]
    NOT?: AccountingEntryWhereInput | AccountingEntryWhereInput[]
    entryDate?: DateTimeFilter<"AccountingEntry"> | Date | string
    accountNumber?: StringFilter<"AccountingEntry"> | string
    debit?: FloatFilter<"AccountingEntry"> | number
    credit?: FloatFilter<"AccountingEntry"> | number
    description?: StringNullableFilter<"AccountingEntry"> | string | null
    sourceDocumentType?: EnumSourceDocumentTypeFilter<"AccountingEntry"> | $Enums.SourceDocumentType
    sourceDocumentId?: IntFilter<"AccountingEntry"> | number
    createdBy?: IntFilter<"AccountingEntry"> | number
    createdAt?: DateTimeFilter<"AccountingEntry"> | Date | string
    creator?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type AccountingEntryOrderByWithAggregationInput = {
    id?: SortOrder
    entryDate?: SortOrder
    accountNumber?: SortOrder
    debit?: SortOrder
    credit?: SortOrder
    description?: SortOrderInput | SortOrder
    sourceDocumentType?: SortOrder
    sourceDocumentId?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    _count?: AccountingEntryCountOrderByAggregateInput
    _avg?: AccountingEntryAvgOrderByAggregateInput
    _max?: AccountingEntryMaxOrderByAggregateInput
    _min?: AccountingEntryMinOrderByAggregateInput
    _sum?: AccountingEntrySumOrderByAggregateInput
  }

  export type AccountingEntryScalarWhereWithAggregatesInput = {
    AND?: AccountingEntryScalarWhereWithAggregatesInput | AccountingEntryScalarWhereWithAggregatesInput[]
    OR?: AccountingEntryScalarWhereWithAggregatesInput[]
    NOT?: AccountingEntryScalarWhereWithAggregatesInput | AccountingEntryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AccountingEntry"> | number
    entryDate?: DateTimeWithAggregatesFilter<"AccountingEntry"> | Date | string
    accountNumber?: StringWithAggregatesFilter<"AccountingEntry"> | string
    debit?: FloatWithAggregatesFilter<"AccountingEntry"> | number
    credit?: FloatWithAggregatesFilter<"AccountingEntry"> | number
    description?: StringNullableWithAggregatesFilter<"AccountingEntry"> | string | null
    sourceDocumentType?: EnumSourceDocumentTypeWithAggregatesFilter<"AccountingEntry"> | $Enums.SourceDocumentType
    sourceDocumentId?: IntWithAggregatesFilter<"AccountingEntry"> | number
    createdBy?: IntWithAggregatesFilter<"AccountingEntry"> | number
    createdAt?: DateTimeWithAggregatesFilter<"AccountingEntry"> | Date | string
  }

  export type CashFlowWhereInput = {
    AND?: CashFlowWhereInput | CashFlowWhereInput[]
    OR?: CashFlowWhereInput[]
    NOT?: CashFlowWhereInput | CashFlowWhereInput[]
    id?: IntFilter<"CashFlow"> | number
    transactionDate?: DateTimeFilter<"CashFlow"> | Date | string
    type?: EnumCashFlowTypeFilter<"CashFlow"> | $Enums.CashFlowType
    amount?: FloatFilter<"CashFlow"> | number
    description?: StringNullableFilter<"CashFlow"> | string | null
    category?: StringNullableFilter<"CashFlow"> | string | null
    sourceDocumentType?: EnumSourceDocumentTypeFilter<"CashFlow"> | $Enums.SourceDocumentType
    sourceDocumentId?: IntFilter<"CashFlow"> | number
    createdBy?: IntFilter<"CashFlow"> | number
    createdAt?: DateTimeFilter<"CashFlow"> | Date | string
    creator?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type CashFlowOrderByWithRelationInput = {
    id?: SortOrder
    transactionDate?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    sourceDocumentType?: SortOrder
    sourceDocumentId?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    creator?: UserOrderByWithRelationInput
  }

  export type CashFlowWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CashFlowWhereInput | CashFlowWhereInput[]
    OR?: CashFlowWhereInput[]
    NOT?: CashFlowWhereInput | CashFlowWhereInput[]
    transactionDate?: DateTimeFilter<"CashFlow"> | Date | string
    type?: EnumCashFlowTypeFilter<"CashFlow"> | $Enums.CashFlowType
    amount?: FloatFilter<"CashFlow"> | number
    description?: StringNullableFilter<"CashFlow"> | string | null
    category?: StringNullableFilter<"CashFlow"> | string | null
    sourceDocumentType?: EnumSourceDocumentTypeFilter<"CashFlow"> | $Enums.SourceDocumentType
    sourceDocumentId?: IntFilter<"CashFlow"> | number
    createdBy?: IntFilter<"CashFlow"> | number
    createdAt?: DateTimeFilter<"CashFlow"> | Date | string
    creator?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type CashFlowOrderByWithAggregationInput = {
    id?: SortOrder
    transactionDate?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    sourceDocumentType?: SortOrder
    sourceDocumentId?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    _count?: CashFlowCountOrderByAggregateInput
    _avg?: CashFlowAvgOrderByAggregateInput
    _max?: CashFlowMaxOrderByAggregateInput
    _min?: CashFlowMinOrderByAggregateInput
    _sum?: CashFlowSumOrderByAggregateInput
  }

  export type CashFlowScalarWhereWithAggregatesInput = {
    AND?: CashFlowScalarWhereWithAggregatesInput | CashFlowScalarWhereWithAggregatesInput[]
    OR?: CashFlowScalarWhereWithAggregatesInput[]
    NOT?: CashFlowScalarWhereWithAggregatesInput | CashFlowScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CashFlow"> | number
    transactionDate?: DateTimeWithAggregatesFilter<"CashFlow"> | Date | string
    type?: EnumCashFlowTypeWithAggregatesFilter<"CashFlow"> | $Enums.CashFlowType
    amount?: FloatWithAggregatesFilter<"CashFlow"> | number
    description?: StringNullableWithAggregatesFilter<"CashFlow"> | string | null
    category?: StringNullableWithAggregatesFilter<"CashFlow"> | string | null
    sourceDocumentType?: EnumSourceDocumentTypeWithAggregatesFilter<"CashFlow"> | $Enums.SourceDocumentType
    sourceDocumentId?: IntWithAggregatesFilter<"CashFlow"> | number
    createdBy?: IntWithAggregatesFilter<"CashFlow"> | number
    createdAt?: DateTimeWithAggregatesFilter<"CashFlow"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: IntFilter<"AuditLog"> | number
    userId?: IntFilter<"AuditLog"> | number
    action?: StringFilter<"AuditLog"> | string
    details?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    details?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    userId?: IntFilter<"AuditLog"> | number
    action?: StringFilter<"AuditLog"> | string
    details?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    details?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _avg?: AuditLogAvgOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
    _sum?: AuditLogSumOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AuditLog"> | number
    userId?: IntWithAggregatesFilter<"AuditLog"> | number
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    details?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type EmployeeWhereInput = {
    AND?: EmployeeWhereInput | EmployeeWhereInput[]
    OR?: EmployeeWhereInput[]
    NOT?: EmployeeWhereInput | EmployeeWhereInput[]
    id?: IntFilter<"Employee"> | number
    employeeNumber?: StringFilter<"Employee"> | string
    registrationNumber?: StringNullableFilter<"Employee"> | string | null
    firstName?: StringFilter<"Employee"> | string
    lastName?: StringFilter<"Employee"> | string
    email?: StringNullableFilter<"Employee"> | string | null
    phone?: StringNullableFilter<"Employee"> | string | null
    address?: StringNullableFilter<"Employee"> | string | null
    dateOfBirth?: DateTimeFilter<"Employee"> | Date | string
    placeOfBirth?: StringNullableFilter<"Employee"> | string | null
    nationality?: StringNullableFilter<"Employee"> | string | null
    socialSecurityNumber?: StringNullableFilter<"Employee"> | string | null
    cnpsNumber?: StringNullableFilter<"Employee"> | string | null
    cnamNumber?: StringNullableFilter<"Employee"> | string | null
    bankAccount?: StringNullableFilter<"Employee"> | string | null
    emergencyContact?: StringNullableFilter<"Employee"> | string | null
    serviceId?: IntNullableFilter<"Employee"> | number | null
    position?: StringFilter<"Employee"> | string
    department?: StringNullableFilter<"Employee"> | string | null
    category?: StringNullableFilter<"Employee"> | string | null
    level?: StringNullableFilter<"Employee"> | string | null
    manager?: StringNullableFilter<"Employee"> | string | null
    hireDate?: DateTimeFilter<"Employee"> | Date | string
    isActive?: BoolFilter<"Employee"> | boolean
    userId?: IntNullableFilter<"Employee"> | number | null
    createdAt?: DateTimeFilter<"Employee"> | Date | string
    updatedAt?: DateTimeFilter<"Employee"> | Date | string
    service?: XOR<ServiceNullableRelationFilter, ServiceWhereInput> | null
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    contracts?: ContractListRelationFilter
    salaries?: SalaryListRelationFilter
    leaveRequests?: LeaveRequestListRelationFilter
    loans?: LoanListRelationFilter
  }

  export type EmployeeOrderByWithRelationInput = {
    id?: SortOrder
    employeeNumber?: SortOrder
    registrationNumber?: SortOrderInput | SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrder
    placeOfBirth?: SortOrderInput | SortOrder
    nationality?: SortOrderInput | SortOrder
    socialSecurityNumber?: SortOrderInput | SortOrder
    cnpsNumber?: SortOrderInput | SortOrder
    cnamNumber?: SortOrderInput | SortOrder
    bankAccount?: SortOrderInput | SortOrder
    emergencyContact?: SortOrderInput | SortOrder
    serviceId?: SortOrderInput | SortOrder
    position?: SortOrder
    department?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    level?: SortOrderInput | SortOrder
    manager?: SortOrderInput | SortOrder
    hireDate?: SortOrder
    isActive?: SortOrder
    userId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    service?: ServiceOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    contracts?: ContractOrderByRelationAggregateInput
    salaries?: SalaryOrderByRelationAggregateInput
    leaveRequests?: LeaveRequestOrderByRelationAggregateInput
    loans?: LoanOrderByRelationAggregateInput
  }

  export type EmployeeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    employeeNumber?: string
    registrationNumber?: string
    userId?: number
    AND?: EmployeeWhereInput | EmployeeWhereInput[]
    OR?: EmployeeWhereInput[]
    NOT?: EmployeeWhereInput | EmployeeWhereInput[]
    firstName?: StringFilter<"Employee"> | string
    lastName?: StringFilter<"Employee"> | string
    email?: StringNullableFilter<"Employee"> | string | null
    phone?: StringNullableFilter<"Employee"> | string | null
    address?: StringNullableFilter<"Employee"> | string | null
    dateOfBirth?: DateTimeFilter<"Employee"> | Date | string
    placeOfBirth?: StringNullableFilter<"Employee"> | string | null
    nationality?: StringNullableFilter<"Employee"> | string | null
    socialSecurityNumber?: StringNullableFilter<"Employee"> | string | null
    cnpsNumber?: StringNullableFilter<"Employee"> | string | null
    cnamNumber?: StringNullableFilter<"Employee"> | string | null
    bankAccount?: StringNullableFilter<"Employee"> | string | null
    emergencyContact?: StringNullableFilter<"Employee"> | string | null
    serviceId?: IntNullableFilter<"Employee"> | number | null
    position?: StringFilter<"Employee"> | string
    department?: StringNullableFilter<"Employee"> | string | null
    category?: StringNullableFilter<"Employee"> | string | null
    level?: StringNullableFilter<"Employee"> | string | null
    manager?: StringNullableFilter<"Employee"> | string | null
    hireDate?: DateTimeFilter<"Employee"> | Date | string
    isActive?: BoolFilter<"Employee"> | boolean
    createdAt?: DateTimeFilter<"Employee"> | Date | string
    updatedAt?: DateTimeFilter<"Employee"> | Date | string
    service?: XOR<ServiceNullableRelationFilter, ServiceWhereInput> | null
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    contracts?: ContractListRelationFilter
    salaries?: SalaryListRelationFilter
    leaveRequests?: LeaveRequestListRelationFilter
    loans?: LoanListRelationFilter
  }, "id" | "employeeNumber" | "registrationNumber" | "userId">

  export type EmployeeOrderByWithAggregationInput = {
    id?: SortOrder
    employeeNumber?: SortOrder
    registrationNumber?: SortOrderInput | SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrder
    placeOfBirth?: SortOrderInput | SortOrder
    nationality?: SortOrderInput | SortOrder
    socialSecurityNumber?: SortOrderInput | SortOrder
    cnpsNumber?: SortOrderInput | SortOrder
    cnamNumber?: SortOrderInput | SortOrder
    bankAccount?: SortOrderInput | SortOrder
    emergencyContact?: SortOrderInput | SortOrder
    serviceId?: SortOrderInput | SortOrder
    position?: SortOrder
    department?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    level?: SortOrderInput | SortOrder
    manager?: SortOrderInput | SortOrder
    hireDate?: SortOrder
    isActive?: SortOrder
    userId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmployeeCountOrderByAggregateInput
    _avg?: EmployeeAvgOrderByAggregateInput
    _max?: EmployeeMaxOrderByAggregateInput
    _min?: EmployeeMinOrderByAggregateInput
    _sum?: EmployeeSumOrderByAggregateInput
  }

  export type EmployeeScalarWhereWithAggregatesInput = {
    AND?: EmployeeScalarWhereWithAggregatesInput | EmployeeScalarWhereWithAggregatesInput[]
    OR?: EmployeeScalarWhereWithAggregatesInput[]
    NOT?: EmployeeScalarWhereWithAggregatesInput | EmployeeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Employee"> | number
    employeeNumber?: StringWithAggregatesFilter<"Employee"> | string
    registrationNumber?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    firstName?: StringWithAggregatesFilter<"Employee"> | string
    lastName?: StringWithAggregatesFilter<"Employee"> | string
    email?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    address?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    dateOfBirth?: DateTimeWithAggregatesFilter<"Employee"> | Date | string
    placeOfBirth?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    nationality?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    socialSecurityNumber?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    cnpsNumber?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    cnamNumber?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    bankAccount?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    emergencyContact?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    serviceId?: IntNullableWithAggregatesFilter<"Employee"> | number | null
    position?: StringWithAggregatesFilter<"Employee"> | string
    department?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    category?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    level?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    manager?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    hireDate?: DateTimeWithAggregatesFilter<"Employee"> | Date | string
    isActive?: BoolWithAggregatesFilter<"Employee"> | boolean
    userId?: IntNullableWithAggregatesFilter<"Employee"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Employee"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Employee"> | Date | string
  }

  export type ContractWhereInput = {
    AND?: ContractWhereInput | ContractWhereInput[]
    OR?: ContractWhereInput[]
    NOT?: ContractWhereInput | ContractWhereInput[]
    id?: IntFilter<"Contract"> | number
    employeeId?: IntFilter<"Contract"> | number
    contractType?: EnumContractTypeFilter<"Contract"> | $Enums.ContractType
    startDate?: DateTimeFilter<"Contract"> | Date | string
    endDate?: DateTimeNullableFilter<"Contract"> | Date | string | null
    baseSalary?: FloatFilter<"Contract"> | number
    workingHours?: FloatFilter<"Contract"> | number
    benefits?: StringNullableFilter<"Contract"> | string | null
    terms?: StringNullableFilter<"Contract"> | string | null
    isActive?: BoolFilter<"Contract"> | boolean
    createdAt?: DateTimeFilter<"Contract"> | Date | string
    updatedAt?: DateTimeFilter<"Contract"> | Date | string
    employee?: XOR<EmployeeRelationFilter, EmployeeWhereInput>
  }

  export type ContractOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    contractType?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    baseSalary?: SortOrder
    workingHours?: SortOrder
    benefits?: SortOrderInput | SortOrder
    terms?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employee?: EmployeeOrderByWithRelationInput
  }

  export type ContractWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ContractWhereInput | ContractWhereInput[]
    OR?: ContractWhereInput[]
    NOT?: ContractWhereInput | ContractWhereInput[]
    employeeId?: IntFilter<"Contract"> | number
    contractType?: EnumContractTypeFilter<"Contract"> | $Enums.ContractType
    startDate?: DateTimeFilter<"Contract"> | Date | string
    endDate?: DateTimeNullableFilter<"Contract"> | Date | string | null
    baseSalary?: FloatFilter<"Contract"> | number
    workingHours?: FloatFilter<"Contract"> | number
    benefits?: StringNullableFilter<"Contract"> | string | null
    terms?: StringNullableFilter<"Contract"> | string | null
    isActive?: BoolFilter<"Contract"> | boolean
    createdAt?: DateTimeFilter<"Contract"> | Date | string
    updatedAt?: DateTimeFilter<"Contract"> | Date | string
    employee?: XOR<EmployeeRelationFilter, EmployeeWhereInput>
  }, "id">

  export type ContractOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    contractType?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    baseSalary?: SortOrder
    workingHours?: SortOrder
    benefits?: SortOrderInput | SortOrder
    terms?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContractCountOrderByAggregateInput
    _avg?: ContractAvgOrderByAggregateInput
    _max?: ContractMaxOrderByAggregateInput
    _min?: ContractMinOrderByAggregateInput
    _sum?: ContractSumOrderByAggregateInput
  }

  export type ContractScalarWhereWithAggregatesInput = {
    AND?: ContractScalarWhereWithAggregatesInput | ContractScalarWhereWithAggregatesInput[]
    OR?: ContractScalarWhereWithAggregatesInput[]
    NOT?: ContractScalarWhereWithAggregatesInput | ContractScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Contract"> | number
    employeeId?: IntWithAggregatesFilter<"Contract"> | number
    contractType?: EnumContractTypeWithAggregatesFilter<"Contract"> | $Enums.ContractType
    startDate?: DateTimeWithAggregatesFilter<"Contract"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"Contract"> | Date | string | null
    baseSalary?: FloatWithAggregatesFilter<"Contract"> | number
    workingHours?: FloatWithAggregatesFilter<"Contract"> | number
    benefits?: StringNullableWithAggregatesFilter<"Contract"> | string | null
    terms?: StringNullableWithAggregatesFilter<"Contract"> | string | null
    isActive?: BoolWithAggregatesFilter<"Contract"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Contract"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Contract"> | Date | string
  }

  export type SalaryWhereInput = {
    AND?: SalaryWhereInput | SalaryWhereInput[]
    OR?: SalaryWhereInput[]
    NOT?: SalaryWhereInput | SalaryWhereInput[]
    id?: IntFilter<"Salary"> | number
    employeeId?: IntFilter<"Salary"> | number
    paymentDate?: DateTimeFilter<"Salary"> | Date | string
    workingDays?: IntFilter<"Salary"> | number
    baseSalary?: FloatFilter<"Salary"> | number
    overtime?: FloatFilter<"Salary"> | number
    bonuses?: FloatFilter<"Salary"> | number
    allowances?: FloatFilter<"Salary"> | number
    paidLeave?: FloatFilter<"Salary"> | number
    grossSalary?: FloatFilter<"Salary"> | number
    socialContributions?: FloatFilter<"Salary"> | number
    cnpsEmployee?: FloatFilter<"Salary"> | number
    cnamEmployee?: FloatFilter<"Salary"> | number
    fdfpEmployee?: FloatFilter<"Salary"> | number
    taxes?: FloatFilter<"Salary"> | number
    nonTaxableAmount?: FloatFilter<"Salary"> | number
    otherDeductions?: FloatFilter<"Salary"> | number
    loanDeductions?: FloatFilter<"Salary"> | number
    totalDeductions?: FloatFilter<"Salary"> | number
    netSalary?: FloatFilter<"Salary"> | number
    status?: EnumSalaryStatusFilter<"Salary"> | $Enums.SalaryStatus
    paymentMethod?: EnumPaymentMethodNullableFilter<"Salary"> | $Enums.PaymentMethod | null
    reference?: StringNullableFilter<"Salary"> | string | null
    notes?: StringNullableFilter<"Salary"> | string | null
    createdAt?: DateTimeFilter<"Salary"> | Date | string
    employee?: XOR<EmployeeRelationFilter, EmployeeWhereInput>
    loanPayments?: LoanPaymentListRelationFilter
  }

  export type SalaryOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    paymentDate?: SortOrder
    workingDays?: SortOrder
    baseSalary?: SortOrder
    overtime?: SortOrder
    bonuses?: SortOrder
    allowances?: SortOrder
    paidLeave?: SortOrder
    grossSalary?: SortOrder
    socialContributions?: SortOrder
    cnpsEmployee?: SortOrder
    cnamEmployee?: SortOrder
    fdfpEmployee?: SortOrder
    taxes?: SortOrder
    nonTaxableAmount?: SortOrder
    otherDeductions?: SortOrder
    loanDeductions?: SortOrder
    totalDeductions?: SortOrder
    netSalary?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    reference?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    employee?: EmployeeOrderByWithRelationInput
    loanPayments?: LoanPaymentOrderByRelationAggregateInput
  }

  export type SalaryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SalaryWhereInput | SalaryWhereInput[]
    OR?: SalaryWhereInput[]
    NOT?: SalaryWhereInput | SalaryWhereInput[]
    employeeId?: IntFilter<"Salary"> | number
    paymentDate?: DateTimeFilter<"Salary"> | Date | string
    workingDays?: IntFilter<"Salary"> | number
    baseSalary?: FloatFilter<"Salary"> | number
    overtime?: FloatFilter<"Salary"> | number
    bonuses?: FloatFilter<"Salary"> | number
    allowances?: FloatFilter<"Salary"> | number
    paidLeave?: FloatFilter<"Salary"> | number
    grossSalary?: FloatFilter<"Salary"> | number
    socialContributions?: FloatFilter<"Salary"> | number
    cnpsEmployee?: FloatFilter<"Salary"> | number
    cnamEmployee?: FloatFilter<"Salary"> | number
    fdfpEmployee?: FloatFilter<"Salary"> | number
    taxes?: FloatFilter<"Salary"> | number
    nonTaxableAmount?: FloatFilter<"Salary"> | number
    otherDeductions?: FloatFilter<"Salary"> | number
    loanDeductions?: FloatFilter<"Salary"> | number
    totalDeductions?: FloatFilter<"Salary"> | number
    netSalary?: FloatFilter<"Salary"> | number
    status?: EnumSalaryStatusFilter<"Salary"> | $Enums.SalaryStatus
    paymentMethod?: EnumPaymentMethodNullableFilter<"Salary"> | $Enums.PaymentMethod | null
    reference?: StringNullableFilter<"Salary"> | string | null
    notes?: StringNullableFilter<"Salary"> | string | null
    createdAt?: DateTimeFilter<"Salary"> | Date | string
    employee?: XOR<EmployeeRelationFilter, EmployeeWhereInput>
    loanPayments?: LoanPaymentListRelationFilter
  }, "id">

  export type SalaryOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    paymentDate?: SortOrder
    workingDays?: SortOrder
    baseSalary?: SortOrder
    overtime?: SortOrder
    bonuses?: SortOrder
    allowances?: SortOrder
    paidLeave?: SortOrder
    grossSalary?: SortOrder
    socialContributions?: SortOrder
    cnpsEmployee?: SortOrder
    cnamEmployee?: SortOrder
    fdfpEmployee?: SortOrder
    taxes?: SortOrder
    nonTaxableAmount?: SortOrder
    otherDeductions?: SortOrder
    loanDeductions?: SortOrder
    totalDeductions?: SortOrder
    netSalary?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    reference?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: SalaryCountOrderByAggregateInput
    _avg?: SalaryAvgOrderByAggregateInput
    _max?: SalaryMaxOrderByAggregateInput
    _min?: SalaryMinOrderByAggregateInput
    _sum?: SalarySumOrderByAggregateInput
  }

  export type SalaryScalarWhereWithAggregatesInput = {
    AND?: SalaryScalarWhereWithAggregatesInput | SalaryScalarWhereWithAggregatesInput[]
    OR?: SalaryScalarWhereWithAggregatesInput[]
    NOT?: SalaryScalarWhereWithAggregatesInput | SalaryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Salary"> | number
    employeeId?: IntWithAggregatesFilter<"Salary"> | number
    paymentDate?: DateTimeWithAggregatesFilter<"Salary"> | Date | string
    workingDays?: IntWithAggregatesFilter<"Salary"> | number
    baseSalary?: FloatWithAggregatesFilter<"Salary"> | number
    overtime?: FloatWithAggregatesFilter<"Salary"> | number
    bonuses?: FloatWithAggregatesFilter<"Salary"> | number
    allowances?: FloatWithAggregatesFilter<"Salary"> | number
    paidLeave?: FloatWithAggregatesFilter<"Salary"> | number
    grossSalary?: FloatWithAggregatesFilter<"Salary"> | number
    socialContributions?: FloatWithAggregatesFilter<"Salary"> | number
    cnpsEmployee?: FloatWithAggregatesFilter<"Salary"> | number
    cnamEmployee?: FloatWithAggregatesFilter<"Salary"> | number
    fdfpEmployee?: FloatWithAggregatesFilter<"Salary"> | number
    taxes?: FloatWithAggregatesFilter<"Salary"> | number
    nonTaxableAmount?: FloatWithAggregatesFilter<"Salary"> | number
    otherDeductions?: FloatWithAggregatesFilter<"Salary"> | number
    loanDeductions?: FloatWithAggregatesFilter<"Salary"> | number
    totalDeductions?: FloatWithAggregatesFilter<"Salary"> | number
    netSalary?: FloatWithAggregatesFilter<"Salary"> | number
    status?: EnumSalaryStatusWithAggregatesFilter<"Salary"> | $Enums.SalaryStatus
    paymentMethod?: EnumPaymentMethodNullableWithAggregatesFilter<"Salary"> | $Enums.PaymentMethod | null
    reference?: StringNullableWithAggregatesFilter<"Salary"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Salary"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Salary"> | Date | string
  }

  export type LoanPaymentWhereInput = {
    AND?: LoanPaymentWhereInput | LoanPaymentWhereInput[]
    OR?: LoanPaymentWhereInput[]
    NOT?: LoanPaymentWhereInput | LoanPaymentWhereInput[]
    id?: IntFilter<"LoanPayment"> | number
    loanId?: IntFilter<"LoanPayment"> | number
    salaryId?: IntNullableFilter<"LoanPayment"> | number | null
    amount?: FloatFilter<"LoanPayment"> | number
    paymentDate?: DateTimeFilter<"LoanPayment"> | Date | string
    principal?: FloatFilter<"LoanPayment"> | number
    interest?: FloatFilter<"LoanPayment"> | number
    notes?: StringNullableFilter<"LoanPayment"> | string | null
    createdAt?: DateTimeFilter<"LoanPayment"> | Date | string
    loan?: XOR<LoanRelationFilter, LoanWhereInput>
    salary?: XOR<SalaryNullableRelationFilter, SalaryWhereInput> | null
  }

  export type LoanPaymentOrderByWithRelationInput = {
    id?: SortOrder
    loanId?: SortOrder
    salaryId?: SortOrderInput | SortOrder
    amount?: SortOrder
    paymentDate?: SortOrder
    principal?: SortOrder
    interest?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    loan?: LoanOrderByWithRelationInput
    salary?: SalaryOrderByWithRelationInput
  }

  export type LoanPaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LoanPaymentWhereInput | LoanPaymentWhereInput[]
    OR?: LoanPaymentWhereInput[]
    NOT?: LoanPaymentWhereInput | LoanPaymentWhereInput[]
    loanId?: IntFilter<"LoanPayment"> | number
    salaryId?: IntNullableFilter<"LoanPayment"> | number | null
    amount?: FloatFilter<"LoanPayment"> | number
    paymentDate?: DateTimeFilter<"LoanPayment"> | Date | string
    principal?: FloatFilter<"LoanPayment"> | number
    interest?: FloatFilter<"LoanPayment"> | number
    notes?: StringNullableFilter<"LoanPayment"> | string | null
    createdAt?: DateTimeFilter<"LoanPayment"> | Date | string
    loan?: XOR<LoanRelationFilter, LoanWhereInput>
    salary?: XOR<SalaryNullableRelationFilter, SalaryWhereInput> | null
  }, "id">

  export type LoanPaymentOrderByWithAggregationInput = {
    id?: SortOrder
    loanId?: SortOrder
    salaryId?: SortOrderInput | SortOrder
    amount?: SortOrder
    paymentDate?: SortOrder
    principal?: SortOrder
    interest?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: LoanPaymentCountOrderByAggregateInput
    _avg?: LoanPaymentAvgOrderByAggregateInput
    _max?: LoanPaymentMaxOrderByAggregateInput
    _min?: LoanPaymentMinOrderByAggregateInput
    _sum?: LoanPaymentSumOrderByAggregateInput
  }

  export type LoanPaymentScalarWhereWithAggregatesInput = {
    AND?: LoanPaymentScalarWhereWithAggregatesInput | LoanPaymentScalarWhereWithAggregatesInput[]
    OR?: LoanPaymentScalarWhereWithAggregatesInput[]
    NOT?: LoanPaymentScalarWhereWithAggregatesInput | LoanPaymentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LoanPayment"> | number
    loanId?: IntWithAggregatesFilter<"LoanPayment"> | number
    salaryId?: IntNullableWithAggregatesFilter<"LoanPayment"> | number | null
    amount?: FloatWithAggregatesFilter<"LoanPayment"> | number
    paymentDate?: DateTimeWithAggregatesFilter<"LoanPayment"> | Date | string
    principal?: FloatWithAggregatesFilter<"LoanPayment"> | number
    interest?: FloatWithAggregatesFilter<"LoanPayment"> | number
    notes?: StringNullableWithAggregatesFilter<"LoanPayment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"LoanPayment"> | Date | string
  }

  export type LeaveRequestWhereInput = {
    AND?: LeaveRequestWhereInput | LeaveRequestWhereInput[]
    OR?: LeaveRequestWhereInput[]
    NOT?: LeaveRequestWhereInput | LeaveRequestWhereInput[]
    id?: IntFilter<"LeaveRequest"> | number
    employeeId?: IntFilter<"LeaveRequest"> | number
    leaveType?: EnumLeaveTypeFilter<"LeaveRequest"> | $Enums.LeaveType
    startDate?: DateTimeFilter<"LeaveRequest"> | Date | string
    endDate?: DateTimeFilter<"LeaveRequest"> | Date | string
    days?: IntFilter<"LeaveRequest"> | number
    reason?: StringFilter<"LeaveRequest"> | string
    notes?: StringNullableFilter<"LeaveRequest"> | string | null
    status?: EnumLeaveStatusFilter<"LeaveRequest"> | $Enums.LeaveStatus
    approvedById?: IntNullableFilter<"LeaveRequest"> | number | null
    approvedAt?: DateTimeNullableFilter<"LeaveRequest"> | Date | string | null
    comments?: StringNullableFilter<"LeaveRequest"> | string | null
    createdAt?: DateTimeFilter<"LeaveRequest"> | Date | string
    updatedAt?: DateTimeFilter<"LeaveRequest"> | Date | string
    employee?: XOR<EmployeeRelationFilter, EmployeeWhereInput>
    approvedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type LeaveRequestOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    leaveType?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    days?: SortOrder
    reason?: SortOrder
    notes?: SortOrderInput | SortOrder
    status?: SortOrder
    approvedById?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    comments?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employee?: EmployeeOrderByWithRelationInput
    approvedBy?: UserOrderByWithRelationInput
  }

  export type LeaveRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LeaveRequestWhereInput | LeaveRequestWhereInput[]
    OR?: LeaveRequestWhereInput[]
    NOT?: LeaveRequestWhereInput | LeaveRequestWhereInput[]
    employeeId?: IntFilter<"LeaveRequest"> | number
    leaveType?: EnumLeaveTypeFilter<"LeaveRequest"> | $Enums.LeaveType
    startDate?: DateTimeFilter<"LeaveRequest"> | Date | string
    endDate?: DateTimeFilter<"LeaveRequest"> | Date | string
    days?: IntFilter<"LeaveRequest"> | number
    reason?: StringFilter<"LeaveRequest"> | string
    notes?: StringNullableFilter<"LeaveRequest"> | string | null
    status?: EnumLeaveStatusFilter<"LeaveRequest"> | $Enums.LeaveStatus
    approvedById?: IntNullableFilter<"LeaveRequest"> | number | null
    approvedAt?: DateTimeNullableFilter<"LeaveRequest"> | Date | string | null
    comments?: StringNullableFilter<"LeaveRequest"> | string | null
    createdAt?: DateTimeFilter<"LeaveRequest"> | Date | string
    updatedAt?: DateTimeFilter<"LeaveRequest"> | Date | string
    employee?: XOR<EmployeeRelationFilter, EmployeeWhereInput>
    approvedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type LeaveRequestOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    leaveType?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    days?: SortOrder
    reason?: SortOrder
    notes?: SortOrderInput | SortOrder
    status?: SortOrder
    approvedById?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    comments?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LeaveRequestCountOrderByAggregateInput
    _avg?: LeaveRequestAvgOrderByAggregateInput
    _max?: LeaveRequestMaxOrderByAggregateInput
    _min?: LeaveRequestMinOrderByAggregateInput
    _sum?: LeaveRequestSumOrderByAggregateInput
  }

  export type LeaveRequestScalarWhereWithAggregatesInput = {
    AND?: LeaveRequestScalarWhereWithAggregatesInput | LeaveRequestScalarWhereWithAggregatesInput[]
    OR?: LeaveRequestScalarWhereWithAggregatesInput[]
    NOT?: LeaveRequestScalarWhereWithAggregatesInput | LeaveRequestScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LeaveRequest"> | number
    employeeId?: IntWithAggregatesFilter<"LeaveRequest"> | number
    leaveType?: EnumLeaveTypeWithAggregatesFilter<"LeaveRequest"> | $Enums.LeaveType
    startDate?: DateTimeWithAggregatesFilter<"LeaveRequest"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"LeaveRequest"> | Date | string
    days?: IntWithAggregatesFilter<"LeaveRequest"> | number
    reason?: StringWithAggregatesFilter<"LeaveRequest"> | string
    notes?: StringNullableWithAggregatesFilter<"LeaveRequest"> | string | null
    status?: EnumLeaveStatusWithAggregatesFilter<"LeaveRequest"> | $Enums.LeaveStatus
    approvedById?: IntNullableWithAggregatesFilter<"LeaveRequest"> | number | null
    approvedAt?: DateTimeNullableWithAggregatesFilter<"LeaveRequest"> | Date | string | null
    comments?: StringNullableWithAggregatesFilter<"LeaveRequest"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"LeaveRequest"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LeaveRequest"> | Date | string
  }

  export type ProspectWhereInput = {
    AND?: ProspectWhereInput | ProspectWhereInput[]
    OR?: ProspectWhereInput[]
    NOT?: ProspectWhereInput | ProspectWhereInput[]
    id?: IntFilter<"Prospect"> | number
    companyName?: StringFilter<"Prospect"> | string
    contactName?: StringFilter<"Prospect"> | string
    position?: StringNullableFilter<"Prospect"> | string | null
    email?: StringNullableFilter<"Prospect"> | string | null
    phone?: StringNullableFilter<"Prospect"> | string | null
    address?: StringNullableFilter<"Prospect"> | string | null
    website?: StringNullableFilter<"Prospect"> | string | null
    industry?: StringNullableFilter<"Prospect"> | string | null
    companySize?: StringNullableFilter<"Prospect"> | string | null
    estimatedValue?: FloatNullableFilter<"Prospect"> | number | null
    priority?: StringFilter<"Prospect"> | string
    stage?: StringFilter<"Prospect"> | string
    source?: StringNullableFilter<"Prospect"> | string | null
    notes?: StringNullableFilter<"Prospect"> | string | null
    hasBudget?: BoolFilter<"Prospect"> | boolean
    isDecisionMaker?: BoolFilter<"Prospect"> | boolean
    hasNeed?: BoolFilter<"Prospect"> | boolean
    timeline?: StringNullableFilter<"Prospect"> | string | null
    lastContact?: DateTimeFilter<"Prospect"> | Date | string
    nextAction?: StringNullableFilter<"Prospect"> | string | null
    nextActionDate?: DateTimeNullableFilter<"Prospect"> | Date | string | null
    assignedTo?: IntNullableFilter<"Prospect"> | number | null
    createdBy?: IntFilter<"Prospect"> | number
    createdAt?: DateTimeFilter<"Prospect"> | Date | string
    updatedAt?: DateTimeFilter<"Prospect"> | Date | string
    assignedUser?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    creator?: XOR<UserRelationFilter, UserWhereInput>
    activities?: ProspectActivityListRelationFilter
  }

  export type ProspectOrderByWithRelationInput = {
    id?: SortOrder
    companyName?: SortOrder
    contactName?: SortOrder
    position?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    industry?: SortOrderInput | SortOrder
    companySize?: SortOrderInput | SortOrder
    estimatedValue?: SortOrderInput | SortOrder
    priority?: SortOrder
    stage?: SortOrder
    source?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    hasBudget?: SortOrder
    isDecisionMaker?: SortOrder
    hasNeed?: SortOrder
    timeline?: SortOrderInput | SortOrder
    lastContact?: SortOrder
    nextAction?: SortOrderInput | SortOrder
    nextActionDate?: SortOrderInput | SortOrder
    assignedTo?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assignedUser?: UserOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
    activities?: ProspectActivityOrderByRelationAggregateInput
  }

  export type ProspectWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProspectWhereInput | ProspectWhereInput[]
    OR?: ProspectWhereInput[]
    NOT?: ProspectWhereInput | ProspectWhereInput[]
    companyName?: StringFilter<"Prospect"> | string
    contactName?: StringFilter<"Prospect"> | string
    position?: StringNullableFilter<"Prospect"> | string | null
    email?: StringNullableFilter<"Prospect"> | string | null
    phone?: StringNullableFilter<"Prospect"> | string | null
    address?: StringNullableFilter<"Prospect"> | string | null
    website?: StringNullableFilter<"Prospect"> | string | null
    industry?: StringNullableFilter<"Prospect"> | string | null
    companySize?: StringNullableFilter<"Prospect"> | string | null
    estimatedValue?: FloatNullableFilter<"Prospect"> | number | null
    priority?: StringFilter<"Prospect"> | string
    stage?: StringFilter<"Prospect"> | string
    source?: StringNullableFilter<"Prospect"> | string | null
    notes?: StringNullableFilter<"Prospect"> | string | null
    hasBudget?: BoolFilter<"Prospect"> | boolean
    isDecisionMaker?: BoolFilter<"Prospect"> | boolean
    hasNeed?: BoolFilter<"Prospect"> | boolean
    timeline?: StringNullableFilter<"Prospect"> | string | null
    lastContact?: DateTimeFilter<"Prospect"> | Date | string
    nextAction?: StringNullableFilter<"Prospect"> | string | null
    nextActionDate?: DateTimeNullableFilter<"Prospect"> | Date | string | null
    assignedTo?: IntNullableFilter<"Prospect"> | number | null
    createdBy?: IntFilter<"Prospect"> | number
    createdAt?: DateTimeFilter<"Prospect"> | Date | string
    updatedAt?: DateTimeFilter<"Prospect"> | Date | string
    assignedUser?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    creator?: XOR<UserRelationFilter, UserWhereInput>
    activities?: ProspectActivityListRelationFilter
  }, "id">

  export type ProspectOrderByWithAggregationInput = {
    id?: SortOrder
    companyName?: SortOrder
    contactName?: SortOrder
    position?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    industry?: SortOrderInput | SortOrder
    companySize?: SortOrderInput | SortOrder
    estimatedValue?: SortOrderInput | SortOrder
    priority?: SortOrder
    stage?: SortOrder
    source?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    hasBudget?: SortOrder
    isDecisionMaker?: SortOrder
    hasNeed?: SortOrder
    timeline?: SortOrderInput | SortOrder
    lastContact?: SortOrder
    nextAction?: SortOrderInput | SortOrder
    nextActionDate?: SortOrderInput | SortOrder
    assignedTo?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProspectCountOrderByAggregateInput
    _avg?: ProspectAvgOrderByAggregateInput
    _max?: ProspectMaxOrderByAggregateInput
    _min?: ProspectMinOrderByAggregateInput
    _sum?: ProspectSumOrderByAggregateInput
  }

  export type ProspectScalarWhereWithAggregatesInput = {
    AND?: ProspectScalarWhereWithAggregatesInput | ProspectScalarWhereWithAggregatesInput[]
    OR?: ProspectScalarWhereWithAggregatesInput[]
    NOT?: ProspectScalarWhereWithAggregatesInput | ProspectScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Prospect"> | number
    companyName?: StringWithAggregatesFilter<"Prospect"> | string
    contactName?: StringWithAggregatesFilter<"Prospect"> | string
    position?: StringNullableWithAggregatesFilter<"Prospect"> | string | null
    email?: StringNullableWithAggregatesFilter<"Prospect"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Prospect"> | string | null
    address?: StringNullableWithAggregatesFilter<"Prospect"> | string | null
    website?: StringNullableWithAggregatesFilter<"Prospect"> | string | null
    industry?: StringNullableWithAggregatesFilter<"Prospect"> | string | null
    companySize?: StringNullableWithAggregatesFilter<"Prospect"> | string | null
    estimatedValue?: FloatNullableWithAggregatesFilter<"Prospect"> | number | null
    priority?: StringWithAggregatesFilter<"Prospect"> | string
    stage?: StringWithAggregatesFilter<"Prospect"> | string
    source?: StringNullableWithAggregatesFilter<"Prospect"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Prospect"> | string | null
    hasBudget?: BoolWithAggregatesFilter<"Prospect"> | boolean
    isDecisionMaker?: BoolWithAggregatesFilter<"Prospect"> | boolean
    hasNeed?: BoolWithAggregatesFilter<"Prospect"> | boolean
    timeline?: StringNullableWithAggregatesFilter<"Prospect"> | string | null
    lastContact?: DateTimeWithAggregatesFilter<"Prospect"> | Date | string
    nextAction?: StringNullableWithAggregatesFilter<"Prospect"> | string | null
    nextActionDate?: DateTimeNullableWithAggregatesFilter<"Prospect"> | Date | string | null
    assignedTo?: IntNullableWithAggregatesFilter<"Prospect"> | number | null
    createdBy?: IntWithAggregatesFilter<"Prospect"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Prospect"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Prospect"> | Date | string
  }

  export type ProspectActivityWhereInput = {
    AND?: ProspectActivityWhereInput | ProspectActivityWhereInput[]
    OR?: ProspectActivityWhereInput[]
    NOT?: ProspectActivityWhereInput | ProspectActivityWhereInput[]
    id?: IntFilter<"ProspectActivity"> | number
    prospectId?: IntFilter<"ProspectActivity"> | number
    type?: StringFilter<"ProspectActivity"> | string
    subject?: StringNullableFilter<"ProspectActivity"> | string | null
    description?: StringNullableFilter<"ProspectActivity"> | string | null
    scheduledAt?: DateTimeNullableFilter<"ProspectActivity"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"ProspectActivity"> | Date | string | null
    outcome?: StringNullableFilter<"ProspectActivity"> | string | null
    nextAction?: StringNullableFilter<"ProspectActivity"> | string | null
    createdBy?: IntFilter<"ProspectActivity"> | number
    createdAt?: DateTimeFilter<"ProspectActivity"> | Date | string
    prospect?: XOR<ProspectRelationFilter, ProspectWhereInput>
    creator?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ProspectActivityOrderByWithRelationInput = {
    id?: SortOrder
    prospectId?: SortOrder
    type?: SortOrder
    subject?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    outcome?: SortOrderInput | SortOrder
    nextAction?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    prospect?: ProspectOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
  }

  export type ProspectActivityWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProspectActivityWhereInput | ProspectActivityWhereInput[]
    OR?: ProspectActivityWhereInput[]
    NOT?: ProspectActivityWhereInput | ProspectActivityWhereInput[]
    prospectId?: IntFilter<"ProspectActivity"> | number
    type?: StringFilter<"ProspectActivity"> | string
    subject?: StringNullableFilter<"ProspectActivity"> | string | null
    description?: StringNullableFilter<"ProspectActivity"> | string | null
    scheduledAt?: DateTimeNullableFilter<"ProspectActivity"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"ProspectActivity"> | Date | string | null
    outcome?: StringNullableFilter<"ProspectActivity"> | string | null
    nextAction?: StringNullableFilter<"ProspectActivity"> | string | null
    createdBy?: IntFilter<"ProspectActivity"> | number
    createdAt?: DateTimeFilter<"ProspectActivity"> | Date | string
    prospect?: XOR<ProspectRelationFilter, ProspectWhereInput>
    creator?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type ProspectActivityOrderByWithAggregationInput = {
    id?: SortOrder
    prospectId?: SortOrder
    type?: SortOrder
    subject?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    outcome?: SortOrderInput | SortOrder
    nextAction?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    _count?: ProspectActivityCountOrderByAggregateInput
    _avg?: ProspectActivityAvgOrderByAggregateInput
    _max?: ProspectActivityMaxOrderByAggregateInput
    _min?: ProspectActivityMinOrderByAggregateInput
    _sum?: ProspectActivitySumOrderByAggregateInput
  }

  export type ProspectActivityScalarWhereWithAggregatesInput = {
    AND?: ProspectActivityScalarWhereWithAggregatesInput | ProspectActivityScalarWhereWithAggregatesInput[]
    OR?: ProspectActivityScalarWhereWithAggregatesInput[]
    NOT?: ProspectActivityScalarWhereWithAggregatesInput | ProspectActivityScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProspectActivity"> | number
    prospectId?: IntWithAggregatesFilter<"ProspectActivity"> | number
    type?: StringWithAggregatesFilter<"ProspectActivity"> | string
    subject?: StringNullableWithAggregatesFilter<"ProspectActivity"> | string | null
    description?: StringNullableWithAggregatesFilter<"ProspectActivity"> | string | null
    scheduledAt?: DateTimeNullableWithAggregatesFilter<"ProspectActivity"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"ProspectActivity"> | Date | string | null
    outcome?: StringNullableWithAggregatesFilter<"ProspectActivity"> | string | null
    nextAction?: StringNullableWithAggregatesFilter<"ProspectActivity"> | string | null
    createdBy?: IntWithAggregatesFilter<"ProspectActivity"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ProspectActivity"> | Date | string
  }

  export type LoanWhereInput = {
    AND?: LoanWhereInput | LoanWhereInput[]
    OR?: LoanWhereInput[]
    NOT?: LoanWhereInput | LoanWhereInput[]
    id?: IntFilter<"Loan"> | number
    loanNumber?: StringFilter<"Loan"> | string
    employeeId?: IntFilter<"Loan"> | number
    amount?: FloatFilter<"Loan"> | number
    interestRate?: FloatFilter<"Loan"> | number
    monthlyPayment?: FloatFilter<"Loan"> | number
    remainingAmount?: FloatFilter<"Loan"> | number
    startDate?: DateTimeFilter<"Loan"> | Date | string
    endDate?: DateTimeFilter<"Loan"> | Date | string
    purpose?: StringNullableFilter<"Loan"> | string | null
    status?: EnumLoanStatusFilter<"Loan"> | $Enums.LoanStatus
    notes?: StringNullableFilter<"Loan"> | string | null
    createdBy?: IntFilter<"Loan"> | number
    createdAt?: DateTimeFilter<"Loan"> | Date | string
    updatedAt?: DateTimeFilter<"Loan"> | Date | string
    employee?: XOR<EmployeeRelationFilter, EmployeeWhereInput>
    payments?: LoanPaymentListRelationFilter
  }

  export type LoanOrderByWithRelationInput = {
    id?: SortOrder
    loanNumber?: SortOrder
    employeeId?: SortOrder
    amount?: SortOrder
    interestRate?: SortOrder
    monthlyPayment?: SortOrder
    remainingAmount?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    purpose?: SortOrderInput | SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employee?: EmployeeOrderByWithRelationInput
    payments?: LoanPaymentOrderByRelationAggregateInput
  }

  export type LoanWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    loanNumber?: string
    AND?: LoanWhereInput | LoanWhereInput[]
    OR?: LoanWhereInput[]
    NOT?: LoanWhereInput | LoanWhereInput[]
    employeeId?: IntFilter<"Loan"> | number
    amount?: FloatFilter<"Loan"> | number
    interestRate?: FloatFilter<"Loan"> | number
    monthlyPayment?: FloatFilter<"Loan"> | number
    remainingAmount?: FloatFilter<"Loan"> | number
    startDate?: DateTimeFilter<"Loan"> | Date | string
    endDate?: DateTimeFilter<"Loan"> | Date | string
    purpose?: StringNullableFilter<"Loan"> | string | null
    status?: EnumLoanStatusFilter<"Loan"> | $Enums.LoanStatus
    notes?: StringNullableFilter<"Loan"> | string | null
    createdBy?: IntFilter<"Loan"> | number
    createdAt?: DateTimeFilter<"Loan"> | Date | string
    updatedAt?: DateTimeFilter<"Loan"> | Date | string
    employee?: XOR<EmployeeRelationFilter, EmployeeWhereInput>
    payments?: LoanPaymentListRelationFilter
  }, "id" | "loanNumber">

  export type LoanOrderByWithAggregationInput = {
    id?: SortOrder
    loanNumber?: SortOrder
    employeeId?: SortOrder
    amount?: SortOrder
    interestRate?: SortOrder
    monthlyPayment?: SortOrder
    remainingAmount?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    purpose?: SortOrderInput | SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LoanCountOrderByAggregateInput
    _avg?: LoanAvgOrderByAggregateInput
    _max?: LoanMaxOrderByAggregateInput
    _min?: LoanMinOrderByAggregateInput
    _sum?: LoanSumOrderByAggregateInput
  }

  export type LoanScalarWhereWithAggregatesInput = {
    AND?: LoanScalarWhereWithAggregatesInput | LoanScalarWhereWithAggregatesInput[]
    OR?: LoanScalarWhereWithAggregatesInput[]
    NOT?: LoanScalarWhereWithAggregatesInput | LoanScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Loan"> | number
    loanNumber?: StringWithAggregatesFilter<"Loan"> | string
    employeeId?: IntWithAggregatesFilter<"Loan"> | number
    amount?: FloatWithAggregatesFilter<"Loan"> | number
    interestRate?: FloatWithAggregatesFilter<"Loan"> | number
    monthlyPayment?: FloatWithAggregatesFilter<"Loan"> | number
    remainingAmount?: FloatWithAggregatesFilter<"Loan"> | number
    startDate?: DateTimeWithAggregatesFilter<"Loan"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Loan"> | Date | string
    purpose?: StringNullableWithAggregatesFilter<"Loan"> | string | null
    status?: EnumLoanStatusWithAggregatesFilter<"Loan"> | $Enums.LoanStatus
    notes?: StringNullableWithAggregatesFilter<"Loan"> | string | null
    createdBy?: IntWithAggregatesFilter<"Loan"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Loan"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Loan"> | Date | string
  }

  export type SpecialiteWhereInput = {
    AND?: SpecialiteWhereInput | SpecialiteWhereInput[]
    OR?: SpecialiteWhereInput[]
    NOT?: SpecialiteWhereInput | SpecialiteWhereInput[]
    id?: IntFilter<"Specialite"> | number
    libelle?: StringFilter<"Specialite"> | string
    description?: StringNullableFilter<"Specialite"> | string | null
    createdAt?: DateTimeFilter<"Specialite"> | Date | string
    updatedAt?: DateTimeFilter<"Specialite"> | Date | string
    techniciens?: TechnicienListRelationFilter
  }

  export type SpecialiteOrderByWithRelationInput = {
    id?: SortOrder
    libelle?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    techniciens?: TechnicienOrderByRelationAggregateInput
  }

  export type SpecialiteWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    libelle?: string
    AND?: SpecialiteWhereInput | SpecialiteWhereInput[]
    OR?: SpecialiteWhereInput[]
    NOT?: SpecialiteWhereInput | SpecialiteWhereInput[]
    description?: StringNullableFilter<"Specialite"> | string | null
    createdAt?: DateTimeFilter<"Specialite"> | Date | string
    updatedAt?: DateTimeFilter<"Specialite"> | Date | string
    techniciens?: TechnicienListRelationFilter
  }, "id" | "libelle">

  export type SpecialiteOrderByWithAggregationInput = {
    id?: SortOrder
    libelle?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SpecialiteCountOrderByAggregateInput
    _avg?: SpecialiteAvgOrderByAggregateInput
    _max?: SpecialiteMaxOrderByAggregateInput
    _min?: SpecialiteMinOrderByAggregateInput
    _sum?: SpecialiteSumOrderByAggregateInput
  }

  export type SpecialiteScalarWhereWithAggregatesInput = {
    AND?: SpecialiteScalarWhereWithAggregatesInput | SpecialiteScalarWhereWithAggregatesInput[]
    OR?: SpecialiteScalarWhereWithAggregatesInput[]
    NOT?: SpecialiteScalarWhereWithAggregatesInput | SpecialiteScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Specialite"> | number
    libelle?: StringWithAggregatesFilter<"Specialite"> | string
    description?: StringNullableWithAggregatesFilter<"Specialite"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Specialite"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Specialite"> | Date | string
  }

  export type TechnicienWhereInput = {
    AND?: TechnicienWhereInput | TechnicienWhereInput[]
    OR?: TechnicienWhereInput[]
    NOT?: TechnicienWhereInput | TechnicienWhereInput[]
    id?: IntFilter<"Technicien"> | number
    nom?: StringFilter<"Technicien"> | string
    prenom?: StringFilter<"Technicien"> | string
    contact?: StringFilter<"Technicien"> | string
    specialiteId?: IntFilter<"Technicien"> | number
    utilisateurId?: IntNullableFilter<"Technicien"> | number | null
    isActive?: BoolFilter<"Technicien"> | boolean
    createdAt?: DateTimeFilter<"Technicien"> | Date | string
    updatedAt?: DateTimeFilter<"Technicien"> | Date | string
    specialite?: XOR<SpecialiteRelationFilter, SpecialiteWhereInput>
    utilisateur?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    interventions?: TechnicienInterventionListRelationFilter
    rapports?: RapportMissionListRelationFilter
    sortiesMateriels?: SortieMaterielListRelationFilter
  }

  export type TechnicienOrderByWithRelationInput = {
    id?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    contact?: SortOrder
    specialiteId?: SortOrder
    utilisateurId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    specialite?: SpecialiteOrderByWithRelationInput
    utilisateur?: UserOrderByWithRelationInput
    interventions?: TechnicienInterventionOrderByRelationAggregateInput
    rapports?: RapportMissionOrderByRelationAggregateInput
    sortiesMateriels?: SortieMaterielOrderByRelationAggregateInput
  }

  export type TechnicienWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    utilisateurId?: number
    AND?: TechnicienWhereInput | TechnicienWhereInput[]
    OR?: TechnicienWhereInput[]
    NOT?: TechnicienWhereInput | TechnicienWhereInput[]
    nom?: StringFilter<"Technicien"> | string
    prenom?: StringFilter<"Technicien"> | string
    contact?: StringFilter<"Technicien"> | string
    specialiteId?: IntFilter<"Technicien"> | number
    isActive?: BoolFilter<"Technicien"> | boolean
    createdAt?: DateTimeFilter<"Technicien"> | Date | string
    updatedAt?: DateTimeFilter<"Technicien"> | Date | string
    specialite?: XOR<SpecialiteRelationFilter, SpecialiteWhereInput>
    utilisateur?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    interventions?: TechnicienInterventionListRelationFilter
    rapports?: RapportMissionListRelationFilter
    sortiesMateriels?: SortieMaterielListRelationFilter
  }, "id" | "utilisateurId">

  export type TechnicienOrderByWithAggregationInput = {
    id?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    contact?: SortOrder
    specialiteId?: SortOrder
    utilisateurId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TechnicienCountOrderByAggregateInput
    _avg?: TechnicienAvgOrderByAggregateInput
    _max?: TechnicienMaxOrderByAggregateInput
    _min?: TechnicienMinOrderByAggregateInput
    _sum?: TechnicienSumOrderByAggregateInput
  }

  export type TechnicienScalarWhereWithAggregatesInput = {
    AND?: TechnicienScalarWhereWithAggregatesInput | TechnicienScalarWhereWithAggregatesInput[]
    OR?: TechnicienScalarWhereWithAggregatesInput[]
    NOT?: TechnicienScalarWhereWithAggregatesInput | TechnicienScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Technicien"> | number
    nom?: StringWithAggregatesFilter<"Technicien"> | string
    prenom?: StringWithAggregatesFilter<"Technicien"> | string
    contact?: StringWithAggregatesFilter<"Technicien"> | string
    specialiteId?: IntWithAggregatesFilter<"Technicien"> | number
    utilisateurId?: IntNullableWithAggregatesFilter<"Technicien"> | number | null
    isActive?: BoolWithAggregatesFilter<"Technicien"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Technicien"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Technicien"> | Date | string
  }

  export type MissionWhereInput = {
    AND?: MissionWhereInput | MissionWhereInput[]
    OR?: MissionWhereInput[]
    NOT?: MissionWhereInput | MissionWhereInput[]
    numIntervention?: StringFilter<"Mission"> | string
    natureIntervention?: StringFilter<"Mission"> | string
    objectifDuContrat?: StringFilter<"Mission"> | string
    description?: StringNullableFilter<"Mission"> | string | null
    priorite?: StringNullableFilter<"Mission"> | string | null
    statut?: StringNullableFilter<"Mission"> | string | null
    dateSortieFicheIntervention?: DateTimeFilter<"Mission"> | Date | string
    clientId?: IntFilter<"Mission"> | number
    createdAt?: DateTimeFilter<"Mission"> | Date | string
    updatedAt?: DateTimeFilter<"Mission"> | Date | string
    client?: XOR<CustomerRelationFilter, CustomerWhereInput>
    interventions?: InterventionListRelationFilter
    rapports?: RapportMissionListRelationFilter
    devis?: QuoteListRelationFilter
  }

  export type MissionOrderByWithRelationInput = {
    numIntervention?: SortOrder
    natureIntervention?: SortOrder
    objectifDuContrat?: SortOrder
    description?: SortOrderInput | SortOrder
    priorite?: SortOrderInput | SortOrder
    statut?: SortOrderInput | SortOrder
    dateSortieFicheIntervention?: SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    client?: CustomerOrderByWithRelationInput
    interventions?: InterventionOrderByRelationAggregateInput
    rapports?: RapportMissionOrderByRelationAggregateInput
    devis?: QuoteOrderByRelationAggregateInput
  }

  export type MissionWhereUniqueInput = Prisma.AtLeast<{
    numIntervention?: string
    AND?: MissionWhereInput | MissionWhereInput[]
    OR?: MissionWhereInput[]
    NOT?: MissionWhereInput | MissionWhereInput[]
    natureIntervention?: StringFilter<"Mission"> | string
    objectifDuContrat?: StringFilter<"Mission"> | string
    description?: StringNullableFilter<"Mission"> | string | null
    priorite?: StringNullableFilter<"Mission"> | string | null
    statut?: StringNullableFilter<"Mission"> | string | null
    dateSortieFicheIntervention?: DateTimeFilter<"Mission"> | Date | string
    clientId?: IntFilter<"Mission"> | number
    createdAt?: DateTimeFilter<"Mission"> | Date | string
    updatedAt?: DateTimeFilter<"Mission"> | Date | string
    client?: XOR<CustomerRelationFilter, CustomerWhereInput>
    interventions?: InterventionListRelationFilter
    rapports?: RapportMissionListRelationFilter
    devis?: QuoteListRelationFilter
  }, "numIntervention" | "numIntervention">

  export type MissionOrderByWithAggregationInput = {
    numIntervention?: SortOrder
    natureIntervention?: SortOrder
    objectifDuContrat?: SortOrder
    description?: SortOrderInput | SortOrder
    priorite?: SortOrderInput | SortOrder
    statut?: SortOrderInput | SortOrder
    dateSortieFicheIntervention?: SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MissionCountOrderByAggregateInput
    _avg?: MissionAvgOrderByAggregateInput
    _max?: MissionMaxOrderByAggregateInput
    _min?: MissionMinOrderByAggregateInput
    _sum?: MissionSumOrderByAggregateInput
  }

  export type MissionScalarWhereWithAggregatesInput = {
    AND?: MissionScalarWhereWithAggregatesInput | MissionScalarWhereWithAggregatesInput[]
    OR?: MissionScalarWhereWithAggregatesInput[]
    NOT?: MissionScalarWhereWithAggregatesInput | MissionScalarWhereWithAggregatesInput[]
    numIntervention?: StringWithAggregatesFilter<"Mission"> | string
    natureIntervention?: StringWithAggregatesFilter<"Mission"> | string
    objectifDuContrat?: StringWithAggregatesFilter<"Mission"> | string
    description?: StringNullableWithAggregatesFilter<"Mission"> | string | null
    priorite?: StringNullableWithAggregatesFilter<"Mission"> | string | null
    statut?: StringNullableWithAggregatesFilter<"Mission"> | string | null
    dateSortieFicheIntervention?: DateTimeWithAggregatesFilter<"Mission"> | Date | string
    clientId?: IntWithAggregatesFilter<"Mission"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Mission"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Mission"> | Date | string
  }

  export type InterventionWhereInput = {
    AND?: InterventionWhereInput | InterventionWhereInput[]
    OR?: InterventionWhereInput[]
    NOT?: InterventionWhereInput | InterventionWhereInput[]
    id?: IntFilter<"Intervention"> | number
    dateHeureDebut?: DateTimeFilter<"Intervention"> | Date | string
    dateHeureFin?: DateTimeNullableFilter<"Intervention"> | Date | string | null
    duree?: IntNullableFilter<"Intervention"> | number | null
    missionId?: StringFilter<"Intervention"> | string
    statut?: StringFilter<"Intervention"> | string
    commentaire?: StringNullableFilter<"Intervention"> | string | null
    createdAt?: DateTimeFilter<"Intervention"> | Date | string
    updatedAt?: DateTimeFilter<"Intervention"> | Date | string
    mission?: XOR<MissionRelationFilter, MissionWhereInput>
    techniciens?: TechnicienInterventionListRelationFilter
    rapports?: RapportMissionListRelationFilter
    sortiesMateriels?: SortieMaterielListRelationFilter
  }

  export type InterventionOrderByWithRelationInput = {
    id?: SortOrder
    dateHeureDebut?: SortOrder
    dateHeureFin?: SortOrderInput | SortOrder
    duree?: SortOrderInput | SortOrder
    missionId?: SortOrder
    statut?: SortOrder
    commentaire?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    mission?: MissionOrderByWithRelationInput
    techniciens?: TechnicienInterventionOrderByRelationAggregateInput
    rapports?: RapportMissionOrderByRelationAggregateInput
    sortiesMateriels?: SortieMaterielOrderByRelationAggregateInput
  }

  export type InterventionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: InterventionWhereInput | InterventionWhereInput[]
    OR?: InterventionWhereInput[]
    NOT?: InterventionWhereInput | InterventionWhereInput[]
    dateHeureDebut?: DateTimeFilter<"Intervention"> | Date | string
    dateHeureFin?: DateTimeNullableFilter<"Intervention"> | Date | string | null
    duree?: IntNullableFilter<"Intervention"> | number | null
    missionId?: StringFilter<"Intervention"> | string
    statut?: StringFilter<"Intervention"> | string
    commentaire?: StringNullableFilter<"Intervention"> | string | null
    createdAt?: DateTimeFilter<"Intervention"> | Date | string
    updatedAt?: DateTimeFilter<"Intervention"> | Date | string
    mission?: XOR<MissionRelationFilter, MissionWhereInput>
    techniciens?: TechnicienInterventionListRelationFilter
    rapports?: RapportMissionListRelationFilter
    sortiesMateriels?: SortieMaterielListRelationFilter
  }, "id">

  export type InterventionOrderByWithAggregationInput = {
    id?: SortOrder
    dateHeureDebut?: SortOrder
    dateHeureFin?: SortOrderInput | SortOrder
    duree?: SortOrderInput | SortOrder
    missionId?: SortOrder
    statut?: SortOrder
    commentaire?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InterventionCountOrderByAggregateInput
    _avg?: InterventionAvgOrderByAggregateInput
    _max?: InterventionMaxOrderByAggregateInput
    _min?: InterventionMinOrderByAggregateInput
    _sum?: InterventionSumOrderByAggregateInput
  }

  export type InterventionScalarWhereWithAggregatesInput = {
    AND?: InterventionScalarWhereWithAggregatesInput | InterventionScalarWhereWithAggregatesInput[]
    OR?: InterventionScalarWhereWithAggregatesInput[]
    NOT?: InterventionScalarWhereWithAggregatesInput | InterventionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Intervention"> | number
    dateHeureDebut?: DateTimeWithAggregatesFilter<"Intervention"> | Date | string
    dateHeureFin?: DateTimeNullableWithAggregatesFilter<"Intervention"> | Date | string | null
    duree?: IntNullableWithAggregatesFilter<"Intervention"> | number | null
    missionId?: StringWithAggregatesFilter<"Intervention"> | string
    statut?: StringWithAggregatesFilter<"Intervention"> | string
    commentaire?: StringNullableWithAggregatesFilter<"Intervention"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Intervention"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Intervention"> | Date | string
  }

  export type TechnicienInterventionWhereInput = {
    AND?: TechnicienInterventionWhereInput | TechnicienInterventionWhereInput[]
    OR?: TechnicienInterventionWhereInput[]
    NOT?: TechnicienInterventionWhereInput | TechnicienInterventionWhereInput[]
    id?: IntFilter<"TechnicienIntervention"> | number
    technicienId?: IntFilter<"TechnicienIntervention"> | number
    interventionId?: IntFilter<"TechnicienIntervention"> | number
    role?: StringFilter<"TechnicienIntervention"> | string
    commentaire?: StringNullableFilter<"TechnicienIntervention"> | string | null
    createdAt?: DateTimeFilter<"TechnicienIntervention"> | Date | string
    technicien?: XOR<TechnicienRelationFilter, TechnicienWhereInput>
    intervention?: XOR<InterventionRelationFilter, InterventionWhereInput>
  }

  export type TechnicienInterventionOrderByWithRelationInput = {
    id?: SortOrder
    technicienId?: SortOrder
    interventionId?: SortOrder
    role?: SortOrder
    commentaire?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    technicien?: TechnicienOrderByWithRelationInput
    intervention?: InterventionOrderByWithRelationInput
  }

  export type TechnicienInterventionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    technicienId_interventionId?: TechnicienInterventionTechnicienIdInterventionIdCompoundUniqueInput
    AND?: TechnicienInterventionWhereInput | TechnicienInterventionWhereInput[]
    OR?: TechnicienInterventionWhereInput[]
    NOT?: TechnicienInterventionWhereInput | TechnicienInterventionWhereInput[]
    technicienId?: IntFilter<"TechnicienIntervention"> | number
    interventionId?: IntFilter<"TechnicienIntervention"> | number
    role?: StringFilter<"TechnicienIntervention"> | string
    commentaire?: StringNullableFilter<"TechnicienIntervention"> | string | null
    createdAt?: DateTimeFilter<"TechnicienIntervention"> | Date | string
    technicien?: XOR<TechnicienRelationFilter, TechnicienWhereInput>
    intervention?: XOR<InterventionRelationFilter, InterventionWhereInput>
  }, "id" | "technicienId_interventionId">

  export type TechnicienInterventionOrderByWithAggregationInput = {
    id?: SortOrder
    technicienId?: SortOrder
    interventionId?: SortOrder
    role?: SortOrder
    commentaire?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: TechnicienInterventionCountOrderByAggregateInput
    _avg?: TechnicienInterventionAvgOrderByAggregateInput
    _max?: TechnicienInterventionMaxOrderByAggregateInput
    _min?: TechnicienInterventionMinOrderByAggregateInput
    _sum?: TechnicienInterventionSumOrderByAggregateInput
  }

  export type TechnicienInterventionScalarWhereWithAggregatesInput = {
    AND?: TechnicienInterventionScalarWhereWithAggregatesInput | TechnicienInterventionScalarWhereWithAggregatesInput[]
    OR?: TechnicienInterventionScalarWhereWithAggregatesInput[]
    NOT?: TechnicienInterventionScalarWhereWithAggregatesInput | TechnicienInterventionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TechnicienIntervention"> | number
    technicienId?: IntWithAggregatesFilter<"TechnicienIntervention"> | number
    interventionId?: IntWithAggregatesFilter<"TechnicienIntervention"> | number
    role?: StringWithAggregatesFilter<"TechnicienIntervention"> | string
    commentaire?: StringNullableWithAggregatesFilter<"TechnicienIntervention"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TechnicienIntervention"> | Date | string
  }

  export type RapportMissionWhereInput = {
    AND?: RapportMissionWhereInput | RapportMissionWhereInput[]
    OR?: RapportMissionWhereInput[]
    NOT?: RapportMissionWhereInput | RapportMissionWhereInput[]
    id?: IntFilter<"RapportMission"> | number
    titre?: StringFilter<"RapportMission"> | string
    contenu?: StringFilter<"RapportMission"> | string
    interventionId?: IntNullableFilter<"RapportMission"> | number | null
    technicienId?: IntFilter<"RapportMission"> | number
    missionId?: StringFilter<"RapportMission"> | string
    createdById?: IntNullableFilter<"RapportMission"> | number | null
    statut?: StringFilter<"RapportMission"> | string
    dateValidation?: DateTimeNullableFilter<"RapportMission"> | Date | string | null
    commentaire?: StringNullableFilter<"RapportMission"> | string | null
    createdAt?: DateTimeFilter<"RapportMission"> | Date | string
    updatedAt?: DateTimeFilter<"RapportMission"> | Date | string
    intervention?: XOR<InterventionNullableRelationFilter, InterventionWhereInput> | null
    technicien?: XOR<TechnicienRelationFilter, TechnicienWhereInput>
    mission?: XOR<MissionRelationFilter, MissionWhereInput>
    images?: RapportImageListRelationFilter
  }

  export type RapportMissionOrderByWithRelationInput = {
    id?: SortOrder
    titre?: SortOrder
    contenu?: SortOrder
    interventionId?: SortOrderInput | SortOrder
    technicienId?: SortOrder
    missionId?: SortOrder
    createdById?: SortOrderInput | SortOrder
    statut?: SortOrder
    dateValidation?: SortOrderInput | SortOrder
    commentaire?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    intervention?: InterventionOrderByWithRelationInput
    technicien?: TechnicienOrderByWithRelationInput
    mission?: MissionOrderByWithRelationInput
    images?: RapportImageOrderByRelationAggregateInput
  }

  export type RapportMissionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RapportMissionWhereInput | RapportMissionWhereInput[]
    OR?: RapportMissionWhereInput[]
    NOT?: RapportMissionWhereInput | RapportMissionWhereInput[]
    titre?: StringFilter<"RapportMission"> | string
    contenu?: StringFilter<"RapportMission"> | string
    interventionId?: IntNullableFilter<"RapportMission"> | number | null
    technicienId?: IntFilter<"RapportMission"> | number
    missionId?: StringFilter<"RapportMission"> | string
    createdById?: IntNullableFilter<"RapportMission"> | number | null
    statut?: StringFilter<"RapportMission"> | string
    dateValidation?: DateTimeNullableFilter<"RapportMission"> | Date | string | null
    commentaire?: StringNullableFilter<"RapportMission"> | string | null
    createdAt?: DateTimeFilter<"RapportMission"> | Date | string
    updatedAt?: DateTimeFilter<"RapportMission"> | Date | string
    intervention?: XOR<InterventionNullableRelationFilter, InterventionWhereInput> | null
    technicien?: XOR<TechnicienRelationFilter, TechnicienWhereInput>
    mission?: XOR<MissionRelationFilter, MissionWhereInput>
    images?: RapportImageListRelationFilter
  }, "id">

  export type RapportMissionOrderByWithAggregationInput = {
    id?: SortOrder
    titre?: SortOrder
    contenu?: SortOrder
    interventionId?: SortOrderInput | SortOrder
    technicienId?: SortOrder
    missionId?: SortOrder
    createdById?: SortOrderInput | SortOrder
    statut?: SortOrder
    dateValidation?: SortOrderInput | SortOrder
    commentaire?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RapportMissionCountOrderByAggregateInput
    _avg?: RapportMissionAvgOrderByAggregateInput
    _max?: RapportMissionMaxOrderByAggregateInput
    _min?: RapportMissionMinOrderByAggregateInput
    _sum?: RapportMissionSumOrderByAggregateInput
  }

  export type RapportMissionScalarWhereWithAggregatesInput = {
    AND?: RapportMissionScalarWhereWithAggregatesInput | RapportMissionScalarWhereWithAggregatesInput[]
    OR?: RapportMissionScalarWhereWithAggregatesInput[]
    NOT?: RapportMissionScalarWhereWithAggregatesInput | RapportMissionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RapportMission"> | number
    titre?: StringWithAggregatesFilter<"RapportMission"> | string
    contenu?: StringWithAggregatesFilter<"RapportMission"> | string
    interventionId?: IntNullableWithAggregatesFilter<"RapportMission"> | number | null
    technicienId?: IntWithAggregatesFilter<"RapportMission"> | number
    missionId?: StringWithAggregatesFilter<"RapportMission"> | string
    createdById?: IntNullableWithAggregatesFilter<"RapportMission"> | number | null
    statut?: StringWithAggregatesFilter<"RapportMission"> | string
    dateValidation?: DateTimeNullableWithAggregatesFilter<"RapportMission"> | Date | string | null
    commentaire?: StringNullableWithAggregatesFilter<"RapportMission"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"RapportMission"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RapportMission"> | Date | string
  }

  export type RapportImageWhereInput = {
    AND?: RapportImageWhereInput | RapportImageWhereInput[]
    OR?: RapportImageWhereInput[]
    NOT?: RapportImageWhereInput | RapportImageWhereInput[]
    id?: IntFilter<"RapportImage"> | number
    rapportId?: IntFilter<"RapportImage"> | number
    url?: StringFilter<"RapportImage"> | string
    description?: StringNullableFilter<"RapportImage"> | string | null
    ordre?: IntFilter<"RapportImage"> | number
    createdAt?: DateTimeFilter<"RapportImage"> | Date | string
    rapport?: XOR<RapportMissionRelationFilter, RapportMissionWhereInput>
  }

  export type RapportImageOrderByWithRelationInput = {
    id?: SortOrder
    rapportId?: SortOrder
    url?: SortOrder
    description?: SortOrderInput | SortOrder
    ordre?: SortOrder
    createdAt?: SortOrder
    rapport?: RapportMissionOrderByWithRelationInput
  }

  export type RapportImageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RapportImageWhereInput | RapportImageWhereInput[]
    OR?: RapportImageWhereInput[]
    NOT?: RapportImageWhereInput | RapportImageWhereInput[]
    rapportId?: IntFilter<"RapportImage"> | number
    url?: StringFilter<"RapportImage"> | string
    description?: StringNullableFilter<"RapportImage"> | string | null
    ordre?: IntFilter<"RapportImage"> | number
    createdAt?: DateTimeFilter<"RapportImage"> | Date | string
    rapport?: XOR<RapportMissionRelationFilter, RapportMissionWhereInput>
  }, "id">

  export type RapportImageOrderByWithAggregationInput = {
    id?: SortOrder
    rapportId?: SortOrder
    url?: SortOrder
    description?: SortOrderInput | SortOrder
    ordre?: SortOrder
    createdAt?: SortOrder
    _count?: RapportImageCountOrderByAggregateInput
    _avg?: RapportImageAvgOrderByAggregateInput
    _max?: RapportImageMaxOrderByAggregateInput
    _min?: RapportImageMinOrderByAggregateInput
    _sum?: RapportImageSumOrderByAggregateInput
  }

  export type RapportImageScalarWhereWithAggregatesInput = {
    AND?: RapportImageScalarWhereWithAggregatesInput | RapportImageScalarWhereWithAggregatesInput[]
    OR?: RapportImageScalarWhereWithAggregatesInput[]
    NOT?: RapportImageScalarWhereWithAggregatesInput | RapportImageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RapportImage"> | number
    rapportId?: IntWithAggregatesFilter<"RapportImage"> | number
    url?: StringWithAggregatesFilter<"RapportImage"> | string
    description?: StringNullableWithAggregatesFilter<"RapportImage"> | string | null
    ordre?: IntWithAggregatesFilter<"RapportImage"> | number
    createdAt?: DateTimeWithAggregatesFilter<"RapportImage"> | Date | string
  }

  export type MaterielWhereInput = {
    AND?: MaterielWhereInput | MaterielWhereInput[]
    OR?: MaterielWhereInput[]
    NOT?: MaterielWhereInput | MaterielWhereInput[]
    id?: IntFilter<"Materiel"> | number
    reference?: StringFilter<"Materiel"> | string
    designation?: StringFilter<"Materiel"> | string
    description?: StringNullableFilter<"Materiel"> | string | null
    quantiteTotale?: IntFilter<"Materiel"> | number
    quantiteDisponible?: IntFilter<"Materiel"> | number
    seuilAlerte?: IntFilter<"Materiel"> | number
    emplacement?: StringNullableFilter<"Materiel"> | string | null
    categorie?: StringFilter<"Materiel"> | string
    prixUnitaire?: FloatNullableFilter<"Materiel"> | number | null
    fournisseur?: StringNullableFilter<"Materiel"> | string | null
    dateAchat?: DateTimeNullableFilter<"Materiel"> | Date | string | null
    garantie?: StringNullableFilter<"Materiel"> | string | null
    statut?: StringFilter<"Materiel"> | string
    createdAt?: DateTimeFilter<"Materiel"> | Date | string
    updatedAt?: DateTimeFilter<"Materiel"> | Date | string
    sorties?: SortieMaterielListRelationFilter
    entrees?: EntreeMaterielListRelationFilter
  }

  export type MaterielOrderByWithRelationInput = {
    id?: SortOrder
    reference?: SortOrder
    designation?: SortOrder
    description?: SortOrderInput | SortOrder
    quantiteTotale?: SortOrder
    quantiteDisponible?: SortOrder
    seuilAlerte?: SortOrder
    emplacement?: SortOrderInput | SortOrder
    categorie?: SortOrder
    prixUnitaire?: SortOrderInput | SortOrder
    fournisseur?: SortOrderInput | SortOrder
    dateAchat?: SortOrderInput | SortOrder
    garantie?: SortOrderInput | SortOrder
    statut?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sorties?: SortieMaterielOrderByRelationAggregateInput
    entrees?: EntreeMaterielOrderByRelationAggregateInput
  }

  export type MaterielWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    reference?: string
    AND?: MaterielWhereInput | MaterielWhereInput[]
    OR?: MaterielWhereInput[]
    NOT?: MaterielWhereInput | MaterielWhereInput[]
    designation?: StringFilter<"Materiel"> | string
    description?: StringNullableFilter<"Materiel"> | string | null
    quantiteTotale?: IntFilter<"Materiel"> | number
    quantiteDisponible?: IntFilter<"Materiel"> | number
    seuilAlerte?: IntFilter<"Materiel"> | number
    emplacement?: StringNullableFilter<"Materiel"> | string | null
    categorie?: StringFilter<"Materiel"> | string
    prixUnitaire?: FloatNullableFilter<"Materiel"> | number | null
    fournisseur?: StringNullableFilter<"Materiel"> | string | null
    dateAchat?: DateTimeNullableFilter<"Materiel"> | Date | string | null
    garantie?: StringNullableFilter<"Materiel"> | string | null
    statut?: StringFilter<"Materiel"> | string
    createdAt?: DateTimeFilter<"Materiel"> | Date | string
    updatedAt?: DateTimeFilter<"Materiel"> | Date | string
    sorties?: SortieMaterielListRelationFilter
    entrees?: EntreeMaterielListRelationFilter
  }, "id" | "reference">

  export type MaterielOrderByWithAggregationInput = {
    id?: SortOrder
    reference?: SortOrder
    designation?: SortOrder
    description?: SortOrderInput | SortOrder
    quantiteTotale?: SortOrder
    quantiteDisponible?: SortOrder
    seuilAlerte?: SortOrder
    emplacement?: SortOrderInput | SortOrder
    categorie?: SortOrder
    prixUnitaire?: SortOrderInput | SortOrder
    fournisseur?: SortOrderInput | SortOrder
    dateAchat?: SortOrderInput | SortOrder
    garantie?: SortOrderInput | SortOrder
    statut?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MaterielCountOrderByAggregateInput
    _avg?: MaterielAvgOrderByAggregateInput
    _max?: MaterielMaxOrderByAggregateInput
    _min?: MaterielMinOrderByAggregateInput
    _sum?: MaterielSumOrderByAggregateInput
  }

  export type MaterielScalarWhereWithAggregatesInput = {
    AND?: MaterielScalarWhereWithAggregatesInput | MaterielScalarWhereWithAggregatesInput[]
    OR?: MaterielScalarWhereWithAggregatesInput[]
    NOT?: MaterielScalarWhereWithAggregatesInput | MaterielScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Materiel"> | number
    reference?: StringWithAggregatesFilter<"Materiel"> | string
    designation?: StringWithAggregatesFilter<"Materiel"> | string
    description?: StringNullableWithAggregatesFilter<"Materiel"> | string | null
    quantiteTotale?: IntWithAggregatesFilter<"Materiel"> | number
    quantiteDisponible?: IntWithAggregatesFilter<"Materiel"> | number
    seuilAlerte?: IntWithAggregatesFilter<"Materiel"> | number
    emplacement?: StringNullableWithAggregatesFilter<"Materiel"> | string | null
    categorie?: StringWithAggregatesFilter<"Materiel"> | string
    prixUnitaire?: FloatNullableWithAggregatesFilter<"Materiel"> | number | null
    fournisseur?: StringNullableWithAggregatesFilter<"Materiel"> | string | null
    dateAchat?: DateTimeNullableWithAggregatesFilter<"Materiel"> | Date | string | null
    garantie?: StringNullableWithAggregatesFilter<"Materiel"> | string | null
    statut?: StringWithAggregatesFilter<"Materiel"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Materiel"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Materiel"> | Date | string
  }

  export type SortieMaterielWhereInput = {
    AND?: SortieMaterielWhereInput | SortieMaterielWhereInput[]
    OR?: SortieMaterielWhereInput[]
    NOT?: SortieMaterielWhereInput | SortieMaterielWhereInput[]
    id?: IntFilter<"SortieMateriel"> | number
    materielId?: IntFilter<"SortieMateriel"> | number
    interventionId?: IntFilter<"SortieMateriel"> | number
    technicienId?: IntFilter<"SortieMateriel"> | number
    quantite?: IntFilter<"SortieMateriel"> | number
    dateSortie?: DateTimeFilter<"SortieMateriel"> | Date | string
    motif?: StringNullableFilter<"SortieMateriel"> | string | null
    retourne?: BoolFilter<"SortieMateriel"> | boolean
    dateRetour?: DateTimeNullableFilter<"SortieMateriel"> | Date | string | null
    quantiteRetour?: IntNullableFilter<"SortieMateriel"> | number | null
    commentaire?: StringNullableFilter<"SortieMateriel"> | string | null
    createdAt?: DateTimeFilter<"SortieMateriel"> | Date | string
    materiel?: XOR<MaterielRelationFilter, MaterielWhereInput>
    intervention?: XOR<InterventionRelationFilter, InterventionWhereInput>
    technicien?: XOR<TechnicienRelationFilter, TechnicienWhereInput>
  }

  export type SortieMaterielOrderByWithRelationInput = {
    id?: SortOrder
    materielId?: SortOrder
    interventionId?: SortOrder
    technicienId?: SortOrder
    quantite?: SortOrder
    dateSortie?: SortOrder
    motif?: SortOrderInput | SortOrder
    retourne?: SortOrder
    dateRetour?: SortOrderInput | SortOrder
    quantiteRetour?: SortOrderInput | SortOrder
    commentaire?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    materiel?: MaterielOrderByWithRelationInput
    intervention?: InterventionOrderByWithRelationInput
    technicien?: TechnicienOrderByWithRelationInput
  }

  export type SortieMaterielWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SortieMaterielWhereInput | SortieMaterielWhereInput[]
    OR?: SortieMaterielWhereInput[]
    NOT?: SortieMaterielWhereInput | SortieMaterielWhereInput[]
    materielId?: IntFilter<"SortieMateriel"> | number
    interventionId?: IntFilter<"SortieMateriel"> | number
    technicienId?: IntFilter<"SortieMateriel"> | number
    quantite?: IntFilter<"SortieMateriel"> | number
    dateSortie?: DateTimeFilter<"SortieMateriel"> | Date | string
    motif?: StringNullableFilter<"SortieMateriel"> | string | null
    retourne?: BoolFilter<"SortieMateriel"> | boolean
    dateRetour?: DateTimeNullableFilter<"SortieMateriel"> | Date | string | null
    quantiteRetour?: IntNullableFilter<"SortieMateriel"> | number | null
    commentaire?: StringNullableFilter<"SortieMateriel"> | string | null
    createdAt?: DateTimeFilter<"SortieMateriel"> | Date | string
    materiel?: XOR<MaterielRelationFilter, MaterielWhereInput>
    intervention?: XOR<InterventionRelationFilter, InterventionWhereInput>
    technicien?: XOR<TechnicienRelationFilter, TechnicienWhereInput>
  }, "id">

  export type SortieMaterielOrderByWithAggregationInput = {
    id?: SortOrder
    materielId?: SortOrder
    interventionId?: SortOrder
    technicienId?: SortOrder
    quantite?: SortOrder
    dateSortie?: SortOrder
    motif?: SortOrderInput | SortOrder
    retourne?: SortOrder
    dateRetour?: SortOrderInput | SortOrder
    quantiteRetour?: SortOrderInput | SortOrder
    commentaire?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: SortieMaterielCountOrderByAggregateInput
    _avg?: SortieMaterielAvgOrderByAggregateInput
    _max?: SortieMaterielMaxOrderByAggregateInput
    _min?: SortieMaterielMinOrderByAggregateInput
    _sum?: SortieMaterielSumOrderByAggregateInput
  }

  export type SortieMaterielScalarWhereWithAggregatesInput = {
    AND?: SortieMaterielScalarWhereWithAggregatesInput | SortieMaterielScalarWhereWithAggregatesInput[]
    OR?: SortieMaterielScalarWhereWithAggregatesInput[]
    NOT?: SortieMaterielScalarWhereWithAggregatesInput | SortieMaterielScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SortieMateriel"> | number
    materielId?: IntWithAggregatesFilter<"SortieMateriel"> | number
    interventionId?: IntWithAggregatesFilter<"SortieMateriel"> | number
    technicienId?: IntWithAggregatesFilter<"SortieMateriel"> | number
    quantite?: IntWithAggregatesFilter<"SortieMateriel"> | number
    dateSortie?: DateTimeWithAggregatesFilter<"SortieMateriel"> | Date | string
    motif?: StringNullableWithAggregatesFilter<"SortieMateriel"> | string | null
    retourne?: BoolWithAggregatesFilter<"SortieMateriel"> | boolean
    dateRetour?: DateTimeNullableWithAggregatesFilter<"SortieMateriel"> | Date | string | null
    quantiteRetour?: IntNullableWithAggregatesFilter<"SortieMateriel"> | number | null
    commentaire?: StringNullableWithAggregatesFilter<"SortieMateriel"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SortieMateriel"> | Date | string
  }

  export type EntreeMaterielWhereInput = {
    AND?: EntreeMaterielWhereInput | EntreeMaterielWhereInput[]
    OR?: EntreeMaterielWhereInput[]
    NOT?: EntreeMaterielWhereInput | EntreeMaterielWhereInput[]
    id?: IntFilter<"EntreeMateriel"> | number
    materielId?: IntFilter<"EntreeMateriel"> | number
    quantite?: IntFilter<"EntreeMateriel"> | number
    dateEntree?: DateTimeFilter<"EntreeMateriel"> | Date | string
    source?: StringFilter<"EntreeMateriel"> | string
    prixTotal?: FloatNullableFilter<"EntreeMateriel"> | number | null
    fournisseur?: StringNullableFilter<"EntreeMateriel"> | string | null
    facture?: StringNullableFilter<"EntreeMateriel"> | string | null
    commentaire?: StringNullableFilter<"EntreeMateriel"> | string | null
    createdAt?: DateTimeFilter<"EntreeMateriel"> | Date | string
    materiel?: XOR<MaterielRelationFilter, MaterielWhereInput>
  }

  export type EntreeMaterielOrderByWithRelationInput = {
    id?: SortOrder
    materielId?: SortOrder
    quantite?: SortOrder
    dateEntree?: SortOrder
    source?: SortOrder
    prixTotal?: SortOrderInput | SortOrder
    fournisseur?: SortOrderInput | SortOrder
    facture?: SortOrderInput | SortOrder
    commentaire?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    materiel?: MaterielOrderByWithRelationInput
  }

  export type EntreeMaterielWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EntreeMaterielWhereInput | EntreeMaterielWhereInput[]
    OR?: EntreeMaterielWhereInput[]
    NOT?: EntreeMaterielWhereInput | EntreeMaterielWhereInput[]
    materielId?: IntFilter<"EntreeMateriel"> | number
    quantite?: IntFilter<"EntreeMateriel"> | number
    dateEntree?: DateTimeFilter<"EntreeMateriel"> | Date | string
    source?: StringFilter<"EntreeMateriel"> | string
    prixTotal?: FloatNullableFilter<"EntreeMateriel"> | number | null
    fournisseur?: StringNullableFilter<"EntreeMateriel"> | string | null
    facture?: StringNullableFilter<"EntreeMateriel"> | string | null
    commentaire?: StringNullableFilter<"EntreeMateriel"> | string | null
    createdAt?: DateTimeFilter<"EntreeMateriel"> | Date | string
    materiel?: XOR<MaterielRelationFilter, MaterielWhereInput>
  }, "id">

  export type EntreeMaterielOrderByWithAggregationInput = {
    id?: SortOrder
    materielId?: SortOrder
    quantite?: SortOrder
    dateEntree?: SortOrder
    source?: SortOrder
    prixTotal?: SortOrderInput | SortOrder
    fournisseur?: SortOrderInput | SortOrder
    facture?: SortOrderInput | SortOrder
    commentaire?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: EntreeMaterielCountOrderByAggregateInput
    _avg?: EntreeMaterielAvgOrderByAggregateInput
    _max?: EntreeMaterielMaxOrderByAggregateInput
    _min?: EntreeMaterielMinOrderByAggregateInput
    _sum?: EntreeMaterielSumOrderByAggregateInput
  }

  export type EntreeMaterielScalarWhereWithAggregatesInput = {
    AND?: EntreeMaterielScalarWhereWithAggregatesInput | EntreeMaterielScalarWhereWithAggregatesInput[]
    OR?: EntreeMaterielScalarWhereWithAggregatesInput[]
    NOT?: EntreeMaterielScalarWhereWithAggregatesInput | EntreeMaterielScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EntreeMateriel"> | number
    materielId?: IntWithAggregatesFilter<"EntreeMateriel"> | number
    quantite?: IntWithAggregatesFilter<"EntreeMateriel"> | number
    dateEntree?: DateTimeWithAggregatesFilter<"EntreeMateriel"> | Date | string
    source?: StringWithAggregatesFilter<"EntreeMateriel"> | string
    prixTotal?: FloatNullableWithAggregatesFilter<"EntreeMateriel"> | number | null
    fournisseur?: StringNullableWithAggregatesFilter<"EntreeMateriel"> | string | null
    facture?: StringNullableWithAggregatesFilter<"EntreeMateriel"> | string | null
    commentaire?: StringNullableWithAggregatesFilter<"EntreeMateriel"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"EntreeMateriel"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: IntFilter<"Notification"> | number
    type?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    data?: StringNullableFilter<"Notification"> | string | null
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    userId?: IntFilter<"Notification"> | number
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    message?: SortOrder
    data?: SortOrderInput | SortOrder
    readAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    type?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    data?: StringNullableFilter<"Notification"> | string | null
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    userId?: IntFilter<"Notification"> | number
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    message?: SortOrder
    data?: SortOrderInput | SortOrder
    readAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _avg?: NotificationAvgOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
    _sum?: NotificationSumOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Notification"> | number
    type?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    data?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    readAt?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    userId?: IntWithAggregatesFilter<"Notification"> | number
  }

  export type ServiceCreateInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutServiceInput
    customers?: CustomerCreateNestedManyWithoutServiceInput
    employees?: EmployeeCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutServiceInput
    customers?: CustomerUncheckedCreateNestedManyWithoutServiceInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutServiceNestedInput
    customers?: CustomerUpdateManyWithoutServiceNestedInput
    employees?: EmployeeUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutServiceNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutServiceNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    preferences?: string | null
    permissions?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    service?: ServiceCreateNestedOneWithoutUsersInput
    createdCustomers?: CustomerCreateNestedManyWithoutCreatorInput
    createdQuotes?: QuoteCreateNestedManyWithoutCreatorInput
    createdInvoices?: InvoiceCreateNestedManyWithoutCreatorInput
    createdPayments?: PaymentCreateNestedManyWithoutCreatorInput
    serviceApprovals?: QuoteCreateNestedManyWithoutServiceManagerInput
    dgApprovals?: QuoteCreateNestedManyWithoutDgApproverInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    quoteApprovals?: QuoteApprovalCreateNestedManyWithoutApproverInput
    createdExpenses?: ExpenseCreateNestedManyWithoutCreatorInput
    accountingEntries?: AccountingEntryCreateNestedManyWithoutCreatorInput
    cashFlowEntries?: CashFlowCreateNestedManyWithoutCreatorInput
    createdReminders?: ReminderCreateNestedManyWithoutCreatorInput
    createdRecurringInvoices?: RecurringInvoiceCreateNestedManyWithoutCreatorInput
    employee?: EmployeeCreateNestedOneWithoutUserInput
    leaveApprovals?: LeaveRequestCreateNestedManyWithoutApprovedByInput
    assignedProspects?: ProspectCreateNestedManyWithoutAssignedUserInput
    createdProspects?: ProspectCreateNestedManyWithoutCreatorInput
    createdProspectActivities?: ProspectActivityCreateNestedManyWithoutCreatorInput
    technicien?: TechnicienCreateNestedOneWithoutUtilisateurInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    serviceId?: number | null
    isActive?: boolean
    lastLogin?: Date | string | null
    preferences?: string | null
    permissions?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdCustomers?: CustomerUncheckedCreateNestedManyWithoutCreatorInput
    createdQuotes?: QuoteUncheckedCreateNestedManyWithoutCreatorInput
    createdInvoices?: InvoiceUncheckedCreateNestedManyWithoutCreatorInput
    createdPayments?: PaymentUncheckedCreateNestedManyWithoutCreatorInput
    serviceApprovals?: QuoteUncheckedCreateNestedManyWithoutServiceManagerInput
    dgApprovals?: QuoteUncheckedCreateNestedManyWithoutDgApproverInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    quoteApprovals?: QuoteApprovalUncheckedCreateNestedManyWithoutApproverInput
    createdExpenses?: ExpenseUncheckedCreateNestedManyWithoutCreatorInput
    accountingEntries?: AccountingEntryUncheckedCreateNestedManyWithoutCreatorInput
    cashFlowEntries?: CashFlowUncheckedCreateNestedManyWithoutCreatorInput
    createdReminders?: ReminderUncheckedCreateNestedManyWithoutCreatorInput
    createdRecurringInvoices?: RecurringInvoiceUncheckedCreateNestedManyWithoutCreatorInput
    employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    leaveApprovals?: LeaveRequestUncheckedCreateNestedManyWithoutApprovedByInput
    assignedProspects?: ProspectUncheckedCreateNestedManyWithoutAssignedUserInput
    createdProspects?: ProspectUncheckedCreateNestedManyWithoutCreatorInput
    createdProspectActivities?: ProspectActivityUncheckedCreateNestedManyWithoutCreatorInput
    technicien?: TechnicienUncheckedCreateNestedOneWithoutUtilisateurInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneWithoutUsersNestedInput
    createdCustomers?: CustomerUpdateManyWithoutCreatorNestedInput
    createdQuotes?: QuoteUpdateManyWithoutCreatorNestedInput
    createdInvoices?: InvoiceUpdateManyWithoutCreatorNestedInput
    createdPayments?: PaymentUpdateManyWithoutCreatorNestedInput
    serviceApprovals?: QuoteUpdateManyWithoutServiceManagerNestedInput
    dgApprovals?: QuoteUpdateManyWithoutDgApproverNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    quoteApprovals?: QuoteApprovalUpdateManyWithoutApproverNestedInput
    createdExpenses?: ExpenseUpdateManyWithoutCreatorNestedInput
    accountingEntries?: AccountingEntryUpdateManyWithoutCreatorNestedInput
    cashFlowEntries?: CashFlowUpdateManyWithoutCreatorNestedInput
    createdReminders?: ReminderUpdateManyWithoutCreatorNestedInput
    createdRecurringInvoices?: RecurringInvoiceUpdateManyWithoutCreatorNestedInput
    employee?: EmployeeUpdateOneWithoutUserNestedInput
    leaveApprovals?: LeaveRequestUpdateManyWithoutApprovedByNestedInput
    assignedProspects?: ProspectUpdateManyWithoutAssignedUserNestedInput
    createdProspects?: ProspectUpdateManyWithoutCreatorNestedInput
    createdProspectActivities?: ProspectActivityUpdateManyWithoutCreatorNestedInput
    technicien?: TechnicienUpdateOneWithoutUtilisateurNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    serviceId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdCustomers?: CustomerUncheckedUpdateManyWithoutCreatorNestedInput
    createdQuotes?: QuoteUncheckedUpdateManyWithoutCreatorNestedInput
    createdInvoices?: InvoiceUncheckedUpdateManyWithoutCreatorNestedInput
    createdPayments?: PaymentUncheckedUpdateManyWithoutCreatorNestedInput
    serviceApprovals?: QuoteUncheckedUpdateManyWithoutServiceManagerNestedInput
    dgApprovals?: QuoteUncheckedUpdateManyWithoutDgApproverNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    quoteApprovals?: QuoteApprovalUncheckedUpdateManyWithoutApproverNestedInput
    createdExpenses?: ExpenseUncheckedUpdateManyWithoutCreatorNestedInput
    accountingEntries?: AccountingEntryUncheckedUpdateManyWithoutCreatorNestedInput
    cashFlowEntries?: CashFlowUncheckedUpdateManyWithoutCreatorNestedInput
    createdReminders?: ReminderUncheckedUpdateManyWithoutCreatorNestedInput
    createdRecurringInvoices?: RecurringInvoiceUncheckedUpdateManyWithoutCreatorNestedInput
    employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    leaveApprovals?: LeaveRequestUncheckedUpdateManyWithoutApprovedByNestedInput
    assignedProspects?: ProspectUncheckedUpdateManyWithoutAssignedUserNestedInput
    createdProspects?: ProspectUncheckedUpdateManyWithoutCreatorNestedInput
    createdProspectActivities?: ProspectActivityUncheckedUpdateManyWithoutCreatorNestedInput
    technicien?: TechnicienUncheckedUpdateOneWithoutUtilisateurNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    serviceId?: number | null
    isActive?: boolean
    lastLogin?: Date | string | null
    preferences?: string | null
    permissions?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    serviceId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerCreateInput = {
    customerNumber: string
    type?: $Enums.CustomerType
    name: string
    legalName?: string | null
    siret?: string | null
    vatNumber?: string | null
    email?: string | null
    phone?: string | null
    mobile?: string | null
    website?: string | null
    paymentTerms?: number
    paymentMethod?: $Enums.PaymentMethod
    creditLimit?: number
    discountRate?: number
    category?: string | null
    tags?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    service?: ServiceCreateNestedOneWithoutCustomersInput
    creator: UserCreateNestedOneWithoutCreatedCustomersInput
    addresses?: CustomerAddressCreateNestedManyWithoutCustomerInput
    quotes?: QuoteCreateNestedManyWithoutCustomerInput
    invoices?: InvoiceCreateNestedManyWithoutCustomerInput
    payments?: PaymentCreateNestedManyWithoutCustomerInput
    recurringInvoices?: RecurringInvoiceCreateNestedManyWithoutCustomerInput
    missions?: MissionCreateNestedManyWithoutClientInput
  }

  export type CustomerUncheckedCreateInput = {
    id?: number
    customerNumber: string
    type?: $Enums.CustomerType
    name: string
    legalName?: string | null
    siret?: string | null
    vatNumber?: string | null
    email?: string | null
    phone?: string | null
    mobile?: string | null
    website?: string | null
    paymentTerms?: number
    paymentMethod?: $Enums.PaymentMethod
    creditLimit?: number
    discountRate?: number
    category?: string | null
    tags?: string | null
    notes?: string | null
    isActive?: boolean
    serviceId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: number
    addresses?: CustomerAddressUncheckedCreateNestedManyWithoutCustomerInput
    quotes?: QuoteUncheckedCreateNestedManyWithoutCustomerInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCustomerInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCustomerInput
    recurringInvoices?: RecurringInvoiceUncheckedCreateNestedManyWithoutCustomerInput
    missions?: MissionUncheckedCreateNestedManyWithoutClientInput
  }

  export type CustomerUpdateInput = {
    customerNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    siret?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: IntFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    creditLimit?: FloatFieldUpdateOperationsInput | number
    discountRate?: FloatFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneWithoutCustomersNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedCustomersNestedInput
    addresses?: CustomerAddressUpdateManyWithoutCustomerNestedInput
    quotes?: QuoteUpdateManyWithoutCustomerNestedInput
    invoices?: InvoiceUpdateManyWithoutCustomerNestedInput
    payments?: PaymentUpdateManyWithoutCustomerNestedInput
    recurringInvoices?: RecurringInvoiceUpdateManyWithoutCustomerNestedInput
    missions?: MissionUpdateManyWithoutClientNestedInput
  }

  export type CustomerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    siret?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: IntFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    creditLimit?: FloatFieldUpdateOperationsInput | number
    discountRate?: FloatFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    serviceId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    addresses?: CustomerAddressUncheckedUpdateManyWithoutCustomerNestedInput
    quotes?: QuoteUncheckedUpdateManyWithoutCustomerNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCustomerNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCustomerNestedInput
    recurringInvoices?: RecurringInvoiceUncheckedUpdateManyWithoutCustomerNestedInput
    missions?: MissionUncheckedUpdateManyWithoutClientNestedInput
  }

  export type CustomerCreateManyInput = {
    id?: number
    customerNumber: string
    type?: $Enums.CustomerType
    name: string
    legalName?: string | null
    siret?: string | null
    vatNumber?: string | null
    email?: string | null
    phone?: string | null
    mobile?: string | null
    website?: string | null
    paymentTerms?: number
    paymentMethod?: $Enums.PaymentMethod
    creditLimit?: number
    discountRate?: number
    category?: string | null
    tags?: string | null
    notes?: string | null
    isActive?: boolean
    serviceId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: number
  }

  export type CustomerUpdateManyMutationInput = {
    customerNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    siret?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: IntFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    creditLimit?: FloatFieldUpdateOperationsInput | number
    discountRate?: FloatFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    siret?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: IntFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    creditLimit?: FloatFieldUpdateOperationsInput | number
    discountRate?: FloatFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    serviceId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
  }

  export type CustomerAddressCreateInput = {
    type: $Enums.AddressType
    name?: string | null
    addressLine1: string
    addressLine2?: string | null
    postalCode: string
    city: string
    country?: string
    isDefault?: boolean
    createdAt?: Date | string
    customer: CustomerCreateNestedOneWithoutAddressesInput
    quotes?: QuoteCreateNestedManyWithoutCustomerAddressInput
    invoices?: InvoiceCreateNestedManyWithoutCustomerAddressInput
  }

  export type CustomerAddressUncheckedCreateInput = {
    id?: number
    customerId: number
    type: $Enums.AddressType
    name?: string | null
    addressLine1: string
    addressLine2?: string | null
    postalCode: string
    city: string
    country?: string
    isDefault?: boolean
    createdAt?: Date | string
    quotes?: QuoteUncheckedCreateNestedManyWithoutCustomerAddressInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCustomerAddressInput
  }

  export type CustomerAddressUpdateInput = {
    type?: EnumAddressTypeFieldUpdateOperationsInput | $Enums.AddressType
    name?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutAddressesNestedInput
    quotes?: QuoteUpdateManyWithoutCustomerAddressNestedInput
    invoices?: InvoiceUpdateManyWithoutCustomerAddressNestedInput
  }

  export type CustomerAddressUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    type?: EnumAddressTypeFieldUpdateOperationsInput | $Enums.AddressType
    name?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotes?: QuoteUncheckedUpdateManyWithoutCustomerAddressNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCustomerAddressNestedInput
  }

  export type CustomerAddressCreateManyInput = {
    id?: number
    customerId: number
    type: $Enums.AddressType
    name?: string | null
    addressLine1: string
    addressLine2?: string | null
    postalCode: string
    city: string
    country?: string
    isDefault?: boolean
    createdAt?: Date | string
  }

  export type CustomerAddressUpdateManyMutationInput = {
    type?: EnumAddressTypeFieldUpdateOperationsInput | $Enums.AddressType
    name?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerAddressUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    type?: EnumAddressTypeFieldUpdateOperationsInput | $Enums.AddressType
    name?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateInput = {
    sku: string
    name: string
    description?: string | null
    type?: $Enums.ProductType
    category?: string | null
    unit?: string
    priceHt: number
    vatRate?: number
    costPrice?: number | null
    stockQuantity?: number
    stockAlertThreshold?: number
    isActive?: boolean
    weight?: number | null
    dimensions?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    prices?: ProductPriceCreateNestedManyWithoutProductInput
    quoteItems?: QuoteItemCreateNestedManyWithoutProductInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutProductInput
    recurringInvoiceItems?: RecurringInvoiceItemCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: number
    sku: string
    name: string
    description?: string | null
    type?: $Enums.ProductType
    category?: string | null
    unit?: string
    priceHt: number
    vatRate?: number
    costPrice?: number | null
    stockQuantity?: number
    stockAlertThreshold?: number
    isActive?: boolean
    weight?: number | null
    dimensions?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    prices?: ProductPriceUncheckedCreateNestedManyWithoutProductInput
    quoteItems?: QuoteItemUncheckedCreateNestedManyWithoutProductInput
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutProductInput
    recurringInvoiceItems?: RecurringInvoiceItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    category?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    priceHt?: FloatFieldUpdateOperationsInput | number
    vatRate?: FloatFieldUpdateOperationsInput | number
    costPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    stockAlertThreshold?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    dimensions?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prices?: ProductPriceUpdateManyWithoutProductNestedInput
    quoteItems?: QuoteItemUpdateManyWithoutProductNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutProductNestedInput
    recurringInvoiceItems?: RecurringInvoiceItemUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    category?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    priceHt?: FloatFieldUpdateOperationsInput | number
    vatRate?: FloatFieldUpdateOperationsInput | number
    costPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    stockAlertThreshold?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    dimensions?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prices?: ProductPriceUncheckedUpdateManyWithoutProductNestedInput
    quoteItems?: QuoteItemUncheckedUpdateManyWithoutProductNestedInput
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutProductNestedInput
    recurringInvoiceItems?: RecurringInvoiceItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: number
    sku: string
    name: string
    description?: string | null
    type?: $Enums.ProductType
    category?: string | null
    unit?: string
    priceHt: number
    vatRate?: number
    costPrice?: number | null
    stockQuantity?: number
    stockAlertThreshold?: number
    isActive?: boolean
    weight?: number | null
    dimensions?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUpdateManyMutationInput = {
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    category?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    priceHt?: FloatFieldUpdateOperationsInput | number
    vatRate?: FloatFieldUpdateOperationsInput | number
    costPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    stockAlertThreshold?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    dimensions?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    category?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    priceHt?: FloatFieldUpdateOperationsInput | number
    vatRate?: FloatFieldUpdateOperationsInput | number
    costPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    stockAlertThreshold?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    dimensions?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductPriceCreateInput = {
    customerCategory?: string | null
    minQuantity?: number
    priceHt: number
    validFrom?: Date | string | null
    validUntil?: Date | string | null
    createdAt?: Date | string
    product: ProductCreateNestedOneWithoutPricesInput
  }

  export type ProductPriceUncheckedCreateInput = {
    id?: number
    productId: number
    customerCategory?: string | null
    minQuantity?: number
    priceHt: number
    validFrom?: Date | string | null
    validUntil?: Date | string | null
    createdAt?: Date | string
  }

  export type ProductPriceUpdateInput = {
    customerCategory?: NullableStringFieldUpdateOperationsInput | string | null
    minQuantity?: IntFieldUpdateOperationsInput | number
    priceHt?: FloatFieldUpdateOperationsInput | number
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutPricesNestedInput
  }

  export type ProductPriceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    customerCategory?: NullableStringFieldUpdateOperationsInput | string | null
    minQuantity?: IntFieldUpdateOperationsInput | number
    priceHt?: FloatFieldUpdateOperationsInput | number
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductPriceCreateManyInput = {
    id?: number
    productId: number
    customerCategory?: string | null
    minQuantity?: number
    priceHt: number
    validFrom?: Date | string | null
    validUntil?: Date | string | null
    createdAt?: Date | string
  }

  export type ProductPriceUpdateManyMutationInput = {
    customerCategory?: NullableStringFieldUpdateOperationsInput | string | null
    minQuantity?: IntFieldUpdateOperationsInput | number
    priceHt?: FloatFieldUpdateOperationsInput | number
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductPriceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    customerCategory?: NullableStringFieldUpdateOperationsInput | string | null
    minQuantity?: IntFieldUpdateOperationsInput | number
    priceHt?: FloatFieldUpdateOperationsInput | number
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuoteCreateInput = {
    quoteNumber: string
    status?: $Enums.QuoteStatus
    quoteDate: Date | string
    validUntil: Date | string
    subtotalHt?: number
    discountAmount?: number
    totalVat?: number
    totalTtc?: number
    terms?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt?: Date | string | null
    submittedForServiceApprovalAt?: Date | string | null
    serviceManagerApprovalDate?: Date | string | null
    serviceManagerComments?: string | null
    dgApprovalDate?: Date | string | null
    dgComments?: string | null
    acceptedAt?: Date | string | null
    customer: CustomerCreateNestedOneWithoutQuotesInput
    customerAddress?: CustomerAddressCreateNestedOneWithoutQuotesInput
    creator: UserCreateNestedOneWithoutCreatedQuotesInput
    serviceManager?: UserCreateNestedOneWithoutServiceApprovalsInput
    dgApprover?: UserCreateNestedOneWithoutDgApprovalsInput
    items?: QuoteItemCreateNestedManyWithoutQuoteInput
    invoices?: InvoiceCreateNestedManyWithoutQuoteInput
    approvals?: QuoteApprovalCreateNestedManyWithoutQuoteInput
    missions?: MissionCreateNestedManyWithoutDevisInput
  }

  export type QuoteUncheckedCreateInput = {
    id?: number
    quoteNumber: string
    customerId: number
    customerAddressId?: number | null
    status?: $Enums.QuoteStatus
    quoteDate: Date | string
    validUntil: Date | string
    subtotalHt?: number
    discountAmount?: number
    totalVat?: number
    totalTtc?: number
    terms?: string | null
    notes?: string | null
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt?: Date | string | null
    submittedForServiceApprovalAt?: Date | string | null
    serviceManagerApprovedBy?: number | null
    serviceManagerApprovalDate?: Date | string | null
    serviceManagerComments?: string | null
    dgApprovedBy?: number | null
    dgApprovalDate?: Date | string | null
    dgComments?: string | null
    acceptedAt?: Date | string | null
    items?: QuoteItemUncheckedCreateNestedManyWithoutQuoteInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutQuoteInput
    approvals?: QuoteApprovalUncheckedCreateNestedManyWithoutQuoteInput
    missions?: MissionUncheckedCreateNestedManyWithoutDevisInput
  }

  export type QuoteUpdateInput = {
    quoteNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    quoteDate?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotalHt?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalVat?: FloatFieldUpdateOperationsInput | number
    totalTtc?: FloatFieldUpdateOperationsInput | number
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedForServiceApprovalAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceManagerApprovalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceManagerComments?: NullableStringFieldUpdateOperationsInput | string | null
    dgApprovalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dgComments?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customer?: CustomerUpdateOneRequiredWithoutQuotesNestedInput
    customerAddress?: CustomerAddressUpdateOneWithoutQuotesNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedQuotesNestedInput
    serviceManager?: UserUpdateOneWithoutServiceApprovalsNestedInput
    dgApprover?: UserUpdateOneWithoutDgApprovalsNestedInput
    items?: QuoteItemUpdateManyWithoutQuoteNestedInput
    invoices?: InvoiceUpdateManyWithoutQuoteNestedInput
    approvals?: QuoteApprovalUpdateManyWithoutQuoteNestedInput
    missions?: MissionUpdateManyWithoutDevisNestedInput
  }

  export type QuoteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    quoteNumber?: StringFieldUpdateOperationsInput | string
    customerId?: IntFieldUpdateOperationsInput | number
    customerAddressId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    quoteDate?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotalHt?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalVat?: FloatFieldUpdateOperationsInput | number
    totalTtc?: FloatFieldUpdateOperationsInput | number
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedForServiceApprovalAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceManagerApprovedBy?: NullableIntFieldUpdateOperationsInput | number | null
    serviceManagerApprovalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceManagerComments?: NullableStringFieldUpdateOperationsInput | string | null
    dgApprovedBy?: NullableIntFieldUpdateOperationsInput | number | null
    dgApprovalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dgComments?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: QuoteItemUncheckedUpdateManyWithoutQuoteNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutQuoteNestedInput
    approvals?: QuoteApprovalUncheckedUpdateManyWithoutQuoteNestedInput
    missions?: MissionUncheckedUpdateManyWithoutDevisNestedInput
  }

  export type QuoteCreateManyInput = {
    id?: number
    quoteNumber: string
    customerId: number
    customerAddressId?: number | null
    status?: $Enums.QuoteStatus
    quoteDate: Date | string
    validUntil: Date | string
    subtotalHt?: number
    discountAmount?: number
    totalVat?: number
    totalTtc?: number
    terms?: string | null
    notes?: string | null
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt?: Date | string | null
    submittedForServiceApprovalAt?: Date | string | null
    serviceManagerApprovedBy?: number | null
    serviceManagerApprovalDate?: Date | string | null
    serviceManagerComments?: string | null
    dgApprovedBy?: number | null
    dgApprovalDate?: Date | string | null
    dgComments?: string | null
    acceptedAt?: Date | string | null
  }

  export type QuoteUpdateManyMutationInput = {
    quoteNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    quoteDate?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotalHt?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalVat?: FloatFieldUpdateOperationsInput | number
    totalTtc?: FloatFieldUpdateOperationsInput | number
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedForServiceApprovalAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceManagerApprovalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceManagerComments?: NullableStringFieldUpdateOperationsInput | string | null
    dgApprovalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dgComments?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuoteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    quoteNumber?: StringFieldUpdateOperationsInput | string
    customerId?: IntFieldUpdateOperationsInput | number
    customerAddressId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    quoteDate?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotalHt?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalVat?: FloatFieldUpdateOperationsInput | number
    totalTtc?: FloatFieldUpdateOperationsInput | number
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedForServiceApprovalAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceManagerApprovedBy?: NullableIntFieldUpdateOperationsInput | number | null
    serviceManagerApprovalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceManagerComments?: NullableStringFieldUpdateOperationsInput | string | null
    dgApprovedBy?: NullableIntFieldUpdateOperationsInput | number | null
    dgApprovalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dgComments?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuoteItemCreateInput = {
    description: string
    quantity: number
    unitPriceHt: number
    discountRate?: number
    vatRate: number
    totalHt: number
    sortOrder?: number
    quote: QuoteCreateNestedOneWithoutItemsInput
    product?: ProductCreateNestedOneWithoutQuoteItemsInput
  }

  export type QuoteItemUncheckedCreateInput = {
    id?: number
    quoteId: number
    productId?: number | null
    description: string
    quantity: number
    unitPriceHt: number
    discountRate?: number
    vatRate: number
    totalHt: number
    sortOrder?: number
  }

  export type QuoteItemUpdateInput = {
    description?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPriceHt?: FloatFieldUpdateOperationsInput | number
    discountRate?: FloatFieldUpdateOperationsInput | number
    vatRate?: FloatFieldUpdateOperationsInput | number
    totalHt?: FloatFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
    quote?: QuoteUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneWithoutQuoteItemsNestedInput
  }

  export type QuoteItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    quoteId?: IntFieldUpdateOperationsInput | number
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPriceHt?: FloatFieldUpdateOperationsInput | number
    discountRate?: FloatFieldUpdateOperationsInput | number
    vatRate?: FloatFieldUpdateOperationsInput | number
    totalHt?: FloatFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
  }

  export type QuoteItemCreateManyInput = {
    id?: number
    quoteId: number
    productId?: number | null
    description: string
    quantity: number
    unitPriceHt: number
    discountRate?: number
    vatRate: number
    totalHt: number
    sortOrder?: number
  }

  export type QuoteItemUpdateManyMutationInput = {
    description?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPriceHt?: FloatFieldUpdateOperationsInput | number
    discountRate?: FloatFieldUpdateOperationsInput | number
    vatRate?: FloatFieldUpdateOperationsInput | number
    totalHt?: FloatFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
  }

  export type QuoteItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    quoteId?: IntFieldUpdateOperationsInput | number
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPriceHt?: FloatFieldUpdateOperationsInput | number
    discountRate?: FloatFieldUpdateOperationsInput | number
    vatRate?: FloatFieldUpdateOperationsInput | number
    totalHt?: FloatFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
  }

  export type QuoteApprovalCreateInput = {
    approvalLevel: $Enums.ApprovalLevel
    status?: $Enums.ApprovalStatus
    approvalDate?: Date | string | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    quote: QuoteCreateNestedOneWithoutApprovalsInput
    approver: UserCreateNestedOneWithoutQuoteApprovalsInput
  }

  export type QuoteApprovalUncheckedCreateInput = {
    id?: number
    quoteId: number
    approverId: number
    approvalLevel: $Enums.ApprovalLevel
    status?: $Enums.ApprovalStatus
    approvalDate?: Date | string | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuoteApprovalUpdateInput = {
    approvalLevel?: EnumApprovalLevelFieldUpdateOperationsInput | $Enums.ApprovalLevel
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approvalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quote?: QuoteUpdateOneRequiredWithoutApprovalsNestedInput
    approver?: UserUpdateOneRequiredWithoutQuoteApprovalsNestedInput
  }

  export type QuoteApprovalUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    quoteId?: IntFieldUpdateOperationsInput | number
    approverId?: IntFieldUpdateOperationsInput | number
    approvalLevel?: EnumApprovalLevelFieldUpdateOperationsInput | $Enums.ApprovalLevel
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approvalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuoteApprovalCreateManyInput = {
    id?: number
    quoteId: number
    approverId: number
    approvalLevel: $Enums.ApprovalLevel
    status?: $Enums.ApprovalStatus
    approvalDate?: Date | string | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuoteApprovalUpdateManyMutationInput = {
    approvalLevel?: EnumApprovalLevelFieldUpdateOperationsInput | $Enums.ApprovalLevel
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approvalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuoteApprovalUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    quoteId?: IntFieldUpdateOperationsInput | number
    approverId?: IntFieldUpdateOperationsInput | number
    approvalLevel?: EnumApprovalLevelFieldUpdateOperationsInput | $Enums.ApprovalLevel
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approvalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateInput = {
    invoiceNumber: string
    type?: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    invoiceDate: Date | string
    dueDate: Date | string
    subtotalHt?: number
    discountAmount?: number
    totalVat?: number
    totalTtc?: number
    paidAmount?: number
    balanceDue?: number
    paymentTerms?: number
    lateFeeRate?: number
    terms?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt?: Date | string | null
    customer: CustomerCreateNestedOneWithoutInvoicesInput
    customerAddress?: CustomerAddressCreateNestedOneWithoutInvoicesInput
    quote?: QuoteCreateNestedOneWithoutInvoicesInput
    creator: UserCreateNestedOneWithoutCreatedInvoicesInput
    items?: InvoiceItemCreateNestedManyWithoutInvoiceInput
    paymentAllocations?: PaymentAllocationCreateNestedManyWithoutInvoiceInput
    reminders?: ReminderCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateInput = {
    id?: number
    invoiceNumber: string
    customerId: number
    customerAddressId?: number | null
    quoteId?: number | null
    type?: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    invoiceDate: Date | string
    dueDate: Date | string
    subtotalHt?: number
    discountAmount?: number
    totalVat?: number
    totalTtc?: number
    paidAmount?: number
    balanceDue?: number
    paymentTerms?: number
    lateFeeRate?: number
    terms?: string | null
    notes?: string | null
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt?: Date | string | null
    items?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
    paymentAllocations?: PaymentAllocationUncheckedCreateNestedManyWithoutInvoiceInput
    reminders?: ReminderUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUpdateInput = {
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotalHt?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalVat?: FloatFieldUpdateOperationsInput | number
    totalTtc?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    balanceDue?: FloatFieldUpdateOperationsInput | number
    paymentTerms?: IntFieldUpdateOperationsInput | number
    lateFeeRate?: FloatFieldUpdateOperationsInput | number
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customer?: CustomerUpdateOneRequiredWithoutInvoicesNestedInput
    customerAddress?: CustomerAddressUpdateOneWithoutInvoicesNestedInput
    quote?: QuoteUpdateOneWithoutInvoicesNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedInvoicesNestedInput
    items?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
    paymentAllocations?: PaymentAllocationUpdateManyWithoutInvoiceNestedInput
    reminders?: ReminderUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    customerId?: IntFieldUpdateOperationsInput | number
    customerAddressId?: NullableIntFieldUpdateOperationsInput | number | null
    quoteId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotalHt?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalVat?: FloatFieldUpdateOperationsInput | number
    totalTtc?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    balanceDue?: FloatFieldUpdateOperationsInput | number
    paymentTerms?: IntFieldUpdateOperationsInput | number
    lateFeeRate?: FloatFieldUpdateOperationsInput | number
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
    paymentAllocations?: PaymentAllocationUncheckedUpdateManyWithoutInvoiceNestedInput
    reminders?: ReminderUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceCreateManyInput = {
    id?: number
    invoiceNumber: string
    customerId: number
    customerAddressId?: number | null
    quoteId?: number | null
    type?: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    invoiceDate: Date | string
    dueDate: Date | string
    subtotalHt?: number
    discountAmount?: number
    totalVat?: number
    totalTtc?: number
    paidAmount?: number
    balanceDue?: number
    paymentTerms?: number
    lateFeeRate?: number
    terms?: string | null
    notes?: string | null
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt?: Date | string | null
  }

  export type InvoiceUpdateManyMutationInput = {
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotalHt?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalVat?: FloatFieldUpdateOperationsInput | number
    totalTtc?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    balanceDue?: FloatFieldUpdateOperationsInput | number
    paymentTerms?: IntFieldUpdateOperationsInput | number
    lateFeeRate?: FloatFieldUpdateOperationsInput | number
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InvoiceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    customerId?: IntFieldUpdateOperationsInput | number
    customerAddressId?: NullableIntFieldUpdateOperationsInput | number | null
    quoteId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotalHt?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalVat?: FloatFieldUpdateOperationsInput | number
    totalTtc?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    balanceDue?: FloatFieldUpdateOperationsInput | number
    paymentTerms?: IntFieldUpdateOperationsInput | number
    lateFeeRate?: FloatFieldUpdateOperationsInput | number
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InvoiceItemCreateInput = {
    description: string
    quantity: number
    unitPriceHt: number
    discountRate?: number
    vatRate: number
    totalHt: number
    sortOrder?: number
    invoice: InvoiceCreateNestedOneWithoutItemsInput
    product?: ProductCreateNestedOneWithoutInvoiceItemsInput
  }

  export type InvoiceItemUncheckedCreateInput = {
    id?: number
    invoiceId: number
    productId?: number | null
    description: string
    quantity: number
    unitPriceHt: number
    discountRate?: number
    vatRate: number
    totalHt: number
    sortOrder?: number
  }

  export type InvoiceItemUpdateInput = {
    description?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPriceHt?: FloatFieldUpdateOperationsInput | number
    discountRate?: FloatFieldUpdateOperationsInput | number
    vatRate?: FloatFieldUpdateOperationsInput | number
    totalHt?: FloatFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
    invoice?: InvoiceUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneWithoutInvoiceItemsNestedInput
  }

  export type InvoiceItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPriceHt?: FloatFieldUpdateOperationsInput | number
    discountRate?: FloatFieldUpdateOperationsInput | number
    vatRate?: FloatFieldUpdateOperationsInput | number
    totalHt?: FloatFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
  }

  export type InvoiceItemCreateManyInput = {
    id?: number
    invoiceId: number
    productId?: number | null
    description: string
    quantity: number
    unitPriceHt: number
    discountRate?: number
    vatRate: number
    totalHt: number
    sortOrder?: number
  }

  export type InvoiceItemUpdateManyMutationInput = {
    description?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPriceHt?: FloatFieldUpdateOperationsInput | number
    discountRate?: FloatFieldUpdateOperationsInput | number
    vatRate?: FloatFieldUpdateOperationsInput | number
    totalHt?: FloatFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
  }

  export type InvoiceItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPriceHt?: FloatFieldUpdateOperationsInput | number
    discountRate?: FloatFieldUpdateOperationsInput | number
    vatRate?: FloatFieldUpdateOperationsInput | number
    totalHt?: FloatFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
  }

  export type PaymentCreateInput = {
    paymentNumber: string
    amount: number
    paymentDate: Date | string
    paymentMethod: $Enums.PaymentMethod
    reference?: string | null
    notes?: string | null
    createdAt?: Date | string
    customer: CustomerCreateNestedOneWithoutPaymentsInput
    creator: UserCreateNestedOneWithoutCreatedPaymentsInput
    allocations?: PaymentAllocationCreateNestedManyWithoutPaymentInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: number
    paymentNumber: string
    customerId: number
    amount: number
    paymentDate: Date | string
    paymentMethod: $Enums.PaymentMethod
    reference?: string | null
    notes?: string | null
    createdBy: number
    createdAt?: Date | string
    allocations?: PaymentAllocationUncheckedCreateNestedManyWithoutPaymentInput
  }

  export type PaymentUpdateInput = {
    paymentNumber?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutPaymentsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedPaymentsNestedInput
    allocations?: PaymentAllocationUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    paymentNumber?: StringFieldUpdateOperationsInput | string
    customerId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    allocations?: PaymentAllocationUncheckedUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentCreateManyInput = {
    id?: number
    paymentNumber: string
    customerId: number
    amount: number
    paymentDate: Date | string
    paymentMethod: $Enums.PaymentMethod
    reference?: string | null
    notes?: string | null
    createdBy: number
    createdAt?: Date | string
  }

  export type PaymentUpdateManyMutationInput = {
    paymentNumber?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    paymentNumber?: StringFieldUpdateOperationsInput | string
    customerId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentAllocationCreateInput = {
    amount: number
    createdAt?: Date | string
    payment: PaymentCreateNestedOneWithoutAllocationsInput
    invoice: InvoiceCreateNestedOneWithoutPaymentAllocationsInput
  }

  export type PaymentAllocationUncheckedCreateInput = {
    id?: number
    paymentId: number
    invoiceId: number
    amount: number
    createdAt?: Date | string
  }

  export type PaymentAllocationUpdateInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payment?: PaymentUpdateOneRequiredWithoutAllocationsNestedInput
    invoice?: InvoiceUpdateOneRequiredWithoutPaymentAllocationsNestedInput
  }

  export type PaymentAllocationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    paymentId?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentAllocationCreateManyInput = {
    id?: number
    paymentId: number
    invoiceId: number
    amount: number
    createdAt?: Date | string
  }

  export type PaymentAllocationUpdateManyMutationInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentAllocationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    paymentId?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecurringInvoiceCreateInput = {
    templateName: string
    frequency: $Enums.RecurringFrequency
    startDate: Date | string
    endDate?: Date | string | null
    nextInvoiceDate: Date | string
    isActive?: boolean
    subtotalHt?: number
    totalVat?: number
    totalTtc?: number
    terms?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutRecurringInvoicesInput
    creator: UserCreateNestedOneWithoutCreatedRecurringInvoicesInput
    items?: RecurringInvoiceItemCreateNestedManyWithoutRecurringInvoiceInput
  }

  export type RecurringInvoiceUncheckedCreateInput = {
    id?: number
    customerId: number
    templateName: string
    frequency: $Enums.RecurringFrequency
    startDate: Date | string
    endDate?: Date | string | null
    nextInvoiceDate: Date | string
    isActive?: boolean
    subtotalHt?: number
    totalVat?: number
    totalTtc?: number
    terms?: string | null
    notes?: string | null
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: RecurringInvoiceItemUncheckedCreateNestedManyWithoutRecurringInvoiceInput
  }

  export type RecurringInvoiceUpdateInput = {
    templateName?: StringFieldUpdateOperationsInput | string
    frequency?: EnumRecurringFrequencyFieldUpdateOperationsInput | $Enums.RecurringFrequency
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextInvoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subtotalHt?: FloatFieldUpdateOperationsInput | number
    totalVat?: FloatFieldUpdateOperationsInput | number
    totalTtc?: FloatFieldUpdateOperationsInput | number
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutRecurringInvoicesNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedRecurringInvoicesNestedInput
    items?: RecurringInvoiceItemUpdateManyWithoutRecurringInvoiceNestedInput
  }

  export type RecurringInvoiceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    templateName?: StringFieldUpdateOperationsInput | string
    frequency?: EnumRecurringFrequencyFieldUpdateOperationsInput | $Enums.RecurringFrequency
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextInvoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subtotalHt?: FloatFieldUpdateOperationsInput | number
    totalVat?: FloatFieldUpdateOperationsInput | number
    totalTtc?: FloatFieldUpdateOperationsInput | number
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: RecurringInvoiceItemUncheckedUpdateManyWithoutRecurringInvoiceNestedInput
  }

  export type RecurringInvoiceCreateManyInput = {
    id?: number
    customerId: number
    templateName: string
    frequency: $Enums.RecurringFrequency
    startDate: Date | string
    endDate?: Date | string | null
    nextInvoiceDate: Date | string
    isActive?: boolean
    subtotalHt?: number
    totalVat?: number
    totalTtc?: number
    terms?: string | null
    notes?: string | null
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecurringInvoiceUpdateManyMutationInput = {
    templateName?: StringFieldUpdateOperationsInput | string
    frequency?: EnumRecurringFrequencyFieldUpdateOperationsInput | $Enums.RecurringFrequency
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextInvoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subtotalHt?: FloatFieldUpdateOperationsInput | number
    totalVat?: FloatFieldUpdateOperationsInput | number
    totalTtc?: FloatFieldUpdateOperationsInput | number
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecurringInvoiceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    templateName?: StringFieldUpdateOperationsInput | string
    frequency?: EnumRecurringFrequencyFieldUpdateOperationsInput | $Enums.RecurringFrequency
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextInvoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subtotalHt?: FloatFieldUpdateOperationsInput | number
    totalVat?: FloatFieldUpdateOperationsInput | number
    totalTtc?: FloatFieldUpdateOperationsInput | number
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecurringInvoiceItemCreateInput = {
    description: string
    quantity: number
    unitPriceHt: number
    vatRate: number
    totalHt: number
    sortOrder?: number
    recurringInvoice: RecurringInvoiceCreateNestedOneWithoutItemsInput
    product?: ProductCreateNestedOneWithoutRecurringInvoiceItemsInput
  }

  export type RecurringInvoiceItemUncheckedCreateInput = {
    id?: number
    recurringInvoiceId: number
    productId?: number | null
    description: string
    quantity: number
    unitPriceHt: number
    vatRate: number
    totalHt: number
    sortOrder?: number
  }

  export type RecurringInvoiceItemUpdateInput = {
    description?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPriceHt?: FloatFieldUpdateOperationsInput | number
    vatRate?: FloatFieldUpdateOperationsInput | number
    totalHt?: FloatFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
    recurringInvoice?: RecurringInvoiceUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneWithoutRecurringInvoiceItemsNestedInput
  }

  export type RecurringInvoiceItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    recurringInvoiceId?: IntFieldUpdateOperationsInput | number
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPriceHt?: FloatFieldUpdateOperationsInput | number
    vatRate?: FloatFieldUpdateOperationsInput | number
    totalHt?: FloatFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
  }

  export type RecurringInvoiceItemCreateManyInput = {
    id?: number
    recurringInvoiceId: number
    productId?: number | null
    description: string
    quantity: number
    unitPriceHt: number
    vatRate: number
    totalHt: number
    sortOrder?: number
  }

  export type RecurringInvoiceItemUpdateManyMutationInput = {
    description?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPriceHt?: FloatFieldUpdateOperationsInput | number
    vatRate?: FloatFieldUpdateOperationsInput | number
    totalHt?: FloatFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
  }

  export type RecurringInvoiceItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    recurringInvoiceId?: IntFieldUpdateOperationsInput | number
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPriceHt?: FloatFieldUpdateOperationsInput | number
    vatRate?: FloatFieldUpdateOperationsInput | number
    totalHt?: FloatFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
  }

  export type ReminderCreateInput = {
    type: $Enums.ReminderType
    sentDate: Date | string
    dueDate?: Date | string | null
    amountDue: number
    lateFees?: number
    status?: $Enums.ReminderStatus
    emailSubject?: string | null
    emailBody?: string | null
    createdAt?: Date | string
    invoice: InvoiceCreateNestedOneWithoutRemindersInput
    creator: UserCreateNestedOneWithoutCreatedRemindersInput
  }

  export type ReminderUncheckedCreateInput = {
    id?: number
    invoiceId: number
    type: $Enums.ReminderType
    sentDate: Date | string
    dueDate?: Date | string | null
    amountDue: number
    lateFees?: number
    status?: $Enums.ReminderStatus
    emailSubject?: string | null
    emailBody?: string | null
    createdBy: number
    createdAt?: Date | string
  }

  export type ReminderUpdateInput = {
    type?: EnumReminderTypeFieldUpdateOperationsInput | $Enums.ReminderType
    sentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amountDue?: FloatFieldUpdateOperationsInput | number
    lateFees?: FloatFieldUpdateOperationsInput | number
    status?: EnumReminderStatusFieldUpdateOperationsInput | $Enums.ReminderStatus
    emailSubject?: NullableStringFieldUpdateOperationsInput | string | null
    emailBody?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneRequiredWithoutRemindersNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedRemindersNestedInput
  }

  export type ReminderUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    type?: EnumReminderTypeFieldUpdateOperationsInput | $Enums.ReminderType
    sentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amountDue?: FloatFieldUpdateOperationsInput | number
    lateFees?: FloatFieldUpdateOperationsInput | number
    status?: EnumReminderStatusFieldUpdateOperationsInput | $Enums.ReminderStatus
    emailSubject?: NullableStringFieldUpdateOperationsInput | string | null
    emailBody?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReminderCreateManyInput = {
    id?: number
    invoiceId: number
    type: $Enums.ReminderType
    sentDate: Date | string
    dueDate?: Date | string | null
    amountDue: number
    lateFees?: number
    status?: $Enums.ReminderStatus
    emailSubject?: string | null
    emailBody?: string | null
    createdBy: number
    createdAt?: Date | string
  }

  export type ReminderUpdateManyMutationInput = {
    type?: EnumReminderTypeFieldUpdateOperationsInput | $Enums.ReminderType
    sentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amountDue?: FloatFieldUpdateOperationsInput | number
    lateFees?: FloatFieldUpdateOperationsInput | number
    status?: EnumReminderStatusFieldUpdateOperationsInput | $Enums.ReminderStatus
    emailSubject?: NullableStringFieldUpdateOperationsInput | string | null
    emailBody?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReminderUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    type?: EnumReminderTypeFieldUpdateOperationsInput | $Enums.ReminderType
    sentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amountDue?: FloatFieldUpdateOperationsInput | number
    lateFees?: FloatFieldUpdateOperationsInput | number
    status?: EnumReminderStatusFieldUpdateOperationsInput | $Enums.ReminderStatus
    emailSubject?: NullableStringFieldUpdateOperationsInput | string | null
    emailBody?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateInput = {
    type: $Enums.DocumentType
    referenceId: number
    filename: string
    filePath: string
    fileSize?: number | null
    mimeType?: string | null
    generatedAt?: Date | string
  }

  export type DocumentUncheckedCreateInput = {
    id?: number
    type: $Enums.DocumentType
    referenceId: number
    filename: string
    filePath: string
    fileSize?: number | null
    mimeType?: string | null
    generatedAt?: Date | string
  }

  export type DocumentUpdateInput = {
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    referenceId?: IntFieldUpdateOperationsInput | number
    filename?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    referenceId?: IntFieldUpdateOperationsInput | number
    filename?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateManyInput = {
    id?: number
    type: $Enums.DocumentType
    referenceId: number
    filename: string
    filePath: string
    fileSize?: number | null
    mimeType?: string | null
    generatedAt?: Date | string
  }

  export type DocumentUpdateManyMutationInput = {
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    referenceId?: IntFieldUpdateOperationsInput | number
    filename?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    referenceId?: IntFieldUpdateOperationsInput | number
    filename?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseCreateInput = {
    expenseNumber: string
    category: string
    description?: string | null
    amountHt: number
    vatAmount?: number
    totalTtc: number
    expenseDate: Date | string
    paymentDate?: Date | string | null
    paymentMethod?: $Enums.PaymentMethod
    status?: $Enums.ExpenseStatus
    receiptUrl?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    supplier?: SupplierCreateNestedOneWithoutExpensesInput
    creator: UserCreateNestedOneWithoutCreatedExpensesInput
  }

  export type ExpenseUncheckedCreateInput = {
    id?: number
    expenseNumber: string
    supplierId?: number | null
    category: string
    description?: string | null
    amountHt: number
    vatAmount?: number
    totalTtc: number
    expenseDate: Date | string
    paymentDate?: Date | string | null
    paymentMethod?: $Enums.PaymentMethod
    status?: $Enums.ExpenseStatus
    receiptUrl?: string | null
    notes?: string | null
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseUpdateInput = {
    expenseNumber?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amountHt?: FloatFieldUpdateOperationsInput | number
    vatAmount?: FloatFieldUpdateOperationsInput | number
    totalTtc?: FloatFieldUpdateOperationsInput | number
    expenseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumExpenseStatusFieldUpdateOperationsInput | $Enums.ExpenseStatus
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: SupplierUpdateOneWithoutExpensesNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedExpensesNestedInput
  }

  export type ExpenseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    expenseNumber?: StringFieldUpdateOperationsInput | string
    supplierId?: NullableIntFieldUpdateOperationsInput | number | null
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amountHt?: FloatFieldUpdateOperationsInput | number
    vatAmount?: FloatFieldUpdateOperationsInput | number
    totalTtc?: FloatFieldUpdateOperationsInput | number
    expenseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumExpenseStatusFieldUpdateOperationsInput | $Enums.ExpenseStatus
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseCreateManyInput = {
    id?: number
    expenseNumber: string
    supplierId?: number | null
    category: string
    description?: string | null
    amountHt: number
    vatAmount?: number
    totalTtc: number
    expenseDate: Date | string
    paymentDate?: Date | string | null
    paymentMethod?: $Enums.PaymentMethod
    status?: $Enums.ExpenseStatus
    receiptUrl?: string | null
    notes?: string | null
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseUpdateManyMutationInput = {
    expenseNumber?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amountHt?: FloatFieldUpdateOperationsInput | number
    vatAmount?: FloatFieldUpdateOperationsInput | number
    totalTtc?: FloatFieldUpdateOperationsInput | number
    expenseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumExpenseStatusFieldUpdateOperationsInput | $Enums.ExpenseStatus
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    expenseNumber?: StringFieldUpdateOperationsInput | string
    supplierId?: NullableIntFieldUpdateOperationsInput | number | null
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amountHt?: FloatFieldUpdateOperationsInput | number
    vatAmount?: FloatFieldUpdateOperationsInput | number
    totalTtc?: FloatFieldUpdateOperationsInput | number
    expenseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumExpenseStatusFieldUpdateOperationsInput | $Enums.ExpenseStatus
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierCreateInput = {
    name: string
    contactPerson?: string | null
    email?: string | null
    phone?: string | null
    addressLine1?: string | null
    city?: string | null
    postalCode?: string | null
    country?: string | null
    vatNumber?: string | null
    bankName?: string | null
    bankIban?: string | null
    bankBic?: string | null
    paymentTerms?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    expenses?: ExpenseCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateInput = {
    id?: number
    name: string
    contactPerson?: string | null
    email?: string | null
    phone?: string | null
    addressLine1?: string | null
    city?: string | null
    postalCode?: string | null
    country?: string | null
    vatNumber?: string | null
    bankName?: string | null
    bankIban?: string | null
    bankBic?: string | null
    paymentTerms?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    expenses?: ExpenseUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankIban?: NullableStringFieldUpdateOperationsInput | string | null
    bankBic?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expenses?: ExpenseUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankIban?: NullableStringFieldUpdateOperationsInput | string | null
    bankBic?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expenses?: ExpenseUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierCreateManyInput = {
    id?: number
    name: string
    contactPerson?: string | null
    email?: string | null
    phone?: string | null
    addressLine1?: string | null
    city?: string | null
    postalCode?: string | null
    country?: string | null
    vatNumber?: string | null
    bankName?: string | null
    bankIban?: string | null
    bankBic?: string | null
    paymentTerms?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupplierUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankIban?: NullableStringFieldUpdateOperationsInput | string | null
    bankBic?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankIban?: NullableStringFieldUpdateOperationsInput | string | null
    bankBic?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountingEntryCreateInput = {
    entryDate: Date | string
    accountNumber: string
    debit?: number
    credit?: number
    description?: string | null
    sourceDocumentType: $Enums.SourceDocumentType
    sourceDocumentId: number
    createdAt?: Date | string
    creator: UserCreateNestedOneWithoutAccountingEntriesInput
  }

  export type AccountingEntryUncheckedCreateInput = {
    id?: number
    entryDate: Date | string
    accountNumber: string
    debit?: number
    credit?: number
    description?: string | null
    sourceDocumentType: $Enums.SourceDocumentType
    sourceDocumentId: number
    createdBy: number
    createdAt?: Date | string
  }

  export type AccountingEntryUpdateInput = {
    entryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    debit?: FloatFieldUpdateOperationsInput | number
    credit?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sourceDocumentType?: EnumSourceDocumentTypeFieldUpdateOperationsInput | $Enums.SourceDocumentType
    sourceDocumentId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutAccountingEntriesNestedInput
  }

  export type AccountingEntryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    entryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    debit?: FloatFieldUpdateOperationsInput | number
    credit?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sourceDocumentType?: EnumSourceDocumentTypeFieldUpdateOperationsInput | $Enums.SourceDocumentType
    sourceDocumentId?: IntFieldUpdateOperationsInput | number
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountingEntryCreateManyInput = {
    id?: number
    entryDate: Date | string
    accountNumber: string
    debit?: number
    credit?: number
    description?: string | null
    sourceDocumentType: $Enums.SourceDocumentType
    sourceDocumentId: number
    createdBy: number
    createdAt?: Date | string
  }

  export type AccountingEntryUpdateManyMutationInput = {
    entryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    debit?: FloatFieldUpdateOperationsInput | number
    credit?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sourceDocumentType?: EnumSourceDocumentTypeFieldUpdateOperationsInput | $Enums.SourceDocumentType
    sourceDocumentId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountingEntryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    entryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    debit?: FloatFieldUpdateOperationsInput | number
    credit?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sourceDocumentType?: EnumSourceDocumentTypeFieldUpdateOperationsInput | $Enums.SourceDocumentType
    sourceDocumentId?: IntFieldUpdateOperationsInput | number
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashFlowCreateInput = {
    transactionDate: Date | string
    type: $Enums.CashFlowType
    amount: number
    description?: string | null
    category?: string | null
    sourceDocumentType: $Enums.SourceDocumentType
    sourceDocumentId: number
    createdAt?: Date | string
    creator: UserCreateNestedOneWithoutCashFlowEntriesInput
  }

  export type CashFlowUncheckedCreateInput = {
    id?: number
    transactionDate: Date | string
    type: $Enums.CashFlowType
    amount: number
    description?: string | null
    category?: string | null
    sourceDocumentType: $Enums.SourceDocumentType
    sourceDocumentId: number
    createdBy: number
    createdAt?: Date | string
  }

  export type CashFlowUpdateInput = {
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumCashFlowTypeFieldUpdateOperationsInput | $Enums.CashFlowType
    amount?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    sourceDocumentType?: EnumSourceDocumentTypeFieldUpdateOperationsInput | $Enums.SourceDocumentType
    sourceDocumentId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCashFlowEntriesNestedInput
  }

  export type CashFlowUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumCashFlowTypeFieldUpdateOperationsInput | $Enums.CashFlowType
    amount?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    sourceDocumentType?: EnumSourceDocumentTypeFieldUpdateOperationsInput | $Enums.SourceDocumentType
    sourceDocumentId?: IntFieldUpdateOperationsInput | number
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashFlowCreateManyInput = {
    id?: number
    transactionDate: Date | string
    type: $Enums.CashFlowType
    amount: number
    description?: string | null
    category?: string | null
    sourceDocumentType: $Enums.SourceDocumentType
    sourceDocumentId: number
    createdBy: number
    createdAt?: Date | string
  }

  export type CashFlowUpdateManyMutationInput = {
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumCashFlowTypeFieldUpdateOperationsInput | $Enums.CashFlowType
    amount?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    sourceDocumentType?: EnumSourceDocumentTypeFieldUpdateOperationsInput | $Enums.SourceDocumentType
    sourceDocumentId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashFlowUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumCashFlowTypeFieldUpdateOperationsInput | $Enums.CashFlowType
    amount?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    sourceDocumentType?: EnumSourceDocumentTypeFieldUpdateOperationsInput | $Enums.SourceDocumentType
    sourceDocumentId?: IntFieldUpdateOperationsInput | number
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    action: string
    details?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: number
    userId: number
    action: string
    details?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: number
    userId: number
    action: string
    details?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeCreateInput = {
    employeeNumber: string
    registrationNumber?: string | null
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    address?: string | null
    dateOfBirth: Date | string
    placeOfBirth?: string | null
    nationality?: string | null
    socialSecurityNumber?: string | null
    cnpsNumber?: string | null
    cnamNumber?: string | null
    bankAccount?: string | null
    emergencyContact?: string | null
    position: string
    department?: string | null
    category?: string | null
    level?: string | null
    manager?: string | null
    hireDate: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    service?: ServiceCreateNestedOneWithoutEmployeesInput
    user?: UserCreateNestedOneWithoutEmployeeInput
    contracts?: ContractCreateNestedManyWithoutEmployeeInput
    salaries?: SalaryCreateNestedManyWithoutEmployeeInput
    leaveRequests?: LeaveRequestCreateNestedManyWithoutEmployeeInput
    loans?: LoanCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateInput = {
    id?: number
    employeeNumber: string
    registrationNumber?: string | null
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    address?: string | null
    dateOfBirth: Date | string
    placeOfBirth?: string | null
    nationality?: string | null
    socialSecurityNumber?: string | null
    cnpsNumber?: string | null
    cnamNumber?: string | null
    bankAccount?: string | null
    emergencyContact?: string | null
    serviceId?: number | null
    position: string
    department?: string | null
    category?: string | null
    level?: string | null
    manager?: string | null
    hireDate: Date | string
    isActive?: boolean
    userId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contracts?: ContractUncheckedCreateNestedManyWithoutEmployeeInput
    salaries?: SalaryUncheckedCreateNestedManyWithoutEmployeeInput
    leaveRequests?: LeaveRequestUncheckedCreateNestedManyWithoutEmployeeInput
    loans?: LoanUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUpdateInput = {
    employeeNumber?: StringFieldUpdateOperationsInput | string
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    placeOfBirth?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    socialSecurityNumber?: NullableStringFieldUpdateOperationsInput | string | null
    cnpsNumber?: NullableStringFieldUpdateOperationsInput | string | null
    cnamNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    position?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    manager?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneWithoutEmployeesNestedInput
    user?: UserUpdateOneWithoutEmployeeNestedInput
    contracts?: ContractUpdateManyWithoutEmployeeNestedInput
    salaries?: SalaryUpdateManyWithoutEmployeeNestedInput
    leaveRequests?: LeaveRequestUpdateManyWithoutEmployeeNestedInput
    loans?: LoanUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeNumber?: StringFieldUpdateOperationsInput | string
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    placeOfBirth?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    socialSecurityNumber?: NullableStringFieldUpdateOperationsInput | string | null
    cnpsNumber?: NullableStringFieldUpdateOperationsInput | string | null
    cnamNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: NullableIntFieldUpdateOperationsInput | number | null
    position?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    manager?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contracts?: ContractUncheckedUpdateManyWithoutEmployeeNestedInput
    salaries?: SalaryUncheckedUpdateManyWithoutEmployeeNestedInput
    leaveRequests?: LeaveRequestUncheckedUpdateManyWithoutEmployeeNestedInput
    loans?: LoanUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeCreateManyInput = {
    id?: number
    employeeNumber: string
    registrationNumber?: string | null
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    address?: string | null
    dateOfBirth: Date | string
    placeOfBirth?: string | null
    nationality?: string | null
    socialSecurityNumber?: string | null
    cnpsNumber?: string | null
    cnamNumber?: string | null
    bankAccount?: string | null
    emergencyContact?: string | null
    serviceId?: number | null
    position: string
    department?: string | null
    category?: string | null
    level?: string | null
    manager?: string | null
    hireDate: Date | string
    isActive?: boolean
    userId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeUpdateManyMutationInput = {
    employeeNumber?: StringFieldUpdateOperationsInput | string
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    placeOfBirth?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    socialSecurityNumber?: NullableStringFieldUpdateOperationsInput | string | null
    cnpsNumber?: NullableStringFieldUpdateOperationsInput | string | null
    cnamNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    position?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    manager?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeNumber?: StringFieldUpdateOperationsInput | string
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    placeOfBirth?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    socialSecurityNumber?: NullableStringFieldUpdateOperationsInput | string | null
    cnpsNumber?: NullableStringFieldUpdateOperationsInput | string | null
    cnamNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: NullableIntFieldUpdateOperationsInput | number | null
    position?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    manager?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractCreateInput = {
    contractType: $Enums.ContractType
    startDate: Date | string
    endDate?: Date | string | null
    baseSalary: number
    workingHours: number
    benefits?: string | null
    terms?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutContractsInput
  }

  export type ContractUncheckedCreateInput = {
    id?: number
    employeeId: number
    contractType: $Enums.ContractType
    startDate: Date | string
    endDate?: Date | string | null
    baseSalary: number
    workingHours: number
    benefits?: string | null
    terms?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContractUpdateInput = {
    contractType?: EnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    baseSalary?: FloatFieldUpdateOperationsInput | number
    workingHours?: FloatFieldUpdateOperationsInput | number
    benefits?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutContractsNestedInput
  }

  export type ContractUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    contractType?: EnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    baseSalary?: FloatFieldUpdateOperationsInput | number
    workingHours?: FloatFieldUpdateOperationsInput | number
    benefits?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractCreateManyInput = {
    id?: number
    employeeId: number
    contractType: $Enums.ContractType
    startDate: Date | string
    endDate?: Date | string | null
    baseSalary: number
    workingHours: number
    benefits?: string | null
    terms?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContractUpdateManyMutationInput = {
    contractType?: EnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    baseSalary?: FloatFieldUpdateOperationsInput | number
    workingHours?: FloatFieldUpdateOperationsInput | number
    benefits?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    contractType?: EnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    baseSalary?: FloatFieldUpdateOperationsInput | number
    workingHours?: FloatFieldUpdateOperationsInput | number
    benefits?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryCreateInput = {
    paymentDate: Date | string
    workingDays?: number
    baseSalary: number
    overtime?: number
    bonuses?: number
    allowances?: number
    paidLeave?: number
    grossSalary: number
    socialContributions?: number
    cnpsEmployee?: number
    cnamEmployee?: number
    fdfpEmployee?: number
    taxes?: number
    nonTaxableAmount?: number
    otherDeductions?: number
    loanDeductions?: number
    totalDeductions: number
    netSalary: number
    status?: $Enums.SalaryStatus
    paymentMethod?: $Enums.PaymentMethod | null
    reference?: string | null
    notes?: string | null
    createdAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutSalariesInput
    loanPayments?: LoanPaymentCreateNestedManyWithoutSalaryInput
  }

  export type SalaryUncheckedCreateInput = {
    id?: number
    employeeId: number
    paymentDate: Date | string
    workingDays?: number
    baseSalary: number
    overtime?: number
    bonuses?: number
    allowances?: number
    paidLeave?: number
    grossSalary: number
    socialContributions?: number
    cnpsEmployee?: number
    cnamEmployee?: number
    fdfpEmployee?: number
    taxes?: number
    nonTaxableAmount?: number
    otherDeductions?: number
    loanDeductions?: number
    totalDeductions: number
    netSalary: number
    status?: $Enums.SalaryStatus
    paymentMethod?: $Enums.PaymentMethod | null
    reference?: string | null
    notes?: string | null
    createdAt?: Date | string
    loanPayments?: LoanPaymentUncheckedCreateNestedManyWithoutSalaryInput
  }

  export type SalaryUpdateInput = {
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    workingDays?: IntFieldUpdateOperationsInput | number
    baseSalary?: FloatFieldUpdateOperationsInput | number
    overtime?: FloatFieldUpdateOperationsInput | number
    bonuses?: FloatFieldUpdateOperationsInput | number
    allowances?: FloatFieldUpdateOperationsInput | number
    paidLeave?: FloatFieldUpdateOperationsInput | number
    grossSalary?: FloatFieldUpdateOperationsInput | number
    socialContributions?: FloatFieldUpdateOperationsInput | number
    cnpsEmployee?: FloatFieldUpdateOperationsInput | number
    cnamEmployee?: FloatFieldUpdateOperationsInput | number
    fdfpEmployee?: FloatFieldUpdateOperationsInput | number
    taxes?: FloatFieldUpdateOperationsInput | number
    nonTaxableAmount?: FloatFieldUpdateOperationsInput | number
    otherDeductions?: FloatFieldUpdateOperationsInput | number
    loanDeductions?: FloatFieldUpdateOperationsInput | number
    totalDeductions?: FloatFieldUpdateOperationsInput | number
    netSalary?: FloatFieldUpdateOperationsInput | number
    status?: EnumSalaryStatusFieldUpdateOperationsInput | $Enums.SalaryStatus
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutSalariesNestedInput
    loanPayments?: LoanPaymentUpdateManyWithoutSalaryNestedInput
  }

  export type SalaryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    workingDays?: IntFieldUpdateOperationsInput | number
    baseSalary?: FloatFieldUpdateOperationsInput | number
    overtime?: FloatFieldUpdateOperationsInput | number
    bonuses?: FloatFieldUpdateOperationsInput | number
    allowances?: FloatFieldUpdateOperationsInput | number
    paidLeave?: FloatFieldUpdateOperationsInput | number
    grossSalary?: FloatFieldUpdateOperationsInput | number
    socialContributions?: FloatFieldUpdateOperationsInput | number
    cnpsEmployee?: FloatFieldUpdateOperationsInput | number
    cnamEmployee?: FloatFieldUpdateOperationsInput | number
    fdfpEmployee?: FloatFieldUpdateOperationsInput | number
    taxes?: FloatFieldUpdateOperationsInput | number
    nonTaxableAmount?: FloatFieldUpdateOperationsInput | number
    otherDeductions?: FloatFieldUpdateOperationsInput | number
    loanDeductions?: FloatFieldUpdateOperationsInput | number
    totalDeductions?: FloatFieldUpdateOperationsInput | number
    netSalary?: FloatFieldUpdateOperationsInput | number
    status?: EnumSalaryStatusFieldUpdateOperationsInput | $Enums.SalaryStatus
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loanPayments?: LoanPaymentUncheckedUpdateManyWithoutSalaryNestedInput
  }

  export type SalaryCreateManyInput = {
    id?: number
    employeeId: number
    paymentDate: Date | string
    workingDays?: number
    baseSalary: number
    overtime?: number
    bonuses?: number
    allowances?: number
    paidLeave?: number
    grossSalary: number
    socialContributions?: number
    cnpsEmployee?: number
    cnamEmployee?: number
    fdfpEmployee?: number
    taxes?: number
    nonTaxableAmount?: number
    otherDeductions?: number
    loanDeductions?: number
    totalDeductions: number
    netSalary: number
    status?: $Enums.SalaryStatus
    paymentMethod?: $Enums.PaymentMethod | null
    reference?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type SalaryUpdateManyMutationInput = {
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    workingDays?: IntFieldUpdateOperationsInput | number
    baseSalary?: FloatFieldUpdateOperationsInput | number
    overtime?: FloatFieldUpdateOperationsInput | number
    bonuses?: FloatFieldUpdateOperationsInput | number
    allowances?: FloatFieldUpdateOperationsInput | number
    paidLeave?: FloatFieldUpdateOperationsInput | number
    grossSalary?: FloatFieldUpdateOperationsInput | number
    socialContributions?: FloatFieldUpdateOperationsInput | number
    cnpsEmployee?: FloatFieldUpdateOperationsInput | number
    cnamEmployee?: FloatFieldUpdateOperationsInput | number
    fdfpEmployee?: FloatFieldUpdateOperationsInput | number
    taxes?: FloatFieldUpdateOperationsInput | number
    nonTaxableAmount?: FloatFieldUpdateOperationsInput | number
    otherDeductions?: FloatFieldUpdateOperationsInput | number
    loanDeductions?: FloatFieldUpdateOperationsInput | number
    totalDeductions?: FloatFieldUpdateOperationsInput | number
    netSalary?: FloatFieldUpdateOperationsInput | number
    status?: EnumSalaryStatusFieldUpdateOperationsInput | $Enums.SalaryStatus
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    workingDays?: IntFieldUpdateOperationsInput | number
    baseSalary?: FloatFieldUpdateOperationsInput | number
    overtime?: FloatFieldUpdateOperationsInput | number
    bonuses?: FloatFieldUpdateOperationsInput | number
    allowances?: FloatFieldUpdateOperationsInput | number
    paidLeave?: FloatFieldUpdateOperationsInput | number
    grossSalary?: FloatFieldUpdateOperationsInput | number
    socialContributions?: FloatFieldUpdateOperationsInput | number
    cnpsEmployee?: FloatFieldUpdateOperationsInput | number
    cnamEmployee?: FloatFieldUpdateOperationsInput | number
    fdfpEmployee?: FloatFieldUpdateOperationsInput | number
    taxes?: FloatFieldUpdateOperationsInput | number
    nonTaxableAmount?: FloatFieldUpdateOperationsInput | number
    otherDeductions?: FloatFieldUpdateOperationsInput | number
    loanDeductions?: FloatFieldUpdateOperationsInput | number
    totalDeductions?: FloatFieldUpdateOperationsInput | number
    netSalary?: FloatFieldUpdateOperationsInput | number
    status?: EnumSalaryStatusFieldUpdateOperationsInput | $Enums.SalaryStatus
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoanPaymentCreateInput = {
    amount: number
    paymentDate: Date | string
    principal: number
    interest: number
    notes?: string | null
    createdAt?: Date | string
    loan: LoanCreateNestedOneWithoutPaymentsInput
    salary?: SalaryCreateNestedOneWithoutLoanPaymentsInput
  }

  export type LoanPaymentUncheckedCreateInput = {
    id?: number
    loanId: number
    salaryId?: number | null
    amount: number
    paymentDate: Date | string
    principal: number
    interest: number
    notes?: string | null
    createdAt?: Date | string
  }

  export type LoanPaymentUpdateInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    principal?: FloatFieldUpdateOperationsInput | number
    interest?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loan?: LoanUpdateOneRequiredWithoutPaymentsNestedInput
    salary?: SalaryUpdateOneWithoutLoanPaymentsNestedInput
  }

  export type LoanPaymentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    loanId?: IntFieldUpdateOperationsInput | number
    salaryId?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    principal?: FloatFieldUpdateOperationsInput | number
    interest?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoanPaymentCreateManyInput = {
    id?: number
    loanId: number
    salaryId?: number | null
    amount: number
    paymentDate: Date | string
    principal: number
    interest: number
    notes?: string | null
    createdAt?: Date | string
  }

  export type LoanPaymentUpdateManyMutationInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    principal?: FloatFieldUpdateOperationsInput | number
    interest?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoanPaymentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    loanId?: IntFieldUpdateOperationsInput | number
    salaryId?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    principal?: FloatFieldUpdateOperationsInput | number
    interest?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveRequestCreateInput = {
    leaveType: $Enums.LeaveType
    startDate: Date | string
    endDate: Date | string
    days: number
    reason: string
    notes?: string | null
    status?: $Enums.LeaveStatus
    approvedAt?: Date | string | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutLeaveRequestsInput
    approvedBy?: UserCreateNestedOneWithoutLeaveApprovalsInput
  }

  export type LeaveRequestUncheckedCreateInput = {
    id?: number
    employeeId: number
    leaveType: $Enums.LeaveType
    startDate: Date | string
    endDate: Date | string
    days: number
    reason: string
    notes?: string | null
    status?: $Enums.LeaveStatus
    approvedById?: number | null
    approvedAt?: Date | string | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaveRequestUpdateInput = {
    leaveType?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    days?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutLeaveRequestsNestedInput
    approvedBy?: UserUpdateOneWithoutLeaveApprovalsNestedInput
  }

  export type LeaveRequestUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    leaveType?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    days?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveRequestCreateManyInput = {
    id?: number
    employeeId: number
    leaveType: $Enums.LeaveType
    startDate: Date | string
    endDate: Date | string
    days: number
    reason: string
    notes?: string | null
    status?: $Enums.LeaveStatus
    approvedById?: number | null
    approvedAt?: Date | string | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaveRequestUpdateManyMutationInput = {
    leaveType?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    days?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveRequestUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    leaveType?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    days?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProspectCreateInput = {
    companyName: string
    contactName: string
    position?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    website?: string | null
    industry?: string | null
    companySize?: string | null
    estimatedValue?: number | null
    priority?: string
    stage?: string
    source?: string | null
    notes?: string | null
    hasBudget?: boolean
    isDecisionMaker?: boolean
    hasNeed?: boolean
    timeline?: string | null
    lastContact?: Date | string
    nextAction?: string | null
    nextActionDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedUser?: UserCreateNestedOneWithoutAssignedProspectsInput
    creator: UserCreateNestedOneWithoutCreatedProspectsInput
    activities?: ProspectActivityCreateNestedManyWithoutProspectInput
  }

  export type ProspectUncheckedCreateInput = {
    id?: number
    companyName: string
    contactName: string
    position?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    website?: string | null
    industry?: string | null
    companySize?: string | null
    estimatedValue?: number | null
    priority?: string
    stage?: string
    source?: string | null
    notes?: string | null
    hasBudget?: boolean
    isDecisionMaker?: boolean
    hasNeed?: boolean
    timeline?: string | null
    lastContact?: Date | string
    nextAction?: string | null
    nextActionDate?: Date | string | null
    assignedTo?: number | null
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: ProspectActivityUncheckedCreateNestedManyWithoutProspectInput
  }

  export type ProspectUpdateInput = {
    companyName?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedValue?: NullableFloatFieldUpdateOperationsInput | number | null
    priority?: StringFieldUpdateOperationsInput | string
    stage?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    hasBudget?: BoolFieldUpdateOperationsInput | boolean
    isDecisionMaker?: BoolFieldUpdateOperationsInput | boolean
    hasNeed?: BoolFieldUpdateOperationsInput | boolean
    timeline?: NullableStringFieldUpdateOperationsInput | string | null
    lastContact?: DateTimeFieldUpdateOperationsInput | Date | string
    nextAction?: NullableStringFieldUpdateOperationsInput | string | null
    nextActionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedUser?: UserUpdateOneWithoutAssignedProspectsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedProspectsNestedInput
    activities?: ProspectActivityUpdateManyWithoutProspectNestedInput
  }

  export type ProspectUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyName?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedValue?: NullableFloatFieldUpdateOperationsInput | number | null
    priority?: StringFieldUpdateOperationsInput | string
    stage?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    hasBudget?: BoolFieldUpdateOperationsInput | boolean
    isDecisionMaker?: BoolFieldUpdateOperationsInput | boolean
    hasNeed?: BoolFieldUpdateOperationsInput | boolean
    timeline?: NullableStringFieldUpdateOperationsInput | string | null
    lastContact?: DateTimeFieldUpdateOperationsInput | Date | string
    nextAction?: NullableStringFieldUpdateOperationsInput | string | null
    nextActionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: NullableIntFieldUpdateOperationsInput | number | null
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ProspectActivityUncheckedUpdateManyWithoutProspectNestedInput
  }

  export type ProspectCreateManyInput = {
    id?: number
    companyName: string
    contactName: string
    position?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    website?: string | null
    industry?: string | null
    companySize?: string | null
    estimatedValue?: number | null
    priority?: string
    stage?: string
    source?: string | null
    notes?: string | null
    hasBudget?: boolean
    isDecisionMaker?: boolean
    hasNeed?: boolean
    timeline?: string | null
    lastContact?: Date | string
    nextAction?: string | null
    nextActionDate?: Date | string | null
    assignedTo?: number | null
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProspectUpdateManyMutationInput = {
    companyName?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedValue?: NullableFloatFieldUpdateOperationsInput | number | null
    priority?: StringFieldUpdateOperationsInput | string
    stage?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    hasBudget?: BoolFieldUpdateOperationsInput | boolean
    isDecisionMaker?: BoolFieldUpdateOperationsInput | boolean
    hasNeed?: BoolFieldUpdateOperationsInput | boolean
    timeline?: NullableStringFieldUpdateOperationsInput | string | null
    lastContact?: DateTimeFieldUpdateOperationsInput | Date | string
    nextAction?: NullableStringFieldUpdateOperationsInput | string | null
    nextActionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProspectUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyName?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedValue?: NullableFloatFieldUpdateOperationsInput | number | null
    priority?: StringFieldUpdateOperationsInput | string
    stage?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    hasBudget?: BoolFieldUpdateOperationsInput | boolean
    isDecisionMaker?: BoolFieldUpdateOperationsInput | boolean
    hasNeed?: BoolFieldUpdateOperationsInput | boolean
    timeline?: NullableStringFieldUpdateOperationsInput | string | null
    lastContact?: DateTimeFieldUpdateOperationsInput | Date | string
    nextAction?: NullableStringFieldUpdateOperationsInput | string | null
    nextActionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: NullableIntFieldUpdateOperationsInput | number | null
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProspectActivityCreateInput = {
    type: string
    subject?: string | null
    description?: string | null
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    outcome?: string | null
    nextAction?: string | null
    createdAt?: Date | string
    prospect: ProspectCreateNestedOneWithoutActivitiesInput
    creator: UserCreateNestedOneWithoutCreatedProspectActivitiesInput
  }

  export type ProspectActivityUncheckedCreateInput = {
    id?: number
    prospectId: number
    type: string
    subject?: string | null
    description?: string | null
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    outcome?: string | null
    nextAction?: string | null
    createdBy: number
    createdAt?: Date | string
  }

  export type ProspectActivityUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    nextAction?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prospect?: ProspectUpdateOneRequiredWithoutActivitiesNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedProspectActivitiesNestedInput
  }

  export type ProspectActivityUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    prospectId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    nextAction?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProspectActivityCreateManyInput = {
    id?: number
    prospectId: number
    type: string
    subject?: string | null
    description?: string | null
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    outcome?: string | null
    nextAction?: string | null
    createdBy: number
    createdAt?: Date | string
  }

  export type ProspectActivityUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    nextAction?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProspectActivityUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    prospectId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    nextAction?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoanCreateInput = {
    loanNumber: string
    amount: number
    interestRate?: number
    monthlyPayment: number
    remainingAmount: number
    startDate: Date | string
    endDate: Date | string
    purpose?: string | null
    status?: $Enums.LoanStatus
    notes?: string | null
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutLoansInput
    payments?: LoanPaymentCreateNestedManyWithoutLoanInput
  }

  export type LoanUncheckedCreateInput = {
    id?: number
    loanNumber: string
    employeeId: number
    amount: number
    interestRate?: number
    monthlyPayment: number
    remainingAmount: number
    startDate: Date | string
    endDate: Date | string
    purpose?: string | null
    status?: $Enums.LoanStatus
    notes?: string | null
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: LoanPaymentUncheckedCreateNestedManyWithoutLoanInput
  }

  export type LoanUpdateInput = {
    loanNumber?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    interestRate?: FloatFieldUpdateOperationsInput | number
    monthlyPayment?: FloatFieldUpdateOperationsInput | number
    remainingAmount?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLoanStatusFieldUpdateOperationsInput | $Enums.LoanStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutLoansNestedInput
    payments?: LoanPaymentUpdateManyWithoutLoanNestedInput
  }

  export type LoanUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    loanNumber?: StringFieldUpdateOperationsInput | string
    employeeId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    interestRate?: FloatFieldUpdateOperationsInput | number
    monthlyPayment?: FloatFieldUpdateOperationsInput | number
    remainingAmount?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLoanStatusFieldUpdateOperationsInput | $Enums.LoanStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: LoanPaymentUncheckedUpdateManyWithoutLoanNestedInput
  }

  export type LoanCreateManyInput = {
    id?: number
    loanNumber: string
    employeeId: number
    amount: number
    interestRate?: number
    monthlyPayment: number
    remainingAmount: number
    startDate: Date | string
    endDate: Date | string
    purpose?: string | null
    status?: $Enums.LoanStatus
    notes?: string | null
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LoanUpdateManyMutationInput = {
    loanNumber?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    interestRate?: FloatFieldUpdateOperationsInput | number
    monthlyPayment?: FloatFieldUpdateOperationsInput | number
    remainingAmount?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLoanStatusFieldUpdateOperationsInput | $Enums.LoanStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoanUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    loanNumber?: StringFieldUpdateOperationsInput | string
    employeeId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    interestRate?: FloatFieldUpdateOperationsInput | number
    monthlyPayment?: FloatFieldUpdateOperationsInput | number
    remainingAmount?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLoanStatusFieldUpdateOperationsInput | $Enums.LoanStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpecialiteCreateInput = {
    libelle: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    techniciens?: TechnicienCreateNestedManyWithoutSpecialiteInput
  }

  export type SpecialiteUncheckedCreateInput = {
    id?: number
    libelle: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    techniciens?: TechnicienUncheckedCreateNestedManyWithoutSpecialiteInput
  }

  export type SpecialiteUpdateInput = {
    libelle?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    techniciens?: TechnicienUpdateManyWithoutSpecialiteNestedInput
  }

  export type SpecialiteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    libelle?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    techniciens?: TechnicienUncheckedUpdateManyWithoutSpecialiteNestedInput
  }

  export type SpecialiteCreateManyInput = {
    id?: number
    libelle: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SpecialiteUpdateManyMutationInput = {
    libelle?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpecialiteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    libelle?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TechnicienCreateInput = {
    nom: string
    prenom: string
    contact: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    specialite: SpecialiteCreateNestedOneWithoutTechniciensInput
    utilisateur?: UserCreateNestedOneWithoutTechnicienInput
    interventions?: TechnicienInterventionCreateNestedManyWithoutTechnicienInput
    rapports?: RapportMissionCreateNestedManyWithoutTechnicienInput
    sortiesMateriels?: SortieMaterielCreateNestedManyWithoutTechnicienInput
  }

  export type TechnicienUncheckedCreateInput = {
    id?: number
    nom: string
    prenom: string
    contact: string
    specialiteId: number
    utilisateurId?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    interventions?: TechnicienInterventionUncheckedCreateNestedManyWithoutTechnicienInput
    rapports?: RapportMissionUncheckedCreateNestedManyWithoutTechnicienInput
    sortiesMateriels?: SortieMaterielUncheckedCreateNestedManyWithoutTechnicienInput
  }

  export type TechnicienUpdateInput = {
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    specialite?: SpecialiteUpdateOneRequiredWithoutTechniciensNestedInput
    utilisateur?: UserUpdateOneWithoutTechnicienNestedInput
    interventions?: TechnicienInterventionUpdateManyWithoutTechnicienNestedInput
    rapports?: RapportMissionUpdateManyWithoutTechnicienNestedInput
    sortiesMateriels?: SortieMaterielUpdateManyWithoutTechnicienNestedInput
  }

  export type TechnicienUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    specialiteId?: IntFieldUpdateOperationsInput | number
    utilisateurId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interventions?: TechnicienInterventionUncheckedUpdateManyWithoutTechnicienNestedInput
    rapports?: RapportMissionUncheckedUpdateManyWithoutTechnicienNestedInput
    sortiesMateriels?: SortieMaterielUncheckedUpdateManyWithoutTechnicienNestedInput
  }

  export type TechnicienCreateManyInput = {
    id?: number
    nom: string
    prenom: string
    contact: string
    specialiteId: number
    utilisateurId?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TechnicienUpdateManyMutationInput = {
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TechnicienUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    specialiteId?: IntFieldUpdateOperationsInput | number
    utilisateurId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MissionCreateInput = {
    numIntervention: string
    natureIntervention: string
    objectifDuContrat: string
    description?: string | null
    priorite?: string | null
    statut?: string | null
    dateSortieFicheIntervention: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    client: CustomerCreateNestedOneWithoutMissionsInput
    interventions?: InterventionCreateNestedManyWithoutMissionInput
    rapports?: RapportMissionCreateNestedManyWithoutMissionInput
    devis?: QuoteCreateNestedManyWithoutMissionsInput
  }

  export type MissionUncheckedCreateInput = {
    numIntervention: string
    natureIntervention: string
    objectifDuContrat: string
    description?: string | null
    priorite?: string | null
    statut?: string | null
    dateSortieFicheIntervention: Date | string
    clientId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    interventions?: InterventionUncheckedCreateNestedManyWithoutMissionInput
    rapports?: RapportMissionUncheckedCreateNestedManyWithoutMissionInput
    devis?: QuoteUncheckedCreateNestedManyWithoutMissionsInput
  }

  export type MissionUpdateInput = {
    numIntervention?: StringFieldUpdateOperationsInput | string
    natureIntervention?: StringFieldUpdateOperationsInput | string
    objectifDuContrat?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priorite?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: NullableStringFieldUpdateOperationsInput | string | null
    dateSortieFicheIntervention?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: CustomerUpdateOneRequiredWithoutMissionsNestedInput
    interventions?: InterventionUpdateManyWithoutMissionNestedInput
    rapports?: RapportMissionUpdateManyWithoutMissionNestedInput
    devis?: QuoteUpdateManyWithoutMissionsNestedInput
  }

  export type MissionUncheckedUpdateInput = {
    numIntervention?: StringFieldUpdateOperationsInput | string
    natureIntervention?: StringFieldUpdateOperationsInput | string
    objectifDuContrat?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priorite?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: NullableStringFieldUpdateOperationsInput | string | null
    dateSortieFicheIntervention?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interventions?: InterventionUncheckedUpdateManyWithoutMissionNestedInput
    rapports?: RapportMissionUncheckedUpdateManyWithoutMissionNestedInput
    devis?: QuoteUncheckedUpdateManyWithoutMissionsNestedInput
  }

  export type MissionCreateManyInput = {
    numIntervention: string
    natureIntervention: string
    objectifDuContrat: string
    description?: string | null
    priorite?: string | null
    statut?: string | null
    dateSortieFicheIntervention: Date | string
    clientId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MissionUpdateManyMutationInput = {
    numIntervention?: StringFieldUpdateOperationsInput | string
    natureIntervention?: StringFieldUpdateOperationsInput | string
    objectifDuContrat?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priorite?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: NullableStringFieldUpdateOperationsInput | string | null
    dateSortieFicheIntervention?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MissionUncheckedUpdateManyInput = {
    numIntervention?: StringFieldUpdateOperationsInput | string
    natureIntervention?: StringFieldUpdateOperationsInput | string
    objectifDuContrat?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priorite?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: NullableStringFieldUpdateOperationsInput | string | null
    dateSortieFicheIntervention?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterventionCreateInput = {
    dateHeureDebut: Date | string
    dateHeureFin?: Date | string | null
    duree?: number | null
    statut?: string
    commentaire?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    mission: MissionCreateNestedOneWithoutInterventionsInput
    techniciens?: TechnicienInterventionCreateNestedManyWithoutInterventionInput
    rapports?: RapportMissionCreateNestedManyWithoutInterventionInput
    sortiesMateriels?: SortieMaterielCreateNestedManyWithoutInterventionInput
  }

  export type InterventionUncheckedCreateInput = {
    id?: number
    dateHeureDebut: Date | string
    dateHeureFin?: Date | string | null
    duree?: number | null
    missionId: string
    statut?: string
    commentaire?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    techniciens?: TechnicienInterventionUncheckedCreateNestedManyWithoutInterventionInput
    rapports?: RapportMissionUncheckedCreateNestedManyWithoutInterventionInput
    sortiesMateriels?: SortieMaterielUncheckedCreateNestedManyWithoutInterventionInput
  }

  export type InterventionUpdateInput = {
    dateHeureDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateHeureFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duree?: NullableIntFieldUpdateOperationsInput | number | null
    statut?: StringFieldUpdateOperationsInput | string
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mission?: MissionUpdateOneRequiredWithoutInterventionsNestedInput
    techniciens?: TechnicienInterventionUpdateManyWithoutInterventionNestedInput
    rapports?: RapportMissionUpdateManyWithoutInterventionNestedInput
    sortiesMateriels?: SortieMaterielUpdateManyWithoutInterventionNestedInput
  }

  export type InterventionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateHeureDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateHeureFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duree?: NullableIntFieldUpdateOperationsInput | number | null
    missionId?: StringFieldUpdateOperationsInput | string
    statut?: StringFieldUpdateOperationsInput | string
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    techniciens?: TechnicienInterventionUncheckedUpdateManyWithoutInterventionNestedInput
    rapports?: RapportMissionUncheckedUpdateManyWithoutInterventionNestedInput
    sortiesMateriels?: SortieMaterielUncheckedUpdateManyWithoutInterventionNestedInput
  }

  export type InterventionCreateManyInput = {
    id?: number
    dateHeureDebut: Date | string
    dateHeureFin?: Date | string | null
    duree?: number | null
    missionId: string
    statut?: string
    commentaire?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InterventionUpdateManyMutationInput = {
    dateHeureDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateHeureFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duree?: NullableIntFieldUpdateOperationsInput | number | null
    statut?: StringFieldUpdateOperationsInput | string
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterventionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateHeureDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateHeureFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duree?: NullableIntFieldUpdateOperationsInput | number | null
    missionId?: StringFieldUpdateOperationsInput | string
    statut?: StringFieldUpdateOperationsInput | string
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TechnicienInterventionCreateInput = {
    role?: string
    commentaire?: string | null
    createdAt?: Date | string
    technicien: TechnicienCreateNestedOneWithoutInterventionsInput
    intervention: InterventionCreateNestedOneWithoutTechniciensInput
  }

  export type TechnicienInterventionUncheckedCreateInput = {
    id?: number
    technicienId: number
    interventionId: number
    role?: string
    commentaire?: string | null
    createdAt?: Date | string
  }

  export type TechnicienInterventionUpdateInput = {
    role?: StringFieldUpdateOperationsInput | string
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    technicien?: TechnicienUpdateOneRequiredWithoutInterventionsNestedInput
    intervention?: InterventionUpdateOneRequiredWithoutTechniciensNestedInput
  }

  export type TechnicienInterventionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    technicienId?: IntFieldUpdateOperationsInput | number
    interventionId?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TechnicienInterventionCreateManyInput = {
    id?: number
    technicienId: number
    interventionId: number
    role?: string
    commentaire?: string | null
    createdAt?: Date | string
  }

  export type TechnicienInterventionUpdateManyMutationInput = {
    role?: StringFieldUpdateOperationsInput | string
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TechnicienInterventionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    technicienId?: IntFieldUpdateOperationsInput | number
    interventionId?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RapportMissionCreateInput = {
    titre: string
    contenu: string
    createdById?: number | null
    statut?: string
    dateValidation?: Date | string | null
    commentaire?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    intervention?: InterventionCreateNestedOneWithoutRapportsInput
    technicien: TechnicienCreateNestedOneWithoutRapportsInput
    mission: MissionCreateNestedOneWithoutRapportsInput
    images?: RapportImageCreateNestedManyWithoutRapportInput
  }

  export type RapportMissionUncheckedCreateInput = {
    id?: number
    titre: string
    contenu: string
    interventionId?: number | null
    technicienId: number
    missionId: string
    createdById?: number | null
    statut?: string
    dateValidation?: Date | string | null
    commentaire?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: RapportImageUncheckedCreateNestedManyWithoutRapportInput
  }

  export type RapportMissionUpdateInput = {
    titre?: StringFieldUpdateOperationsInput | string
    contenu?: StringFieldUpdateOperationsInput | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    statut?: StringFieldUpdateOperationsInput | string
    dateValidation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intervention?: InterventionUpdateOneWithoutRapportsNestedInput
    technicien?: TechnicienUpdateOneRequiredWithoutRapportsNestedInput
    mission?: MissionUpdateOneRequiredWithoutRapportsNestedInput
    images?: RapportImageUpdateManyWithoutRapportNestedInput
  }

  export type RapportMissionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    titre?: StringFieldUpdateOperationsInput | string
    contenu?: StringFieldUpdateOperationsInput | string
    interventionId?: NullableIntFieldUpdateOperationsInput | number | null
    technicienId?: IntFieldUpdateOperationsInput | number
    missionId?: StringFieldUpdateOperationsInput | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    statut?: StringFieldUpdateOperationsInput | string
    dateValidation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: RapportImageUncheckedUpdateManyWithoutRapportNestedInput
  }

  export type RapportMissionCreateManyInput = {
    id?: number
    titre: string
    contenu: string
    interventionId?: number | null
    technicienId: number
    missionId: string
    createdById?: number | null
    statut?: string
    dateValidation?: Date | string | null
    commentaire?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RapportMissionUpdateManyMutationInput = {
    titre?: StringFieldUpdateOperationsInput | string
    contenu?: StringFieldUpdateOperationsInput | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    statut?: StringFieldUpdateOperationsInput | string
    dateValidation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RapportMissionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    titre?: StringFieldUpdateOperationsInput | string
    contenu?: StringFieldUpdateOperationsInput | string
    interventionId?: NullableIntFieldUpdateOperationsInput | number | null
    technicienId?: IntFieldUpdateOperationsInput | number
    missionId?: StringFieldUpdateOperationsInput | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    statut?: StringFieldUpdateOperationsInput | string
    dateValidation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RapportImageCreateInput = {
    url: string
    description?: string | null
    ordre: number
    createdAt?: Date | string
    rapport: RapportMissionCreateNestedOneWithoutImagesInput
  }

  export type RapportImageUncheckedCreateInput = {
    id?: number
    rapportId: number
    url: string
    description?: string | null
    ordre: number
    createdAt?: Date | string
  }

  export type RapportImageUpdateInput = {
    url?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ordre?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rapport?: RapportMissionUpdateOneRequiredWithoutImagesNestedInput
  }

  export type RapportImageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    rapportId?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ordre?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RapportImageCreateManyInput = {
    id?: number
    rapportId: number
    url: string
    description?: string | null
    ordre: number
    createdAt?: Date | string
  }

  export type RapportImageUpdateManyMutationInput = {
    url?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ordre?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RapportImageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    rapportId?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ordre?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterielCreateInput = {
    reference: string
    designation: string
    description?: string | null
    quantiteTotale?: number
    quantiteDisponible?: number
    seuilAlerte?: number
    emplacement?: string | null
    categorie?: string
    prixUnitaire?: number | null
    fournisseur?: string | null
    dateAchat?: Date | string | null
    garantie?: string | null
    statut?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sorties?: SortieMaterielCreateNestedManyWithoutMaterielInput
    entrees?: EntreeMaterielCreateNestedManyWithoutMaterielInput
  }

  export type MaterielUncheckedCreateInput = {
    id?: number
    reference: string
    designation: string
    description?: string | null
    quantiteTotale?: number
    quantiteDisponible?: number
    seuilAlerte?: number
    emplacement?: string | null
    categorie?: string
    prixUnitaire?: number | null
    fournisseur?: string | null
    dateAchat?: Date | string | null
    garantie?: string | null
    statut?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sorties?: SortieMaterielUncheckedCreateNestedManyWithoutMaterielInput
    entrees?: EntreeMaterielUncheckedCreateNestedManyWithoutMaterielInput
  }

  export type MaterielUpdateInput = {
    reference?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantiteTotale?: IntFieldUpdateOperationsInput | number
    quantiteDisponible?: IntFieldUpdateOperationsInput | number
    seuilAlerte?: IntFieldUpdateOperationsInput | number
    emplacement?: NullableStringFieldUpdateOperationsInput | string | null
    categorie?: StringFieldUpdateOperationsInput | string
    prixUnitaire?: NullableFloatFieldUpdateOperationsInput | number | null
    fournisseur?: NullableStringFieldUpdateOperationsInput | string | null
    dateAchat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garantie?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sorties?: SortieMaterielUpdateManyWithoutMaterielNestedInput
    entrees?: EntreeMaterielUpdateManyWithoutMaterielNestedInput
  }

  export type MaterielUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    reference?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantiteTotale?: IntFieldUpdateOperationsInput | number
    quantiteDisponible?: IntFieldUpdateOperationsInput | number
    seuilAlerte?: IntFieldUpdateOperationsInput | number
    emplacement?: NullableStringFieldUpdateOperationsInput | string | null
    categorie?: StringFieldUpdateOperationsInput | string
    prixUnitaire?: NullableFloatFieldUpdateOperationsInput | number | null
    fournisseur?: NullableStringFieldUpdateOperationsInput | string | null
    dateAchat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garantie?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sorties?: SortieMaterielUncheckedUpdateManyWithoutMaterielNestedInput
    entrees?: EntreeMaterielUncheckedUpdateManyWithoutMaterielNestedInput
  }

  export type MaterielCreateManyInput = {
    id?: number
    reference: string
    designation: string
    description?: string | null
    quantiteTotale?: number
    quantiteDisponible?: number
    seuilAlerte?: number
    emplacement?: string | null
    categorie?: string
    prixUnitaire?: number | null
    fournisseur?: string | null
    dateAchat?: Date | string | null
    garantie?: string | null
    statut?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaterielUpdateManyMutationInput = {
    reference?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantiteTotale?: IntFieldUpdateOperationsInput | number
    quantiteDisponible?: IntFieldUpdateOperationsInput | number
    seuilAlerte?: IntFieldUpdateOperationsInput | number
    emplacement?: NullableStringFieldUpdateOperationsInput | string | null
    categorie?: StringFieldUpdateOperationsInput | string
    prixUnitaire?: NullableFloatFieldUpdateOperationsInput | number | null
    fournisseur?: NullableStringFieldUpdateOperationsInput | string | null
    dateAchat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garantie?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterielUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    reference?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantiteTotale?: IntFieldUpdateOperationsInput | number
    quantiteDisponible?: IntFieldUpdateOperationsInput | number
    seuilAlerte?: IntFieldUpdateOperationsInput | number
    emplacement?: NullableStringFieldUpdateOperationsInput | string | null
    categorie?: StringFieldUpdateOperationsInput | string
    prixUnitaire?: NullableFloatFieldUpdateOperationsInput | number | null
    fournisseur?: NullableStringFieldUpdateOperationsInput | string | null
    dateAchat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garantie?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SortieMaterielCreateInput = {
    quantite: number
    dateSortie?: Date | string
    motif?: string | null
    retourne?: boolean
    dateRetour?: Date | string | null
    quantiteRetour?: number | null
    commentaire?: string | null
    createdAt?: Date | string
    materiel: MaterielCreateNestedOneWithoutSortiesInput
    intervention: InterventionCreateNestedOneWithoutSortiesMaterielsInput
    technicien: TechnicienCreateNestedOneWithoutSortiesMaterielsInput
  }

  export type SortieMaterielUncheckedCreateInput = {
    id?: number
    materielId: number
    interventionId: number
    technicienId: number
    quantite: number
    dateSortie?: Date | string
    motif?: string | null
    retourne?: boolean
    dateRetour?: Date | string | null
    quantiteRetour?: number | null
    commentaire?: string | null
    createdAt?: Date | string
  }

  export type SortieMaterielUpdateInput = {
    quantite?: IntFieldUpdateOperationsInput | number
    dateSortie?: DateTimeFieldUpdateOperationsInput | Date | string
    motif?: NullableStringFieldUpdateOperationsInput | string | null
    retourne?: BoolFieldUpdateOperationsInput | boolean
    dateRetour?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantiteRetour?: NullableIntFieldUpdateOperationsInput | number | null
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    materiel?: MaterielUpdateOneRequiredWithoutSortiesNestedInput
    intervention?: InterventionUpdateOneRequiredWithoutSortiesMaterielsNestedInput
    technicien?: TechnicienUpdateOneRequiredWithoutSortiesMaterielsNestedInput
  }

  export type SortieMaterielUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    materielId?: IntFieldUpdateOperationsInput | number
    interventionId?: IntFieldUpdateOperationsInput | number
    technicienId?: IntFieldUpdateOperationsInput | number
    quantite?: IntFieldUpdateOperationsInput | number
    dateSortie?: DateTimeFieldUpdateOperationsInput | Date | string
    motif?: NullableStringFieldUpdateOperationsInput | string | null
    retourne?: BoolFieldUpdateOperationsInput | boolean
    dateRetour?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantiteRetour?: NullableIntFieldUpdateOperationsInput | number | null
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SortieMaterielCreateManyInput = {
    id?: number
    materielId: number
    interventionId: number
    technicienId: number
    quantite: number
    dateSortie?: Date | string
    motif?: string | null
    retourne?: boolean
    dateRetour?: Date | string | null
    quantiteRetour?: number | null
    commentaire?: string | null
    createdAt?: Date | string
  }

  export type SortieMaterielUpdateManyMutationInput = {
    quantite?: IntFieldUpdateOperationsInput | number
    dateSortie?: DateTimeFieldUpdateOperationsInput | Date | string
    motif?: NullableStringFieldUpdateOperationsInput | string | null
    retourne?: BoolFieldUpdateOperationsInput | boolean
    dateRetour?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantiteRetour?: NullableIntFieldUpdateOperationsInput | number | null
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SortieMaterielUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    materielId?: IntFieldUpdateOperationsInput | number
    interventionId?: IntFieldUpdateOperationsInput | number
    technicienId?: IntFieldUpdateOperationsInput | number
    quantite?: IntFieldUpdateOperationsInput | number
    dateSortie?: DateTimeFieldUpdateOperationsInput | Date | string
    motif?: NullableStringFieldUpdateOperationsInput | string | null
    retourne?: BoolFieldUpdateOperationsInput | boolean
    dateRetour?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantiteRetour?: NullableIntFieldUpdateOperationsInput | number | null
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EntreeMaterielCreateInput = {
    quantite: number
    dateEntree?: Date | string
    source?: string
    prixTotal?: number | null
    fournisseur?: string | null
    facture?: string | null
    commentaire?: string | null
    createdAt?: Date | string
    materiel: MaterielCreateNestedOneWithoutEntreesInput
  }

  export type EntreeMaterielUncheckedCreateInput = {
    id?: number
    materielId: number
    quantite: number
    dateEntree?: Date | string
    source?: string
    prixTotal?: number | null
    fournisseur?: string | null
    facture?: string | null
    commentaire?: string | null
    createdAt?: Date | string
  }

  export type EntreeMaterielUpdateInput = {
    quantite?: IntFieldUpdateOperationsInput | number
    dateEntree?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: StringFieldUpdateOperationsInput | string
    prixTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    fournisseur?: NullableStringFieldUpdateOperationsInput | string | null
    facture?: NullableStringFieldUpdateOperationsInput | string | null
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    materiel?: MaterielUpdateOneRequiredWithoutEntreesNestedInput
  }

  export type EntreeMaterielUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    materielId?: IntFieldUpdateOperationsInput | number
    quantite?: IntFieldUpdateOperationsInput | number
    dateEntree?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: StringFieldUpdateOperationsInput | string
    prixTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    fournisseur?: NullableStringFieldUpdateOperationsInput | string | null
    facture?: NullableStringFieldUpdateOperationsInput | string | null
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EntreeMaterielCreateManyInput = {
    id?: number
    materielId: number
    quantite: number
    dateEntree?: Date | string
    source?: string
    prixTotal?: number | null
    fournisseur?: string | null
    facture?: string | null
    commentaire?: string | null
    createdAt?: Date | string
  }

  export type EntreeMaterielUpdateManyMutationInput = {
    quantite?: IntFieldUpdateOperationsInput | number
    dateEntree?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: StringFieldUpdateOperationsInput | string
    prixTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    fournisseur?: NullableStringFieldUpdateOperationsInput | string | null
    facture?: NullableStringFieldUpdateOperationsInput | string | null
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EntreeMaterielUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    materielId?: IntFieldUpdateOperationsInput | number
    quantite?: IntFieldUpdateOperationsInput | number
    dateEntree?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: StringFieldUpdateOperationsInput | string
    prixTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    fournisseur?: NullableStringFieldUpdateOperationsInput | string | null
    facture?: NullableStringFieldUpdateOperationsInput | string | null
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    type: string
    message: string
    data?: string | null
    readAt?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: number
    type: string
    message: string
    data?: string | null
    readAt?: Date | string | null
    createdAt?: Date | string
    userId: number
  }

  export type NotificationUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type NotificationCreateManyInput = {
    id?: number
    type: string
    message: string
    data?: string | null
    readAt?: Date | string | null
    createdAt?: Date | string
    userId: number
  }

  export type NotificationUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type CustomerListRelationFilter = {
    every?: CustomerWhereInput
    some?: CustomerWhereInput
    none?: CustomerWhereInput
  }

  export type EmployeeListRelationFilter = {
    every?: EmployeeWhereInput
    some?: EmployeeWhereInput
    none?: EmployeeWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmployeeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type ServiceNullableRelationFilter = {
    is?: ServiceWhereInput | null
    isNot?: ServiceWhereInput | null
  }

  export type QuoteListRelationFilter = {
    every?: QuoteWhereInput
    some?: QuoteWhereInput
    none?: QuoteWhereInput
  }

  export type InvoiceListRelationFilter = {
    every?: InvoiceWhereInput
    some?: InvoiceWhereInput
    none?: InvoiceWhereInput
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type QuoteApprovalListRelationFilter = {
    every?: QuoteApprovalWhereInput
    some?: QuoteApprovalWhereInput
    none?: QuoteApprovalWhereInput
  }

  export type ExpenseListRelationFilter = {
    every?: ExpenseWhereInput
    some?: ExpenseWhereInput
    none?: ExpenseWhereInput
  }

  export type AccountingEntryListRelationFilter = {
    every?: AccountingEntryWhereInput
    some?: AccountingEntryWhereInput
    none?: AccountingEntryWhereInput
  }

  export type CashFlowListRelationFilter = {
    every?: CashFlowWhereInput
    some?: CashFlowWhereInput
    none?: CashFlowWhereInput
  }

  export type ReminderListRelationFilter = {
    every?: ReminderWhereInput
    some?: ReminderWhereInput
    none?: ReminderWhereInput
  }

  export type RecurringInvoiceListRelationFilter = {
    every?: RecurringInvoiceWhereInput
    some?: RecurringInvoiceWhereInput
    none?: RecurringInvoiceWhereInput
  }

  export type EmployeeNullableRelationFilter = {
    is?: EmployeeWhereInput | null
    isNot?: EmployeeWhereInput | null
  }

  export type LeaveRequestListRelationFilter = {
    every?: LeaveRequestWhereInput
    some?: LeaveRequestWhereInput
    none?: LeaveRequestWhereInput
  }

  export type ProspectListRelationFilter = {
    every?: ProspectWhereInput
    some?: ProspectWhereInput
    none?: ProspectWhereInput
  }

  export type ProspectActivityListRelationFilter = {
    every?: ProspectActivityWhereInput
    some?: ProspectActivityWhereInput
    none?: ProspectActivityWhereInput
  }

  export type TechnicienNullableRelationFilter = {
    is?: TechnicienWhereInput | null
    isNot?: TechnicienWhereInput | null
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type QuoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuoteApprovalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExpenseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountingEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CashFlowOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReminderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RecurringInvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LeaveRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProspectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProspectActivityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    serviceId?: SortOrder
    isActive?: SortOrder
    lastLogin?: SortOrder
    preferences?: SortOrder
    permissions?: SortOrder
    avatarUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    serviceId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    serviceId?: SortOrder
    isActive?: SortOrder
    lastLogin?: SortOrder
    preferences?: SortOrder
    permissions?: SortOrder
    avatarUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    serviceId?: SortOrder
    isActive?: SortOrder
    lastLogin?: SortOrder
    preferences?: SortOrder
    permissions?: SortOrder
    avatarUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    serviceId?: SortOrder
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumCustomerTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CustomerType | EnumCustomerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CustomerType[] | ListEnumCustomerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CustomerType[] | ListEnumCustomerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCustomerTypeFilter<$PrismaModel> | $Enums.CustomerType
  }

  export type EnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type CustomerAddressListRelationFilter = {
    every?: CustomerAddressWhereInput
    some?: CustomerAddressWhereInput
    none?: CustomerAddressWhereInput
  }

  export type MissionListRelationFilter = {
    every?: MissionWhereInput
    some?: MissionWhereInput
    none?: MissionWhereInput
  }

  export type CustomerAddressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerCountOrderByAggregateInput = {
    id?: SortOrder
    customerNumber?: SortOrder
    type?: SortOrder
    name?: SortOrder
    legalName?: SortOrder
    siret?: SortOrder
    vatNumber?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    mobile?: SortOrder
    website?: SortOrder
    paymentTerms?: SortOrder
    paymentMethod?: SortOrder
    creditLimit?: SortOrder
    discountRate?: SortOrder
    category?: SortOrder
    tags?: SortOrder
    notes?: SortOrder
    isActive?: SortOrder
    serviceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
  }

  export type CustomerAvgOrderByAggregateInput = {
    id?: SortOrder
    paymentTerms?: SortOrder
    creditLimit?: SortOrder
    discountRate?: SortOrder
    serviceId?: SortOrder
    createdBy?: SortOrder
  }

  export type CustomerMaxOrderByAggregateInput = {
    id?: SortOrder
    customerNumber?: SortOrder
    type?: SortOrder
    name?: SortOrder
    legalName?: SortOrder
    siret?: SortOrder
    vatNumber?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    mobile?: SortOrder
    website?: SortOrder
    paymentTerms?: SortOrder
    paymentMethod?: SortOrder
    creditLimit?: SortOrder
    discountRate?: SortOrder
    category?: SortOrder
    tags?: SortOrder
    notes?: SortOrder
    isActive?: SortOrder
    serviceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
  }

  export type CustomerMinOrderByAggregateInput = {
    id?: SortOrder
    customerNumber?: SortOrder
    type?: SortOrder
    name?: SortOrder
    legalName?: SortOrder
    siret?: SortOrder
    vatNumber?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    mobile?: SortOrder
    website?: SortOrder
    paymentTerms?: SortOrder
    paymentMethod?: SortOrder
    creditLimit?: SortOrder
    discountRate?: SortOrder
    category?: SortOrder
    tags?: SortOrder
    notes?: SortOrder
    isActive?: SortOrder
    serviceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
  }

  export type CustomerSumOrderByAggregateInput = {
    id?: SortOrder
    paymentTerms?: SortOrder
    creditLimit?: SortOrder
    discountRate?: SortOrder
    serviceId?: SortOrder
    createdBy?: SortOrder
  }

  export type EnumCustomerTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CustomerType | EnumCustomerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CustomerType[] | ListEnumCustomerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CustomerType[] | ListEnumCustomerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCustomerTypeWithAggregatesFilter<$PrismaModel> | $Enums.CustomerType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCustomerTypeFilter<$PrismaModel>
    _max?: NestedEnumCustomerTypeFilter<$PrismaModel>
  }

  export type EnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumAddressTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AddressType | EnumAddressTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AddressType[] | ListEnumAddressTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AddressType[] | ListEnumAddressTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAddressTypeFilter<$PrismaModel> | $Enums.AddressType
  }

  export type CustomerRelationFilter = {
    is?: CustomerWhereInput
    isNot?: CustomerWhereInput
  }

  export type CustomerAddressCountOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    postalCode?: SortOrder
    city?: SortOrder
    country?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
  }

  export type CustomerAddressAvgOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
  }

  export type CustomerAddressMaxOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    postalCode?: SortOrder
    city?: SortOrder
    country?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
  }

  export type CustomerAddressMinOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    postalCode?: SortOrder
    city?: SortOrder
    country?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
  }

  export type CustomerAddressSumOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
  }

  export type EnumAddressTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AddressType | EnumAddressTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AddressType[] | ListEnumAddressTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AddressType[] | ListEnumAddressTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAddressTypeWithAggregatesFilter<$PrismaModel> | $Enums.AddressType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAddressTypeFilter<$PrismaModel>
    _max?: NestedEnumAddressTypeFilter<$PrismaModel>
  }

  export type EnumProductTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductType | EnumProductTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProductTypeFilter<$PrismaModel> | $Enums.ProductType
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type ProductPriceListRelationFilter = {
    every?: ProductPriceWhereInput
    some?: ProductPriceWhereInput
    none?: ProductPriceWhereInput
  }

  export type QuoteItemListRelationFilter = {
    every?: QuoteItemWhereInput
    some?: QuoteItemWhereInput
    none?: QuoteItemWhereInput
  }

  export type InvoiceItemListRelationFilter = {
    every?: InvoiceItemWhereInput
    some?: InvoiceItemWhereInput
    none?: InvoiceItemWhereInput
  }

  export type RecurringInvoiceItemListRelationFilter = {
    every?: RecurringInvoiceItemWhereInput
    some?: RecurringInvoiceItemWhereInput
    none?: RecurringInvoiceItemWhereInput
  }

  export type ProductPriceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuoteItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RecurringInvoiceItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    category?: SortOrder
    unit?: SortOrder
    priceHt?: SortOrder
    vatRate?: SortOrder
    costPrice?: SortOrder
    stockQuantity?: SortOrder
    stockAlertThreshold?: SortOrder
    isActive?: SortOrder
    weight?: SortOrder
    dimensions?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    id?: SortOrder
    priceHt?: SortOrder
    vatRate?: SortOrder
    costPrice?: SortOrder
    stockQuantity?: SortOrder
    stockAlertThreshold?: SortOrder
    weight?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    category?: SortOrder
    unit?: SortOrder
    priceHt?: SortOrder
    vatRate?: SortOrder
    costPrice?: SortOrder
    stockQuantity?: SortOrder
    stockAlertThreshold?: SortOrder
    isActive?: SortOrder
    weight?: SortOrder
    dimensions?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    category?: SortOrder
    unit?: SortOrder
    priceHt?: SortOrder
    vatRate?: SortOrder
    costPrice?: SortOrder
    stockQuantity?: SortOrder
    stockAlertThreshold?: SortOrder
    isActive?: SortOrder
    weight?: SortOrder
    dimensions?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    id?: SortOrder
    priceHt?: SortOrder
    vatRate?: SortOrder
    costPrice?: SortOrder
    stockQuantity?: SortOrder
    stockAlertThreshold?: SortOrder
    weight?: SortOrder
  }

  export type EnumProductTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductType | EnumProductTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProductTypeWithAggregatesFilter<$PrismaModel> | $Enums.ProductType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProductTypeFilter<$PrismaModel>
    _max?: NestedEnumProductTypeFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type ProductRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type ProductPriceCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    customerCategory?: SortOrder
    minQuantity?: SortOrder
    priceHt?: SortOrder
    validFrom?: SortOrder
    validUntil?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductPriceAvgOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    minQuantity?: SortOrder
    priceHt?: SortOrder
  }

  export type ProductPriceMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    customerCategory?: SortOrder
    minQuantity?: SortOrder
    priceHt?: SortOrder
    validFrom?: SortOrder
    validUntil?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductPriceMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    customerCategory?: SortOrder
    minQuantity?: SortOrder
    priceHt?: SortOrder
    validFrom?: SortOrder
    validUntil?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductPriceSumOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    minQuantity?: SortOrder
    priceHt?: SortOrder
  }

  export type EnumQuoteStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.QuoteStatus | EnumQuoteStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QuoteStatus[] | ListEnumQuoteStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuoteStatus[] | ListEnumQuoteStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQuoteStatusFilter<$PrismaModel> | $Enums.QuoteStatus
  }

  export type CustomerAddressNullableRelationFilter = {
    is?: CustomerAddressWhereInput | null
    isNot?: CustomerAddressWhereInput | null
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type QuoteCountOrderByAggregateInput = {
    id?: SortOrder
    quoteNumber?: SortOrder
    customerId?: SortOrder
    customerAddressId?: SortOrder
    status?: SortOrder
    quoteDate?: SortOrder
    validUntil?: SortOrder
    subtotalHt?: SortOrder
    discountAmount?: SortOrder
    totalVat?: SortOrder
    totalTtc?: SortOrder
    terms?: SortOrder
    notes?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sentAt?: SortOrder
    submittedForServiceApprovalAt?: SortOrder
    serviceManagerApprovedBy?: SortOrder
    serviceManagerApprovalDate?: SortOrder
    serviceManagerComments?: SortOrder
    dgApprovedBy?: SortOrder
    dgApprovalDate?: SortOrder
    dgComments?: SortOrder
    acceptedAt?: SortOrder
  }

  export type QuoteAvgOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    customerAddressId?: SortOrder
    subtotalHt?: SortOrder
    discountAmount?: SortOrder
    totalVat?: SortOrder
    totalTtc?: SortOrder
    createdBy?: SortOrder
    serviceManagerApprovedBy?: SortOrder
    dgApprovedBy?: SortOrder
  }

  export type QuoteMaxOrderByAggregateInput = {
    id?: SortOrder
    quoteNumber?: SortOrder
    customerId?: SortOrder
    customerAddressId?: SortOrder
    status?: SortOrder
    quoteDate?: SortOrder
    validUntil?: SortOrder
    subtotalHt?: SortOrder
    discountAmount?: SortOrder
    totalVat?: SortOrder
    totalTtc?: SortOrder
    terms?: SortOrder
    notes?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sentAt?: SortOrder
    submittedForServiceApprovalAt?: SortOrder
    serviceManagerApprovedBy?: SortOrder
    serviceManagerApprovalDate?: SortOrder
    serviceManagerComments?: SortOrder
    dgApprovedBy?: SortOrder
    dgApprovalDate?: SortOrder
    dgComments?: SortOrder
    acceptedAt?: SortOrder
  }

  export type QuoteMinOrderByAggregateInput = {
    id?: SortOrder
    quoteNumber?: SortOrder
    customerId?: SortOrder
    customerAddressId?: SortOrder
    status?: SortOrder
    quoteDate?: SortOrder
    validUntil?: SortOrder
    subtotalHt?: SortOrder
    discountAmount?: SortOrder
    totalVat?: SortOrder
    totalTtc?: SortOrder
    terms?: SortOrder
    notes?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sentAt?: SortOrder
    submittedForServiceApprovalAt?: SortOrder
    serviceManagerApprovedBy?: SortOrder
    serviceManagerApprovalDate?: SortOrder
    serviceManagerComments?: SortOrder
    dgApprovedBy?: SortOrder
    dgApprovalDate?: SortOrder
    dgComments?: SortOrder
    acceptedAt?: SortOrder
  }

  export type QuoteSumOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    customerAddressId?: SortOrder
    subtotalHt?: SortOrder
    discountAmount?: SortOrder
    totalVat?: SortOrder
    totalTtc?: SortOrder
    createdBy?: SortOrder
    serviceManagerApprovedBy?: SortOrder
    dgApprovedBy?: SortOrder
  }

  export type EnumQuoteStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuoteStatus | EnumQuoteStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QuoteStatus[] | ListEnumQuoteStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuoteStatus[] | ListEnumQuoteStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQuoteStatusWithAggregatesFilter<$PrismaModel> | $Enums.QuoteStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuoteStatusFilter<$PrismaModel>
    _max?: NestedEnumQuoteStatusFilter<$PrismaModel>
  }

  export type QuoteRelationFilter = {
    is?: QuoteWhereInput
    isNot?: QuoteWhereInput
  }

  export type ProductNullableRelationFilter = {
    is?: ProductWhereInput | null
    isNot?: ProductWhereInput | null
  }

  export type QuoteItemCountOrderByAggregateInput = {
    id?: SortOrder
    quoteId?: SortOrder
    productId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPriceHt?: SortOrder
    discountRate?: SortOrder
    vatRate?: SortOrder
    totalHt?: SortOrder
    sortOrder?: SortOrder
  }

  export type QuoteItemAvgOrderByAggregateInput = {
    id?: SortOrder
    quoteId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitPriceHt?: SortOrder
    discountRate?: SortOrder
    vatRate?: SortOrder
    totalHt?: SortOrder
    sortOrder?: SortOrder
  }

  export type QuoteItemMaxOrderByAggregateInput = {
    id?: SortOrder
    quoteId?: SortOrder
    productId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPriceHt?: SortOrder
    discountRate?: SortOrder
    vatRate?: SortOrder
    totalHt?: SortOrder
    sortOrder?: SortOrder
  }

  export type QuoteItemMinOrderByAggregateInput = {
    id?: SortOrder
    quoteId?: SortOrder
    productId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPriceHt?: SortOrder
    discountRate?: SortOrder
    vatRate?: SortOrder
    totalHt?: SortOrder
    sortOrder?: SortOrder
  }

  export type QuoteItemSumOrderByAggregateInput = {
    id?: SortOrder
    quoteId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitPriceHt?: SortOrder
    discountRate?: SortOrder
    vatRate?: SortOrder
    totalHt?: SortOrder
    sortOrder?: SortOrder
  }

  export type EnumApprovalLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.ApprovalLevel | EnumApprovalLevelFieldRefInput<$PrismaModel>
    in?: $Enums.ApprovalLevel[] | ListEnumApprovalLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApprovalLevel[] | ListEnumApprovalLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumApprovalLevelFilter<$PrismaModel> | $Enums.ApprovalLevel
  }

  export type EnumApprovalStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ApprovalStatus | EnumApprovalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApprovalStatusFilter<$PrismaModel> | $Enums.ApprovalStatus
  }

  export type QuoteApprovalQuoteIdApprovalLevelCompoundUniqueInput = {
    quoteId: number
    approvalLevel: $Enums.ApprovalLevel
  }

  export type QuoteApprovalCountOrderByAggregateInput = {
    id?: SortOrder
    quoteId?: SortOrder
    approverId?: SortOrder
    approvalLevel?: SortOrder
    status?: SortOrder
    approvalDate?: SortOrder
    comments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuoteApprovalAvgOrderByAggregateInput = {
    id?: SortOrder
    quoteId?: SortOrder
    approverId?: SortOrder
  }

  export type QuoteApprovalMaxOrderByAggregateInput = {
    id?: SortOrder
    quoteId?: SortOrder
    approverId?: SortOrder
    approvalLevel?: SortOrder
    status?: SortOrder
    approvalDate?: SortOrder
    comments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuoteApprovalMinOrderByAggregateInput = {
    id?: SortOrder
    quoteId?: SortOrder
    approverId?: SortOrder
    approvalLevel?: SortOrder
    status?: SortOrder
    approvalDate?: SortOrder
    comments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuoteApprovalSumOrderByAggregateInput = {
    id?: SortOrder
    quoteId?: SortOrder
    approverId?: SortOrder
  }

  export type EnumApprovalLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApprovalLevel | EnumApprovalLevelFieldRefInput<$PrismaModel>
    in?: $Enums.ApprovalLevel[] | ListEnumApprovalLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApprovalLevel[] | ListEnumApprovalLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumApprovalLevelWithAggregatesFilter<$PrismaModel> | $Enums.ApprovalLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApprovalLevelFilter<$PrismaModel>
    _max?: NestedEnumApprovalLevelFilter<$PrismaModel>
  }

  export type EnumApprovalStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApprovalStatus | EnumApprovalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApprovalStatusWithAggregatesFilter<$PrismaModel> | $Enums.ApprovalStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApprovalStatusFilter<$PrismaModel>
    _max?: NestedEnumApprovalStatusFilter<$PrismaModel>
  }

  export type EnumInvoiceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceType | EnumInvoiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceType[] | ListEnumInvoiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceType[] | ListEnumInvoiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceTypeFilter<$PrismaModel> | $Enums.InvoiceType
  }

  export type EnumInvoiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusFilter<$PrismaModel> | $Enums.InvoiceStatus
  }

  export type QuoteNullableRelationFilter = {
    is?: QuoteWhereInput | null
    isNot?: QuoteWhereInput | null
  }

  export type PaymentAllocationListRelationFilter = {
    every?: PaymentAllocationWhereInput
    some?: PaymentAllocationWhereInput
    none?: PaymentAllocationWhereInput
  }

  export type PaymentAllocationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    customerId?: SortOrder
    customerAddressId?: SortOrder
    quoteId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    invoiceDate?: SortOrder
    dueDate?: SortOrder
    subtotalHt?: SortOrder
    discountAmount?: SortOrder
    totalVat?: SortOrder
    totalTtc?: SortOrder
    paidAmount?: SortOrder
    balanceDue?: SortOrder
    paymentTerms?: SortOrder
    lateFeeRate?: SortOrder
    terms?: SortOrder
    notes?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sentAt?: SortOrder
  }

  export type InvoiceAvgOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    customerAddressId?: SortOrder
    quoteId?: SortOrder
    subtotalHt?: SortOrder
    discountAmount?: SortOrder
    totalVat?: SortOrder
    totalTtc?: SortOrder
    paidAmount?: SortOrder
    balanceDue?: SortOrder
    paymentTerms?: SortOrder
    lateFeeRate?: SortOrder
    createdBy?: SortOrder
  }

  export type InvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    customerId?: SortOrder
    customerAddressId?: SortOrder
    quoteId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    invoiceDate?: SortOrder
    dueDate?: SortOrder
    subtotalHt?: SortOrder
    discountAmount?: SortOrder
    totalVat?: SortOrder
    totalTtc?: SortOrder
    paidAmount?: SortOrder
    balanceDue?: SortOrder
    paymentTerms?: SortOrder
    lateFeeRate?: SortOrder
    terms?: SortOrder
    notes?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sentAt?: SortOrder
  }

  export type InvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    customerId?: SortOrder
    customerAddressId?: SortOrder
    quoteId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    invoiceDate?: SortOrder
    dueDate?: SortOrder
    subtotalHt?: SortOrder
    discountAmount?: SortOrder
    totalVat?: SortOrder
    totalTtc?: SortOrder
    paidAmount?: SortOrder
    balanceDue?: SortOrder
    paymentTerms?: SortOrder
    lateFeeRate?: SortOrder
    terms?: SortOrder
    notes?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sentAt?: SortOrder
  }

  export type InvoiceSumOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    customerAddressId?: SortOrder
    quoteId?: SortOrder
    subtotalHt?: SortOrder
    discountAmount?: SortOrder
    totalVat?: SortOrder
    totalTtc?: SortOrder
    paidAmount?: SortOrder
    balanceDue?: SortOrder
    paymentTerms?: SortOrder
    lateFeeRate?: SortOrder
    createdBy?: SortOrder
  }

  export type EnumInvoiceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceType | EnumInvoiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceType[] | ListEnumInvoiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceType[] | ListEnumInvoiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceTypeWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceTypeFilter<$PrismaModel>
    _max?: NestedEnumInvoiceTypeFilter<$PrismaModel>
  }

  export type EnumInvoiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceStatusFilter<$PrismaModel>
    _max?: NestedEnumInvoiceStatusFilter<$PrismaModel>
  }

  export type InvoiceRelationFilter = {
    is?: InvoiceWhereInput
    isNot?: InvoiceWhereInput
  }

  export type InvoiceItemCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    productId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPriceHt?: SortOrder
    discountRate?: SortOrder
    vatRate?: SortOrder
    totalHt?: SortOrder
    sortOrder?: SortOrder
  }

  export type InvoiceItemAvgOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitPriceHt?: SortOrder
    discountRate?: SortOrder
    vatRate?: SortOrder
    totalHt?: SortOrder
    sortOrder?: SortOrder
  }

  export type InvoiceItemMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    productId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPriceHt?: SortOrder
    discountRate?: SortOrder
    vatRate?: SortOrder
    totalHt?: SortOrder
    sortOrder?: SortOrder
  }

  export type InvoiceItemMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    productId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPriceHt?: SortOrder
    discountRate?: SortOrder
    vatRate?: SortOrder
    totalHt?: SortOrder
    sortOrder?: SortOrder
  }

  export type InvoiceItemSumOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitPriceHt?: SortOrder
    discountRate?: SortOrder
    vatRate?: SortOrder
    totalHt?: SortOrder
    sortOrder?: SortOrder
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    paymentNumber?: SortOrder
    customerId?: SortOrder
    amount?: SortOrder
    paymentDate?: SortOrder
    paymentMethod?: SortOrder
    reference?: SortOrder
    notes?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    amount?: SortOrder
    createdBy?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    paymentNumber?: SortOrder
    customerId?: SortOrder
    amount?: SortOrder
    paymentDate?: SortOrder
    paymentMethod?: SortOrder
    reference?: SortOrder
    notes?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    paymentNumber?: SortOrder
    customerId?: SortOrder
    amount?: SortOrder
    paymentDate?: SortOrder
    paymentMethod?: SortOrder
    reference?: SortOrder
    notes?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    amount?: SortOrder
    createdBy?: SortOrder
  }

  export type PaymentRelationFilter = {
    is?: PaymentWhereInput
    isNot?: PaymentWhereInput
  }

  export type PaymentAllocationCountOrderByAggregateInput = {
    id?: SortOrder
    paymentId?: SortOrder
    invoiceId?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentAllocationAvgOrderByAggregateInput = {
    id?: SortOrder
    paymentId?: SortOrder
    invoiceId?: SortOrder
    amount?: SortOrder
  }

  export type PaymentAllocationMaxOrderByAggregateInput = {
    id?: SortOrder
    paymentId?: SortOrder
    invoiceId?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentAllocationMinOrderByAggregateInput = {
    id?: SortOrder
    paymentId?: SortOrder
    invoiceId?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentAllocationSumOrderByAggregateInput = {
    id?: SortOrder
    paymentId?: SortOrder
    invoiceId?: SortOrder
    amount?: SortOrder
  }

  export type EnumRecurringFrequencyFilter<$PrismaModel = never> = {
    equals?: $Enums.RecurringFrequency | EnumRecurringFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.RecurringFrequency[] | ListEnumRecurringFrequencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.RecurringFrequency[] | ListEnumRecurringFrequencyFieldRefInput<$PrismaModel>
    not?: NestedEnumRecurringFrequencyFilter<$PrismaModel> | $Enums.RecurringFrequency
  }

  export type RecurringInvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    templateName?: SortOrder
    frequency?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    nextInvoiceDate?: SortOrder
    isActive?: SortOrder
    subtotalHt?: SortOrder
    totalVat?: SortOrder
    totalTtc?: SortOrder
    terms?: SortOrder
    notes?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RecurringInvoiceAvgOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    subtotalHt?: SortOrder
    totalVat?: SortOrder
    totalTtc?: SortOrder
    createdBy?: SortOrder
  }

  export type RecurringInvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    templateName?: SortOrder
    frequency?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    nextInvoiceDate?: SortOrder
    isActive?: SortOrder
    subtotalHt?: SortOrder
    totalVat?: SortOrder
    totalTtc?: SortOrder
    terms?: SortOrder
    notes?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RecurringInvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    templateName?: SortOrder
    frequency?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    nextInvoiceDate?: SortOrder
    isActive?: SortOrder
    subtotalHt?: SortOrder
    totalVat?: SortOrder
    totalTtc?: SortOrder
    terms?: SortOrder
    notes?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RecurringInvoiceSumOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    subtotalHt?: SortOrder
    totalVat?: SortOrder
    totalTtc?: SortOrder
    createdBy?: SortOrder
  }

  export type EnumRecurringFrequencyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RecurringFrequency | EnumRecurringFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.RecurringFrequency[] | ListEnumRecurringFrequencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.RecurringFrequency[] | ListEnumRecurringFrequencyFieldRefInput<$PrismaModel>
    not?: NestedEnumRecurringFrequencyWithAggregatesFilter<$PrismaModel> | $Enums.RecurringFrequency
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRecurringFrequencyFilter<$PrismaModel>
    _max?: NestedEnumRecurringFrequencyFilter<$PrismaModel>
  }

  export type RecurringInvoiceRelationFilter = {
    is?: RecurringInvoiceWhereInput
    isNot?: RecurringInvoiceWhereInput
  }

  export type RecurringInvoiceItemCountOrderByAggregateInput = {
    id?: SortOrder
    recurringInvoiceId?: SortOrder
    productId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPriceHt?: SortOrder
    vatRate?: SortOrder
    totalHt?: SortOrder
    sortOrder?: SortOrder
  }

  export type RecurringInvoiceItemAvgOrderByAggregateInput = {
    id?: SortOrder
    recurringInvoiceId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitPriceHt?: SortOrder
    vatRate?: SortOrder
    totalHt?: SortOrder
    sortOrder?: SortOrder
  }

  export type RecurringInvoiceItemMaxOrderByAggregateInput = {
    id?: SortOrder
    recurringInvoiceId?: SortOrder
    productId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPriceHt?: SortOrder
    vatRate?: SortOrder
    totalHt?: SortOrder
    sortOrder?: SortOrder
  }

  export type RecurringInvoiceItemMinOrderByAggregateInput = {
    id?: SortOrder
    recurringInvoiceId?: SortOrder
    productId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPriceHt?: SortOrder
    vatRate?: SortOrder
    totalHt?: SortOrder
    sortOrder?: SortOrder
  }

  export type RecurringInvoiceItemSumOrderByAggregateInput = {
    id?: SortOrder
    recurringInvoiceId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitPriceHt?: SortOrder
    vatRate?: SortOrder
    totalHt?: SortOrder
    sortOrder?: SortOrder
  }

  export type EnumReminderTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ReminderType | EnumReminderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReminderType[] | ListEnumReminderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReminderType[] | ListEnumReminderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReminderTypeFilter<$PrismaModel> | $Enums.ReminderType
  }

  export type EnumReminderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReminderStatus | EnumReminderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReminderStatus[] | ListEnumReminderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReminderStatus[] | ListEnumReminderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReminderStatusFilter<$PrismaModel> | $Enums.ReminderStatus
  }

  export type ReminderCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    type?: SortOrder
    sentDate?: SortOrder
    dueDate?: SortOrder
    amountDue?: SortOrder
    lateFees?: SortOrder
    status?: SortOrder
    emailSubject?: SortOrder
    emailBody?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type ReminderAvgOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    amountDue?: SortOrder
    lateFees?: SortOrder
    createdBy?: SortOrder
  }

  export type ReminderMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    type?: SortOrder
    sentDate?: SortOrder
    dueDate?: SortOrder
    amountDue?: SortOrder
    lateFees?: SortOrder
    status?: SortOrder
    emailSubject?: SortOrder
    emailBody?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type ReminderMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    type?: SortOrder
    sentDate?: SortOrder
    dueDate?: SortOrder
    amountDue?: SortOrder
    lateFees?: SortOrder
    status?: SortOrder
    emailSubject?: SortOrder
    emailBody?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type ReminderSumOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    amountDue?: SortOrder
    lateFees?: SortOrder
    createdBy?: SortOrder
  }

  export type EnumReminderTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReminderType | EnumReminderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReminderType[] | ListEnumReminderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReminderType[] | ListEnumReminderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReminderTypeWithAggregatesFilter<$PrismaModel> | $Enums.ReminderType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReminderTypeFilter<$PrismaModel>
    _max?: NestedEnumReminderTypeFilter<$PrismaModel>
  }

  export type EnumReminderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReminderStatus | EnumReminderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReminderStatus[] | ListEnumReminderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReminderStatus[] | ListEnumReminderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReminderStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReminderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReminderStatusFilter<$PrismaModel>
    _max?: NestedEnumReminderStatusFilter<$PrismaModel>
  }

  export type EnumDocumentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeFilter<$PrismaModel> | $Enums.DocumentType
  }

  export type DocumentCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    referenceId?: SortOrder
    filename?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    generatedAt?: SortOrder
  }

  export type DocumentAvgOrderByAggregateInput = {
    id?: SortOrder
    referenceId?: SortOrder
    fileSize?: SortOrder
  }

  export type DocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    referenceId?: SortOrder
    filename?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    generatedAt?: SortOrder
  }

  export type DocumentMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    referenceId?: SortOrder
    filename?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    generatedAt?: SortOrder
  }

  export type DocumentSumOrderByAggregateInput = {
    id?: SortOrder
    referenceId?: SortOrder
    fileSize?: SortOrder
  }

  export type EnumDocumentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel> | $Enums.DocumentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentTypeFilter<$PrismaModel>
    _max?: NestedEnumDocumentTypeFilter<$PrismaModel>
  }

  export type EnumExpenseStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ExpenseStatus | EnumExpenseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ExpenseStatus[] | ListEnumExpenseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExpenseStatus[] | ListEnumExpenseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumExpenseStatusFilter<$PrismaModel> | $Enums.ExpenseStatus
  }

  export type SupplierNullableRelationFilter = {
    is?: SupplierWhereInput | null
    isNot?: SupplierWhereInput | null
  }

  export type ExpenseCountOrderByAggregateInput = {
    id?: SortOrder
    expenseNumber?: SortOrder
    supplierId?: SortOrder
    category?: SortOrder
    description?: SortOrder
    amountHt?: SortOrder
    vatAmount?: SortOrder
    totalTtc?: SortOrder
    expenseDate?: SortOrder
    paymentDate?: SortOrder
    paymentMethod?: SortOrder
    status?: SortOrder
    receiptUrl?: SortOrder
    notes?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExpenseAvgOrderByAggregateInput = {
    id?: SortOrder
    supplierId?: SortOrder
    amountHt?: SortOrder
    vatAmount?: SortOrder
    totalTtc?: SortOrder
    createdBy?: SortOrder
  }

  export type ExpenseMaxOrderByAggregateInput = {
    id?: SortOrder
    expenseNumber?: SortOrder
    supplierId?: SortOrder
    category?: SortOrder
    description?: SortOrder
    amountHt?: SortOrder
    vatAmount?: SortOrder
    totalTtc?: SortOrder
    expenseDate?: SortOrder
    paymentDate?: SortOrder
    paymentMethod?: SortOrder
    status?: SortOrder
    receiptUrl?: SortOrder
    notes?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExpenseMinOrderByAggregateInput = {
    id?: SortOrder
    expenseNumber?: SortOrder
    supplierId?: SortOrder
    category?: SortOrder
    description?: SortOrder
    amountHt?: SortOrder
    vatAmount?: SortOrder
    totalTtc?: SortOrder
    expenseDate?: SortOrder
    paymentDate?: SortOrder
    paymentMethod?: SortOrder
    status?: SortOrder
    receiptUrl?: SortOrder
    notes?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExpenseSumOrderByAggregateInput = {
    id?: SortOrder
    supplierId?: SortOrder
    amountHt?: SortOrder
    vatAmount?: SortOrder
    totalTtc?: SortOrder
    createdBy?: SortOrder
  }

  export type EnumExpenseStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExpenseStatus | EnumExpenseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ExpenseStatus[] | ListEnumExpenseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExpenseStatus[] | ListEnumExpenseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumExpenseStatusWithAggregatesFilter<$PrismaModel> | $Enums.ExpenseStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumExpenseStatusFilter<$PrismaModel>
    _max?: NestedEnumExpenseStatusFilter<$PrismaModel>
  }

  export type SupplierCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contactPerson?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    addressLine1?: SortOrder
    city?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    vatNumber?: SortOrder
    bankName?: SortOrder
    bankIban?: SortOrder
    bankBic?: SortOrder
    paymentTerms?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupplierAvgOrderByAggregateInput = {
    id?: SortOrder
    paymentTerms?: SortOrder
  }

  export type SupplierMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contactPerson?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    addressLine1?: SortOrder
    city?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    vatNumber?: SortOrder
    bankName?: SortOrder
    bankIban?: SortOrder
    bankBic?: SortOrder
    paymentTerms?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupplierMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contactPerson?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    addressLine1?: SortOrder
    city?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    vatNumber?: SortOrder
    bankName?: SortOrder
    bankIban?: SortOrder
    bankBic?: SortOrder
    paymentTerms?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupplierSumOrderByAggregateInput = {
    id?: SortOrder
    paymentTerms?: SortOrder
  }

  export type EnumSourceDocumentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SourceDocumentType | EnumSourceDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SourceDocumentType[] | ListEnumSourceDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SourceDocumentType[] | ListEnumSourceDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSourceDocumentTypeFilter<$PrismaModel> | $Enums.SourceDocumentType
  }

  export type AccountingEntryCountOrderByAggregateInput = {
    id?: SortOrder
    entryDate?: SortOrder
    accountNumber?: SortOrder
    debit?: SortOrder
    credit?: SortOrder
    description?: SortOrder
    sourceDocumentType?: SortOrder
    sourceDocumentId?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type AccountingEntryAvgOrderByAggregateInput = {
    id?: SortOrder
    debit?: SortOrder
    credit?: SortOrder
    sourceDocumentId?: SortOrder
    createdBy?: SortOrder
  }

  export type AccountingEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    entryDate?: SortOrder
    accountNumber?: SortOrder
    debit?: SortOrder
    credit?: SortOrder
    description?: SortOrder
    sourceDocumentType?: SortOrder
    sourceDocumentId?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type AccountingEntryMinOrderByAggregateInput = {
    id?: SortOrder
    entryDate?: SortOrder
    accountNumber?: SortOrder
    debit?: SortOrder
    credit?: SortOrder
    description?: SortOrder
    sourceDocumentType?: SortOrder
    sourceDocumentId?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type AccountingEntrySumOrderByAggregateInput = {
    id?: SortOrder
    debit?: SortOrder
    credit?: SortOrder
    sourceDocumentId?: SortOrder
    createdBy?: SortOrder
  }

  export type EnumSourceDocumentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SourceDocumentType | EnumSourceDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SourceDocumentType[] | ListEnumSourceDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SourceDocumentType[] | ListEnumSourceDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSourceDocumentTypeWithAggregatesFilter<$PrismaModel> | $Enums.SourceDocumentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSourceDocumentTypeFilter<$PrismaModel>
    _max?: NestedEnumSourceDocumentTypeFilter<$PrismaModel>
  }

  export type EnumCashFlowTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CashFlowType | EnumCashFlowTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CashFlowType[] | ListEnumCashFlowTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CashFlowType[] | ListEnumCashFlowTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCashFlowTypeFilter<$PrismaModel> | $Enums.CashFlowType
  }

  export type CashFlowCountOrderByAggregateInput = {
    id?: SortOrder
    transactionDate?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    category?: SortOrder
    sourceDocumentType?: SortOrder
    sourceDocumentId?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type CashFlowAvgOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    sourceDocumentId?: SortOrder
    createdBy?: SortOrder
  }

  export type CashFlowMaxOrderByAggregateInput = {
    id?: SortOrder
    transactionDate?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    category?: SortOrder
    sourceDocumentType?: SortOrder
    sourceDocumentId?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type CashFlowMinOrderByAggregateInput = {
    id?: SortOrder
    transactionDate?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    category?: SortOrder
    sourceDocumentType?: SortOrder
    sourceDocumentId?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type CashFlowSumOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    sourceDocumentId?: SortOrder
    createdBy?: SortOrder
  }

  export type EnumCashFlowTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CashFlowType | EnumCashFlowTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CashFlowType[] | ListEnumCashFlowTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CashFlowType[] | ListEnumCashFlowTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCashFlowTypeWithAggregatesFilter<$PrismaModel> | $Enums.CashFlowType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCashFlowTypeFilter<$PrismaModel>
    _max?: NestedEnumCashFlowTypeFilter<$PrismaModel>
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type ContractListRelationFilter = {
    every?: ContractWhereInput
    some?: ContractWhereInput
    none?: ContractWhereInput
  }

  export type SalaryListRelationFilter = {
    every?: SalaryWhereInput
    some?: SalaryWhereInput
    none?: SalaryWhereInput
  }

  export type LoanListRelationFilter = {
    every?: LoanWhereInput
    some?: LoanWhereInput
    none?: LoanWhereInput
  }

  export type ContractOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SalaryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LoanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmployeeCountOrderByAggregateInput = {
    id?: SortOrder
    employeeNumber?: SortOrder
    registrationNumber?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    dateOfBirth?: SortOrder
    placeOfBirth?: SortOrder
    nationality?: SortOrder
    socialSecurityNumber?: SortOrder
    cnpsNumber?: SortOrder
    cnamNumber?: SortOrder
    bankAccount?: SortOrder
    emergencyContact?: SortOrder
    serviceId?: SortOrder
    position?: SortOrder
    department?: SortOrder
    category?: SortOrder
    level?: SortOrder
    manager?: SortOrder
    hireDate?: SortOrder
    isActive?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeAvgOrderByAggregateInput = {
    id?: SortOrder
    serviceId?: SortOrder
    userId?: SortOrder
  }

  export type EmployeeMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeNumber?: SortOrder
    registrationNumber?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    dateOfBirth?: SortOrder
    placeOfBirth?: SortOrder
    nationality?: SortOrder
    socialSecurityNumber?: SortOrder
    cnpsNumber?: SortOrder
    cnamNumber?: SortOrder
    bankAccount?: SortOrder
    emergencyContact?: SortOrder
    serviceId?: SortOrder
    position?: SortOrder
    department?: SortOrder
    category?: SortOrder
    level?: SortOrder
    manager?: SortOrder
    hireDate?: SortOrder
    isActive?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeMinOrderByAggregateInput = {
    id?: SortOrder
    employeeNumber?: SortOrder
    registrationNumber?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    dateOfBirth?: SortOrder
    placeOfBirth?: SortOrder
    nationality?: SortOrder
    socialSecurityNumber?: SortOrder
    cnpsNumber?: SortOrder
    cnamNumber?: SortOrder
    bankAccount?: SortOrder
    emergencyContact?: SortOrder
    serviceId?: SortOrder
    position?: SortOrder
    department?: SortOrder
    category?: SortOrder
    level?: SortOrder
    manager?: SortOrder
    hireDate?: SortOrder
    isActive?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeSumOrderByAggregateInput = {
    id?: SortOrder
    serviceId?: SortOrder
    userId?: SortOrder
  }

  export type EnumContractTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ContractType | EnumContractTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContractType[] | ListEnumContractTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContractType[] | ListEnumContractTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContractTypeFilter<$PrismaModel> | $Enums.ContractType
  }

  export type EmployeeRelationFilter = {
    is?: EmployeeWhereInput
    isNot?: EmployeeWhereInput
  }

  export type ContractCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    contractType?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    baseSalary?: SortOrder
    workingHours?: SortOrder
    benefits?: SortOrder
    terms?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContractAvgOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    baseSalary?: SortOrder
    workingHours?: SortOrder
  }

  export type ContractMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    contractType?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    baseSalary?: SortOrder
    workingHours?: SortOrder
    benefits?: SortOrder
    terms?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContractMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    contractType?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    baseSalary?: SortOrder
    workingHours?: SortOrder
    benefits?: SortOrder
    terms?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContractSumOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    baseSalary?: SortOrder
    workingHours?: SortOrder
  }

  export type EnumContractTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContractType | EnumContractTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContractType[] | ListEnumContractTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContractType[] | ListEnumContractTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContractTypeWithAggregatesFilter<$PrismaModel> | $Enums.ContractType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContractTypeFilter<$PrismaModel>
    _max?: NestedEnumContractTypeFilter<$PrismaModel>
  }

  export type EnumSalaryStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SalaryStatus | EnumSalaryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SalaryStatus[] | ListEnumSalaryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SalaryStatus[] | ListEnumSalaryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSalaryStatusFilter<$PrismaModel> | $Enums.SalaryStatus
  }

  export type EnumPaymentMethodNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentMethodNullableFilter<$PrismaModel> | $Enums.PaymentMethod | null
  }

  export type LoanPaymentListRelationFilter = {
    every?: LoanPaymentWhereInput
    some?: LoanPaymentWhereInput
    none?: LoanPaymentWhereInput
  }

  export type LoanPaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SalaryCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    paymentDate?: SortOrder
    workingDays?: SortOrder
    baseSalary?: SortOrder
    overtime?: SortOrder
    bonuses?: SortOrder
    allowances?: SortOrder
    paidLeave?: SortOrder
    grossSalary?: SortOrder
    socialContributions?: SortOrder
    cnpsEmployee?: SortOrder
    cnamEmployee?: SortOrder
    fdfpEmployee?: SortOrder
    taxes?: SortOrder
    nonTaxableAmount?: SortOrder
    otherDeductions?: SortOrder
    loanDeductions?: SortOrder
    totalDeductions?: SortOrder
    netSalary?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    reference?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type SalaryAvgOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    workingDays?: SortOrder
    baseSalary?: SortOrder
    overtime?: SortOrder
    bonuses?: SortOrder
    allowances?: SortOrder
    paidLeave?: SortOrder
    grossSalary?: SortOrder
    socialContributions?: SortOrder
    cnpsEmployee?: SortOrder
    cnamEmployee?: SortOrder
    fdfpEmployee?: SortOrder
    taxes?: SortOrder
    nonTaxableAmount?: SortOrder
    otherDeductions?: SortOrder
    loanDeductions?: SortOrder
    totalDeductions?: SortOrder
    netSalary?: SortOrder
  }

  export type SalaryMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    paymentDate?: SortOrder
    workingDays?: SortOrder
    baseSalary?: SortOrder
    overtime?: SortOrder
    bonuses?: SortOrder
    allowances?: SortOrder
    paidLeave?: SortOrder
    grossSalary?: SortOrder
    socialContributions?: SortOrder
    cnpsEmployee?: SortOrder
    cnamEmployee?: SortOrder
    fdfpEmployee?: SortOrder
    taxes?: SortOrder
    nonTaxableAmount?: SortOrder
    otherDeductions?: SortOrder
    loanDeductions?: SortOrder
    totalDeductions?: SortOrder
    netSalary?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    reference?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type SalaryMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    paymentDate?: SortOrder
    workingDays?: SortOrder
    baseSalary?: SortOrder
    overtime?: SortOrder
    bonuses?: SortOrder
    allowances?: SortOrder
    paidLeave?: SortOrder
    grossSalary?: SortOrder
    socialContributions?: SortOrder
    cnpsEmployee?: SortOrder
    cnamEmployee?: SortOrder
    fdfpEmployee?: SortOrder
    taxes?: SortOrder
    nonTaxableAmount?: SortOrder
    otherDeductions?: SortOrder
    loanDeductions?: SortOrder
    totalDeductions?: SortOrder
    netSalary?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    reference?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type SalarySumOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    workingDays?: SortOrder
    baseSalary?: SortOrder
    overtime?: SortOrder
    bonuses?: SortOrder
    allowances?: SortOrder
    paidLeave?: SortOrder
    grossSalary?: SortOrder
    socialContributions?: SortOrder
    cnpsEmployee?: SortOrder
    cnamEmployee?: SortOrder
    fdfpEmployee?: SortOrder
    taxes?: SortOrder
    nonTaxableAmount?: SortOrder
    otherDeductions?: SortOrder
    loanDeductions?: SortOrder
    totalDeductions?: SortOrder
    netSalary?: SortOrder
  }

  export type EnumSalaryStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SalaryStatus | EnumSalaryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SalaryStatus[] | ListEnumSalaryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SalaryStatus[] | ListEnumSalaryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSalaryStatusWithAggregatesFilter<$PrismaModel> | $Enums.SalaryStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSalaryStatusFilter<$PrismaModel>
    _max?: NestedEnumSalaryStatusFilter<$PrismaModel>
  }

  export type EnumPaymentMethodNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentMethodNullableWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodNullableFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodNullableFilter<$PrismaModel>
  }

  export type LoanRelationFilter = {
    is?: LoanWhereInput
    isNot?: LoanWhereInput
  }

  export type SalaryNullableRelationFilter = {
    is?: SalaryWhereInput | null
    isNot?: SalaryWhereInput | null
  }

  export type LoanPaymentCountOrderByAggregateInput = {
    id?: SortOrder
    loanId?: SortOrder
    salaryId?: SortOrder
    amount?: SortOrder
    paymentDate?: SortOrder
    principal?: SortOrder
    interest?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type LoanPaymentAvgOrderByAggregateInput = {
    id?: SortOrder
    loanId?: SortOrder
    salaryId?: SortOrder
    amount?: SortOrder
    principal?: SortOrder
    interest?: SortOrder
  }

  export type LoanPaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    loanId?: SortOrder
    salaryId?: SortOrder
    amount?: SortOrder
    paymentDate?: SortOrder
    principal?: SortOrder
    interest?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type LoanPaymentMinOrderByAggregateInput = {
    id?: SortOrder
    loanId?: SortOrder
    salaryId?: SortOrder
    amount?: SortOrder
    paymentDate?: SortOrder
    principal?: SortOrder
    interest?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type LoanPaymentSumOrderByAggregateInput = {
    id?: SortOrder
    loanId?: SortOrder
    salaryId?: SortOrder
    amount?: SortOrder
    principal?: SortOrder
    interest?: SortOrder
  }

  export type EnumLeaveTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveType | EnumLeaveTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveType[] | ListEnumLeaveTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaveType[] | ListEnumLeaveTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaveTypeFilter<$PrismaModel> | $Enums.LeaveType
  }

  export type EnumLeaveStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveStatus | EnumLeaveStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveStatus[] | ListEnumLeaveStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaveStatus[] | ListEnumLeaveStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaveStatusFilter<$PrismaModel> | $Enums.LeaveStatus
  }

  export type LeaveRequestCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    leaveType?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    days?: SortOrder
    reason?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    approvedById?: SortOrder
    approvedAt?: SortOrder
    comments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeaveRequestAvgOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    days?: SortOrder
    approvedById?: SortOrder
  }

  export type LeaveRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    leaveType?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    days?: SortOrder
    reason?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    approvedById?: SortOrder
    approvedAt?: SortOrder
    comments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeaveRequestMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    leaveType?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    days?: SortOrder
    reason?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    approvedById?: SortOrder
    approvedAt?: SortOrder
    comments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeaveRequestSumOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    days?: SortOrder
    approvedById?: SortOrder
  }

  export type EnumLeaveTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveType | EnumLeaveTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveType[] | ListEnumLeaveTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaveType[] | ListEnumLeaveTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaveTypeWithAggregatesFilter<$PrismaModel> | $Enums.LeaveType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeaveTypeFilter<$PrismaModel>
    _max?: NestedEnumLeaveTypeFilter<$PrismaModel>
  }

  export type EnumLeaveStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveStatus | EnumLeaveStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveStatus[] | ListEnumLeaveStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaveStatus[] | ListEnumLeaveStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaveStatusWithAggregatesFilter<$PrismaModel> | $Enums.LeaveStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeaveStatusFilter<$PrismaModel>
    _max?: NestedEnumLeaveStatusFilter<$PrismaModel>
  }

  export type ProspectCountOrderByAggregateInput = {
    id?: SortOrder
    companyName?: SortOrder
    contactName?: SortOrder
    position?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    website?: SortOrder
    industry?: SortOrder
    companySize?: SortOrder
    estimatedValue?: SortOrder
    priority?: SortOrder
    stage?: SortOrder
    source?: SortOrder
    notes?: SortOrder
    hasBudget?: SortOrder
    isDecisionMaker?: SortOrder
    hasNeed?: SortOrder
    timeline?: SortOrder
    lastContact?: SortOrder
    nextAction?: SortOrder
    nextActionDate?: SortOrder
    assignedTo?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProspectAvgOrderByAggregateInput = {
    id?: SortOrder
    estimatedValue?: SortOrder
    assignedTo?: SortOrder
    createdBy?: SortOrder
  }

  export type ProspectMaxOrderByAggregateInput = {
    id?: SortOrder
    companyName?: SortOrder
    contactName?: SortOrder
    position?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    website?: SortOrder
    industry?: SortOrder
    companySize?: SortOrder
    estimatedValue?: SortOrder
    priority?: SortOrder
    stage?: SortOrder
    source?: SortOrder
    notes?: SortOrder
    hasBudget?: SortOrder
    isDecisionMaker?: SortOrder
    hasNeed?: SortOrder
    timeline?: SortOrder
    lastContact?: SortOrder
    nextAction?: SortOrder
    nextActionDate?: SortOrder
    assignedTo?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProspectMinOrderByAggregateInput = {
    id?: SortOrder
    companyName?: SortOrder
    contactName?: SortOrder
    position?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    website?: SortOrder
    industry?: SortOrder
    companySize?: SortOrder
    estimatedValue?: SortOrder
    priority?: SortOrder
    stage?: SortOrder
    source?: SortOrder
    notes?: SortOrder
    hasBudget?: SortOrder
    isDecisionMaker?: SortOrder
    hasNeed?: SortOrder
    timeline?: SortOrder
    lastContact?: SortOrder
    nextAction?: SortOrder
    nextActionDate?: SortOrder
    assignedTo?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProspectSumOrderByAggregateInput = {
    id?: SortOrder
    estimatedValue?: SortOrder
    assignedTo?: SortOrder
    createdBy?: SortOrder
  }

  export type ProspectRelationFilter = {
    is?: ProspectWhereInput
    isNot?: ProspectWhereInput
  }

  export type ProspectActivityCountOrderByAggregateInput = {
    id?: SortOrder
    prospectId?: SortOrder
    type?: SortOrder
    subject?: SortOrder
    description?: SortOrder
    scheduledAt?: SortOrder
    completedAt?: SortOrder
    outcome?: SortOrder
    nextAction?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type ProspectActivityAvgOrderByAggregateInput = {
    id?: SortOrder
    prospectId?: SortOrder
    createdBy?: SortOrder
  }

  export type ProspectActivityMaxOrderByAggregateInput = {
    id?: SortOrder
    prospectId?: SortOrder
    type?: SortOrder
    subject?: SortOrder
    description?: SortOrder
    scheduledAt?: SortOrder
    completedAt?: SortOrder
    outcome?: SortOrder
    nextAction?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type ProspectActivityMinOrderByAggregateInput = {
    id?: SortOrder
    prospectId?: SortOrder
    type?: SortOrder
    subject?: SortOrder
    description?: SortOrder
    scheduledAt?: SortOrder
    completedAt?: SortOrder
    outcome?: SortOrder
    nextAction?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type ProspectActivitySumOrderByAggregateInput = {
    id?: SortOrder
    prospectId?: SortOrder
    createdBy?: SortOrder
  }

  export type EnumLoanStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LoanStatus | EnumLoanStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LoanStatus[] | ListEnumLoanStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LoanStatus[] | ListEnumLoanStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLoanStatusFilter<$PrismaModel> | $Enums.LoanStatus
  }

  export type LoanCountOrderByAggregateInput = {
    id?: SortOrder
    loanNumber?: SortOrder
    employeeId?: SortOrder
    amount?: SortOrder
    interestRate?: SortOrder
    monthlyPayment?: SortOrder
    remainingAmount?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    purpose?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LoanAvgOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    amount?: SortOrder
    interestRate?: SortOrder
    monthlyPayment?: SortOrder
    remainingAmount?: SortOrder
    createdBy?: SortOrder
  }

  export type LoanMaxOrderByAggregateInput = {
    id?: SortOrder
    loanNumber?: SortOrder
    employeeId?: SortOrder
    amount?: SortOrder
    interestRate?: SortOrder
    monthlyPayment?: SortOrder
    remainingAmount?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    purpose?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LoanMinOrderByAggregateInput = {
    id?: SortOrder
    loanNumber?: SortOrder
    employeeId?: SortOrder
    amount?: SortOrder
    interestRate?: SortOrder
    monthlyPayment?: SortOrder
    remainingAmount?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    purpose?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LoanSumOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    amount?: SortOrder
    interestRate?: SortOrder
    monthlyPayment?: SortOrder
    remainingAmount?: SortOrder
    createdBy?: SortOrder
  }

  export type EnumLoanStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LoanStatus | EnumLoanStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LoanStatus[] | ListEnumLoanStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LoanStatus[] | ListEnumLoanStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLoanStatusWithAggregatesFilter<$PrismaModel> | $Enums.LoanStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLoanStatusFilter<$PrismaModel>
    _max?: NestedEnumLoanStatusFilter<$PrismaModel>
  }

  export type TechnicienListRelationFilter = {
    every?: TechnicienWhereInput
    some?: TechnicienWhereInput
    none?: TechnicienWhereInput
  }

  export type TechnicienOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SpecialiteCountOrderByAggregateInput = {
    id?: SortOrder
    libelle?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SpecialiteAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SpecialiteMaxOrderByAggregateInput = {
    id?: SortOrder
    libelle?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SpecialiteMinOrderByAggregateInput = {
    id?: SortOrder
    libelle?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SpecialiteSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SpecialiteRelationFilter = {
    is?: SpecialiteWhereInput
    isNot?: SpecialiteWhereInput
  }

  export type TechnicienInterventionListRelationFilter = {
    every?: TechnicienInterventionWhereInput
    some?: TechnicienInterventionWhereInput
    none?: TechnicienInterventionWhereInput
  }

  export type RapportMissionListRelationFilter = {
    every?: RapportMissionWhereInput
    some?: RapportMissionWhereInput
    none?: RapportMissionWhereInput
  }

  export type SortieMaterielListRelationFilter = {
    every?: SortieMaterielWhereInput
    some?: SortieMaterielWhereInput
    none?: SortieMaterielWhereInput
  }

  export type TechnicienInterventionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RapportMissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SortieMaterielOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TechnicienCountOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    contact?: SortOrder
    specialiteId?: SortOrder
    utilisateurId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TechnicienAvgOrderByAggregateInput = {
    id?: SortOrder
    specialiteId?: SortOrder
    utilisateurId?: SortOrder
  }

  export type TechnicienMaxOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    contact?: SortOrder
    specialiteId?: SortOrder
    utilisateurId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TechnicienMinOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    contact?: SortOrder
    specialiteId?: SortOrder
    utilisateurId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TechnicienSumOrderByAggregateInput = {
    id?: SortOrder
    specialiteId?: SortOrder
    utilisateurId?: SortOrder
  }

  export type InterventionListRelationFilter = {
    every?: InterventionWhereInput
    some?: InterventionWhereInput
    none?: InterventionWhereInput
  }

  export type InterventionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MissionCountOrderByAggregateInput = {
    numIntervention?: SortOrder
    natureIntervention?: SortOrder
    objectifDuContrat?: SortOrder
    description?: SortOrder
    priorite?: SortOrder
    statut?: SortOrder
    dateSortieFicheIntervention?: SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MissionAvgOrderByAggregateInput = {
    clientId?: SortOrder
  }

  export type MissionMaxOrderByAggregateInput = {
    numIntervention?: SortOrder
    natureIntervention?: SortOrder
    objectifDuContrat?: SortOrder
    description?: SortOrder
    priorite?: SortOrder
    statut?: SortOrder
    dateSortieFicheIntervention?: SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MissionMinOrderByAggregateInput = {
    numIntervention?: SortOrder
    natureIntervention?: SortOrder
    objectifDuContrat?: SortOrder
    description?: SortOrder
    priorite?: SortOrder
    statut?: SortOrder
    dateSortieFicheIntervention?: SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MissionSumOrderByAggregateInput = {
    clientId?: SortOrder
  }

  export type MissionRelationFilter = {
    is?: MissionWhereInput
    isNot?: MissionWhereInput
  }

  export type InterventionCountOrderByAggregateInput = {
    id?: SortOrder
    dateHeureDebut?: SortOrder
    dateHeureFin?: SortOrder
    duree?: SortOrder
    missionId?: SortOrder
    statut?: SortOrder
    commentaire?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InterventionAvgOrderByAggregateInput = {
    id?: SortOrder
    duree?: SortOrder
  }

  export type InterventionMaxOrderByAggregateInput = {
    id?: SortOrder
    dateHeureDebut?: SortOrder
    dateHeureFin?: SortOrder
    duree?: SortOrder
    missionId?: SortOrder
    statut?: SortOrder
    commentaire?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InterventionMinOrderByAggregateInput = {
    id?: SortOrder
    dateHeureDebut?: SortOrder
    dateHeureFin?: SortOrder
    duree?: SortOrder
    missionId?: SortOrder
    statut?: SortOrder
    commentaire?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InterventionSumOrderByAggregateInput = {
    id?: SortOrder
    duree?: SortOrder
  }

  export type TechnicienRelationFilter = {
    is?: TechnicienWhereInput
    isNot?: TechnicienWhereInput
  }

  export type InterventionRelationFilter = {
    is?: InterventionWhereInput
    isNot?: InterventionWhereInput
  }

  export type TechnicienInterventionTechnicienIdInterventionIdCompoundUniqueInput = {
    technicienId: number
    interventionId: number
  }

  export type TechnicienInterventionCountOrderByAggregateInput = {
    id?: SortOrder
    technicienId?: SortOrder
    interventionId?: SortOrder
    role?: SortOrder
    commentaire?: SortOrder
    createdAt?: SortOrder
  }

  export type TechnicienInterventionAvgOrderByAggregateInput = {
    id?: SortOrder
    technicienId?: SortOrder
    interventionId?: SortOrder
  }

  export type TechnicienInterventionMaxOrderByAggregateInput = {
    id?: SortOrder
    technicienId?: SortOrder
    interventionId?: SortOrder
    role?: SortOrder
    commentaire?: SortOrder
    createdAt?: SortOrder
  }

  export type TechnicienInterventionMinOrderByAggregateInput = {
    id?: SortOrder
    technicienId?: SortOrder
    interventionId?: SortOrder
    role?: SortOrder
    commentaire?: SortOrder
    createdAt?: SortOrder
  }

  export type TechnicienInterventionSumOrderByAggregateInput = {
    id?: SortOrder
    technicienId?: SortOrder
    interventionId?: SortOrder
  }

  export type InterventionNullableRelationFilter = {
    is?: InterventionWhereInput | null
    isNot?: InterventionWhereInput | null
  }

  export type RapportImageListRelationFilter = {
    every?: RapportImageWhereInput
    some?: RapportImageWhereInput
    none?: RapportImageWhereInput
  }

  export type RapportImageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RapportMissionCountOrderByAggregateInput = {
    id?: SortOrder
    titre?: SortOrder
    contenu?: SortOrder
    interventionId?: SortOrder
    technicienId?: SortOrder
    missionId?: SortOrder
    createdById?: SortOrder
    statut?: SortOrder
    dateValidation?: SortOrder
    commentaire?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RapportMissionAvgOrderByAggregateInput = {
    id?: SortOrder
    interventionId?: SortOrder
    technicienId?: SortOrder
    createdById?: SortOrder
  }

  export type RapportMissionMaxOrderByAggregateInput = {
    id?: SortOrder
    titre?: SortOrder
    contenu?: SortOrder
    interventionId?: SortOrder
    technicienId?: SortOrder
    missionId?: SortOrder
    createdById?: SortOrder
    statut?: SortOrder
    dateValidation?: SortOrder
    commentaire?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RapportMissionMinOrderByAggregateInput = {
    id?: SortOrder
    titre?: SortOrder
    contenu?: SortOrder
    interventionId?: SortOrder
    technicienId?: SortOrder
    missionId?: SortOrder
    createdById?: SortOrder
    statut?: SortOrder
    dateValidation?: SortOrder
    commentaire?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RapportMissionSumOrderByAggregateInput = {
    id?: SortOrder
    interventionId?: SortOrder
    technicienId?: SortOrder
    createdById?: SortOrder
  }

  export type RapportMissionRelationFilter = {
    is?: RapportMissionWhereInput
    isNot?: RapportMissionWhereInput
  }

  export type RapportImageCountOrderByAggregateInput = {
    id?: SortOrder
    rapportId?: SortOrder
    url?: SortOrder
    description?: SortOrder
    ordre?: SortOrder
    createdAt?: SortOrder
  }

  export type RapportImageAvgOrderByAggregateInput = {
    id?: SortOrder
    rapportId?: SortOrder
    ordre?: SortOrder
  }

  export type RapportImageMaxOrderByAggregateInput = {
    id?: SortOrder
    rapportId?: SortOrder
    url?: SortOrder
    description?: SortOrder
    ordre?: SortOrder
    createdAt?: SortOrder
  }

  export type RapportImageMinOrderByAggregateInput = {
    id?: SortOrder
    rapportId?: SortOrder
    url?: SortOrder
    description?: SortOrder
    ordre?: SortOrder
    createdAt?: SortOrder
  }

  export type RapportImageSumOrderByAggregateInput = {
    id?: SortOrder
    rapportId?: SortOrder
    ordre?: SortOrder
  }

  export type EntreeMaterielListRelationFilter = {
    every?: EntreeMaterielWhereInput
    some?: EntreeMaterielWhereInput
    none?: EntreeMaterielWhereInput
  }

  export type EntreeMaterielOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MaterielCountOrderByAggregateInput = {
    id?: SortOrder
    reference?: SortOrder
    designation?: SortOrder
    description?: SortOrder
    quantiteTotale?: SortOrder
    quantiteDisponible?: SortOrder
    seuilAlerte?: SortOrder
    emplacement?: SortOrder
    categorie?: SortOrder
    prixUnitaire?: SortOrder
    fournisseur?: SortOrder
    dateAchat?: SortOrder
    garantie?: SortOrder
    statut?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MaterielAvgOrderByAggregateInput = {
    id?: SortOrder
    quantiteTotale?: SortOrder
    quantiteDisponible?: SortOrder
    seuilAlerte?: SortOrder
    prixUnitaire?: SortOrder
  }

  export type MaterielMaxOrderByAggregateInput = {
    id?: SortOrder
    reference?: SortOrder
    designation?: SortOrder
    description?: SortOrder
    quantiteTotale?: SortOrder
    quantiteDisponible?: SortOrder
    seuilAlerte?: SortOrder
    emplacement?: SortOrder
    categorie?: SortOrder
    prixUnitaire?: SortOrder
    fournisseur?: SortOrder
    dateAchat?: SortOrder
    garantie?: SortOrder
    statut?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MaterielMinOrderByAggregateInput = {
    id?: SortOrder
    reference?: SortOrder
    designation?: SortOrder
    description?: SortOrder
    quantiteTotale?: SortOrder
    quantiteDisponible?: SortOrder
    seuilAlerte?: SortOrder
    emplacement?: SortOrder
    categorie?: SortOrder
    prixUnitaire?: SortOrder
    fournisseur?: SortOrder
    dateAchat?: SortOrder
    garantie?: SortOrder
    statut?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MaterielSumOrderByAggregateInput = {
    id?: SortOrder
    quantiteTotale?: SortOrder
    quantiteDisponible?: SortOrder
    seuilAlerte?: SortOrder
    prixUnitaire?: SortOrder
  }

  export type MaterielRelationFilter = {
    is?: MaterielWhereInput
    isNot?: MaterielWhereInput
  }

  export type SortieMaterielCountOrderByAggregateInput = {
    id?: SortOrder
    materielId?: SortOrder
    interventionId?: SortOrder
    technicienId?: SortOrder
    quantite?: SortOrder
    dateSortie?: SortOrder
    motif?: SortOrder
    retourne?: SortOrder
    dateRetour?: SortOrder
    quantiteRetour?: SortOrder
    commentaire?: SortOrder
    createdAt?: SortOrder
  }

  export type SortieMaterielAvgOrderByAggregateInput = {
    id?: SortOrder
    materielId?: SortOrder
    interventionId?: SortOrder
    technicienId?: SortOrder
    quantite?: SortOrder
    quantiteRetour?: SortOrder
  }

  export type SortieMaterielMaxOrderByAggregateInput = {
    id?: SortOrder
    materielId?: SortOrder
    interventionId?: SortOrder
    technicienId?: SortOrder
    quantite?: SortOrder
    dateSortie?: SortOrder
    motif?: SortOrder
    retourne?: SortOrder
    dateRetour?: SortOrder
    quantiteRetour?: SortOrder
    commentaire?: SortOrder
    createdAt?: SortOrder
  }

  export type SortieMaterielMinOrderByAggregateInput = {
    id?: SortOrder
    materielId?: SortOrder
    interventionId?: SortOrder
    technicienId?: SortOrder
    quantite?: SortOrder
    dateSortie?: SortOrder
    motif?: SortOrder
    retourne?: SortOrder
    dateRetour?: SortOrder
    quantiteRetour?: SortOrder
    commentaire?: SortOrder
    createdAt?: SortOrder
  }

  export type SortieMaterielSumOrderByAggregateInput = {
    id?: SortOrder
    materielId?: SortOrder
    interventionId?: SortOrder
    technicienId?: SortOrder
    quantite?: SortOrder
    quantiteRetour?: SortOrder
  }

  export type EntreeMaterielCountOrderByAggregateInput = {
    id?: SortOrder
    materielId?: SortOrder
    quantite?: SortOrder
    dateEntree?: SortOrder
    source?: SortOrder
    prixTotal?: SortOrder
    fournisseur?: SortOrder
    facture?: SortOrder
    commentaire?: SortOrder
    createdAt?: SortOrder
  }

  export type EntreeMaterielAvgOrderByAggregateInput = {
    id?: SortOrder
    materielId?: SortOrder
    quantite?: SortOrder
    prixTotal?: SortOrder
  }

  export type EntreeMaterielMaxOrderByAggregateInput = {
    id?: SortOrder
    materielId?: SortOrder
    quantite?: SortOrder
    dateEntree?: SortOrder
    source?: SortOrder
    prixTotal?: SortOrder
    fournisseur?: SortOrder
    facture?: SortOrder
    commentaire?: SortOrder
    createdAt?: SortOrder
  }

  export type EntreeMaterielMinOrderByAggregateInput = {
    id?: SortOrder
    materielId?: SortOrder
    quantite?: SortOrder
    dateEntree?: SortOrder
    source?: SortOrder
    prixTotal?: SortOrder
    fournisseur?: SortOrder
    facture?: SortOrder
    commentaire?: SortOrder
    createdAt?: SortOrder
  }

  export type EntreeMaterielSumOrderByAggregateInput = {
    id?: SortOrder
    materielId?: SortOrder
    quantite?: SortOrder
    prixTotal?: SortOrder
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    message?: SortOrder
    data?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type NotificationAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    message?: SortOrder
    data?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    message?: SortOrder
    data?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type NotificationSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type UserCreateNestedManyWithoutServiceInput = {
    create?: XOR<UserCreateWithoutServiceInput, UserUncheckedCreateWithoutServiceInput> | UserCreateWithoutServiceInput[] | UserUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: UserCreateOrConnectWithoutServiceInput | UserCreateOrConnectWithoutServiceInput[]
    createMany?: UserCreateManyServiceInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type CustomerCreateNestedManyWithoutServiceInput = {
    create?: XOR<CustomerCreateWithoutServiceInput, CustomerUncheckedCreateWithoutServiceInput> | CustomerCreateWithoutServiceInput[] | CustomerUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutServiceInput | CustomerCreateOrConnectWithoutServiceInput[]
    createMany?: CustomerCreateManyServiceInputEnvelope
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
  }

  export type EmployeeCreateNestedManyWithoutServiceInput = {
    create?: XOR<EmployeeCreateWithoutServiceInput, EmployeeUncheckedCreateWithoutServiceInput> | EmployeeCreateWithoutServiceInput[] | EmployeeUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutServiceInput | EmployeeCreateOrConnectWithoutServiceInput[]
    createMany?: EmployeeCreateManyServiceInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<UserCreateWithoutServiceInput, UserUncheckedCreateWithoutServiceInput> | UserCreateWithoutServiceInput[] | UserUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: UserCreateOrConnectWithoutServiceInput | UserCreateOrConnectWithoutServiceInput[]
    createMany?: UserCreateManyServiceInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type CustomerUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<CustomerCreateWithoutServiceInput, CustomerUncheckedCreateWithoutServiceInput> | CustomerCreateWithoutServiceInput[] | CustomerUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutServiceInput | CustomerCreateOrConnectWithoutServiceInput[]
    createMany?: CustomerCreateManyServiceInputEnvelope
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
  }

  export type EmployeeUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<EmployeeCreateWithoutServiceInput, EmployeeUncheckedCreateWithoutServiceInput> | EmployeeCreateWithoutServiceInput[] | EmployeeUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutServiceInput | EmployeeCreateOrConnectWithoutServiceInput[]
    createMany?: EmployeeCreateManyServiceInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateManyWithoutServiceNestedInput = {
    create?: XOR<UserCreateWithoutServiceInput, UserUncheckedCreateWithoutServiceInput> | UserCreateWithoutServiceInput[] | UserUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: UserCreateOrConnectWithoutServiceInput | UserCreateOrConnectWithoutServiceInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutServiceInput | UserUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: UserCreateManyServiceInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutServiceInput | UserUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: UserUpdateManyWithWhereWithoutServiceInput | UserUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type CustomerUpdateManyWithoutServiceNestedInput = {
    create?: XOR<CustomerCreateWithoutServiceInput, CustomerUncheckedCreateWithoutServiceInput> | CustomerCreateWithoutServiceInput[] | CustomerUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutServiceInput | CustomerCreateOrConnectWithoutServiceInput[]
    upsert?: CustomerUpsertWithWhereUniqueWithoutServiceInput | CustomerUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: CustomerCreateManyServiceInputEnvelope
    set?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    disconnect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    delete?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    update?: CustomerUpdateWithWhereUniqueWithoutServiceInput | CustomerUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: CustomerUpdateManyWithWhereWithoutServiceInput | CustomerUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
  }

  export type EmployeeUpdateManyWithoutServiceNestedInput = {
    create?: XOR<EmployeeCreateWithoutServiceInput, EmployeeUncheckedCreateWithoutServiceInput> | EmployeeCreateWithoutServiceInput[] | EmployeeUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutServiceInput | EmployeeCreateOrConnectWithoutServiceInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutServiceInput | EmployeeUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: EmployeeCreateManyServiceInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutServiceInput | EmployeeUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutServiceInput | EmployeeUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<UserCreateWithoutServiceInput, UserUncheckedCreateWithoutServiceInput> | UserCreateWithoutServiceInput[] | UserUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: UserCreateOrConnectWithoutServiceInput | UserCreateOrConnectWithoutServiceInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutServiceInput | UserUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: UserCreateManyServiceInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutServiceInput | UserUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: UserUpdateManyWithWhereWithoutServiceInput | UserUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type CustomerUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<CustomerCreateWithoutServiceInput, CustomerUncheckedCreateWithoutServiceInput> | CustomerCreateWithoutServiceInput[] | CustomerUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutServiceInput | CustomerCreateOrConnectWithoutServiceInput[]
    upsert?: CustomerUpsertWithWhereUniqueWithoutServiceInput | CustomerUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: CustomerCreateManyServiceInputEnvelope
    set?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    disconnect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    delete?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    update?: CustomerUpdateWithWhereUniqueWithoutServiceInput | CustomerUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: CustomerUpdateManyWithWhereWithoutServiceInput | CustomerUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
  }

  export type EmployeeUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<EmployeeCreateWithoutServiceInput, EmployeeUncheckedCreateWithoutServiceInput> | EmployeeCreateWithoutServiceInput[] | EmployeeUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutServiceInput | EmployeeCreateOrConnectWithoutServiceInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutServiceInput | EmployeeUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: EmployeeCreateManyServiceInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutServiceInput | EmployeeUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutServiceInput | EmployeeUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type ServiceCreateNestedOneWithoutUsersInput = {
    create?: XOR<ServiceCreateWithoutUsersInput, ServiceUncheckedCreateWithoutUsersInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutUsersInput
    connect?: ServiceWhereUniqueInput
  }

  export type CustomerCreateNestedManyWithoutCreatorInput = {
    create?: XOR<CustomerCreateWithoutCreatorInput, CustomerUncheckedCreateWithoutCreatorInput> | CustomerCreateWithoutCreatorInput[] | CustomerUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutCreatorInput | CustomerCreateOrConnectWithoutCreatorInput[]
    createMany?: CustomerCreateManyCreatorInputEnvelope
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
  }

  export type QuoteCreateNestedManyWithoutCreatorInput = {
    create?: XOR<QuoteCreateWithoutCreatorInput, QuoteUncheckedCreateWithoutCreatorInput> | QuoteCreateWithoutCreatorInput[] | QuoteUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: QuoteCreateOrConnectWithoutCreatorInput | QuoteCreateOrConnectWithoutCreatorInput[]
    createMany?: QuoteCreateManyCreatorInputEnvelope
    connect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutCreatorInput = {
    create?: XOR<InvoiceCreateWithoutCreatorInput, InvoiceUncheckedCreateWithoutCreatorInput> | InvoiceCreateWithoutCreatorInput[] | InvoiceUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCreatorInput | InvoiceCreateOrConnectWithoutCreatorInput[]
    createMany?: InvoiceCreateManyCreatorInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutCreatorInput = {
    create?: XOR<PaymentCreateWithoutCreatorInput, PaymentUncheckedCreateWithoutCreatorInput> | PaymentCreateWithoutCreatorInput[] | PaymentUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutCreatorInput | PaymentCreateOrConnectWithoutCreatorInput[]
    createMany?: PaymentCreateManyCreatorInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type QuoteCreateNestedManyWithoutServiceManagerInput = {
    create?: XOR<QuoteCreateWithoutServiceManagerInput, QuoteUncheckedCreateWithoutServiceManagerInput> | QuoteCreateWithoutServiceManagerInput[] | QuoteUncheckedCreateWithoutServiceManagerInput[]
    connectOrCreate?: QuoteCreateOrConnectWithoutServiceManagerInput | QuoteCreateOrConnectWithoutServiceManagerInput[]
    createMany?: QuoteCreateManyServiceManagerInputEnvelope
    connect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
  }

  export type QuoteCreateNestedManyWithoutDgApproverInput = {
    create?: XOR<QuoteCreateWithoutDgApproverInput, QuoteUncheckedCreateWithoutDgApproverInput> | QuoteCreateWithoutDgApproverInput[] | QuoteUncheckedCreateWithoutDgApproverInput[]
    connectOrCreate?: QuoteCreateOrConnectWithoutDgApproverInput | QuoteCreateOrConnectWithoutDgApproverInput[]
    createMany?: QuoteCreateManyDgApproverInputEnvelope
    connect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type QuoteApprovalCreateNestedManyWithoutApproverInput = {
    create?: XOR<QuoteApprovalCreateWithoutApproverInput, QuoteApprovalUncheckedCreateWithoutApproverInput> | QuoteApprovalCreateWithoutApproverInput[] | QuoteApprovalUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: QuoteApprovalCreateOrConnectWithoutApproverInput | QuoteApprovalCreateOrConnectWithoutApproverInput[]
    createMany?: QuoteApprovalCreateManyApproverInputEnvelope
    connect?: QuoteApprovalWhereUniqueInput | QuoteApprovalWhereUniqueInput[]
  }

  export type ExpenseCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ExpenseCreateWithoutCreatorInput, ExpenseUncheckedCreateWithoutCreatorInput> | ExpenseCreateWithoutCreatorInput[] | ExpenseUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutCreatorInput | ExpenseCreateOrConnectWithoutCreatorInput[]
    createMany?: ExpenseCreateManyCreatorInputEnvelope
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
  }

  export type AccountingEntryCreateNestedManyWithoutCreatorInput = {
    create?: XOR<AccountingEntryCreateWithoutCreatorInput, AccountingEntryUncheckedCreateWithoutCreatorInput> | AccountingEntryCreateWithoutCreatorInput[] | AccountingEntryUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: AccountingEntryCreateOrConnectWithoutCreatorInput | AccountingEntryCreateOrConnectWithoutCreatorInput[]
    createMany?: AccountingEntryCreateManyCreatorInputEnvelope
    connect?: AccountingEntryWhereUniqueInput | AccountingEntryWhereUniqueInput[]
  }

  export type CashFlowCreateNestedManyWithoutCreatorInput = {
    create?: XOR<CashFlowCreateWithoutCreatorInput, CashFlowUncheckedCreateWithoutCreatorInput> | CashFlowCreateWithoutCreatorInput[] | CashFlowUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CashFlowCreateOrConnectWithoutCreatorInput | CashFlowCreateOrConnectWithoutCreatorInput[]
    createMany?: CashFlowCreateManyCreatorInputEnvelope
    connect?: CashFlowWhereUniqueInput | CashFlowWhereUniqueInput[]
  }

  export type ReminderCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ReminderCreateWithoutCreatorInput, ReminderUncheckedCreateWithoutCreatorInput> | ReminderCreateWithoutCreatorInput[] | ReminderUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ReminderCreateOrConnectWithoutCreatorInput | ReminderCreateOrConnectWithoutCreatorInput[]
    createMany?: ReminderCreateManyCreatorInputEnvelope
    connect?: ReminderWhereUniqueInput | ReminderWhereUniqueInput[]
  }

  export type RecurringInvoiceCreateNestedManyWithoutCreatorInput = {
    create?: XOR<RecurringInvoiceCreateWithoutCreatorInput, RecurringInvoiceUncheckedCreateWithoutCreatorInput> | RecurringInvoiceCreateWithoutCreatorInput[] | RecurringInvoiceUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: RecurringInvoiceCreateOrConnectWithoutCreatorInput | RecurringInvoiceCreateOrConnectWithoutCreatorInput[]
    createMany?: RecurringInvoiceCreateManyCreatorInputEnvelope
    connect?: RecurringInvoiceWhereUniqueInput | RecurringInvoiceWhereUniqueInput[]
  }

  export type EmployeeCreateNestedOneWithoutUserInput = {
    create?: XOR<EmployeeCreateWithoutUserInput, EmployeeUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutUserInput
    connect?: EmployeeWhereUniqueInput
  }

  export type LeaveRequestCreateNestedManyWithoutApprovedByInput = {
    create?: XOR<LeaveRequestCreateWithoutApprovedByInput, LeaveRequestUncheckedCreateWithoutApprovedByInput> | LeaveRequestCreateWithoutApprovedByInput[] | LeaveRequestUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: LeaveRequestCreateOrConnectWithoutApprovedByInput | LeaveRequestCreateOrConnectWithoutApprovedByInput[]
    createMany?: LeaveRequestCreateManyApprovedByInputEnvelope
    connect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
  }

  export type ProspectCreateNestedManyWithoutAssignedUserInput = {
    create?: XOR<ProspectCreateWithoutAssignedUserInput, ProspectUncheckedCreateWithoutAssignedUserInput> | ProspectCreateWithoutAssignedUserInput[] | ProspectUncheckedCreateWithoutAssignedUserInput[]
    connectOrCreate?: ProspectCreateOrConnectWithoutAssignedUserInput | ProspectCreateOrConnectWithoutAssignedUserInput[]
    createMany?: ProspectCreateManyAssignedUserInputEnvelope
    connect?: ProspectWhereUniqueInput | ProspectWhereUniqueInput[]
  }

  export type ProspectCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ProspectCreateWithoutCreatorInput, ProspectUncheckedCreateWithoutCreatorInput> | ProspectCreateWithoutCreatorInput[] | ProspectUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ProspectCreateOrConnectWithoutCreatorInput | ProspectCreateOrConnectWithoutCreatorInput[]
    createMany?: ProspectCreateManyCreatorInputEnvelope
    connect?: ProspectWhereUniqueInput | ProspectWhereUniqueInput[]
  }

  export type ProspectActivityCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ProspectActivityCreateWithoutCreatorInput, ProspectActivityUncheckedCreateWithoutCreatorInput> | ProspectActivityCreateWithoutCreatorInput[] | ProspectActivityUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ProspectActivityCreateOrConnectWithoutCreatorInput | ProspectActivityCreateOrConnectWithoutCreatorInput[]
    createMany?: ProspectActivityCreateManyCreatorInputEnvelope
    connect?: ProspectActivityWhereUniqueInput | ProspectActivityWhereUniqueInput[]
  }

  export type TechnicienCreateNestedOneWithoutUtilisateurInput = {
    create?: XOR<TechnicienCreateWithoutUtilisateurInput, TechnicienUncheckedCreateWithoutUtilisateurInput>
    connectOrCreate?: TechnicienCreateOrConnectWithoutUtilisateurInput
    connect?: TechnicienWhereUniqueInput
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type CustomerUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<CustomerCreateWithoutCreatorInput, CustomerUncheckedCreateWithoutCreatorInput> | CustomerCreateWithoutCreatorInput[] | CustomerUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutCreatorInput | CustomerCreateOrConnectWithoutCreatorInput[]
    createMany?: CustomerCreateManyCreatorInputEnvelope
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
  }

  export type QuoteUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<QuoteCreateWithoutCreatorInput, QuoteUncheckedCreateWithoutCreatorInput> | QuoteCreateWithoutCreatorInput[] | QuoteUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: QuoteCreateOrConnectWithoutCreatorInput | QuoteCreateOrConnectWithoutCreatorInput[]
    createMany?: QuoteCreateManyCreatorInputEnvelope
    connect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<InvoiceCreateWithoutCreatorInput, InvoiceUncheckedCreateWithoutCreatorInput> | InvoiceCreateWithoutCreatorInput[] | InvoiceUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCreatorInput | InvoiceCreateOrConnectWithoutCreatorInput[]
    createMany?: InvoiceCreateManyCreatorInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<PaymentCreateWithoutCreatorInput, PaymentUncheckedCreateWithoutCreatorInput> | PaymentCreateWithoutCreatorInput[] | PaymentUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutCreatorInput | PaymentCreateOrConnectWithoutCreatorInput[]
    createMany?: PaymentCreateManyCreatorInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type QuoteUncheckedCreateNestedManyWithoutServiceManagerInput = {
    create?: XOR<QuoteCreateWithoutServiceManagerInput, QuoteUncheckedCreateWithoutServiceManagerInput> | QuoteCreateWithoutServiceManagerInput[] | QuoteUncheckedCreateWithoutServiceManagerInput[]
    connectOrCreate?: QuoteCreateOrConnectWithoutServiceManagerInput | QuoteCreateOrConnectWithoutServiceManagerInput[]
    createMany?: QuoteCreateManyServiceManagerInputEnvelope
    connect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
  }

  export type QuoteUncheckedCreateNestedManyWithoutDgApproverInput = {
    create?: XOR<QuoteCreateWithoutDgApproverInput, QuoteUncheckedCreateWithoutDgApproverInput> | QuoteCreateWithoutDgApproverInput[] | QuoteUncheckedCreateWithoutDgApproverInput[]
    connectOrCreate?: QuoteCreateOrConnectWithoutDgApproverInput | QuoteCreateOrConnectWithoutDgApproverInput[]
    createMany?: QuoteCreateManyDgApproverInputEnvelope
    connect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type QuoteApprovalUncheckedCreateNestedManyWithoutApproverInput = {
    create?: XOR<QuoteApprovalCreateWithoutApproverInput, QuoteApprovalUncheckedCreateWithoutApproverInput> | QuoteApprovalCreateWithoutApproverInput[] | QuoteApprovalUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: QuoteApprovalCreateOrConnectWithoutApproverInput | QuoteApprovalCreateOrConnectWithoutApproverInput[]
    createMany?: QuoteApprovalCreateManyApproverInputEnvelope
    connect?: QuoteApprovalWhereUniqueInput | QuoteApprovalWhereUniqueInput[]
  }

  export type ExpenseUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ExpenseCreateWithoutCreatorInput, ExpenseUncheckedCreateWithoutCreatorInput> | ExpenseCreateWithoutCreatorInput[] | ExpenseUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutCreatorInput | ExpenseCreateOrConnectWithoutCreatorInput[]
    createMany?: ExpenseCreateManyCreatorInputEnvelope
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
  }

  export type AccountingEntryUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<AccountingEntryCreateWithoutCreatorInput, AccountingEntryUncheckedCreateWithoutCreatorInput> | AccountingEntryCreateWithoutCreatorInput[] | AccountingEntryUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: AccountingEntryCreateOrConnectWithoutCreatorInput | AccountingEntryCreateOrConnectWithoutCreatorInput[]
    createMany?: AccountingEntryCreateManyCreatorInputEnvelope
    connect?: AccountingEntryWhereUniqueInput | AccountingEntryWhereUniqueInput[]
  }

  export type CashFlowUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<CashFlowCreateWithoutCreatorInput, CashFlowUncheckedCreateWithoutCreatorInput> | CashFlowCreateWithoutCreatorInput[] | CashFlowUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CashFlowCreateOrConnectWithoutCreatorInput | CashFlowCreateOrConnectWithoutCreatorInput[]
    createMany?: CashFlowCreateManyCreatorInputEnvelope
    connect?: CashFlowWhereUniqueInput | CashFlowWhereUniqueInput[]
  }

  export type ReminderUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ReminderCreateWithoutCreatorInput, ReminderUncheckedCreateWithoutCreatorInput> | ReminderCreateWithoutCreatorInput[] | ReminderUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ReminderCreateOrConnectWithoutCreatorInput | ReminderCreateOrConnectWithoutCreatorInput[]
    createMany?: ReminderCreateManyCreatorInputEnvelope
    connect?: ReminderWhereUniqueInput | ReminderWhereUniqueInput[]
  }

  export type RecurringInvoiceUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<RecurringInvoiceCreateWithoutCreatorInput, RecurringInvoiceUncheckedCreateWithoutCreatorInput> | RecurringInvoiceCreateWithoutCreatorInput[] | RecurringInvoiceUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: RecurringInvoiceCreateOrConnectWithoutCreatorInput | RecurringInvoiceCreateOrConnectWithoutCreatorInput[]
    createMany?: RecurringInvoiceCreateManyCreatorInputEnvelope
    connect?: RecurringInvoiceWhereUniqueInput | RecurringInvoiceWhereUniqueInput[]
  }

  export type EmployeeUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<EmployeeCreateWithoutUserInput, EmployeeUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutUserInput
    connect?: EmployeeWhereUniqueInput
  }

  export type LeaveRequestUncheckedCreateNestedManyWithoutApprovedByInput = {
    create?: XOR<LeaveRequestCreateWithoutApprovedByInput, LeaveRequestUncheckedCreateWithoutApprovedByInput> | LeaveRequestCreateWithoutApprovedByInput[] | LeaveRequestUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: LeaveRequestCreateOrConnectWithoutApprovedByInput | LeaveRequestCreateOrConnectWithoutApprovedByInput[]
    createMany?: LeaveRequestCreateManyApprovedByInputEnvelope
    connect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
  }

  export type ProspectUncheckedCreateNestedManyWithoutAssignedUserInput = {
    create?: XOR<ProspectCreateWithoutAssignedUserInput, ProspectUncheckedCreateWithoutAssignedUserInput> | ProspectCreateWithoutAssignedUserInput[] | ProspectUncheckedCreateWithoutAssignedUserInput[]
    connectOrCreate?: ProspectCreateOrConnectWithoutAssignedUserInput | ProspectCreateOrConnectWithoutAssignedUserInput[]
    createMany?: ProspectCreateManyAssignedUserInputEnvelope
    connect?: ProspectWhereUniqueInput | ProspectWhereUniqueInput[]
  }

  export type ProspectUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ProspectCreateWithoutCreatorInput, ProspectUncheckedCreateWithoutCreatorInput> | ProspectCreateWithoutCreatorInput[] | ProspectUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ProspectCreateOrConnectWithoutCreatorInput | ProspectCreateOrConnectWithoutCreatorInput[]
    createMany?: ProspectCreateManyCreatorInputEnvelope
    connect?: ProspectWhereUniqueInput | ProspectWhereUniqueInput[]
  }

  export type ProspectActivityUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ProspectActivityCreateWithoutCreatorInput, ProspectActivityUncheckedCreateWithoutCreatorInput> | ProspectActivityCreateWithoutCreatorInput[] | ProspectActivityUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ProspectActivityCreateOrConnectWithoutCreatorInput | ProspectActivityCreateOrConnectWithoutCreatorInput[]
    createMany?: ProspectActivityCreateManyCreatorInputEnvelope
    connect?: ProspectActivityWhereUniqueInput | ProspectActivityWhereUniqueInput[]
  }

  export type TechnicienUncheckedCreateNestedOneWithoutUtilisateurInput = {
    create?: XOR<TechnicienCreateWithoutUtilisateurInput, TechnicienUncheckedCreateWithoutUtilisateurInput>
    connectOrCreate?: TechnicienCreateOrConnectWithoutUtilisateurInput
    connect?: TechnicienWhereUniqueInput
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type ServiceUpdateOneWithoutUsersNestedInput = {
    create?: XOR<ServiceCreateWithoutUsersInput, ServiceUncheckedCreateWithoutUsersInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutUsersInput
    upsert?: ServiceUpsertWithoutUsersInput
    disconnect?: ServiceWhereInput | boolean
    delete?: ServiceWhereInput | boolean
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutUsersInput, ServiceUpdateWithoutUsersInput>, ServiceUncheckedUpdateWithoutUsersInput>
  }

  export type CustomerUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<CustomerCreateWithoutCreatorInput, CustomerUncheckedCreateWithoutCreatorInput> | CustomerCreateWithoutCreatorInput[] | CustomerUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutCreatorInput | CustomerCreateOrConnectWithoutCreatorInput[]
    upsert?: CustomerUpsertWithWhereUniqueWithoutCreatorInput | CustomerUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: CustomerCreateManyCreatorInputEnvelope
    set?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    disconnect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    delete?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    update?: CustomerUpdateWithWhereUniqueWithoutCreatorInput | CustomerUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: CustomerUpdateManyWithWhereWithoutCreatorInput | CustomerUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
  }

  export type QuoteUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<QuoteCreateWithoutCreatorInput, QuoteUncheckedCreateWithoutCreatorInput> | QuoteCreateWithoutCreatorInput[] | QuoteUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: QuoteCreateOrConnectWithoutCreatorInput | QuoteCreateOrConnectWithoutCreatorInput[]
    upsert?: QuoteUpsertWithWhereUniqueWithoutCreatorInput | QuoteUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: QuoteCreateManyCreatorInputEnvelope
    set?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    disconnect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    delete?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    connect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    update?: QuoteUpdateWithWhereUniqueWithoutCreatorInput | QuoteUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: QuoteUpdateManyWithWhereWithoutCreatorInput | QuoteUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: QuoteScalarWhereInput | QuoteScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<InvoiceCreateWithoutCreatorInput, InvoiceUncheckedCreateWithoutCreatorInput> | InvoiceCreateWithoutCreatorInput[] | InvoiceUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCreatorInput | InvoiceCreateOrConnectWithoutCreatorInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutCreatorInput | InvoiceUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: InvoiceCreateManyCreatorInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutCreatorInput | InvoiceUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutCreatorInput | InvoiceUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<PaymentCreateWithoutCreatorInput, PaymentUncheckedCreateWithoutCreatorInput> | PaymentCreateWithoutCreatorInput[] | PaymentUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutCreatorInput | PaymentCreateOrConnectWithoutCreatorInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutCreatorInput | PaymentUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: PaymentCreateManyCreatorInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutCreatorInput | PaymentUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutCreatorInput | PaymentUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type QuoteUpdateManyWithoutServiceManagerNestedInput = {
    create?: XOR<QuoteCreateWithoutServiceManagerInput, QuoteUncheckedCreateWithoutServiceManagerInput> | QuoteCreateWithoutServiceManagerInput[] | QuoteUncheckedCreateWithoutServiceManagerInput[]
    connectOrCreate?: QuoteCreateOrConnectWithoutServiceManagerInput | QuoteCreateOrConnectWithoutServiceManagerInput[]
    upsert?: QuoteUpsertWithWhereUniqueWithoutServiceManagerInput | QuoteUpsertWithWhereUniqueWithoutServiceManagerInput[]
    createMany?: QuoteCreateManyServiceManagerInputEnvelope
    set?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    disconnect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    delete?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    connect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    update?: QuoteUpdateWithWhereUniqueWithoutServiceManagerInput | QuoteUpdateWithWhereUniqueWithoutServiceManagerInput[]
    updateMany?: QuoteUpdateManyWithWhereWithoutServiceManagerInput | QuoteUpdateManyWithWhereWithoutServiceManagerInput[]
    deleteMany?: QuoteScalarWhereInput | QuoteScalarWhereInput[]
  }

  export type QuoteUpdateManyWithoutDgApproverNestedInput = {
    create?: XOR<QuoteCreateWithoutDgApproverInput, QuoteUncheckedCreateWithoutDgApproverInput> | QuoteCreateWithoutDgApproverInput[] | QuoteUncheckedCreateWithoutDgApproverInput[]
    connectOrCreate?: QuoteCreateOrConnectWithoutDgApproverInput | QuoteCreateOrConnectWithoutDgApproverInput[]
    upsert?: QuoteUpsertWithWhereUniqueWithoutDgApproverInput | QuoteUpsertWithWhereUniqueWithoutDgApproverInput[]
    createMany?: QuoteCreateManyDgApproverInputEnvelope
    set?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    disconnect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    delete?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    connect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    update?: QuoteUpdateWithWhereUniqueWithoutDgApproverInput | QuoteUpdateWithWhereUniqueWithoutDgApproverInput[]
    updateMany?: QuoteUpdateManyWithWhereWithoutDgApproverInput | QuoteUpdateManyWithWhereWithoutDgApproverInput[]
    deleteMany?: QuoteScalarWhereInput | QuoteScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type QuoteApprovalUpdateManyWithoutApproverNestedInput = {
    create?: XOR<QuoteApprovalCreateWithoutApproverInput, QuoteApprovalUncheckedCreateWithoutApproverInput> | QuoteApprovalCreateWithoutApproverInput[] | QuoteApprovalUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: QuoteApprovalCreateOrConnectWithoutApproverInput | QuoteApprovalCreateOrConnectWithoutApproverInput[]
    upsert?: QuoteApprovalUpsertWithWhereUniqueWithoutApproverInput | QuoteApprovalUpsertWithWhereUniqueWithoutApproverInput[]
    createMany?: QuoteApprovalCreateManyApproverInputEnvelope
    set?: QuoteApprovalWhereUniqueInput | QuoteApprovalWhereUniqueInput[]
    disconnect?: QuoteApprovalWhereUniqueInput | QuoteApprovalWhereUniqueInput[]
    delete?: QuoteApprovalWhereUniqueInput | QuoteApprovalWhereUniqueInput[]
    connect?: QuoteApprovalWhereUniqueInput | QuoteApprovalWhereUniqueInput[]
    update?: QuoteApprovalUpdateWithWhereUniqueWithoutApproverInput | QuoteApprovalUpdateWithWhereUniqueWithoutApproverInput[]
    updateMany?: QuoteApprovalUpdateManyWithWhereWithoutApproverInput | QuoteApprovalUpdateManyWithWhereWithoutApproverInput[]
    deleteMany?: QuoteApprovalScalarWhereInput | QuoteApprovalScalarWhereInput[]
  }

  export type ExpenseUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ExpenseCreateWithoutCreatorInput, ExpenseUncheckedCreateWithoutCreatorInput> | ExpenseCreateWithoutCreatorInput[] | ExpenseUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutCreatorInput | ExpenseCreateOrConnectWithoutCreatorInput[]
    upsert?: ExpenseUpsertWithWhereUniqueWithoutCreatorInput | ExpenseUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ExpenseCreateManyCreatorInputEnvelope
    set?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    disconnect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    delete?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    update?: ExpenseUpdateWithWhereUniqueWithoutCreatorInput | ExpenseUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ExpenseUpdateManyWithWhereWithoutCreatorInput | ExpenseUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
  }

  export type AccountingEntryUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<AccountingEntryCreateWithoutCreatorInput, AccountingEntryUncheckedCreateWithoutCreatorInput> | AccountingEntryCreateWithoutCreatorInput[] | AccountingEntryUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: AccountingEntryCreateOrConnectWithoutCreatorInput | AccountingEntryCreateOrConnectWithoutCreatorInput[]
    upsert?: AccountingEntryUpsertWithWhereUniqueWithoutCreatorInput | AccountingEntryUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: AccountingEntryCreateManyCreatorInputEnvelope
    set?: AccountingEntryWhereUniqueInput | AccountingEntryWhereUniqueInput[]
    disconnect?: AccountingEntryWhereUniqueInput | AccountingEntryWhereUniqueInput[]
    delete?: AccountingEntryWhereUniqueInput | AccountingEntryWhereUniqueInput[]
    connect?: AccountingEntryWhereUniqueInput | AccountingEntryWhereUniqueInput[]
    update?: AccountingEntryUpdateWithWhereUniqueWithoutCreatorInput | AccountingEntryUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: AccountingEntryUpdateManyWithWhereWithoutCreatorInput | AccountingEntryUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: AccountingEntryScalarWhereInput | AccountingEntryScalarWhereInput[]
  }

  export type CashFlowUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<CashFlowCreateWithoutCreatorInput, CashFlowUncheckedCreateWithoutCreatorInput> | CashFlowCreateWithoutCreatorInput[] | CashFlowUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CashFlowCreateOrConnectWithoutCreatorInput | CashFlowCreateOrConnectWithoutCreatorInput[]
    upsert?: CashFlowUpsertWithWhereUniqueWithoutCreatorInput | CashFlowUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: CashFlowCreateManyCreatorInputEnvelope
    set?: CashFlowWhereUniqueInput | CashFlowWhereUniqueInput[]
    disconnect?: CashFlowWhereUniqueInput | CashFlowWhereUniqueInput[]
    delete?: CashFlowWhereUniqueInput | CashFlowWhereUniqueInput[]
    connect?: CashFlowWhereUniqueInput | CashFlowWhereUniqueInput[]
    update?: CashFlowUpdateWithWhereUniqueWithoutCreatorInput | CashFlowUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: CashFlowUpdateManyWithWhereWithoutCreatorInput | CashFlowUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: CashFlowScalarWhereInput | CashFlowScalarWhereInput[]
  }

  export type ReminderUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ReminderCreateWithoutCreatorInput, ReminderUncheckedCreateWithoutCreatorInput> | ReminderCreateWithoutCreatorInput[] | ReminderUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ReminderCreateOrConnectWithoutCreatorInput | ReminderCreateOrConnectWithoutCreatorInput[]
    upsert?: ReminderUpsertWithWhereUniqueWithoutCreatorInput | ReminderUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ReminderCreateManyCreatorInputEnvelope
    set?: ReminderWhereUniqueInput | ReminderWhereUniqueInput[]
    disconnect?: ReminderWhereUniqueInput | ReminderWhereUniqueInput[]
    delete?: ReminderWhereUniqueInput | ReminderWhereUniqueInput[]
    connect?: ReminderWhereUniqueInput | ReminderWhereUniqueInput[]
    update?: ReminderUpdateWithWhereUniqueWithoutCreatorInput | ReminderUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ReminderUpdateManyWithWhereWithoutCreatorInput | ReminderUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ReminderScalarWhereInput | ReminderScalarWhereInput[]
  }

  export type RecurringInvoiceUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<RecurringInvoiceCreateWithoutCreatorInput, RecurringInvoiceUncheckedCreateWithoutCreatorInput> | RecurringInvoiceCreateWithoutCreatorInput[] | RecurringInvoiceUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: RecurringInvoiceCreateOrConnectWithoutCreatorInput | RecurringInvoiceCreateOrConnectWithoutCreatorInput[]
    upsert?: RecurringInvoiceUpsertWithWhereUniqueWithoutCreatorInput | RecurringInvoiceUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: RecurringInvoiceCreateManyCreatorInputEnvelope
    set?: RecurringInvoiceWhereUniqueInput | RecurringInvoiceWhereUniqueInput[]
    disconnect?: RecurringInvoiceWhereUniqueInput | RecurringInvoiceWhereUniqueInput[]
    delete?: RecurringInvoiceWhereUniqueInput | RecurringInvoiceWhereUniqueInput[]
    connect?: RecurringInvoiceWhereUniqueInput | RecurringInvoiceWhereUniqueInput[]
    update?: RecurringInvoiceUpdateWithWhereUniqueWithoutCreatorInput | RecurringInvoiceUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: RecurringInvoiceUpdateManyWithWhereWithoutCreatorInput | RecurringInvoiceUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: RecurringInvoiceScalarWhereInput | RecurringInvoiceScalarWhereInput[]
  }

  export type EmployeeUpdateOneWithoutUserNestedInput = {
    create?: XOR<EmployeeCreateWithoutUserInput, EmployeeUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutUserInput
    upsert?: EmployeeUpsertWithoutUserInput
    disconnect?: EmployeeWhereInput | boolean
    delete?: EmployeeWhereInput | boolean
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutUserInput, EmployeeUpdateWithoutUserInput>, EmployeeUncheckedUpdateWithoutUserInput>
  }

  export type LeaveRequestUpdateManyWithoutApprovedByNestedInput = {
    create?: XOR<LeaveRequestCreateWithoutApprovedByInput, LeaveRequestUncheckedCreateWithoutApprovedByInput> | LeaveRequestCreateWithoutApprovedByInput[] | LeaveRequestUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: LeaveRequestCreateOrConnectWithoutApprovedByInput | LeaveRequestCreateOrConnectWithoutApprovedByInput[]
    upsert?: LeaveRequestUpsertWithWhereUniqueWithoutApprovedByInput | LeaveRequestUpsertWithWhereUniqueWithoutApprovedByInput[]
    createMany?: LeaveRequestCreateManyApprovedByInputEnvelope
    set?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    disconnect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    delete?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    connect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    update?: LeaveRequestUpdateWithWhereUniqueWithoutApprovedByInput | LeaveRequestUpdateWithWhereUniqueWithoutApprovedByInput[]
    updateMany?: LeaveRequestUpdateManyWithWhereWithoutApprovedByInput | LeaveRequestUpdateManyWithWhereWithoutApprovedByInput[]
    deleteMany?: LeaveRequestScalarWhereInput | LeaveRequestScalarWhereInput[]
  }

  export type ProspectUpdateManyWithoutAssignedUserNestedInput = {
    create?: XOR<ProspectCreateWithoutAssignedUserInput, ProspectUncheckedCreateWithoutAssignedUserInput> | ProspectCreateWithoutAssignedUserInput[] | ProspectUncheckedCreateWithoutAssignedUserInput[]
    connectOrCreate?: ProspectCreateOrConnectWithoutAssignedUserInput | ProspectCreateOrConnectWithoutAssignedUserInput[]
    upsert?: ProspectUpsertWithWhereUniqueWithoutAssignedUserInput | ProspectUpsertWithWhereUniqueWithoutAssignedUserInput[]
    createMany?: ProspectCreateManyAssignedUserInputEnvelope
    set?: ProspectWhereUniqueInput | ProspectWhereUniqueInput[]
    disconnect?: ProspectWhereUniqueInput | ProspectWhereUniqueInput[]
    delete?: ProspectWhereUniqueInput | ProspectWhereUniqueInput[]
    connect?: ProspectWhereUniqueInput | ProspectWhereUniqueInput[]
    update?: ProspectUpdateWithWhereUniqueWithoutAssignedUserInput | ProspectUpdateWithWhereUniqueWithoutAssignedUserInput[]
    updateMany?: ProspectUpdateManyWithWhereWithoutAssignedUserInput | ProspectUpdateManyWithWhereWithoutAssignedUserInput[]
    deleteMany?: ProspectScalarWhereInput | ProspectScalarWhereInput[]
  }

  export type ProspectUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ProspectCreateWithoutCreatorInput, ProspectUncheckedCreateWithoutCreatorInput> | ProspectCreateWithoutCreatorInput[] | ProspectUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ProspectCreateOrConnectWithoutCreatorInput | ProspectCreateOrConnectWithoutCreatorInput[]
    upsert?: ProspectUpsertWithWhereUniqueWithoutCreatorInput | ProspectUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ProspectCreateManyCreatorInputEnvelope
    set?: ProspectWhereUniqueInput | ProspectWhereUniqueInput[]
    disconnect?: ProspectWhereUniqueInput | ProspectWhereUniqueInput[]
    delete?: ProspectWhereUniqueInput | ProspectWhereUniqueInput[]
    connect?: ProspectWhereUniqueInput | ProspectWhereUniqueInput[]
    update?: ProspectUpdateWithWhereUniqueWithoutCreatorInput | ProspectUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ProspectUpdateManyWithWhereWithoutCreatorInput | ProspectUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ProspectScalarWhereInput | ProspectScalarWhereInput[]
  }

  export type ProspectActivityUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ProspectActivityCreateWithoutCreatorInput, ProspectActivityUncheckedCreateWithoutCreatorInput> | ProspectActivityCreateWithoutCreatorInput[] | ProspectActivityUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ProspectActivityCreateOrConnectWithoutCreatorInput | ProspectActivityCreateOrConnectWithoutCreatorInput[]
    upsert?: ProspectActivityUpsertWithWhereUniqueWithoutCreatorInput | ProspectActivityUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ProspectActivityCreateManyCreatorInputEnvelope
    set?: ProspectActivityWhereUniqueInput | ProspectActivityWhereUniqueInput[]
    disconnect?: ProspectActivityWhereUniqueInput | ProspectActivityWhereUniqueInput[]
    delete?: ProspectActivityWhereUniqueInput | ProspectActivityWhereUniqueInput[]
    connect?: ProspectActivityWhereUniqueInput | ProspectActivityWhereUniqueInput[]
    update?: ProspectActivityUpdateWithWhereUniqueWithoutCreatorInput | ProspectActivityUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ProspectActivityUpdateManyWithWhereWithoutCreatorInput | ProspectActivityUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ProspectActivityScalarWhereInput | ProspectActivityScalarWhereInput[]
  }

  export type TechnicienUpdateOneWithoutUtilisateurNestedInput = {
    create?: XOR<TechnicienCreateWithoutUtilisateurInput, TechnicienUncheckedCreateWithoutUtilisateurInput>
    connectOrCreate?: TechnicienCreateOrConnectWithoutUtilisateurInput
    upsert?: TechnicienUpsertWithoutUtilisateurInput
    disconnect?: TechnicienWhereInput | boolean
    delete?: TechnicienWhereInput | boolean
    connect?: TechnicienWhereUniqueInput
    update?: XOR<XOR<TechnicienUpdateToOneWithWhereWithoutUtilisateurInput, TechnicienUpdateWithoutUtilisateurInput>, TechnicienUncheckedUpdateWithoutUtilisateurInput>
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CustomerUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<CustomerCreateWithoutCreatorInput, CustomerUncheckedCreateWithoutCreatorInput> | CustomerCreateWithoutCreatorInput[] | CustomerUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutCreatorInput | CustomerCreateOrConnectWithoutCreatorInput[]
    upsert?: CustomerUpsertWithWhereUniqueWithoutCreatorInput | CustomerUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: CustomerCreateManyCreatorInputEnvelope
    set?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    disconnect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    delete?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    update?: CustomerUpdateWithWhereUniqueWithoutCreatorInput | CustomerUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: CustomerUpdateManyWithWhereWithoutCreatorInput | CustomerUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
  }

  export type QuoteUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<QuoteCreateWithoutCreatorInput, QuoteUncheckedCreateWithoutCreatorInput> | QuoteCreateWithoutCreatorInput[] | QuoteUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: QuoteCreateOrConnectWithoutCreatorInput | QuoteCreateOrConnectWithoutCreatorInput[]
    upsert?: QuoteUpsertWithWhereUniqueWithoutCreatorInput | QuoteUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: QuoteCreateManyCreatorInputEnvelope
    set?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    disconnect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    delete?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    connect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    update?: QuoteUpdateWithWhereUniqueWithoutCreatorInput | QuoteUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: QuoteUpdateManyWithWhereWithoutCreatorInput | QuoteUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: QuoteScalarWhereInput | QuoteScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<InvoiceCreateWithoutCreatorInput, InvoiceUncheckedCreateWithoutCreatorInput> | InvoiceCreateWithoutCreatorInput[] | InvoiceUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCreatorInput | InvoiceCreateOrConnectWithoutCreatorInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutCreatorInput | InvoiceUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: InvoiceCreateManyCreatorInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutCreatorInput | InvoiceUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutCreatorInput | InvoiceUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<PaymentCreateWithoutCreatorInput, PaymentUncheckedCreateWithoutCreatorInput> | PaymentCreateWithoutCreatorInput[] | PaymentUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutCreatorInput | PaymentCreateOrConnectWithoutCreatorInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutCreatorInput | PaymentUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: PaymentCreateManyCreatorInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutCreatorInput | PaymentUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutCreatorInput | PaymentUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type QuoteUncheckedUpdateManyWithoutServiceManagerNestedInput = {
    create?: XOR<QuoteCreateWithoutServiceManagerInput, QuoteUncheckedCreateWithoutServiceManagerInput> | QuoteCreateWithoutServiceManagerInput[] | QuoteUncheckedCreateWithoutServiceManagerInput[]
    connectOrCreate?: QuoteCreateOrConnectWithoutServiceManagerInput | QuoteCreateOrConnectWithoutServiceManagerInput[]
    upsert?: QuoteUpsertWithWhereUniqueWithoutServiceManagerInput | QuoteUpsertWithWhereUniqueWithoutServiceManagerInput[]
    createMany?: QuoteCreateManyServiceManagerInputEnvelope
    set?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    disconnect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    delete?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    connect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    update?: QuoteUpdateWithWhereUniqueWithoutServiceManagerInput | QuoteUpdateWithWhereUniqueWithoutServiceManagerInput[]
    updateMany?: QuoteUpdateManyWithWhereWithoutServiceManagerInput | QuoteUpdateManyWithWhereWithoutServiceManagerInput[]
    deleteMany?: QuoteScalarWhereInput | QuoteScalarWhereInput[]
  }

  export type QuoteUncheckedUpdateManyWithoutDgApproverNestedInput = {
    create?: XOR<QuoteCreateWithoutDgApproverInput, QuoteUncheckedCreateWithoutDgApproverInput> | QuoteCreateWithoutDgApproverInput[] | QuoteUncheckedCreateWithoutDgApproverInput[]
    connectOrCreate?: QuoteCreateOrConnectWithoutDgApproverInput | QuoteCreateOrConnectWithoutDgApproverInput[]
    upsert?: QuoteUpsertWithWhereUniqueWithoutDgApproverInput | QuoteUpsertWithWhereUniqueWithoutDgApproverInput[]
    createMany?: QuoteCreateManyDgApproverInputEnvelope
    set?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    disconnect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    delete?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    connect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    update?: QuoteUpdateWithWhereUniqueWithoutDgApproverInput | QuoteUpdateWithWhereUniqueWithoutDgApproverInput[]
    updateMany?: QuoteUpdateManyWithWhereWithoutDgApproverInput | QuoteUpdateManyWithWhereWithoutDgApproverInput[]
    deleteMany?: QuoteScalarWhereInput | QuoteScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type QuoteApprovalUncheckedUpdateManyWithoutApproverNestedInput = {
    create?: XOR<QuoteApprovalCreateWithoutApproverInput, QuoteApprovalUncheckedCreateWithoutApproverInput> | QuoteApprovalCreateWithoutApproverInput[] | QuoteApprovalUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: QuoteApprovalCreateOrConnectWithoutApproverInput | QuoteApprovalCreateOrConnectWithoutApproverInput[]
    upsert?: QuoteApprovalUpsertWithWhereUniqueWithoutApproverInput | QuoteApprovalUpsertWithWhereUniqueWithoutApproverInput[]
    createMany?: QuoteApprovalCreateManyApproverInputEnvelope
    set?: QuoteApprovalWhereUniqueInput | QuoteApprovalWhereUniqueInput[]
    disconnect?: QuoteApprovalWhereUniqueInput | QuoteApprovalWhereUniqueInput[]
    delete?: QuoteApprovalWhereUniqueInput | QuoteApprovalWhereUniqueInput[]
    connect?: QuoteApprovalWhereUniqueInput | QuoteApprovalWhereUniqueInput[]
    update?: QuoteApprovalUpdateWithWhereUniqueWithoutApproverInput | QuoteApprovalUpdateWithWhereUniqueWithoutApproverInput[]
    updateMany?: QuoteApprovalUpdateManyWithWhereWithoutApproverInput | QuoteApprovalUpdateManyWithWhereWithoutApproverInput[]
    deleteMany?: QuoteApprovalScalarWhereInput | QuoteApprovalScalarWhereInput[]
  }

  export type ExpenseUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ExpenseCreateWithoutCreatorInput, ExpenseUncheckedCreateWithoutCreatorInput> | ExpenseCreateWithoutCreatorInput[] | ExpenseUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutCreatorInput | ExpenseCreateOrConnectWithoutCreatorInput[]
    upsert?: ExpenseUpsertWithWhereUniqueWithoutCreatorInput | ExpenseUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ExpenseCreateManyCreatorInputEnvelope
    set?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    disconnect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    delete?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    update?: ExpenseUpdateWithWhereUniqueWithoutCreatorInput | ExpenseUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ExpenseUpdateManyWithWhereWithoutCreatorInput | ExpenseUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
  }

  export type AccountingEntryUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<AccountingEntryCreateWithoutCreatorInput, AccountingEntryUncheckedCreateWithoutCreatorInput> | AccountingEntryCreateWithoutCreatorInput[] | AccountingEntryUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: AccountingEntryCreateOrConnectWithoutCreatorInput | AccountingEntryCreateOrConnectWithoutCreatorInput[]
    upsert?: AccountingEntryUpsertWithWhereUniqueWithoutCreatorInput | AccountingEntryUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: AccountingEntryCreateManyCreatorInputEnvelope
    set?: AccountingEntryWhereUniqueInput | AccountingEntryWhereUniqueInput[]
    disconnect?: AccountingEntryWhereUniqueInput | AccountingEntryWhereUniqueInput[]
    delete?: AccountingEntryWhereUniqueInput | AccountingEntryWhereUniqueInput[]
    connect?: AccountingEntryWhereUniqueInput | AccountingEntryWhereUniqueInput[]
    update?: AccountingEntryUpdateWithWhereUniqueWithoutCreatorInput | AccountingEntryUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: AccountingEntryUpdateManyWithWhereWithoutCreatorInput | AccountingEntryUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: AccountingEntryScalarWhereInput | AccountingEntryScalarWhereInput[]
  }

  export type CashFlowUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<CashFlowCreateWithoutCreatorInput, CashFlowUncheckedCreateWithoutCreatorInput> | CashFlowCreateWithoutCreatorInput[] | CashFlowUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CashFlowCreateOrConnectWithoutCreatorInput | CashFlowCreateOrConnectWithoutCreatorInput[]
    upsert?: CashFlowUpsertWithWhereUniqueWithoutCreatorInput | CashFlowUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: CashFlowCreateManyCreatorInputEnvelope
    set?: CashFlowWhereUniqueInput | CashFlowWhereUniqueInput[]
    disconnect?: CashFlowWhereUniqueInput | CashFlowWhereUniqueInput[]
    delete?: CashFlowWhereUniqueInput | CashFlowWhereUniqueInput[]
    connect?: CashFlowWhereUniqueInput | CashFlowWhereUniqueInput[]
    update?: CashFlowUpdateWithWhereUniqueWithoutCreatorInput | CashFlowUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: CashFlowUpdateManyWithWhereWithoutCreatorInput | CashFlowUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: CashFlowScalarWhereInput | CashFlowScalarWhereInput[]
  }

  export type ReminderUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ReminderCreateWithoutCreatorInput, ReminderUncheckedCreateWithoutCreatorInput> | ReminderCreateWithoutCreatorInput[] | ReminderUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ReminderCreateOrConnectWithoutCreatorInput | ReminderCreateOrConnectWithoutCreatorInput[]
    upsert?: ReminderUpsertWithWhereUniqueWithoutCreatorInput | ReminderUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ReminderCreateManyCreatorInputEnvelope
    set?: ReminderWhereUniqueInput | ReminderWhereUniqueInput[]
    disconnect?: ReminderWhereUniqueInput | ReminderWhereUniqueInput[]
    delete?: ReminderWhereUniqueInput | ReminderWhereUniqueInput[]
    connect?: ReminderWhereUniqueInput | ReminderWhereUniqueInput[]
    update?: ReminderUpdateWithWhereUniqueWithoutCreatorInput | ReminderUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ReminderUpdateManyWithWhereWithoutCreatorInput | ReminderUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ReminderScalarWhereInput | ReminderScalarWhereInput[]
  }

  export type RecurringInvoiceUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<RecurringInvoiceCreateWithoutCreatorInput, RecurringInvoiceUncheckedCreateWithoutCreatorInput> | RecurringInvoiceCreateWithoutCreatorInput[] | RecurringInvoiceUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: RecurringInvoiceCreateOrConnectWithoutCreatorInput | RecurringInvoiceCreateOrConnectWithoutCreatorInput[]
    upsert?: RecurringInvoiceUpsertWithWhereUniqueWithoutCreatorInput | RecurringInvoiceUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: RecurringInvoiceCreateManyCreatorInputEnvelope
    set?: RecurringInvoiceWhereUniqueInput | RecurringInvoiceWhereUniqueInput[]
    disconnect?: RecurringInvoiceWhereUniqueInput | RecurringInvoiceWhereUniqueInput[]
    delete?: RecurringInvoiceWhereUniqueInput | RecurringInvoiceWhereUniqueInput[]
    connect?: RecurringInvoiceWhereUniqueInput | RecurringInvoiceWhereUniqueInput[]
    update?: RecurringInvoiceUpdateWithWhereUniqueWithoutCreatorInput | RecurringInvoiceUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: RecurringInvoiceUpdateManyWithWhereWithoutCreatorInput | RecurringInvoiceUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: RecurringInvoiceScalarWhereInput | RecurringInvoiceScalarWhereInput[]
  }

  export type EmployeeUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<EmployeeCreateWithoutUserInput, EmployeeUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutUserInput
    upsert?: EmployeeUpsertWithoutUserInput
    disconnect?: EmployeeWhereInput | boolean
    delete?: EmployeeWhereInput | boolean
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutUserInput, EmployeeUpdateWithoutUserInput>, EmployeeUncheckedUpdateWithoutUserInput>
  }

  export type LeaveRequestUncheckedUpdateManyWithoutApprovedByNestedInput = {
    create?: XOR<LeaveRequestCreateWithoutApprovedByInput, LeaveRequestUncheckedCreateWithoutApprovedByInput> | LeaveRequestCreateWithoutApprovedByInput[] | LeaveRequestUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: LeaveRequestCreateOrConnectWithoutApprovedByInput | LeaveRequestCreateOrConnectWithoutApprovedByInput[]
    upsert?: LeaveRequestUpsertWithWhereUniqueWithoutApprovedByInput | LeaveRequestUpsertWithWhereUniqueWithoutApprovedByInput[]
    createMany?: LeaveRequestCreateManyApprovedByInputEnvelope
    set?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    disconnect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    delete?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    connect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    update?: LeaveRequestUpdateWithWhereUniqueWithoutApprovedByInput | LeaveRequestUpdateWithWhereUniqueWithoutApprovedByInput[]
    updateMany?: LeaveRequestUpdateManyWithWhereWithoutApprovedByInput | LeaveRequestUpdateManyWithWhereWithoutApprovedByInput[]
    deleteMany?: LeaveRequestScalarWhereInput | LeaveRequestScalarWhereInput[]
  }

  export type ProspectUncheckedUpdateManyWithoutAssignedUserNestedInput = {
    create?: XOR<ProspectCreateWithoutAssignedUserInput, ProspectUncheckedCreateWithoutAssignedUserInput> | ProspectCreateWithoutAssignedUserInput[] | ProspectUncheckedCreateWithoutAssignedUserInput[]
    connectOrCreate?: ProspectCreateOrConnectWithoutAssignedUserInput | ProspectCreateOrConnectWithoutAssignedUserInput[]
    upsert?: ProspectUpsertWithWhereUniqueWithoutAssignedUserInput | ProspectUpsertWithWhereUniqueWithoutAssignedUserInput[]
    createMany?: ProspectCreateManyAssignedUserInputEnvelope
    set?: ProspectWhereUniqueInput | ProspectWhereUniqueInput[]
    disconnect?: ProspectWhereUniqueInput | ProspectWhereUniqueInput[]
    delete?: ProspectWhereUniqueInput | ProspectWhereUniqueInput[]
    connect?: ProspectWhereUniqueInput | ProspectWhereUniqueInput[]
    update?: ProspectUpdateWithWhereUniqueWithoutAssignedUserInput | ProspectUpdateWithWhereUniqueWithoutAssignedUserInput[]
    updateMany?: ProspectUpdateManyWithWhereWithoutAssignedUserInput | ProspectUpdateManyWithWhereWithoutAssignedUserInput[]
    deleteMany?: ProspectScalarWhereInput | ProspectScalarWhereInput[]
  }

  export type ProspectUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ProspectCreateWithoutCreatorInput, ProspectUncheckedCreateWithoutCreatorInput> | ProspectCreateWithoutCreatorInput[] | ProspectUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ProspectCreateOrConnectWithoutCreatorInput | ProspectCreateOrConnectWithoutCreatorInput[]
    upsert?: ProspectUpsertWithWhereUniqueWithoutCreatorInput | ProspectUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ProspectCreateManyCreatorInputEnvelope
    set?: ProspectWhereUniqueInput | ProspectWhereUniqueInput[]
    disconnect?: ProspectWhereUniqueInput | ProspectWhereUniqueInput[]
    delete?: ProspectWhereUniqueInput | ProspectWhereUniqueInput[]
    connect?: ProspectWhereUniqueInput | ProspectWhereUniqueInput[]
    update?: ProspectUpdateWithWhereUniqueWithoutCreatorInput | ProspectUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ProspectUpdateManyWithWhereWithoutCreatorInput | ProspectUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ProspectScalarWhereInput | ProspectScalarWhereInput[]
  }

  export type ProspectActivityUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ProspectActivityCreateWithoutCreatorInput, ProspectActivityUncheckedCreateWithoutCreatorInput> | ProspectActivityCreateWithoutCreatorInput[] | ProspectActivityUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ProspectActivityCreateOrConnectWithoutCreatorInput | ProspectActivityCreateOrConnectWithoutCreatorInput[]
    upsert?: ProspectActivityUpsertWithWhereUniqueWithoutCreatorInput | ProspectActivityUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ProspectActivityCreateManyCreatorInputEnvelope
    set?: ProspectActivityWhereUniqueInput | ProspectActivityWhereUniqueInput[]
    disconnect?: ProspectActivityWhereUniqueInput | ProspectActivityWhereUniqueInput[]
    delete?: ProspectActivityWhereUniqueInput | ProspectActivityWhereUniqueInput[]
    connect?: ProspectActivityWhereUniqueInput | ProspectActivityWhereUniqueInput[]
    update?: ProspectActivityUpdateWithWhereUniqueWithoutCreatorInput | ProspectActivityUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ProspectActivityUpdateManyWithWhereWithoutCreatorInput | ProspectActivityUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ProspectActivityScalarWhereInput | ProspectActivityScalarWhereInput[]
  }

  export type TechnicienUncheckedUpdateOneWithoutUtilisateurNestedInput = {
    create?: XOR<TechnicienCreateWithoutUtilisateurInput, TechnicienUncheckedCreateWithoutUtilisateurInput>
    connectOrCreate?: TechnicienCreateOrConnectWithoutUtilisateurInput
    upsert?: TechnicienUpsertWithoutUtilisateurInput
    disconnect?: TechnicienWhereInput | boolean
    delete?: TechnicienWhereInput | boolean
    connect?: TechnicienWhereUniqueInput
    update?: XOR<XOR<TechnicienUpdateToOneWithWhereWithoutUtilisateurInput, TechnicienUpdateWithoutUtilisateurInput>, TechnicienUncheckedUpdateWithoutUtilisateurInput>
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type ServiceCreateNestedOneWithoutCustomersInput = {
    create?: XOR<ServiceCreateWithoutCustomersInput, ServiceUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutCustomersInput
    connect?: ServiceWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedCustomersInput = {
    create?: XOR<UserCreateWithoutCreatedCustomersInput, UserUncheckedCreateWithoutCreatedCustomersInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedCustomersInput
    connect?: UserWhereUniqueInput
  }

  export type CustomerAddressCreateNestedManyWithoutCustomerInput = {
    create?: XOR<CustomerAddressCreateWithoutCustomerInput, CustomerAddressUncheckedCreateWithoutCustomerInput> | CustomerAddressCreateWithoutCustomerInput[] | CustomerAddressUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerAddressCreateOrConnectWithoutCustomerInput | CustomerAddressCreateOrConnectWithoutCustomerInput[]
    createMany?: CustomerAddressCreateManyCustomerInputEnvelope
    connect?: CustomerAddressWhereUniqueInput | CustomerAddressWhereUniqueInput[]
  }

  export type QuoteCreateNestedManyWithoutCustomerInput = {
    create?: XOR<QuoteCreateWithoutCustomerInput, QuoteUncheckedCreateWithoutCustomerInput> | QuoteCreateWithoutCustomerInput[] | QuoteUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: QuoteCreateOrConnectWithoutCustomerInput | QuoteCreateOrConnectWithoutCustomerInput[]
    createMany?: QuoteCreateManyCustomerInputEnvelope
    connect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutCustomerInput = {
    create?: XOR<InvoiceCreateWithoutCustomerInput, InvoiceUncheckedCreateWithoutCustomerInput> | InvoiceCreateWithoutCustomerInput[] | InvoiceUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCustomerInput | InvoiceCreateOrConnectWithoutCustomerInput[]
    createMany?: InvoiceCreateManyCustomerInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutCustomerInput = {
    create?: XOR<PaymentCreateWithoutCustomerInput, PaymentUncheckedCreateWithoutCustomerInput> | PaymentCreateWithoutCustomerInput[] | PaymentUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutCustomerInput | PaymentCreateOrConnectWithoutCustomerInput[]
    createMany?: PaymentCreateManyCustomerInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type RecurringInvoiceCreateNestedManyWithoutCustomerInput = {
    create?: XOR<RecurringInvoiceCreateWithoutCustomerInput, RecurringInvoiceUncheckedCreateWithoutCustomerInput> | RecurringInvoiceCreateWithoutCustomerInput[] | RecurringInvoiceUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: RecurringInvoiceCreateOrConnectWithoutCustomerInput | RecurringInvoiceCreateOrConnectWithoutCustomerInput[]
    createMany?: RecurringInvoiceCreateManyCustomerInputEnvelope
    connect?: RecurringInvoiceWhereUniqueInput | RecurringInvoiceWhereUniqueInput[]
  }

  export type MissionCreateNestedManyWithoutClientInput = {
    create?: XOR<MissionCreateWithoutClientInput, MissionUncheckedCreateWithoutClientInput> | MissionCreateWithoutClientInput[] | MissionUncheckedCreateWithoutClientInput[]
    connectOrCreate?: MissionCreateOrConnectWithoutClientInput | MissionCreateOrConnectWithoutClientInput[]
    createMany?: MissionCreateManyClientInputEnvelope
    connect?: MissionWhereUniqueInput | MissionWhereUniqueInput[]
  }

  export type CustomerAddressUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<CustomerAddressCreateWithoutCustomerInput, CustomerAddressUncheckedCreateWithoutCustomerInput> | CustomerAddressCreateWithoutCustomerInput[] | CustomerAddressUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerAddressCreateOrConnectWithoutCustomerInput | CustomerAddressCreateOrConnectWithoutCustomerInput[]
    createMany?: CustomerAddressCreateManyCustomerInputEnvelope
    connect?: CustomerAddressWhereUniqueInput | CustomerAddressWhereUniqueInput[]
  }

  export type QuoteUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<QuoteCreateWithoutCustomerInput, QuoteUncheckedCreateWithoutCustomerInput> | QuoteCreateWithoutCustomerInput[] | QuoteUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: QuoteCreateOrConnectWithoutCustomerInput | QuoteCreateOrConnectWithoutCustomerInput[]
    createMany?: QuoteCreateManyCustomerInputEnvelope
    connect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<InvoiceCreateWithoutCustomerInput, InvoiceUncheckedCreateWithoutCustomerInput> | InvoiceCreateWithoutCustomerInput[] | InvoiceUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCustomerInput | InvoiceCreateOrConnectWithoutCustomerInput[]
    createMany?: InvoiceCreateManyCustomerInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<PaymentCreateWithoutCustomerInput, PaymentUncheckedCreateWithoutCustomerInput> | PaymentCreateWithoutCustomerInput[] | PaymentUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutCustomerInput | PaymentCreateOrConnectWithoutCustomerInput[]
    createMany?: PaymentCreateManyCustomerInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type RecurringInvoiceUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<RecurringInvoiceCreateWithoutCustomerInput, RecurringInvoiceUncheckedCreateWithoutCustomerInput> | RecurringInvoiceCreateWithoutCustomerInput[] | RecurringInvoiceUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: RecurringInvoiceCreateOrConnectWithoutCustomerInput | RecurringInvoiceCreateOrConnectWithoutCustomerInput[]
    createMany?: RecurringInvoiceCreateManyCustomerInputEnvelope
    connect?: RecurringInvoiceWhereUniqueInput | RecurringInvoiceWhereUniqueInput[]
  }

  export type MissionUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<MissionCreateWithoutClientInput, MissionUncheckedCreateWithoutClientInput> | MissionCreateWithoutClientInput[] | MissionUncheckedCreateWithoutClientInput[]
    connectOrCreate?: MissionCreateOrConnectWithoutClientInput | MissionCreateOrConnectWithoutClientInput[]
    createMany?: MissionCreateManyClientInputEnvelope
    connect?: MissionWhereUniqueInput | MissionWhereUniqueInput[]
  }

  export type EnumCustomerTypeFieldUpdateOperationsInput = {
    set?: $Enums.CustomerType
  }

  export type EnumPaymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethod
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ServiceUpdateOneWithoutCustomersNestedInput = {
    create?: XOR<ServiceCreateWithoutCustomersInput, ServiceUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutCustomersInput
    upsert?: ServiceUpsertWithoutCustomersInput
    disconnect?: ServiceWhereInput | boolean
    delete?: ServiceWhereInput | boolean
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutCustomersInput, ServiceUpdateWithoutCustomersInput>, ServiceUncheckedUpdateWithoutCustomersInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedCustomersNestedInput = {
    create?: XOR<UserCreateWithoutCreatedCustomersInput, UserUncheckedCreateWithoutCreatedCustomersInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedCustomersInput
    upsert?: UserUpsertWithoutCreatedCustomersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedCustomersInput, UserUpdateWithoutCreatedCustomersInput>, UserUncheckedUpdateWithoutCreatedCustomersInput>
  }

  export type CustomerAddressUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<CustomerAddressCreateWithoutCustomerInput, CustomerAddressUncheckedCreateWithoutCustomerInput> | CustomerAddressCreateWithoutCustomerInput[] | CustomerAddressUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerAddressCreateOrConnectWithoutCustomerInput | CustomerAddressCreateOrConnectWithoutCustomerInput[]
    upsert?: CustomerAddressUpsertWithWhereUniqueWithoutCustomerInput | CustomerAddressUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: CustomerAddressCreateManyCustomerInputEnvelope
    set?: CustomerAddressWhereUniqueInput | CustomerAddressWhereUniqueInput[]
    disconnect?: CustomerAddressWhereUniqueInput | CustomerAddressWhereUniqueInput[]
    delete?: CustomerAddressWhereUniqueInput | CustomerAddressWhereUniqueInput[]
    connect?: CustomerAddressWhereUniqueInput | CustomerAddressWhereUniqueInput[]
    update?: CustomerAddressUpdateWithWhereUniqueWithoutCustomerInput | CustomerAddressUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: CustomerAddressUpdateManyWithWhereWithoutCustomerInput | CustomerAddressUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: CustomerAddressScalarWhereInput | CustomerAddressScalarWhereInput[]
  }

  export type QuoteUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<QuoteCreateWithoutCustomerInput, QuoteUncheckedCreateWithoutCustomerInput> | QuoteCreateWithoutCustomerInput[] | QuoteUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: QuoteCreateOrConnectWithoutCustomerInput | QuoteCreateOrConnectWithoutCustomerInput[]
    upsert?: QuoteUpsertWithWhereUniqueWithoutCustomerInput | QuoteUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: QuoteCreateManyCustomerInputEnvelope
    set?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    disconnect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    delete?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    connect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    update?: QuoteUpdateWithWhereUniqueWithoutCustomerInput | QuoteUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: QuoteUpdateManyWithWhereWithoutCustomerInput | QuoteUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: QuoteScalarWhereInput | QuoteScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<InvoiceCreateWithoutCustomerInput, InvoiceUncheckedCreateWithoutCustomerInput> | InvoiceCreateWithoutCustomerInput[] | InvoiceUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCustomerInput | InvoiceCreateOrConnectWithoutCustomerInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutCustomerInput | InvoiceUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: InvoiceCreateManyCustomerInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutCustomerInput | InvoiceUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutCustomerInput | InvoiceUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<PaymentCreateWithoutCustomerInput, PaymentUncheckedCreateWithoutCustomerInput> | PaymentCreateWithoutCustomerInput[] | PaymentUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutCustomerInput | PaymentCreateOrConnectWithoutCustomerInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutCustomerInput | PaymentUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: PaymentCreateManyCustomerInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutCustomerInput | PaymentUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutCustomerInput | PaymentUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type RecurringInvoiceUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<RecurringInvoiceCreateWithoutCustomerInput, RecurringInvoiceUncheckedCreateWithoutCustomerInput> | RecurringInvoiceCreateWithoutCustomerInput[] | RecurringInvoiceUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: RecurringInvoiceCreateOrConnectWithoutCustomerInput | RecurringInvoiceCreateOrConnectWithoutCustomerInput[]
    upsert?: RecurringInvoiceUpsertWithWhereUniqueWithoutCustomerInput | RecurringInvoiceUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: RecurringInvoiceCreateManyCustomerInputEnvelope
    set?: RecurringInvoiceWhereUniqueInput | RecurringInvoiceWhereUniqueInput[]
    disconnect?: RecurringInvoiceWhereUniqueInput | RecurringInvoiceWhereUniqueInput[]
    delete?: RecurringInvoiceWhereUniqueInput | RecurringInvoiceWhereUniqueInput[]
    connect?: RecurringInvoiceWhereUniqueInput | RecurringInvoiceWhereUniqueInput[]
    update?: RecurringInvoiceUpdateWithWhereUniqueWithoutCustomerInput | RecurringInvoiceUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: RecurringInvoiceUpdateManyWithWhereWithoutCustomerInput | RecurringInvoiceUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: RecurringInvoiceScalarWhereInput | RecurringInvoiceScalarWhereInput[]
  }

  export type MissionUpdateManyWithoutClientNestedInput = {
    create?: XOR<MissionCreateWithoutClientInput, MissionUncheckedCreateWithoutClientInput> | MissionCreateWithoutClientInput[] | MissionUncheckedCreateWithoutClientInput[]
    connectOrCreate?: MissionCreateOrConnectWithoutClientInput | MissionCreateOrConnectWithoutClientInput[]
    upsert?: MissionUpsertWithWhereUniqueWithoutClientInput | MissionUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: MissionCreateManyClientInputEnvelope
    set?: MissionWhereUniqueInput | MissionWhereUniqueInput[]
    disconnect?: MissionWhereUniqueInput | MissionWhereUniqueInput[]
    delete?: MissionWhereUniqueInput | MissionWhereUniqueInput[]
    connect?: MissionWhereUniqueInput | MissionWhereUniqueInput[]
    update?: MissionUpdateWithWhereUniqueWithoutClientInput | MissionUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: MissionUpdateManyWithWhereWithoutClientInput | MissionUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: MissionScalarWhereInput | MissionScalarWhereInput[]
  }

  export type CustomerAddressUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<CustomerAddressCreateWithoutCustomerInput, CustomerAddressUncheckedCreateWithoutCustomerInput> | CustomerAddressCreateWithoutCustomerInput[] | CustomerAddressUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerAddressCreateOrConnectWithoutCustomerInput | CustomerAddressCreateOrConnectWithoutCustomerInput[]
    upsert?: CustomerAddressUpsertWithWhereUniqueWithoutCustomerInput | CustomerAddressUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: CustomerAddressCreateManyCustomerInputEnvelope
    set?: CustomerAddressWhereUniqueInput | CustomerAddressWhereUniqueInput[]
    disconnect?: CustomerAddressWhereUniqueInput | CustomerAddressWhereUniqueInput[]
    delete?: CustomerAddressWhereUniqueInput | CustomerAddressWhereUniqueInput[]
    connect?: CustomerAddressWhereUniqueInput | CustomerAddressWhereUniqueInput[]
    update?: CustomerAddressUpdateWithWhereUniqueWithoutCustomerInput | CustomerAddressUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: CustomerAddressUpdateManyWithWhereWithoutCustomerInput | CustomerAddressUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: CustomerAddressScalarWhereInput | CustomerAddressScalarWhereInput[]
  }

  export type QuoteUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<QuoteCreateWithoutCustomerInput, QuoteUncheckedCreateWithoutCustomerInput> | QuoteCreateWithoutCustomerInput[] | QuoteUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: QuoteCreateOrConnectWithoutCustomerInput | QuoteCreateOrConnectWithoutCustomerInput[]
    upsert?: QuoteUpsertWithWhereUniqueWithoutCustomerInput | QuoteUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: QuoteCreateManyCustomerInputEnvelope
    set?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    disconnect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    delete?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    connect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    update?: QuoteUpdateWithWhereUniqueWithoutCustomerInput | QuoteUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: QuoteUpdateManyWithWhereWithoutCustomerInput | QuoteUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: QuoteScalarWhereInput | QuoteScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<InvoiceCreateWithoutCustomerInput, InvoiceUncheckedCreateWithoutCustomerInput> | InvoiceCreateWithoutCustomerInput[] | InvoiceUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCustomerInput | InvoiceCreateOrConnectWithoutCustomerInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutCustomerInput | InvoiceUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: InvoiceCreateManyCustomerInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutCustomerInput | InvoiceUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutCustomerInput | InvoiceUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<PaymentCreateWithoutCustomerInput, PaymentUncheckedCreateWithoutCustomerInput> | PaymentCreateWithoutCustomerInput[] | PaymentUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutCustomerInput | PaymentCreateOrConnectWithoutCustomerInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutCustomerInput | PaymentUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: PaymentCreateManyCustomerInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutCustomerInput | PaymentUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutCustomerInput | PaymentUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type RecurringInvoiceUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<RecurringInvoiceCreateWithoutCustomerInput, RecurringInvoiceUncheckedCreateWithoutCustomerInput> | RecurringInvoiceCreateWithoutCustomerInput[] | RecurringInvoiceUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: RecurringInvoiceCreateOrConnectWithoutCustomerInput | RecurringInvoiceCreateOrConnectWithoutCustomerInput[]
    upsert?: RecurringInvoiceUpsertWithWhereUniqueWithoutCustomerInput | RecurringInvoiceUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: RecurringInvoiceCreateManyCustomerInputEnvelope
    set?: RecurringInvoiceWhereUniqueInput | RecurringInvoiceWhereUniqueInput[]
    disconnect?: RecurringInvoiceWhereUniqueInput | RecurringInvoiceWhereUniqueInput[]
    delete?: RecurringInvoiceWhereUniqueInput | RecurringInvoiceWhereUniqueInput[]
    connect?: RecurringInvoiceWhereUniqueInput | RecurringInvoiceWhereUniqueInput[]
    update?: RecurringInvoiceUpdateWithWhereUniqueWithoutCustomerInput | RecurringInvoiceUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: RecurringInvoiceUpdateManyWithWhereWithoutCustomerInput | RecurringInvoiceUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: RecurringInvoiceScalarWhereInput | RecurringInvoiceScalarWhereInput[]
  }

  export type MissionUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<MissionCreateWithoutClientInput, MissionUncheckedCreateWithoutClientInput> | MissionCreateWithoutClientInput[] | MissionUncheckedCreateWithoutClientInput[]
    connectOrCreate?: MissionCreateOrConnectWithoutClientInput | MissionCreateOrConnectWithoutClientInput[]
    upsert?: MissionUpsertWithWhereUniqueWithoutClientInput | MissionUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: MissionCreateManyClientInputEnvelope
    set?: MissionWhereUniqueInput | MissionWhereUniqueInput[]
    disconnect?: MissionWhereUniqueInput | MissionWhereUniqueInput[]
    delete?: MissionWhereUniqueInput | MissionWhereUniqueInput[]
    connect?: MissionWhereUniqueInput | MissionWhereUniqueInput[]
    update?: MissionUpdateWithWhereUniqueWithoutClientInput | MissionUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: MissionUpdateManyWithWhereWithoutClientInput | MissionUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: MissionScalarWhereInput | MissionScalarWhereInput[]
  }

  export type CustomerCreateNestedOneWithoutAddressesInput = {
    create?: XOR<CustomerCreateWithoutAddressesInput, CustomerUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutAddressesInput
    connect?: CustomerWhereUniqueInput
  }

  export type QuoteCreateNestedManyWithoutCustomerAddressInput = {
    create?: XOR<QuoteCreateWithoutCustomerAddressInput, QuoteUncheckedCreateWithoutCustomerAddressInput> | QuoteCreateWithoutCustomerAddressInput[] | QuoteUncheckedCreateWithoutCustomerAddressInput[]
    connectOrCreate?: QuoteCreateOrConnectWithoutCustomerAddressInput | QuoteCreateOrConnectWithoutCustomerAddressInput[]
    createMany?: QuoteCreateManyCustomerAddressInputEnvelope
    connect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutCustomerAddressInput = {
    create?: XOR<InvoiceCreateWithoutCustomerAddressInput, InvoiceUncheckedCreateWithoutCustomerAddressInput> | InvoiceCreateWithoutCustomerAddressInput[] | InvoiceUncheckedCreateWithoutCustomerAddressInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCustomerAddressInput | InvoiceCreateOrConnectWithoutCustomerAddressInput[]
    createMany?: InvoiceCreateManyCustomerAddressInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type QuoteUncheckedCreateNestedManyWithoutCustomerAddressInput = {
    create?: XOR<QuoteCreateWithoutCustomerAddressInput, QuoteUncheckedCreateWithoutCustomerAddressInput> | QuoteCreateWithoutCustomerAddressInput[] | QuoteUncheckedCreateWithoutCustomerAddressInput[]
    connectOrCreate?: QuoteCreateOrConnectWithoutCustomerAddressInput | QuoteCreateOrConnectWithoutCustomerAddressInput[]
    createMany?: QuoteCreateManyCustomerAddressInputEnvelope
    connect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutCustomerAddressInput = {
    create?: XOR<InvoiceCreateWithoutCustomerAddressInput, InvoiceUncheckedCreateWithoutCustomerAddressInput> | InvoiceCreateWithoutCustomerAddressInput[] | InvoiceUncheckedCreateWithoutCustomerAddressInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCustomerAddressInput | InvoiceCreateOrConnectWithoutCustomerAddressInput[]
    createMany?: InvoiceCreateManyCustomerAddressInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type EnumAddressTypeFieldUpdateOperationsInput = {
    set?: $Enums.AddressType
  }

  export type CustomerUpdateOneRequiredWithoutAddressesNestedInput = {
    create?: XOR<CustomerCreateWithoutAddressesInput, CustomerUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutAddressesInput
    upsert?: CustomerUpsertWithoutAddressesInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutAddressesInput, CustomerUpdateWithoutAddressesInput>, CustomerUncheckedUpdateWithoutAddressesInput>
  }

  export type QuoteUpdateManyWithoutCustomerAddressNestedInput = {
    create?: XOR<QuoteCreateWithoutCustomerAddressInput, QuoteUncheckedCreateWithoutCustomerAddressInput> | QuoteCreateWithoutCustomerAddressInput[] | QuoteUncheckedCreateWithoutCustomerAddressInput[]
    connectOrCreate?: QuoteCreateOrConnectWithoutCustomerAddressInput | QuoteCreateOrConnectWithoutCustomerAddressInput[]
    upsert?: QuoteUpsertWithWhereUniqueWithoutCustomerAddressInput | QuoteUpsertWithWhereUniqueWithoutCustomerAddressInput[]
    createMany?: QuoteCreateManyCustomerAddressInputEnvelope
    set?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    disconnect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    delete?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    connect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    update?: QuoteUpdateWithWhereUniqueWithoutCustomerAddressInput | QuoteUpdateWithWhereUniqueWithoutCustomerAddressInput[]
    updateMany?: QuoteUpdateManyWithWhereWithoutCustomerAddressInput | QuoteUpdateManyWithWhereWithoutCustomerAddressInput[]
    deleteMany?: QuoteScalarWhereInput | QuoteScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutCustomerAddressNestedInput = {
    create?: XOR<InvoiceCreateWithoutCustomerAddressInput, InvoiceUncheckedCreateWithoutCustomerAddressInput> | InvoiceCreateWithoutCustomerAddressInput[] | InvoiceUncheckedCreateWithoutCustomerAddressInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCustomerAddressInput | InvoiceCreateOrConnectWithoutCustomerAddressInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutCustomerAddressInput | InvoiceUpsertWithWhereUniqueWithoutCustomerAddressInput[]
    createMany?: InvoiceCreateManyCustomerAddressInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutCustomerAddressInput | InvoiceUpdateWithWhereUniqueWithoutCustomerAddressInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutCustomerAddressInput | InvoiceUpdateManyWithWhereWithoutCustomerAddressInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type QuoteUncheckedUpdateManyWithoutCustomerAddressNestedInput = {
    create?: XOR<QuoteCreateWithoutCustomerAddressInput, QuoteUncheckedCreateWithoutCustomerAddressInput> | QuoteCreateWithoutCustomerAddressInput[] | QuoteUncheckedCreateWithoutCustomerAddressInput[]
    connectOrCreate?: QuoteCreateOrConnectWithoutCustomerAddressInput | QuoteCreateOrConnectWithoutCustomerAddressInput[]
    upsert?: QuoteUpsertWithWhereUniqueWithoutCustomerAddressInput | QuoteUpsertWithWhereUniqueWithoutCustomerAddressInput[]
    createMany?: QuoteCreateManyCustomerAddressInputEnvelope
    set?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    disconnect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    delete?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    connect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    update?: QuoteUpdateWithWhereUniqueWithoutCustomerAddressInput | QuoteUpdateWithWhereUniqueWithoutCustomerAddressInput[]
    updateMany?: QuoteUpdateManyWithWhereWithoutCustomerAddressInput | QuoteUpdateManyWithWhereWithoutCustomerAddressInput[]
    deleteMany?: QuoteScalarWhereInput | QuoteScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutCustomerAddressNestedInput = {
    create?: XOR<InvoiceCreateWithoutCustomerAddressInput, InvoiceUncheckedCreateWithoutCustomerAddressInput> | InvoiceCreateWithoutCustomerAddressInput[] | InvoiceUncheckedCreateWithoutCustomerAddressInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCustomerAddressInput | InvoiceCreateOrConnectWithoutCustomerAddressInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutCustomerAddressInput | InvoiceUpsertWithWhereUniqueWithoutCustomerAddressInput[]
    createMany?: InvoiceCreateManyCustomerAddressInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutCustomerAddressInput | InvoiceUpdateWithWhereUniqueWithoutCustomerAddressInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutCustomerAddressInput | InvoiceUpdateManyWithWhereWithoutCustomerAddressInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type ProductPriceCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductPriceCreateWithoutProductInput, ProductPriceUncheckedCreateWithoutProductInput> | ProductPriceCreateWithoutProductInput[] | ProductPriceUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductPriceCreateOrConnectWithoutProductInput | ProductPriceCreateOrConnectWithoutProductInput[]
    createMany?: ProductPriceCreateManyProductInputEnvelope
    connect?: ProductPriceWhereUniqueInput | ProductPriceWhereUniqueInput[]
  }

  export type QuoteItemCreateNestedManyWithoutProductInput = {
    create?: XOR<QuoteItemCreateWithoutProductInput, QuoteItemUncheckedCreateWithoutProductInput> | QuoteItemCreateWithoutProductInput[] | QuoteItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: QuoteItemCreateOrConnectWithoutProductInput | QuoteItemCreateOrConnectWithoutProductInput[]
    createMany?: QuoteItemCreateManyProductInputEnvelope
    connect?: QuoteItemWhereUniqueInput | QuoteItemWhereUniqueInput[]
  }

  export type InvoiceItemCreateNestedManyWithoutProductInput = {
    create?: XOR<InvoiceItemCreateWithoutProductInput, InvoiceItemUncheckedCreateWithoutProductInput> | InvoiceItemCreateWithoutProductInput[] | InvoiceItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutProductInput | InvoiceItemCreateOrConnectWithoutProductInput[]
    createMany?: InvoiceItemCreateManyProductInputEnvelope
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
  }

  export type RecurringInvoiceItemCreateNestedManyWithoutProductInput = {
    create?: XOR<RecurringInvoiceItemCreateWithoutProductInput, RecurringInvoiceItemUncheckedCreateWithoutProductInput> | RecurringInvoiceItemCreateWithoutProductInput[] | RecurringInvoiceItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: RecurringInvoiceItemCreateOrConnectWithoutProductInput | RecurringInvoiceItemCreateOrConnectWithoutProductInput[]
    createMany?: RecurringInvoiceItemCreateManyProductInputEnvelope
    connect?: RecurringInvoiceItemWhereUniqueInput | RecurringInvoiceItemWhereUniqueInput[]
  }

  export type ProductPriceUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductPriceCreateWithoutProductInput, ProductPriceUncheckedCreateWithoutProductInput> | ProductPriceCreateWithoutProductInput[] | ProductPriceUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductPriceCreateOrConnectWithoutProductInput | ProductPriceCreateOrConnectWithoutProductInput[]
    createMany?: ProductPriceCreateManyProductInputEnvelope
    connect?: ProductPriceWhereUniqueInput | ProductPriceWhereUniqueInput[]
  }

  export type QuoteItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<QuoteItemCreateWithoutProductInput, QuoteItemUncheckedCreateWithoutProductInput> | QuoteItemCreateWithoutProductInput[] | QuoteItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: QuoteItemCreateOrConnectWithoutProductInput | QuoteItemCreateOrConnectWithoutProductInput[]
    createMany?: QuoteItemCreateManyProductInputEnvelope
    connect?: QuoteItemWhereUniqueInput | QuoteItemWhereUniqueInput[]
  }

  export type InvoiceItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<InvoiceItemCreateWithoutProductInput, InvoiceItemUncheckedCreateWithoutProductInput> | InvoiceItemCreateWithoutProductInput[] | InvoiceItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutProductInput | InvoiceItemCreateOrConnectWithoutProductInput[]
    createMany?: InvoiceItemCreateManyProductInputEnvelope
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
  }

  export type RecurringInvoiceItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<RecurringInvoiceItemCreateWithoutProductInput, RecurringInvoiceItemUncheckedCreateWithoutProductInput> | RecurringInvoiceItemCreateWithoutProductInput[] | RecurringInvoiceItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: RecurringInvoiceItemCreateOrConnectWithoutProductInput | RecurringInvoiceItemCreateOrConnectWithoutProductInput[]
    createMany?: RecurringInvoiceItemCreateManyProductInputEnvelope
    connect?: RecurringInvoiceItemWhereUniqueInput | RecurringInvoiceItemWhereUniqueInput[]
  }

  export type EnumProductTypeFieldUpdateOperationsInput = {
    set?: $Enums.ProductType
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProductPriceUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductPriceCreateWithoutProductInput, ProductPriceUncheckedCreateWithoutProductInput> | ProductPriceCreateWithoutProductInput[] | ProductPriceUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductPriceCreateOrConnectWithoutProductInput | ProductPriceCreateOrConnectWithoutProductInput[]
    upsert?: ProductPriceUpsertWithWhereUniqueWithoutProductInput | ProductPriceUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductPriceCreateManyProductInputEnvelope
    set?: ProductPriceWhereUniqueInput | ProductPriceWhereUniqueInput[]
    disconnect?: ProductPriceWhereUniqueInput | ProductPriceWhereUniqueInput[]
    delete?: ProductPriceWhereUniqueInput | ProductPriceWhereUniqueInput[]
    connect?: ProductPriceWhereUniqueInput | ProductPriceWhereUniqueInput[]
    update?: ProductPriceUpdateWithWhereUniqueWithoutProductInput | ProductPriceUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductPriceUpdateManyWithWhereWithoutProductInput | ProductPriceUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductPriceScalarWhereInput | ProductPriceScalarWhereInput[]
  }

  export type QuoteItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<QuoteItemCreateWithoutProductInput, QuoteItemUncheckedCreateWithoutProductInput> | QuoteItemCreateWithoutProductInput[] | QuoteItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: QuoteItemCreateOrConnectWithoutProductInput | QuoteItemCreateOrConnectWithoutProductInput[]
    upsert?: QuoteItemUpsertWithWhereUniqueWithoutProductInput | QuoteItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: QuoteItemCreateManyProductInputEnvelope
    set?: QuoteItemWhereUniqueInput | QuoteItemWhereUniqueInput[]
    disconnect?: QuoteItemWhereUniqueInput | QuoteItemWhereUniqueInput[]
    delete?: QuoteItemWhereUniqueInput | QuoteItemWhereUniqueInput[]
    connect?: QuoteItemWhereUniqueInput | QuoteItemWhereUniqueInput[]
    update?: QuoteItemUpdateWithWhereUniqueWithoutProductInput | QuoteItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: QuoteItemUpdateManyWithWhereWithoutProductInput | QuoteItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: QuoteItemScalarWhereInput | QuoteItemScalarWhereInput[]
  }

  export type InvoiceItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<InvoiceItemCreateWithoutProductInput, InvoiceItemUncheckedCreateWithoutProductInput> | InvoiceItemCreateWithoutProductInput[] | InvoiceItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutProductInput | InvoiceItemCreateOrConnectWithoutProductInput[]
    upsert?: InvoiceItemUpsertWithWhereUniqueWithoutProductInput | InvoiceItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: InvoiceItemCreateManyProductInputEnvelope
    set?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    disconnect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    delete?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    update?: InvoiceItemUpdateWithWhereUniqueWithoutProductInput | InvoiceItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: InvoiceItemUpdateManyWithWhereWithoutProductInput | InvoiceItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
  }

  export type RecurringInvoiceItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<RecurringInvoiceItemCreateWithoutProductInput, RecurringInvoiceItemUncheckedCreateWithoutProductInput> | RecurringInvoiceItemCreateWithoutProductInput[] | RecurringInvoiceItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: RecurringInvoiceItemCreateOrConnectWithoutProductInput | RecurringInvoiceItemCreateOrConnectWithoutProductInput[]
    upsert?: RecurringInvoiceItemUpsertWithWhereUniqueWithoutProductInput | RecurringInvoiceItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: RecurringInvoiceItemCreateManyProductInputEnvelope
    set?: RecurringInvoiceItemWhereUniqueInput | RecurringInvoiceItemWhereUniqueInput[]
    disconnect?: RecurringInvoiceItemWhereUniqueInput | RecurringInvoiceItemWhereUniqueInput[]
    delete?: RecurringInvoiceItemWhereUniqueInput | RecurringInvoiceItemWhereUniqueInput[]
    connect?: RecurringInvoiceItemWhereUniqueInput | RecurringInvoiceItemWhereUniqueInput[]
    update?: RecurringInvoiceItemUpdateWithWhereUniqueWithoutProductInput | RecurringInvoiceItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: RecurringInvoiceItemUpdateManyWithWhereWithoutProductInput | RecurringInvoiceItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: RecurringInvoiceItemScalarWhereInput | RecurringInvoiceItemScalarWhereInput[]
  }

  export type ProductPriceUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductPriceCreateWithoutProductInput, ProductPriceUncheckedCreateWithoutProductInput> | ProductPriceCreateWithoutProductInput[] | ProductPriceUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductPriceCreateOrConnectWithoutProductInput | ProductPriceCreateOrConnectWithoutProductInput[]
    upsert?: ProductPriceUpsertWithWhereUniqueWithoutProductInput | ProductPriceUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductPriceCreateManyProductInputEnvelope
    set?: ProductPriceWhereUniqueInput | ProductPriceWhereUniqueInput[]
    disconnect?: ProductPriceWhereUniqueInput | ProductPriceWhereUniqueInput[]
    delete?: ProductPriceWhereUniqueInput | ProductPriceWhereUniqueInput[]
    connect?: ProductPriceWhereUniqueInput | ProductPriceWhereUniqueInput[]
    update?: ProductPriceUpdateWithWhereUniqueWithoutProductInput | ProductPriceUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductPriceUpdateManyWithWhereWithoutProductInput | ProductPriceUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductPriceScalarWhereInput | ProductPriceScalarWhereInput[]
  }

  export type QuoteItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<QuoteItemCreateWithoutProductInput, QuoteItemUncheckedCreateWithoutProductInput> | QuoteItemCreateWithoutProductInput[] | QuoteItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: QuoteItemCreateOrConnectWithoutProductInput | QuoteItemCreateOrConnectWithoutProductInput[]
    upsert?: QuoteItemUpsertWithWhereUniqueWithoutProductInput | QuoteItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: QuoteItemCreateManyProductInputEnvelope
    set?: QuoteItemWhereUniqueInput | QuoteItemWhereUniqueInput[]
    disconnect?: QuoteItemWhereUniqueInput | QuoteItemWhereUniqueInput[]
    delete?: QuoteItemWhereUniqueInput | QuoteItemWhereUniqueInput[]
    connect?: QuoteItemWhereUniqueInput | QuoteItemWhereUniqueInput[]
    update?: QuoteItemUpdateWithWhereUniqueWithoutProductInput | QuoteItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: QuoteItemUpdateManyWithWhereWithoutProductInput | QuoteItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: QuoteItemScalarWhereInput | QuoteItemScalarWhereInput[]
  }

  export type InvoiceItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<InvoiceItemCreateWithoutProductInput, InvoiceItemUncheckedCreateWithoutProductInput> | InvoiceItemCreateWithoutProductInput[] | InvoiceItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutProductInput | InvoiceItemCreateOrConnectWithoutProductInput[]
    upsert?: InvoiceItemUpsertWithWhereUniqueWithoutProductInput | InvoiceItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: InvoiceItemCreateManyProductInputEnvelope
    set?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    disconnect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    delete?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    update?: InvoiceItemUpdateWithWhereUniqueWithoutProductInput | InvoiceItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: InvoiceItemUpdateManyWithWhereWithoutProductInput | InvoiceItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
  }

  export type RecurringInvoiceItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<RecurringInvoiceItemCreateWithoutProductInput, RecurringInvoiceItemUncheckedCreateWithoutProductInput> | RecurringInvoiceItemCreateWithoutProductInput[] | RecurringInvoiceItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: RecurringInvoiceItemCreateOrConnectWithoutProductInput | RecurringInvoiceItemCreateOrConnectWithoutProductInput[]
    upsert?: RecurringInvoiceItemUpsertWithWhereUniqueWithoutProductInput | RecurringInvoiceItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: RecurringInvoiceItemCreateManyProductInputEnvelope
    set?: RecurringInvoiceItemWhereUniqueInput | RecurringInvoiceItemWhereUniqueInput[]
    disconnect?: RecurringInvoiceItemWhereUniqueInput | RecurringInvoiceItemWhereUniqueInput[]
    delete?: RecurringInvoiceItemWhereUniqueInput | RecurringInvoiceItemWhereUniqueInput[]
    connect?: RecurringInvoiceItemWhereUniqueInput | RecurringInvoiceItemWhereUniqueInput[]
    update?: RecurringInvoiceItemUpdateWithWhereUniqueWithoutProductInput | RecurringInvoiceItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: RecurringInvoiceItemUpdateManyWithWhereWithoutProductInput | RecurringInvoiceItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: RecurringInvoiceItemScalarWhereInput | RecurringInvoiceItemScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutPricesInput = {
    create?: XOR<ProductCreateWithoutPricesInput, ProductUncheckedCreateWithoutPricesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutPricesInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutPricesNestedInput = {
    create?: XOR<ProductCreateWithoutPricesInput, ProductUncheckedCreateWithoutPricesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutPricesInput
    upsert?: ProductUpsertWithoutPricesInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutPricesInput, ProductUpdateWithoutPricesInput>, ProductUncheckedUpdateWithoutPricesInput>
  }

  export type CustomerCreateNestedOneWithoutQuotesInput = {
    create?: XOR<CustomerCreateWithoutQuotesInput, CustomerUncheckedCreateWithoutQuotesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutQuotesInput
    connect?: CustomerWhereUniqueInput
  }

  export type CustomerAddressCreateNestedOneWithoutQuotesInput = {
    create?: XOR<CustomerAddressCreateWithoutQuotesInput, CustomerAddressUncheckedCreateWithoutQuotesInput>
    connectOrCreate?: CustomerAddressCreateOrConnectWithoutQuotesInput
    connect?: CustomerAddressWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedQuotesInput = {
    create?: XOR<UserCreateWithoutCreatedQuotesInput, UserUncheckedCreateWithoutCreatedQuotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedQuotesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutServiceApprovalsInput = {
    create?: XOR<UserCreateWithoutServiceApprovalsInput, UserUncheckedCreateWithoutServiceApprovalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutServiceApprovalsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDgApprovalsInput = {
    create?: XOR<UserCreateWithoutDgApprovalsInput, UserUncheckedCreateWithoutDgApprovalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDgApprovalsInput
    connect?: UserWhereUniqueInput
  }

  export type QuoteItemCreateNestedManyWithoutQuoteInput = {
    create?: XOR<QuoteItemCreateWithoutQuoteInput, QuoteItemUncheckedCreateWithoutQuoteInput> | QuoteItemCreateWithoutQuoteInput[] | QuoteItemUncheckedCreateWithoutQuoteInput[]
    connectOrCreate?: QuoteItemCreateOrConnectWithoutQuoteInput | QuoteItemCreateOrConnectWithoutQuoteInput[]
    createMany?: QuoteItemCreateManyQuoteInputEnvelope
    connect?: QuoteItemWhereUniqueInput | QuoteItemWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutQuoteInput = {
    create?: XOR<InvoiceCreateWithoutQuoteInput, InvoiceUncheckedCreateWithoutQuoteInput> | InvoiceCreateWithoutQuoteInput[] | InvoiceUncheckedCreateWithoutQuoteInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutQuoteInput | InvoiceCreateOrConnectWithoutQuoteInput[]
    createMany?: InvoiceCreateManyQuoteInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type QuoteApprovalCreateNestedManyWithoutQuoteInput = {
    create?: XOR<QuoteApprovalCreateWithoutQuoteInput, QuoteApprovalUncheckedCreateWithoutQuoteInput> | QuoteApprovalCreateWithoutQuoteInput[] | QuoteApprovalUncheckedCreateWithoutQuoteInput[]
    connectOrCreate?: QuoteApprovalCreateOrConnectWithoutQuoteInput | QuoteApprovalCreateOrConnectWithoutQuoteInput[]
    createMany?: QuoteApprovalCreateManyQuoteInputEnvelope
    connect?: QuoteApprovalWhereUniqueInput | QuoteApprovalWhereUniqueInput[]
  }

  export type MissionCreateNestedManyWithoutDevisInput = {
    create?: XOR<MissionCreateWithoutDevisInput, MissionUncheckedCreateWithoutDevisInput> | MissionCreateWithoutDevisInput[] | MissionUncheckedCreateWithoutDevisInput[]
    connectOrCreate?: MissionCreateOrConnectWithoutDevisInput | MissionCreateOrConnectWithoutDevisInput[]
    connect?: MissionWhereUniqueInput | MissionWhereUniqueInput[]
  }

  export type QuoteItemUncheckedCreateNestedManyWithoutQuoteInput = {
    create?: XOR<QuoteItemCreateWithoutQuoteInput, QuoteItemUncheckedCreateWithoutQuoteInput> | QuoteItemCreateWithoutQuoteInput[] | QuoteItemUncheckedCreateWithoutQuoteInput[]
    connectOrCreate?: QuoteItemCreateOrConnectWithoutQuoteInput | QuoteItemCreateOrConnectWithoutQuoteInput[]
    createMany?: QuoteItemCreateManyQuoteInputEnvelope
    connect?: QuoteItemWhereUniqueInput | QuoteItemWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutQuoteInput = {
    create?: XOR<InvoiceCreateWithoutQuoteInput, InvoiceUncheckedCreateWithoutQuoteInput> | InvoiceCreateWithoutQuoteInput[] | InvoiceUncheckedCreateWithoutQuoteInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutQuoteInput | InvoiceCreateOrConnectWithoutQuoteInput[]
    createMany?: InvoiceCreateManyQuoteInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type QuoteApprovalUncheckedCreateNestedManyWithoutQuoteInput = {
    create?: XOR<QuoteApprovalCreateWithoutQuoteInput, QuoteApprovalUncheckedCreateWithoutQuoteInput> | QuoteApprovalCreateWithoutQuoteInput[] | QuoteApprovalUncheckedCreateWithoutQuoteInput[]
    connectOrCreate?: QuoteApprovalCreateOrConnectWithoutQuoteInput | QuoteApprovalCreateOrConnectWithoutQuoteInput[]
    createMany?: QuoteApprovalCreateManyQuoteInputEnvelope
    connect?: QuoteApprovalWhereUniqueInput | QuoteApprovalWhereUniqueInput[]
  }

  export type MissionUncheckedCreateNestedManyWithoutDevisInput = {
    create?: XOR<MissionCreateWithoutDevisInput, MissionUncheckedCreateWithoutDevisInput> | MissionCreateWithoutDevisInput[] | MissionUncheckedCreateWithoutDevisInput[]
    connectOrCreate?: MissionCreateOrConnectWithoutDevisInput | MissionCreateOrConnectWithoutDevisInput[]
    connect?: MissionWhereUniqueInput | MissionWhereUniqueInput[]
  }

  export type EnumQuoteStatusFieldUpdateOperationsInput = {
    set?: $Enums.QuoteStatus
  }

  export type CustomerUpdateOneRequiredWithoutQuotesNestedInput = {
    create?: XOR<CustomerCreateWithoutQuotesInput, CustomerUncheckedCreateWithoutQuotesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutQuotesInput
    upsert?: CustomerUpsertWithoutQuotesInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutQuotesInput, CustomerUpdateWithoutQuotesInput>, CustomerUncheckedUpdateWithoutQuotesInput>
  }

  export type CustomerAddressUpdateOneWithoutQuotesNestedInput = {
    create?: XOR<CustomerAddressCreateWithoutQuotesInput, CustomerAddressUncheckedCreateWithoutQuotesInput>
    connectOrCreate?: CustomerAddressCreateOrConnectWithoutQuotesInput
    upsert?: CustomerAddressUpsertWithoutQuotesInput
    disconnect?: CustomerAddressWhereInput | boolean
    delete?: CustomerAddressWhereInput | boolean
    connect?: CustomerAddressWhereUniqueInput
    update?: XOR<XOR<CustomerAddressUpdateToOneWithWhereWithoutQuotesInput, CustomerAddressUpdateWithoutQuotesInput>, CustomerAddressUncheckedUpdateWithoutQuotesInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedQuotesNestedInput = {
    create?: XOR<UserCreateWithoutCreatedQuotesInput, UserUncheckedCreateWithoutCreatedQuotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedQuotesInput
    upsert?: UserUpsertWithoutCreatedQuotesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedQuotesInput, UserUpdateWithoutCreatedQuotesInput>, UserUncheckedUpdateWithoutCreatedQuotesInput>
  }

  export type UserUpdateOneWithoutServiceApprovalsNestedInput = {
    create?: XOR<UserCreateWithoutServiceApprovalsInput, UserUncheckedCreateWithoutServiceApprovalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutServiceApprovalsInput
    upsert?: UserUpsertWithoutServiceApprovalsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutServiceApprovalsInput, UserUpdateWithoutServiceApprovalsInput>, UserUncheckedUpdateWithoutServiceApprovalsInput>
  }

  export type UserUpdateOneWithoutDgApprovalsNestedInput = {
    create?: XOR<UserCreateWithoutDgApprovalsInput, UserUncheckedCreateWithoutDgApprovalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDgApprovalsInput
    upsert?: UserUpsertWithoutDgApprovalsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDgApprovalsInput, UserUpdateWithoutDgApprovalsInput>, UserUncheckedUpdateWithoutDgApprovalsInput>
  }

  export type QuoteItemUpdateManyWithoutQuoteNestedInput = {
    create?: XOR<QuoteItemCreateWithoutQuoteInput, QuoteItemUncheckedCreateWithoutQuoteInput> | QuoteItemCreateWithoutQuoteInput[] | QuoteItemUncheckedCreateWithoutQuoteInput[]
    connectOrCreate?: QuoteItemCreateOrConnectWithoutQuoteInput | QuoteItemCreateOrConnectWithoutQuoteInput[]
    upsert?: QuoteItemUpsertWithWhereUniqueWithoutQuoteInput | QuoteItemUpsertWithWhereUniqueWithoutQuoteInput[]
    createMany?: QuoteItemCreateManyQuoteInputEnvelope
    set?: QuoteItemWhereUniqueInput | QuoteItemWhereUniqueInput[]
    disconnect?: QuoteItemWhereUniqueInput | QuoteItemWhereUniqueInput[]
    delete?: QuoteItemWhereUniqueInput | QuoteItemWhereUniqueInput[]
    connect?: QuoteItemWhereUniqueInput | QuoteItemWhereUniqueInput[]
    update?: QuoteItemUpdateWithWhereUniqueWithoutQuoteInput | QuoteItemUpdateWithWhereUniqueWithoutQuoteInput[]
    updateMany?: QuoteItemUpdateManyWithWhereWithoutQuoteInput | QuoteItemUpdateManyWithWhereWithoutQuoteInput[]
    deleteMany?: QuoteItemScalarWhereInput | QuoteItemScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutQuoteNestedInput = {
    create?: XOR<InvoiceCreateWithoutQuoteInput, InvoiceUncheckedCreateWithoutQuoteInput> | InvoiceCreateWithoutQuoteInput[] | InvoiceUncheckedCreateWithoutQuoteInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutQuoteInput | InvoiceCreateOrConnectWithoutQuoteInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutQuoteInput | InvoiceUpsertWithWhereUniqueWithoutQuoteInput[]
    createMany?: InvoiceCreateManyQuoteInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutQuoteInput | InvoiceUpdateWithWhereUniqueWithoutQuoteInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutQuoteInput | InvoiceUpdateManyWithWhereWithoutQuoteInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type QuoteApprovalUpdateManyWithoutQuoteNestedInput = {
    create?: XOR<QuoteApprovalCreateWithoutQuoteInput, QuoteApprovalUncheckedCreateWithoutQuoteInput> | QuoteApprovalCreateWithoutQuoteInput[] | QuoteApprovalUncheckedCreateWithoutQuoteInput[]
    connectOrCreate?: QuoteApprovalCreateOrConnectWithoutQuoteInput | QuoteApprovalCreateOrConnectWithoutQuoteInput[]
    upsert?: QuoteApprovalUpsertWithWhereUniqueWithoutQuoteInput | QuoteApprovalUpsertWithWhereUniqueWithoutQuoteInput[]
    createMany?: QuoteApprovalCreateManyQuoteInputEnvelope
    set?: QuoteApprovalWhereUniqueInput | QuoteApprovalWhereUniqueInput[]
    disconnect?: QuoteApprovalWhereUniqueInput | QuoteApprovalWhereUniqueInput[]
    delete?: QuoteApprovalWhereUniqueInput | QuoteApprovalWhereUniqueInput[]
    connect?: QuoteApprovalWhereUniqueInput | QuoteApprovalWhereUniqueInput[]
    update?: QuoteApprovalUpdateWithWhereUniqueWithoutQuoteInput | QuoteApprovalUpdateWithWhereUniqueWithoutQuoteInput[]
    updateMany?: QuoteApprovalUpdateManyWithWhereWithoutQuoteInput | QuoteApprovalUpdateManyWithWhereWithoutQuoteInput[]
    deleteMany?: QuoteApprovalScalarWhereInput | QuoteApprovalScalarWhereInput[]
  }

  export type MissionUpdateManyWithoutDevisNestedInput = {
    create?: XOR<MissionCreateWithoutDevisInput, MissionUncheckedCreateWithoutDevisInput> | MissionCreateWithoutDevisInput[] | MissionUncheckedCreateWithoutDevisInput[]
    connectOrCreate?: MissionCreateOrConnectWithoutDevisInput | MissionCreateOrConnectWithoutDevisInput[]
    upsert?: MissionUpsertWithWhereUniqueWithoutDevisInput | MissionUpsertWithWhereUniqueWithoutDevisInput[]
    set?: MissionWhereUniqueInput | MissionWhereUniqueInput[]
    disconnect?: MissionWhereUniqueInput | MissionWhereUniqueInput[]
    delete?: MissionWhereUniqueInput | MissionWhereUniqueInput[]
    connect?: MissionWhereUniqueInput | MissionWhereUniqueInput[]
    update?: MissionUpdateWithWhereUniqueWithoutDevisInput | MissionUpdateWithWhereUniqueWithoutDevisInput[]
    updateMany?: MissionUpdateManyWithWhereWithoutDevisInput | MissionUpdateManyWithWhereWithoutDevisInput[]
    deleteMany?: MissionScalarWhereInput | MissionScalarWhereInput[]
  }

  export type QuoteItemUncheckedUpdateManyWithoutQuoteNestedInput = {
    create?: XOR<QuoteItemCreateWithoutQuoteInput, QuoteItemUncheckedCreateWithoutQuoteInput> | QuoteItemCreateWithoutQuoteInput[] | QuoteItemUncheckedCreateWithoutQuoteInput[]
    connectOrCreate?: QuoteItemCreateOrConnectWithoutQuoteInput | QuoteItemCreateOrConnectWithoutQuoteInput[]
    upsert?: QuoteItemUpsertWithWhereUniqueWithoutQuoteInput | QuoteItemUpsertWithWhereUniqueWithoutQuoteInput[]
    createMany?: QuoteItemCreateManyQuoteInputEnvelope
    set?: QuoteItemWhereUniqueInput | QuoteItemWhereUniqueInput[]
    disconnect?: QuoteItemWhereUniqueInput | QuoteItemWhereUniqueInput[]
    delete?: QuoteItemWhereUniqueInput | QuoteItemWhereUniqueInput[]
    connect?: QuoteItemWhereUniqueInput | QuoteItemWhereUniqueInput[]
    update?: QuoteItemUpdateWithWhereUniqueWithoutQuoteInput | QuoteItemUpdateWithWhereUniqueWithoutQuoteInput[]
    updateMany?: QuoteItemUpdateManyWithWhereWithoutQuoteInput | QuoteItemUpdateManyWithWhereWithoutQuoteInput[]
    deleteMany?: QuoteItemScalarWhereInput | QuoteItemScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutQuoteNestedInput = {
    create?: XOR<InvoiceCreateWithoutQuoteInput, InvoiceUncheckedCreateWithoutQuoteInput> | InvoiceCreateWithoutQuoteInput[] | InvoiceUncheckedCreateWithoutQuoteInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutQuoteInput | InvoiceCreateOrConnectWithoutQuoteInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutQuoteInput | InvoiceUpsertWithWhereUniqueWithoutQuoteInput[]
    createMany?: InvoiceCreateManyQuoteInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutQuoteInput | InvoiceUpdateWithWhereUniqueWithoutQuoteInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutQuoteInput | InvoiceUpdateManyWithWhereWithoutQuoteInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type QuoteApprovalUncheckedUpdateManyWithoutQuoteNestedInput = {
    create?: XOR<QuoteApprovalCreateWithoutQuoteInput, QuoteApprovalUncheckedCreateWithoutQuoteInput> | QuoteApprovalCreateWithoutQuoteInput[] | QuoteApprovalUncheckedCreateWithoutQuoteInput[]
    connectOrCreate?: QuoteApprovalCreateOrConnectWithoutQuoteInput | QuoteApprovalCreateOrConnectWithoutQuoteInput[]
    upsert?: QuoteApprovalUpsertWithWhereUniqueWithoutQuoteInput | QuoteApprovalUpsertWithWhereUniqueWithoutQuoteInput[]
    createMany?: QuoteApprovalCreateManyQuoteInputEnvelope
    set?: QuoteApprovalWhereUniqueInput | QuoteApprovalWhereUniqueInput[]
    disconnect?: QuoteApprovalWhereUniqueInput | QuoteApprovalWhereUniqueInput[]
    delete?: QuoteApprovalWhereUniqueInput | QuoteApprovalWhereUniqueInput[]
    connect?: QuoteApprovalWhereUniqueInput | QuoteApprovalWhereUniqueInput[]
    update?: QuoteApprovalUpdateWithWhereUniqueWithoutQuoteInput | QuoteApprovalUpdateWithWhereUniqueWithoutQuoteInput[]
    updateMany?: QuoteApprovalUpdateManyWithWhereWithoutQuoteInput | QuoteApprovalUpdateManyWithWhereWithoutQuoteInput[]
    deleteMany?: QuoteApprovalScalarWhereInput | QuoteApprovalScalarWhereInput[]
  }

  export type MissionUncheckedUpdateManyWithoutDevisNestedInput = {
    create?: XOR<MissionCreateWithoutDevisInput, MissionUncheckedCreateWithoutDevisInput> | MissionCreateWithoutDevisInput[] | MissionUncheckedCreateWithoutDevisInput[]
    connectOrCreate?: MissionCreateOrConnectWithoutDevisInput | MissionCreateOrConnectWithoutDevisInput[]
    upsert?: MissionUpsertWithWhereUniqueWithoutDevisInput | MissionUpsertWithWhereUniqueWithoutDevisInput[]
    set?: MissionWhereUniqueInput | MissionWhereUniqueInput[]
    disconnect?: MissionWhereUniqueInput | MissionWhereUniqueInput[]
    delete?: MissionWhereUniqueInput | MissionWhereUniqueInput[]
    connect?: MissionWhereUniqueInput | MissionWhereUniqueInput[]
    update?: MissionUpdateWithWhereUniqueWithoutDevisInput | MissionUpdateWithWhereUniqueWithoutDevisInput[]
    updateMany?: MissionUpdateManyWithWhereWithoutDevisInput | MissionUpdateManyWithWhereWithoutDevisInput[]
    deleteMany?: MissionScalarWhereInput | MissionScalarWhereInput[]
  }

  export type QuoteCreateNestedOneWithoutItemsInput = {
    create?: XOR<QuoteCreateWithoutItemsInput, QuoteUncheckedCreateWithoutItemsInput>
    connectOrCreate?: QuoteCreateOrConnectWithoutItemsInput
    connect?: QuoteWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutQuoteItemsInput = {
    create?: XOR<ProductCreateWithoutQuoteItemsInput, ProductUncheckedCreateWithoutQuoteItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutQuoteItemsInput
    connect?: ProductWhereUniqueInput
  }

  export type QuoteUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<QuoteCreateWithoutItemsInput, QuoteUncheckedCreateWithoutItemsInput>
    connectOrCreate?: QuoteCreateOrConnectWithoutItemsInput
    upsert?: QuoteUpsertWithoutItemsInput
    connect?: QuoteWhereUniqueInput
    update?: XOR<XOR<QuoteUpdateToOneWithWhereWithoutItemsInput, QuoteUpdateWithoutItemsInput>, QuoteUncheckedUpdateWithoutItemsInput>
  }

  export type ProductUpdateOneWithoutQuoteItemsNestedInput = {
    create?: XOR<ProductCreateWithoutQuoteItemsInput, ProductUncheckedCreateWithoutQuoteItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutQuoteItemsInput
    upsert?: ProductUpsertWithoutQuoteItemsInput
    disconnect?: ProductWhereInput | boolean
    delete?: ProductWhereInput | boolean
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutQuoteItemsInput, ProductUpdateWithoutQuoteItemsInput>, ProductUncheckedUpdateWithoutQuoteItemsInput>
  }

  export type QuoteCreateNestedOneWithoutApprovalsInput = {
    create?: XOR<QuoteCreateWithoutApprovalsInput, QuoteUncheckedCreateWithoutApprovalsInput>
    connectOrCreate?: QuoteCreateOrConnectWithoutApprovalsInput
    connect?: QuoteWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutQuoteApprovalsInput = {
    create?: XOR<UserCreateWithoutQuoteApprovalsInput, UserUncheckedCreateWithoutQuoteApprovalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutQuoteApprovalsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumApprovalLevelFieldUpdateOperationsInput = {
    set?: $Enums.ApprovalLevel
  }

  export type EnumApprovalStatusFieldUpdateOperationsInput = {
    set?: $Enums.ApprovalStatus
  }

  export type QuoteUpdateOneRequiredWithoutApprovalsNestedInput = {
    create?: XOR<QuoteCreateWithoutApprovalsInput, QuoteUncheckedCreateWithoutApprovalsInput>
    connectOrCreate?: QuoteCreateOrConnectWithoutApprovalsInput
    upsert?: QuoteUpsertWithoutApprovalsInput
    connect?: QuoteWhereUniqueInput
    update?: XOR<XOR<QuoteUpdateToOneWithWhereWithoutApprovalsInput, QuoteUpdateWithoutApprovalsInput>, QuoteUncheckedUpdateWithoutApprovalsInput>
  }

  export type UserUpdateOneRequiredWithoutQuoteApprovalsNestedInput = {
    create?: XOR<UserCreateWithoutQuoteApprovalsInput, UserUncheckedCreateWithoutQuoteApprovalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutQuoteApprovalsInput
    upsert?: UserUpsertWithoutQuoteApprovalsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutQuoteApprovalsInput, UserUpdateWithoutQuoteApprovalsInput>, UserUncheckedUpdateWithoutQuoteApprovalsInput>
  }

  export type CustomerCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<CustomerCreateWithoutInvoicesInput, CustomerUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutInvoicesInput
    connect?: CustomerWhereUniqueInput
  }

  export type CustomerAddressCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<CustomerAddressCreateWithoutInvoicesInput, CustomerAddressUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: CustomerAddressCreateOrConnectWithoutInvoicesInput
    connect?: CustomerAddressWhereUniqueInput
  }

  export type QuoteCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<QuoteCreateWithoutInvoicesInput, QuoteUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: QuoteCreateOrConnectWithoutInvoicesInput
    connect?: QuoteWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedInvoicesInput = {
    create?: XOR<UserCreateWithoutCreatedInvoicesInput, UserUncheckedCreateWithoutCreatedInvoicesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedInvoicesInput
    connect?: UserWhereUniqueInput
  }

  export type InvoiceItemCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput> | InvoiceItemCreateWithoutInvoiceInput[] | InvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutInvoiceInput | InvoiceItemCreateOrConnectWithoutInvoiceInput[]
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
  }

  export type PaymentAllocationCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<PaymentAllocationCreateWithoutInvoiceInput, PaymentAllocationUncheckedCreateWithoutInvoiceInput> | PaymentAllocationCreateWithoutInvoiceInput[] | PaymentAllocationUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentAllocationCreateOrConnectWithoutInvoiceInput | PaymentAllocationCreateOrConnectWithoutInvoiceInput[]
    createMany?: PaymentAllocationCreateManyInvoiceInputEnvelope
    connect?: PaymentAllocationWhereUniqueInput | PaymentAllocationWhereUniqueInput[]
  }

  export type ReminderCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<ReminderCreateWithoutInvoiceInput, ReminderUncheckedCreateWithoutInvoiceInput> | ReminderCreateWithoutInvoiceInput[] | ReminderUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: ReminderCreateOrConnectWithoutInvoiceInput | ReminderCreateOrConnectWithoutInvoiceInput[]
    createMany?: ReminderCreateManyInvoiceInputEnvelope
    connect?: ReminderWhereUniqueInput | ReminderWhereUniqueInput[]
  }

  export type InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput> | InvoiceItemCreateWithoutInvoiceInput[] | InvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutInvoiceInput | InvoiceItemCreateOrConnectWithoutInvoiceInput[]
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
  }

  export type PaymentAllocationUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<PaymentAllocationCreateWithoutInvoiceInput, PaymentAllocationUncheckedCreateWithoutInvoiceInput> | PaymentAllocationCreateWithoutInvoiceInput[] | PaymentAllocationUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentAllocationCreateOrConnectWithoutInvoiceInput | PaymentAllocationCreateOrConnectWithoutInvoiceInput[]
    createMany?: PaymentAllocationCreateManyInvoiceInputEnvelope
    connect?: PaymentAllocationWhereUniqueInput | PaymentAllocationWhereUniqueInput[]
  }

  export type ReminderUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<ReminderCreateWithoutInvoiceInput, ReminderUncheckedCreateWithoutInvoiceInput> | ReminderCreateWithoutInvoiceInput[] | ReminderUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: ReminderCreateOrConnectWithoutInvoiceInput | ReminderCreateOrConnectWithoutInvoiceInput[]
    createMany?: ReminderCreateManyInvoiceInputEnvelope
    connect?: ReminderWhereUniqueInput | ReminderWhereUniqueInput[]
  }

  export type EnumInvoiceTypeFieldUpdateOperationsInput = {
    set?: $Enums.InvoiceType
  }

  export type EnumInvoiceStatusFieldUpdateOperationsInput = {
    set?: $Enums.InvoiceStatus
  }

  export type CustomerUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<CustomerCreateWithoutInvoicesInput, CustomerUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutInvoicesInput
    upsert?: CustomerUpsertWithoutInvoicesInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutInvoicesInput, CustomerUpdateWithoutInvoicesInput>, CustomerUncheckedUpdateWithoutInvoicesInput>
  }

  export type CustomerAddressUpdateOneWithoutInvoicesNestedInput = {
    create?: XOR<CustomerAddressCreateWithoutInvoicesInput, CustomerAddressUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: CustomerAddressCreateOrConnectWithoutInvoicesInput
    upsert?: CustomerAddressUpsertWithoutInvoicesInput
    disconnect?: CustomerAddressWhereInput | boolean
    delete?: CustomerAddressWhereInput | boolean
    connect?: CustomerAddressWhereUniqueInput
    update?: XOR<XOR<CustomerAddressUpdateToOneWithWhereWithoutInvoicesInput, CustomerAddressUpdateWithoutInvoicesInput>, CustomerAddressUncheckedUpdateWithoutInvoicesInput>
  }

  export type QuoteUpdateOneWithoutInvoicesNestedInput = {
    create?: XOR<QuoteCreateWithoutInvoicesInput, QuoteUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: QuoteCreateOrConnectWithoutInvoicesInput
    upsert?: QuoteUpsertWithoutInvoicesInput
    disconnect?: QuoteWhereInput | boolean
    delete?: QuoteWhereInput | boolean
    connect?: QuoteWhereUniqueInput
    update?: XOR<XOR<QuoteUpdateToOneWithWhereWithoutInvoicesInput, QuoteUpdateWithoutInvoicesInput>, QuoteUncheckedUpdateWithoutInvoicesInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedInvoicesNestedInput = {
    create?: XOR<UserCreateWithoutCreatedInvoicesInput, UserUncheckedCreateWithoutCreatedInvoicesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedInvoicesInput
    upsert?: UserUpsertWithoutCreatedInvoicesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedInvoicesInput, UserUpdateWithoutCreatedInvoicesInput>, UserUncheckedUpdateWithoutCreatedInvoicesInput>
  }

  export type InvoiceItemUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput> | InvoiceItemCreateWithoutInvoiceInput[] | InvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutInvoiceInput | InvoiceItemCreateOrConnectWithoutInvoiceInput[]
    upsert?: InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput | InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    set?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    disconnect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    delete?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    update?: InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput | InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: InvoiceItemUpdateManyWithWhereWithoutInvoiceInput | InvoiceItemUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
  }

  export type PaymentAllocationUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<PaymentAllocationCreateWithoutInvoiceInput, PaymentAllocationUncheckedCreateWithoutInvoiceInput> | PaymentAllocationCreateWithoutInvoiceInput[] | PaymentAllocationUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentAllocationCreateOrConnectWithoutInvoiceInput | PaymentAllocationCreateOrConnectWithoutInvoiceInput[]
    upsert?: PaymentAllocationUpsertWithWhereUniqueWithoutInvoiceInput | PaymentAllocationUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: PaymentAllocationCreateManyInvoiceInputEnvelope
    set?: PaymentAllocationWhereUniqueInput | PaymentAllocationWhereUniqueInput[]
    disconnect?: PaymentAllocationWhereUniqueInput | PaymentAllocationWhereUniqueInput[]
    delete?: PaymentAllocationWhereUniqueInput | PaymentAllocationWhereUniqueInput[]
    connect?: PaymentAllocationWhereUniqueInput | PaymentAllocationWhereUniqueInput[]
    update?: PaymentAllocationUpdateWithWhereUniqueWithoutInvoiceInput | PaymentAllocationUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: PaymentAllocationUpdateManyWithWhereWithoutInvoiceInput | PaymentAllocationUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: PaymentAllocationScalarWhereInput | PaymentAllocationScalarWhereInput[]
  }

  export type ReminderUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<ReminderCreateWithoutInvoiceInput, ReminderUncheckedCreateWithoutInvoiceInput> | ReminderCreateWithoutInvoiceInput[] | ReminderUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: ReminderCreateOrConnectWithoutInvoiceInput | ReminderCreateOrConnectWithoutInvoiceInput[]
    upsert?: ReminderUpsertWithWhereUniqueWithoutInvoiceInput | ReminderUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: ReminderCreateManyInvoiceInputEnvelope
    set?: ReminderWhereUniqueInput | ReminderWhereUniqueInput[]
    disconnect?: ReminderWhereUniqueInput | ReminderWhereUniqueInput[]
    delete?: ReminderWhereUniqueInput | ReminderWhereUniqueInput[]
    connect?: ReminderWhereUniqueInput | ReminderWhereUniqueInput[]
    update?: ReminderUpdateWithWhereUniqueWithoutInvoiceInput | ReminderUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: ReminderUpdateManyWithWhereWithoutInvoiceInput | ReminderUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: ReminderScalarWhereInput | ReminderScalarWhereInput[]
  }

  export type InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput> | InvoiceItemCreateWithoutInvoiceInput[] | InvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutInvoiceInput | InvoiceItemCreateOrConnectWithoutInvoiceInput[]
    upsert?: InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput | InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    set?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    disconnect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    delete?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    update?: InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput | InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: InvoiceItemUpdateManyWithWhereWithoutInvoiceInput | InvoiceItemUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
  }

  export type PaymentAllocationUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<PaymentAllocationCreateWithoutInvoiceInput, PaymentAllocationUncheckedCreateWithoutInvoiceInput> | PaymentAllocationCreateWithoutInvoiceInput[] | PaymentAllocationUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentAllocationCreateOrConnectWithoutInvoiceInput | PaymentAllocationCreateOrConnectWithoutInvoiceInput[]
    upsert?: PaymentAllocationUpsertWithWhereUniqueWithoutInvoiceInput | PaymentAllocationUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: PaymentAllocationCreateManyInvoiceInputEnvelope
    set?: PaymentAllocationWhereUniqueInput | PaymentAllocationWhereUniqueInput[]
    disconnect?: PaymentAllocationWhereUniqueInput | PaymentAllocationWhereUniqueInput[]
    delete?: PaymentAllocationWhereUniqueInput | PaymentAllocationWhereUniqueInput[]
    connect?: PaymentAllocationWhereUniqueInput | PaymentAllocationWhereUniqueInput[]
    update?: PaymentAllocationUpdateWithWhereUniqueWithoutInvoiceInput | PaymentAllocationUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: PaymentAllocationUpdateManyWithWhereWithoutInvoiceInput | PaymentAllocationUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: PaymentAllocationScalarWhereInput | PaymentAllocationScalarWhereInput[]
  }

  export type ReminderUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<ReminderCreateWithoutInvoiceInput, ReminderUncheckedCreateWithoutInvoiceInput> | ReminderCreateWithoutInvoiceInput[] | ReminderUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: ReminderCreateOrConnectWithoutInvoiceInput | ReminderCreateOrConnectWithoutInvoiceInput[]
    upsert?: ReminderUpsertWithWhereUniqueWithoutInvoiceInput | ReminderUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: ReminderCreateManyInvoiceInputEnvelope
    set?: ReminderWhereUniqueInput | ReminderWhereUniqueInput[]
    disconnect?: ReminderWhereUniqueInput | ReminderWhereUniqueInput[]
    delete?: ReminderWhereUniqueInput | ReminderWhereUniqueInput[]
    connect?: ReminderWhereUniqueInput | ReminderWhereUniqueInput[]
    update?: ReminderUpdateWithWhereUniqueWithoutInvoiceInput | ReminderUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: ReminderUpdateManyWithWhereWithoutInvoiceInput | ReminderUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: ReminderScalarWhereInput | ReminderScalarWhereInput[]
  }

  export type InvoiceCreateNestedOneWithoutItemsInput = {
    create?: XOR<InvoiceCreateWithoutItemsInput, InvoiceUncheckedCreateWithoutItemsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutItemsInput
    connect?: InvoiceWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutInvoiceItemsInput = {
    create?: XOR<ProductCreateWithoutInvoiceItemsInput, ProductUncheckedCreateWithoutInvoiceItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutInvoiceItemsInput
    connect?: ProductWhereUniqueInput
  }

  export type InvoiceUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<InvoiceCreateWithoutItemsInput, InvoiceUncheckedCreateWithoutItemsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutItemsInput
    upsert?: InvoiceUpsertWithoutItemsInput
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutItemsInput, InvoiceUpdateWithoutItemsInput>, InvoiceUncheckedUpdateWithoutItemsInput>
  }

  export type ProductUpdateOneWithoutInvoiceItemsNestedInput = {
    create?: XOR<ProductCreateWithoutInvoiceItemsInput, ProductUncheckedCreateWithoutInvoiceItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutInvoiceItemsInput
    upsert?: ProductUpsertWithoutInvoiceItemsInput
    disconnect?: ProductWhereInput | boolean
    delete?: ProductWhereInput | boolean
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutInvoiceItemsInput, ProductUpdateWithoutInvoiceItemsInput>, ProductUncheckedUpdateWithoutInvoiceItemsInput>
  }

  export type CustomerCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<CustomerCreateWithoutPaymentsInput, CustomerUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutPaymentsInput
    connect?: CustomerWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedPaymentsInput = {
    create?: XOR<UserCreateWithoutCreatedPaymentsInput, UserUncheckedCreateWithoutCreatedPaymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedPaymentsInput
    connect?: UserWhereUniqueInput
  }

  export type PaymentAllocationCreateNestedManyWithoutPaymentInput = {
    create?: XOR<PaymentAllocationCreateWithoutPaymentInput, PaymentAllocationUncheckedCreateWithoutPaymentInput> | PaymentAllocationCreateWithoutPaymentInput[] | PaymentAllocationUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: PaymentAllocationCreateOrConnectWithoutPaymentInput | PaymentAllocationCreateOrConnectWithoutPaymentInput[]
    createMany?: PaymentAllocationCreateManyPaymentInputEnvelope
    connect?: PaymentAllocationWhereUniqueInput | PaymentAllocationWhereUniqueInput[]
  }

  export type PaymentAllocationUncheckedCreateNestedManyWithoutPaymentInput = {
    create?: XOR<PaymentAllocationCreateWithoutPaymentInput, PaymentAllocationUncheckedCreateWithoutPaymentInput> | PaymentAllocationCreateWithoutPaymentInput[] | PaymentAllocationUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: PaymentAllocationCreateOrConnectWithoutPaymentInput | PaymentAllocationCreateOrConnectWithoutPaymentInput[]
    createMany?: PaymentAllocationCreateManyPaymentInputEnvelope
    connect?: PaymentAllocationWhereUniqueInput | PaymentAllocationWhereUniqueInput[]
  }

  export type CustomerUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<CustomerCreateWithoutPaymentsInput, CustomerUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutPaymentsInput
    upsert?: CustomerUpsertWithoutPaymentsInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutPaymentsInput, CustomerUpdateWithoutPaymentsInput>, CustomerUncheckedUpdateWithoutPaymentsInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedPaymentsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedPaymentsInput, UserUncheckedCreateWithoutCreatedPaymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedPaymentsInput
    upsert?: UserUpsertWithoutCreatedPaymentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedPaymentsInput, UserUpdateWithoutCreatedPaymentsInput>, UserUncheckedUpdateWithoutCreatedPaymentsInput>
  }

  export type PaymentAllocationUpdateManyWithoutPaymentNestedInput = {
    create?: XOR<PaymentAllocationCreateWithoutPaymentInput, PaymentAllocationUncheckedCreateWithoutPaymentInput> | PaymentAllocationCreateWithoutPaymentInput[] | PaymentAllocationUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: PaymentAllocationCreateOrConnectWithoutPaymentInput | PaymentAllocationCreateOrConnectWithoutPaymentInput[]
    upsert?: PaymentAllocationUpsertWithWhereUniqueWithoutPaymentInput | PaymentAllocationUpsertWithWhereUniqueWithoutPaymentInput[]
    createMany?: PaymentAllocationCreateManyPaymentInputEnvelope
    set?: PaymentAllocationWhereUniqueInput | PaymentAllocationWhereUniqueInput[]
    disconnect?: PaymentAllocationWhereUniqueInput | PaymentAllocationWhereUniqueInput[]
    delete?: PaymentAllocationWhereUniqueInput | PaymentAllocationWhereUniqueInput[]
    connect?: PaymentAllocationWhereUniqueInput | PaymentAllocationWhereUniqueInput[]
    update?: PaymentAllocationUpdateWithWhereUniqueWithoutPaymentInput | PaymentAllocationUpdateWithWhereUniqueWithoutPaymentInput[]
    updateMany?: PaymentAllocationUpdateManyWithWhereWithoutPaymentInput | PaymentAllocationUpdateManyWithWhereWithoutPaymentInput[]
    deleteMany?: PaymentAllocationScalarWhereInput | PaymentAllocationScalarWhereInput[]
  }

  export type PaymentAllocationUncheckedUpdateManyWithoutPaymentNestedInput = {
    create?: XOR<PaymentAllocationCreateWithoutPaymentInput, PaymentAllocationUncheckedCreateWithoutPaymentInput> | PaymentAllocationCreateWithoutPaymentInput[] | PaymentAllocationUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: PaymentAllocationCreateOrConnectWithoutPaymentInput | PaymentAllocationCreateOrConnectWithoutPaymentInput[]
    upsert?: PaymentAllocationUpsertWithWhereUniqueWithoutPaymentInput | PaymentAllocationUpsertWithWhereUniqueWithoutPaymentInput[]
    createMany?: PaymentAllocationCreateManyPaymentInputEnvelope
    set?: PaymentAllocationWhereUniqueInput | PaymentAllocationWhereUniqueInput[]
    disconnect?: PaymentAllocationWhereUniqueInput | PaymentAllocationWhereUniqueInput[]
    delete?: PaymentAllocationWhereUniqueInput | PaymentAllocationWhereUniqueInput[]
    connect?: PaymentAllocationWhereUniqueInput | PaymentAllocationWhereUniqueInput[]
    update?: PaymentAllocationUpdateWithWhereUniqueWithoutPaymentInput | PaymentAllocationUpdateWithWhereUniqueWithoutPaymentInput[]
    updateMany?: PaymentAllocationUpdateManyWithWhereWithoutPaymentInput | PaymentAllocationUpdateManyWithWhereWithoutPaymentInput[]
    deleteMany?: PaymentAllocationScalarWhereInput | PaymentAllocationScalarWhereInput[]
  }

  export type PaymentCreateNestedOneWithoutAllocationsInput = {
    create?: XOR<PaymentCreateWithoutAllocationsInput, PaymentUncheckedCreateWithoutAllocationsInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutAllocationsInput
    connect?: PaymentWhereUniqueInput
  }

  export type InvoiceCreateNestedOneWithoutPaymentAllocationsInput = {
    create?: XOR<InvoiceCreateWithoutPaymentAllocationsInput, InvoiceUncheckedCreateWithoutPaymentAllocationsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutPaymentAllocationsInput
    connect?: InvoiceWhereUniqueInput
  }

  export type PaymentUpdateOneRequiredWithoutAllocationsNestedInput = {
    create?: XOR<PaymentCreateWithoutAllocationsInput, PaymentUncheckedCreateWithoutAllocationsInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutAllocationsInput
    upsert?: PaymentUpsertWithoutAllocationsInput
    connect?: PaymentWhereUniqueInput
    update?: XOR<XOR<PaymentUpdateToOneWithWhereWithoutAllocationsInput, PaymentUpdateWithoutAllocationsInput>, PaymentUncheckedUpdateWithoutAllocationsInput>
  }

  export type InvoiceUpdateOneRequiredWithoutPaymentAllocationsNestedInput = {
    create?: XOR<InvoiceCreateWithoutPaymentAllocationsInput, InvoiceUncheckedCreateWithoutPaymentAllocationsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutPaymentAllocationsInput
    upsert?: InvoiceUpsertWithoutPaymentAllocationsInput
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutPaymentAllocationsInput, InvoiceUpdateWithoutPaymentAllocationsInput>, InvoiceUncheckedUpdateWithoutPaymentAllocationsInput>
  }

  export type CustomerCreateNestedOneWithoutRecurringInvoicesInput = {
    create?: XOR<CustomerCreateWithoutRecurringInvoicesInput, CustomerUncheckedCreateWithoutRecurringInvoicesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutRecurringInvoicesInput
    connect?: CustomerWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedRecurringInvoicesInput = {
    create?: XOR<UserCreateWithoutCreatedRecurringInvoicesInput, UserUncheckedCreateWithoutCreatedRecurringInvoicesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedRecurringInvoicesInput
    connect?: UserWhereUniqueInput
  }

  export type RecurringInvoiceItemCreateNestedManyWithoutRecurringInvoiceInput = {
    create?: XOR<RecurringInvoiceItemCreateWithoutRecurringInvoiceInput, RecurringInvoiceItemUncheckedCreateWithoutRecurringInvoiceInput> | RecurringInvoiceItemCreateWithoutRecurringInvoiceInput[] | RecurringInvoiceItemUncheckedCreateWithoutRecurringInvoiceInput[]
    connectOrCreate?: RecurringInvoiceItemCreateOrConnectWithoutRecurringInvoiceInput | RecurringInvoiceItemCreateOrConnectWithoutRecurringInvoiceInput[]
    createMany?: RecurringInvoiceItemCreateManyRecurringInvoiceInputEnvelope
    connect?: RecurringInvoiceItemWhereUniqueInput | RecurringInvoiceItemWhereUniqueInput[]
  }

  export type RecurringInvoiceItemUncheckedCreateNestedManyWithoutRecurringInvoiceInput = {
    create?: XOR<RecurringInvoiceItemCreateWithoutRecurringInvoiceInput, RecurringInvoiceItemUncheckedCreateWithoutRecurringInvoiceInput> | RecurringInvoiceItemCreateWithoutRecurringInvoiceInput[] | RecurringInvoiceItemUncheckedCreateWithoutRecurringInvoiceInput[]
    connectOrCreate?: RecurringInvoiceItemCreateOrConnectWithoutRecurringInvoiceInput | RecurringInvoiceItemCreateOrConnectWithoutRecurringInvoiceInput[]
    createMany?: RecurringInvoiceItemCreateManyRecurringInvoiceInputEnvelope
    connect?: RecurringInvoiceItemWhereUniqueInput | RecurringInvoiceItemWhereUniqueInput[]
  }

  export type EnumRecurringFrequencyFieldUpdateOperationsInput = {
    set?: $Enums.RecurringFrequency
  }

  export type CustomerUpdateOneRequiredWithoutRecurringInvoicesNestedInput = {
    create?: XOR<CustomerCreateWithoutRecurringInvoicesInput, CustomerUncheckedCreateWithoutRecurringInvoicesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutRecurringInvoicesInput
    upsert?: CustomerUpsertWithoutRecurringInvoicesInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutRecurringInvoicesInput, CustomerUpdateWithoutRecurringInvoicesInput>, CustomerUncheckedUpdateWithoutRecurringInvoicesInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedRecurringInvoicesNestedInput = {
    create?: XOR<UserCreateWithoutCreatedRecurringInvoicesInput, UserUncheckedCreateWithoutCreatedRecurringInvoicesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedRecurringInvoicesInput
    upsert?: UserUpsertWithoutCreatedRecurringInvoicesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedRecurringInvoicesInput, UserUpdateWithoutCreatedRecurringInvoicesInput>, UserUncheckedUpdateWithoutCreatedRecurringInvoicesInput>
  }

  export type RecurringInvoiceItemUpdateManyWithoutRecurringInvoiceNestedInput = {
    create?: XOR<RecurringInvoiceItemCreateWithoutRecurringInvoiceInput, RecurringInvoiceItemUncheckedCreateWithoutRecurringInvoiceInput> | RecurringInvoiceItemCreateWithoutRecurringInvoiceInput[] | RecurringInvoiceItemUncheckedCreateWithoutRecurringInvoiceInput[]
    connectOrCreate?: RecurringInvoiceItemCreateOrConnectWithoutRecurringInvoiceInput | RecurringInvoiceItemCreateOrConnectWithoutRecurringInvoiceInput[]
    upsert?: RecurringInvoiceItemUpsertWithWhereUniqueWithoutRecurringInvoiceInput | RecurringInvoiceItemUpsertWithWhereUniqueWithoutRecurringInvoiceInput[]
    createMany?: RecurringInvoiceItemCreateManyRecurringInvoiceInputEnvelope
    set?: RecurringInvoiceItemWhereUniqueInput | RecurringInvoiceItemWhereUniqueInput[]
    disconnect?: RecurringInvoiceItemWhereUniqueInput | RecurringInvoiceItemWhereUniqueInput[]
    delete?: RecurringInvoiceItemWhereUniqueInput | RecurringInvoiceItemWhereUniqueInput[]
    connect?: RecurringInvoiceItemWhereUniqueInput | RecurringInvoiceItemWhereUniqueInput[]
    update?: RecurringInvoiceItemUpdateWithWhereUniqueWithoutRecurringInvoiceInput | RecurringInvoiceItemUpdateWithWhereUniqueWithoutRecurringInvoiceInput[]
    updateMany?: RecurringInvoiceItemUpdateManyWithWhereWithoutRecurringInvoiceInput | RecurringInvoiceItemUpdateManyWithWhereWithoutRecurringInvoiceInput[]
    deleteMany?: RecurringInvoiceItemScalarWhereInput | RecurringInvoiceItemScalarWhereInput[]
  }

  export type RecurringInvoiceItemUncheckedUpdateManyWithoutRecurringInvoiceNestedInput = {
    create?: XOR<RecurringInvoiceItemCreateWithoutRecurringInvoiceInput, RecurringInvoiceItemUncheckedCreateWithoutRecurringInvoiceInput> | RecurringInvoiceItemCreateWithoutRecurringInvoiceInput[] | RecurringInvoiceItemUncheckedCreateWithoutRecurringInvoiceInput[]
    connectOrCreate?: RecurringInvoiceItemCreateOrConnectWithoutRecurringInvoiceInput | RecurringInvoiceItemCreateOrConnectWithoutRecurringInvoiceInput[]
    upsert?: RecurringInvoiceItemUpsertWithWhereUniqueWithoutRecurringInvoiceInput | RecurringInvoiceItemUpsertWithWhereUniqueWithoutRecurringInvoiceInput[]
    createMany?: RecurringInvoiceItemCreateManyRecurringInvoiceInputEnvelope
    set?: RecurringInvoiceItemWhereUniqueInput | RecurringInvoiceItemWhereUniqueInput[]
    disconnect?: RecurringInvoiceItemWhereUniqueInput | RecurringInvoiceItemWhereUniqueInput[]
    delete?: RecurringInvoiceItemWhereUniqueInput | RecurringInvoiceItemWhereUniqueInput[]
    connect?: RecurringInvoiceItemWhereUniqueInput | RecurringInvoiceItemWhereUniqueInput[]
    update?: RecurringInvoiceItemUpdateWithWhereUniqueWithoutRecurringInvoiceInput | RecurringInvoiceItemUpdateWithWhereUniqueWithoutRecurringInvoiceInput[]
    updateMany?: RecurringInvoiceItemUpdateManyWithWhereWithoutRecurringInvoiceInput | RecurringInvoiceItemUpdateManyWithWhereWithoutRecurringInvoiceInput[]
    deleteMany?: RecurringInvoiceItemScalarWhereInput | RecurringInvoiceItemScalarWhereInput[]
  }

  export type RecurringInvoiceCreateNestedOneWithoutItemsInput = {
    create?: XOR<RecurringInvoiceCreateWithoutItemsInput, RecurringInvoiceUncheckedCreateWithoutItemsInput>
    connectOrCreate?: RecurringInvoiceCreateOrConnectWithoutItemsInput
    connect?: RecurringInvoiceWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutRecurringInvoiceItemsInput = {
    create?: XOR<ProductCreateWithoutRecurringInvoiceItemsInput, ProductUncheckedCreateWithoutRecurringInvoiceItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutRecurringInvoiceItemsInput
    connect?: ProductWhereUniqueInput
  }

  export type RecurringInvoiceUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<RecurringInvoiceCreateWithoutItemsInput, RecurringInvoiceUncheckedCreateWithoutItemsInput>
    connectOrCreate?: RecurringInvoiceCreateOrConnectWithoutItemsInput
    upsert?: RecurringInvoiceUpsertWithoutItemsInput
    connect?: RecurringInvoiceWhereUniqueInput
    update?: XOR<XOR<RecurringInvoiceUpdateToOneWithWhereWithoutItemsInput, RecurringInvoiceUpdateWithoutItemsInput>, RecurringInvoiceUncheckedUpdateWithoutItemsInput>
  }

  export type ProductUpdateOneWithoutRecurringInvoiceItemsNestedInput = {
    create?: XOR<ProductCreateWithoutRecurringInvoiceItemsInput, ProductUncheckedCreateWithoutRecurringInvoiceItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutRecurringInvoiceItemsInput
    upsert?: ProductUpsertWithoutRecurringInvoiceItemsInput
    disconnect?: ProductWhereInput | boolean
    delete?: ProductWhereInput | boolean
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutRecurringInvoiceItemsInput, ProductUpdateWithoutRecurringInvoiceItemsInput>, ProductUncheckedUpdateWithoutRecurringInvoiceItemsInput>
  }

  export type InvoiceCreateNestedOneWithoutRemindersInput = {
    create?: XOR<InvoiceCreateWithoutRemindersInput, InvoiceUncheckedCreateWithoutRemindersInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutRemindersInput
    connect?: InvoiceWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedRemindersInput = {
    create?: XOR<UserCreateWithoutCreatedRemindersInput, UserUncheckedCreateWithoutCreatedRemindersInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedRemindersInput
    connect?: UserWhereUniqueInput
  }

  export type EnumReminderTypeFieldUpdateOperationsInput = {
    set?: $Enums.ReminderType
  }

  export type EnumReminderStatusFieldUpdateOperationsInput = {
    set?: $Enums.ReminderStatus
  }

  export type InvoiceUpdateOneRequiredWithoutRemindersNestedInput = {
    create?: XOR<InvoiceCreateWithoutRemindersInput, InvoiceUncheckedCreateWithoutRemindersInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutRemindersInput
    upsert?: InvoiceUpsertWithoutRemindersInput
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutRemindersInput, InvoiceUpdateWithoutRemindersInput>, InvoiceUncheckedUpdateWithoutRemindersInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedRemindersNestedInput = {
    create?: XOR<UserCreateWithoutCreatedRemindersInput, UserUncheckedCreateWithoutCreatedRemindersInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedRemindersInput
    upsert?: UserUpsertWithoutCreatedRemindersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedRemindersInput, UserUpdateWithoutCreatedRemindersInput>, UserUncheckedUpdateWithoutCreatedRemindersInput>
  }

  export type EnumDocumentTypeFieldUpdateOperationsInput = {
    set?: $Enums.DocumentType
  }

  export type SupplierCreateNestedOneWithoutExpensesInput = {
    create?: XOR<SupplierCreateWithoutExpensesInput, SupplierUncheckedCreateWithoutExpensesInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutExpensesInput
    connect?: SupplierWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedExpensesInput = {
    create?: XOR<UserCreateWithoutCreatedExpensesInput, UserUncheckedCreateWithoutCreatedExpensesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedExpensesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumExpenseStatusFieldUpdateOperationsInput = {
    set?: $Enums.ExpenseStatus
  }

  export type SupplierUpdateOneWithoutExpensesNestedInput = {
    create?: XOR<SupplierCreateWithoutExpensesInput, SupplierUncheckedCreateWithoutExpensesInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutExpensesInput
    upsert?: SupplierUpsertWithoutExpensesInput
    disconnect?: SupplierWhereInput | boolean
    delete?: SupplierWhereInput | boolean
    connect?: SupplierWhereUniqueInput
    update?: XOR<XOR<SupplierUpdateToOneWithWhereWithoutExpensesInput, SupplierUpdateWithoutExpensesInput>, SupplierUncheckedUpdateWithoutExpensesInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedExpensesNestedInput = {
    create?: XOR<UserCreateWithoutCreatedExpensesInput, UserUncheckedCreateWithoutCreatedExpensesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedExpensesInput
    upsert?: UserUpsertWithoutCreatedExpensesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedExpensesInput, UserUpdateWithoutCreatedExpensesInput>, UserUncheckedUpdateWithoutCreatedExpensesInput>
  }

  export type ExpenseCreateNestedManyWithoutSupplierInput = {
    create?: XOR<ExpenseCreateWithoutSupplierInput, ExpenseUncheckedCreateWithoutSupplierInput> | ExpenseCreateWithoutSupplierInput[] | ExpenseUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutSupplierInput | ExpenseCreateOrConnectWithoutSupplierInput[]
    createMany?: ExpenseCreateManySupplierInputEnvelope
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
  }

  export type ExpenseUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<ExpenseCreateWithoutSupplierInput, ExpenseUncheckedCreateWithoutSupplierInput> | ExpenseCreateWithoutSupplierInput[] | ExpenseUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutSupplierInput | ExpenseCreateOrConnectWithoutSupplierInput[]
    createMany?: ExpenseCreateManySupplierInputEnvelope
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
  }

  export type ExpenseUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<ExpenseCreateWithoutSupplierInput, ExpenseUncheckedCreateWithoutSupplierInput> | ExpenseCreateWithoutSupplierInput[] | ExpenseUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutSupplierInput | ExpenseCreateOrConnectWithoutSupplierInput[]
    upsert?: ExpenseUpsertWithWhereUniqueWithoutSupplierInput | ExpenseUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: ExpenseCreateManySupplierInputEnvelope
    set?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    disconnect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    delete?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    update?: ExpenseUpdateWithWhereUniqueWithoutSupplierInput | ExpenseUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: ExpenseUpdateManyWithWhereWithoutSupplierInput | ExpenseUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
  }

  export type ExpenseUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<ExpenseCreateWithoutSupplierInput, ExpenseUncheckedCreateWithoutSupplierInput> | ExpenseCreateWithoutSupplierInput[] | ExpenseUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutSupplierInput | ExpenseCreateOrConnectWithoutSupplierInput[]
    upsert?: ExpenseUpsertWithWhereUniqueWithoutSupplierInput | ExpenseUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: ExpenseCreateManySupplierInputEnvelope
    set?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    disconnect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    delete?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    update?: ExpenseUpdateWithWhereUniqueWithoutSupplierInput | ExpenseUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: ExpenseUpdateManyWithWhereWithoutSupplierInput | ExpenseUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAccountingEntriesInput = {
    create?: XOR<UserCreateWithoutAccountingEntriesInput, UserUncheckedCreateWithoutAccountingEntriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountingEntriesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumSourceDocumentTypeFieldUpdateOperationsInput = {
    set?: $Enums.SourceDocumentType
  }

  export type UserUpdateOneRequiredWithoutAccountingEntriesNestedInput = {
    create?: XOR<UserCreateWithoutAccountingEntriesInput, UserUncheckedCreateWithoutAccountingEntriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountingEntriesInput
    upsert?: UserUpsertWithoutAccountingEntriesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountingEntriesInput, UserUpdateWithoutAccountingEntriesInput>, UserUncheckedUpdateWithoutAccountingEntriesInput>
  }

  export type UserCreateNestedOneWithoutCashFlowEntriesInput = {
    create?: XOR<UserCreateWithoutCashFlowEntriesInput, UserUncheckedCreateWithoutCashFlowEntriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCashFlowEntriesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumCashFlowTypeFieldUpdateOperationsInput = {
    set?: $Enums.CashFlowType
  }

  export type UserUpdateOneRequiredWithoutCashFlowEntriesNestedInput = {
    create?: XOR<UserCreateWithoutCashFlowEntriesInput, UserUncheckedCreateWithoutCashFlowEntriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCashFlowEntriesInput
    upsert?: UserUpsertWithoutCashFlowEntriesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCashFlowEntriesInput, UserUpdateWithoutCashFlowEntriesInput>, UserUncheckedUpdateWithoutCashFlowEntriesInput>
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type ServiceCreateNestedOneWithoutEmployeesInput = {
    create?: XOR<ServiceCreateWithoutEmployeesInput, ServiceUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutEmployeesInput
    connect?: ServiceWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutEmployeeInput = {
    create?: XOR<UserCreateWithoutEmployeeInput, UserUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmployeeInput
    connect?: UserWhereUniqueInput
  }

  export type ContractCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<ContractCreateWithoutEmployeeInput, ContractUncheckedCreateWithoutEmployeeInput> | ContractCreateWithoutEmployeeInput[] | ContractUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: ContractCreateOrConnectWithoutEmployeeInput | ContractCreateOrConnectWithoutEmployeeInput[]
    createMany?: ContractCreateManyEmployeeInputEnvelope
    connect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
  }

  export type SalaryCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<SalaryCreateWithoutEmployeeInput, SalaryUncheckedCreateWithoutEmployeeInput> | SalaryCreateWithoutEmployeeInput[] | SalaryUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: SalaryCreateOrConnectWithoutEmployeeInput | SalaryCreateOrConnectWithoutEmployeeInput[]
    createMany?: SalaryCreateManyEmployeeInputEnvelope
    connect?: SalaryWhereUniqueInput | SalaryWhereUniqueInput[]
  }

  export type LeaveRequestCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<LeaveRequestCreateWithoutEmployeeInput, LeaveRequestUncheckedCreateWithoutEmployeeInput> | LeaveRequestCreateWithoutEmployeeInput[] | LeaveRequestUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: LeaveRequestCreateOrConnectWithoutEmployeeInput | LeaveRequestCreateOrConnectWithoutEmployeeInput[]
    createMany?: LeaveRequestCreateManyEmployeeInputEnvelope
    connect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
  }

  export type LoanCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<LoanCreateWithoutEmployeeInput, LoanUncheckedCreateWithoutEmployeeInput> | LoanCreateWithoutEmployeeInput[] | LoanUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: LoanCreateOrConnectWithoutEmployeeInput | LoanCreateOrConnectWithoutEmployeeInput[]
    createMany?: LoanCreateManyEmployeeInputEnvelope
    connect?: LoanWhereUniqueInput | LoanWhereUniqueInput[]
  }

  export type ContractUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<ContractCreateWithoutEmployeeInput, ContractUncheckedCreateWithoutEmployeeInput> | ContractCreateWithoutEmployeeInput[] | ContractUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: ContractCreateOrConnectWithoutEmployeeInput | ContractCreateOrConnectWithoutEmployeeInput[]
    createMany?: ContractCreateManyEmployeeInputEnvelope
    connect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
  }

  export type SalaryUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<SalaryCreateWithoutEmployeeInput, SalaryUncheckedCreateWithoutEmployeeInput> | SalaryCreateWithoutEmployeeInput[] | SalaryUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: SalaryCreateOrConnectWithoutEmployeeInput | SalaryCreateOrConnectWithoutEmployeeInput[]
    createMany?: SalaryCreateManyEmployeeInputEnvelope
    connect?: SalaryWhereUniqueInput | SalaryWhereUniqueInput[]
  }

  export type LeaveRequestUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<LeaveRequestCreateWithoutEmployeeInput, LeaveRequestUncheckedCreateWithoutEmployeeInput> | LeaveRequestCreateWithoutEmployeeInput[] | LeaveRequestUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: LeaveRequestCreateOrConnectWithoutEmployeeInput | LeaveRequestCreateOrConnectWithoutEmployeeInput[]
    createMany?: LeaveRequestCreateManyEmployeeInputEnvelope
    connect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
  }

  export type LoanUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<LoanCreateWithoutEmployeeInput, LoanUncheckedCreateWithoutEmployeeInput> | LoanCreateWithoutEmployeeInput[] | LoanUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: LoanCreateOrConnectWithoutEmployeeInput | LoanCreateOrConnectWithoutEmployeeInput[]
    createMany?: LoanCreateManyEmployeeInputEnvelope
    connect?: LoanWhereUniqueInput | LoanWhereUniqueInput[]
  }

  export type ServiceUpdateOneWithoutEmployeesNestedInput = {
    create?: XOR<ServiceCreateWithoutEmployeesInput, ServiceUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutEmployeesInput
    upsert?: ServiceUpsertWithoutEmployeesInput
    disconnect?: ServiceWhereInput | boolean
    delete?: ServiceWhereInput | boolean
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutEmployeesInput, ServiceUpdateWithoutEmployeesInput>, ServiceUncheckedUpdateWithoutEmployeesInput>
  }

  export type UserUpdateOneWithoutEmployeeNestedInput = {
    create?: XOR<UserCreateWithoutEmployeeInput, UserUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmployeeInput
    upsert?: UserUpsertWithoutEmployeeInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEmployeeInput, UserUpdateWithoutEmployeeInput>, UserUncheckedUpdateWithoutEmployeeInput>
  }

  export type ContractUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<ContractCreateWithoutEmployeeInput, ContractUncheckedCreateWithoutEmployeeInput> | ContractCreateWithoutEmployeeInput[] | ContractUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: ContractCreateOrConnectWithoutEmployeeInput | ContractCreateOrConnectWithoutEmployeeInput[]
    upsert?: ContractUpsertWithWhereUniqueWithoutEmployeeInput | ContractUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: ContractCreateManyEmployeeInputEnvelope
    set?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    disconnect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    delete?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    connect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    update?: ContractUpdateWithWhereUniqueWithoutEmployeeInput | ContractUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: ContractUpdateManyWithWhereWithoutEmployeeInput | ContractUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: ContractScalarWhereInput | ContractScalarWhereInput[]
  }

  export type SalaryUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<SalaryCreateWithoutEmployeeInput, SalaryUncheckedCreateWithoutEmployeeInput> | SalaryCreateWithoutEmployeeInput[] | SalaryUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: SalaryCreateOrConnectWithoutEmployeeInput | SalaryCreateOrConnectWithoutEmployeeInput[]
    upsert?: SalaryUpsertWithWhereUniqueWithoutEmployeeInput | SalaryUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: SalaryCreateManyEmployeeInputEnvelope
    set?: SalaryWhereUniqueInput | SalaryWhereUniqueInput[]
    disconnect?: SalaryWhereUniqueInput | SalaryWhereUniqueInput[]
    delete?: SalaryWhereUniqueInput | SalaryWhereUniqueInput[]
    connect?: SalaryWhereUniqueInput | SalaryWhereUniqueInput[]
    update?: SalaryUpdateWithWhereUniqueWithoutEmployeeInput | SalaryUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: SalaryUpdateManyWithWhereWithoutEmployeeInput | SalaryUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: SalaryScalarWhereInput | SalaryScalarWhereInput[]
  }

  export type LeaveRequestUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<LeaveRequestCreateWithoutEmployeeInput, LeaveRequestUncheckedCreateWithoutEmployeeInput> | LeaveRequestCreateWithoutEmployeeInput[] | LeaveRequestUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: LeaveRequestCreateOrConnectWithoutEmployeeInput | LeaveRequestCreateOrConnectWithoutEmployeeInput[]
    upsert?: LeaveRequestUpsertWithWhereUniqueWithoutEmployeeInput | LeaveRequestUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: LeaveRequestCreateManyEmployeeInputEnvelope
    set?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    disconnect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    delete?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    connect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    update?: LeaveRequestUpdateWithWhereUniqueWithoutEmployeeInput | LeaveRequestUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: LeaveRequestUpdateManyWithWhereWithoutEmployeeInput | LeaveRequestUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: LeaveRequestScalarWhereInput | LeaveRequestScalarWhereInput[]
  }

  export type LoanUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<LoanCreateWithoutEmployeeInput, LoanUncheckedCreateWithoutEmployeeInput> | LoanCreateWithoutEmployeeInput[] | LoanUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: LoanCreateOrConnectWithoutEmployeeInput | LoanCreateOrConnectWithoutEmployeeInput[]
    upsert?: LoanUpsertWithWhereUniqueWithoutEmployeeInput | LoanUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: LoanCreateManyEmployeeInputEnvelope
    set?: LoanWhereUniqueInput | LoanWhereUniqueInput[]
    disconnect?: LoanWhereUniqueInput | LoanWhereUniqueInput[]
    delete?: LoanWhereUniqueInput | LoanWhereUniqueInput[]
    connect?: LoanWhereUniqueInput | LoanWhereUniqueInput[]
    update?: LoanUpdateWithWhereUniqueWithoutEmployeeInput | LoanUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: LoanUpdateManyWithWhereWithoutEmployeeInput | LoanUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: LoanScalarWhereInput | LoanScalarWhereInput[]
  }

  export type ContractUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<ContractCreateWithoutEmployeeInput, ContractUncheckedCreateWithoutEmployeeInput> | ContractCreateWithoutEmployeeInput[] | ContractUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: ContractCreateOrConnectWithoutEmployeeInput | ContractCreateOrConnectWithoutEmployeeInput[]
    upsert?: ContractUpsertWithWhereUniqueWithoutEmployeeInput | ContractUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: ContractCreateManyEmployeeInputEnvelope
    set?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    disconnect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    delete?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    connect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    update?: ContractUpdateWithWhereUniqueWithoutEmployeeInput | ContractUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: ContractUpdateManyWithWhereWithoutEmployeeInput | ContractUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: ContractScalarWhereInput | ContractScalarWhereInput[]
  }

  export type SalaryUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<SalaryCreateWithoutEmployeeInput, SalaryUncheckedCreateWithoutEmployeeInput> | SalaryCreateWithoutEmployeeInput[] | SalaryUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: SalaryCreateOrConnectWithoutEmployeeInput | SalaryCreateOrConnectWithoutEmployeeInput[]
    upsert?: SalaryUpsertWithWhereUniqueWithoutEmployeeInput | SalaryUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: SalaryCreateManyEmployeeInputEnvelope
    set?: SalaryWhereUniqueInput | SalaryWhereUniqueInput[]
    disconnect?: SalaryWhereUniqueInput | SalaryWhereUniqueInput[]
    delete?: SalaryWhereUniqueInput | SalaryWhereUniqueInput[]
    connect?: SalaryWhereUniqueInput | SalaryWhereUniqueInput[]
    update?: SalaryUpdateWithWhereUniqueWithoutEmployeeInput | SalaryUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: SalaryUpdateManyWithWhereWithoutEmployeeInput | SalaryUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: SalaryScalarWhereInput | SalaryScalarWhereInput[]
  }

  export type LeaveRequestUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<LeaveRequestCreateWithoutEmployeeInput, LeaveRequestUncheckedCreateWithoutEmployeeInput> | LeaveRequestCreateWithoutEmployeeInput[] | LeaveRequestUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: LeaveRequestCreateOrConnectWithoutEmployeeInput | LeaveRequestCreateOrConnectWithoutEmployeeInput[]
    upsert?: LeaveRequestUpsertWithWhereUniqueWithoutEmployeeInput | LeaveRequestUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: LeaveRequestCreateManyEmployeeInputEnvelope
    set?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    disconnect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    delete?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    connect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    update?: LeaveRequestUpdateWithWhereUniqueWithoutEmployeeInput | LeaveRequestUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: LeaveRequestUpdateManyWithWhereWithoutEmployeeInput | LeaveRequestUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: LeaveRequestScalarWhereInput | LeaveRequestScalarWhereInput[]
  }

  export type LoanUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<LoanCreateWithoutEmployeeInput, LoanUncheckedCreateWithoutEmployeeInput> | LoanCreateWithoutEmployeeInput[] | LoanUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: LoanCreateOrConnectWithoutEmployeeInput | LoanCreateOrConnectWithoutEmployeeInput[]
    upsert?: LoanUpsertWithWhereUniqueWithoutEmployeeInput | LoanUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: LoanCreateManyEmployeeInputEnvelope
    set?: LoanWhereUniqueInput | LoanWhereUniqueInput[]
    disconnect?: LoanWhereUniqueInput | LoanWhereUniqueInput[]
    delete?: LoanWhereUniqueInput | LoanWhereUniqueInput[]
    connect?: LoanWhereUniqueInput | LoanWhereUniqueInput[]
    update?: LoanUpdateWithWhereUniqueWithoutEmployeeInput | LoanUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: LoanUpdateManyWithWhereWithoutEmployeeInput | LoanUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: LoanScalarWhereInput | LoanScalarWhereInput[]
  }

  export type EmployeeCreateNestedOneWithoutContractsInput = {
    create?: XOR<EmployeeCreateWithoutContractsInput, EmployeeUncheckedCreateWithoutContractsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutContractsInput
    connect?: EmployeeWhereUniqueInput
  }

  export type EnumContractTypeFieldUpdateOperationsInput = {
    set?: $Enums.ContractType
  }

  export type EmployeeUpdateOneRequiredWithoutContractsNestedInput = {
    create?: XOR<EmployeeCreateWithoutContractsInput, EmployeeUncheckedCreateWithoutContractsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutContractsInput
    upsert?: EmployeeUpsertWithoutContractsInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutContractsInput, EmployeeUpdateWithoutContractsInput>, EmployeeUncheckedUpdateWithoutContractsInput>
  }

  export type EmployeeCreateNestedOneWithoutSalariesInput = {
    create?: XOR<EmployeeCreateWithoutSalariesInput, EmployeeUncheckedCreateWithoutSalariesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutSalariesInput
    connect?: EmployeeWhereUniqueInput
  }

  export type LoanPaymentCreateNestedManyWithoutSalaryInput = {
    create?: XOR<LoanPaymentCreateWithoutSalaryInput, LoanPaymentUncheckedCreateWithoutSalaryInput> | LoanPaymentCreateWithoutSalaryInput[] | LoanPaymentUncheckedCreateWithoutSalaryInput[]
    connectOrCreate?: LoanPaymentCreateOrConnectWithoutSalaryInput | LoanPaymentCreateOrConnectWithoutSalaryInput[]
    createMany?: LoanPaymentCreateManySalaryInputEnvelope
    connect?: LoanPaymentWhereUniqueInput | LoanPaymentWhereUniqueInput[]
  }

  export type LoanPaymentUncheckedCreateNestedManyWithoutSalaryInput = {
    create?: XOR<LoanPaymentCreateWithoutSalaryInput, LoanPaymentUncheckedCreateWithoutSalaryInput> | LoanPaymentCreateWithoutSalaryInput[] | LoanPaymentUncheckedCreateWithoutSalaryInput[]
    connectOrCreate?: LoanPaymentCreateOrConnectWithoutSalaryInput | LoanPaymentCreateOrConnectWithoutSalaryInput[]
    createMany?: LoanPaymentCreateManySalaryInputEnvelope
    connect?: LoanPaymentWhereUniqueInput | LoanPaymentWhereUniqueInput[]
  }

  export type EnumSalaryStatusFieldUpdateOperationsInput = {
    set?: $Enums.SalaryStatus
  }

  export type NullableEnumPaymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethod | null
  }

  export type EmployeeUpdateOneRequiredWithoutSalariesNestedInput = {
    create?: XOR<EmployeeCreateWithoutSalariesInput, EmployeeUncheckedCreateWithoutSalariesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutSalariesInput
    upsert?: EmployeeUpsertWithoutSalariesInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutSalariesInput, EmployeeUpdateWithoutSalariesInput>, EmployeeUncheckedUpdateWithoutSalariesInput>
  }

  export type LoanPaymentUpdateManyWithoutSalaryNestedInput = {
    create?: XOR<LoanPaymentCreateWithoutSalaryInput, LoanPaymentUncheckedCreateWithoutSalaryInput> | LoanPaymentCreateWithoutSalaryInput[] | LoanPaymentUncheckedCreateWithoutSalaryInput[]
    connectOrCreate?: LoanPaymentCreateOrConnectWithoutSalaryInput | LoanPaymentCreateOrConnectWithoutSalaryInput[]
    upsert?: LoanPaymentUpsertWithWhereUniqueWithoutSalaryInput | LoanPaymentUpsertWithWhereUniqueWithoutSalaryInput[]
    createMany?: LoanPaymentCreateManySalaryInputEnvelope
    set?: LoanPaymentWhereUniqueInput | LoanPaymentWhereUniqueInput[]
    disconnect?: LoanPaymentWhereUniqueInput | LoanPaymentWhereUniqueInput[]
    delete?: LoanPaymentWhereUniqueInput | LoanPaymentWhereUniqueInput[]
    connect?: LoanPaymentWhereUniqueInput | LoanPaymentWhereUniqueInput[]
    update?: LoanPaymentUpdateWithWhereUniqueWithoutSalaryInput | LoanPaymentUpdateWithWhereUniqueWithoutSalaryInput[]
    updateMany?: LoanPaymentUpdateManyWithWhereWithoutSalaryInput | LoanPaymentUpdateManyWithWhereWithoutSalaryInput[]
    deleteMany?: LoanPaymentScalarWhereInput | LoanPaymentScalarWhereInput[]
  }

  export type LoanPaymentUncheckedUpdateManyWithoutSalaryNestedInput = {
    create?: XOR<LoanPaymentCreateWithoutSalaryInput, LoanPaymentUncheckedCreateWithoutSalaryInput> | LoanPaymentCreateWithoutSalaryInput[] | LoanPaymentUncheckedCreateWithoutSalaryInput[]
    connectOrCreate?: LoanPaymentCreateOrConnectWithoutSalaryInput | LoanPaymentCreateOrConnectWithoutSalaryInput[]
    upsert?: LoanPaymentUpsertWithWhereUniqueWithoutSalaryInput | LoanPaymentUpsertWithWhereUniqueWithoutSalaryInput[]
    createMany?: LoanPaymentCreateManySalaryInputEnvelope
    set?: LoanPaymentWhereUniqueInput | LoanPaymentWhereUniqueInput[]
    disconnect?: LoanPaymentWhereUniqueInput | LoanPaymentWhereUniqueInput[]
    delete?: LoanPaymentWhereUniqueInput | LoanPaymentWhereUniqueInput[]
    connect?: LoanPaymentWhereUniqueInput | LoanPaymentWhereUniqueInput[]
    update?: LoanPaymentUpdateWithWhereUniqueWithoutSalaryInput | LoanPaymentUpdateWithWhereUniqueWithoutSalaryInput[]
    updateMany?: LoanPaymentUpdateManyWithWhereWithoutSalaryInput | LoanPaymentUpdateManyWithWhereWithoutSalaryInput[]
    deleteMany?: LoanPaymentScalarWhereInput | LoanPaymentScalarWhereInput[]
  }

  export type LoanCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<LoanCreateWithoutPaymentsInput, LoanUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: LoanCreateOrConnectWithoutPaymentsInput
    connect?: LoanWhereUniqueInput
  }

  export type SalaryCreateNestedOneWithoutLoanPaymentsInput = {
    create?: XOR<SalaryCreateWithoutLoanPaymentsInput, SalaryUncheckedCreateWithoutLoanPaymentsInput>
    connectOrCreate?: SalaryCreateOrConnectWithoutLoanPaymentsInput
    connect?: SalaryWhereUniqueInput
  }

  export type LoanUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<LoanCreateWithoutPaymentsInput, LoanUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: LoanCreateOrConnectWithoutPaymentsInput
    upsert?: LoanUpsertWithoutPaymentsInput
    connect?: LoanWhereUniqueInput
    update?: XOR<XOR<LoanUpdateToOneWithWhereWithoutPaymentsInput, LoanUpdateWithoutPaymentsInput>, LoanUncheckedUpdateWithoutPaymentsInput>
  }

  export type SalaryUpdateOneWithoutLoanPaymentsNestedInput = {
    create?: XOR<SalaryCreateWithoutLoanPaymentsInput, SalaryUncheckedCreateWithoutLoanPaymentsInput>
    connectOrCreate?: SalaryCreateOrConnectWithoutLoanPaymentsInput
    upsert?: SalaryUpsertWithoutLoanPaymentsInput
    disconnect?: SalaryWhereInput | boolean
    delete?: SalaryWhereInput | boolean
    connect?: SalaryWhereUniqueInput
    update?: XOR<XOR<SalaryUpdateToOneWithWhereWithoutLoanPaymentsInput, SalaryUpdateWithoutLoanPaymentsInput>, SalaryUncheckedUpdateWithoutLoanPaymentsInput>
  }

  export type EmployeeCreateNestedOneWithoutLeaveRequestsInput = {
    create?: XOR<EmployeeCreateWithoutLeaveRequestsInput, EmployeeUncheckedCreateWithoutLeaveRequestsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutLeaveRequestsInput
    connect?: EmployeeWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutLeaveApprovalsInput = {
    create?: XOR<UserCreateWithoutLeaveApprovalsInput, UserUncheckedCreateWithoutLeaveApprovalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLeaveApprovalsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumLeaveTypeFieldUpdateOperationsInput = {
    set?: $Enums.LeaveType
  }

  export type EnumLeaveStatusFieldUpdateOperationsInput = {
    set?: $Enums.LeaveStatus
  }

  export type EmployeeUpdateOneRequiredWithoutLeaveRequestsNestedInput = {
    create?: XOR<EmployeeCreateWithoutLeaveRequestsInput, EmployeeUncheckedCreateWithoutLeaveRequestsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutLeaveRequestsInput
    upsert?: EmployeeUpsertWithoutLeaveRequestsInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutLeaveRequestsInput, EmployeeUpdateWithoutLeaveRequestsInput>, EmployeeUncheckedUpdateWithoutLeaveRequestsInput>
  }

  export type UserUpdateOneWithoutLeaveApprovalsNestedInput = {
    create?: XOR<UserCreateWithoutLeaveApprovalsInput, UserUncheckedCreateWithoutLeaveApprovalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLeaveApprovalsInput
    upsert?: UserUpsertWithoutLeaveApprovalsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLeaveApprovalsInput, UserUpdateWithoutLeaveApprovalsInput>, UserUncheckedUpdateWithoutLeaveApprovalsInput>
  }

  export type UserCreateNestedOneWithoutAssignedProspectsInput = {
    create?: XOR<UserCreateWithoutAssignedProspectsInput, UserUncheckedCreateWithoutAssignedProspectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedProspectsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedProspectsInput = {
    create?: XOR<UserCreateWithoutCreatedProspectsInput, UserUncheckedCreateWithoutCreatedProspectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedProspectsInput
    connect?: UserWhereUniqueInput
  }

  export type ProspectActivityCreateNestedManyWithoutProspectInput = {
    create?: XOR<ProspectActivityCreateWithoutProspectInput, ProspectActivityUncheckedCreateWithoutProspectInput> | ProspectActivityCreateWithoutProspectInput[] | ProspectActivityUncheckedCreateWithoutProspectInput[]
    connectOrCreate?: ProspectActivityCreateOrConnectWithoutProspectInput | ProspectActivityCreateOrConnectWithoutProspectInput[]
    createMany?: ProspectActivityCreateManyProspectInputEnvelope
    connect?: ProspectActivityWhereUniqueInput | ProspectActivityWhereUniqueInput[]
  }

  export type ProspectActivityUncheckedCreateNestedManyWithoutProspectInput = {
    create?: XOR<ProspectActivityCreateWithoutProspectInput, ProspectActivityUncheckedCreateWithoutProspectInput> | ProspectActivityCreateWithoutProspectInput[] | ProspectActivityUncheckedCreateWithoutProspectInput[]
    connectOrCreate?: ProspectActivityCreateOrConnectWithoutProspectInput | ProspectActivityCreateOrConnectWithoutProspectInput[]
    createMany?: ProspectActivityCreateManyProspectInputEnvelope
    connect?: ProspectActivityWhereUniqueInput | ProspectActivityWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutAssignedProspectsNestedInput = {
    create?: XOR<UserCreateWithoutAssignedProspectsInput, UserUncheckedCreateWithoutAssignedProspectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedProspectsInput
    upsert?: UserUpsertWithoutAssignedProspectsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAssignedProspectsInput, UserUpdateWithoutAssignedProspectsInput>, UserUncheckedUpdateWithoutAssignedProspectsInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedProspectsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedProspectsInput, UserUncheckedCreateWithoutCreatedProspectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedProspectsInput
    upsert?: UserUpsertWithoutCreatedProspectsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedProspectsInput, UserUpdateWithoutCreatedProspectsInput>, UserUncheckedUpdateWithoutCreatedProspectsInput>
  }

  export type ProspectActivityUpdateManyWithoutProspectNestedInput = {
    create?: XOR<ProspectActivityCreateWithoutProspectInput, ProspectActivityUncheckedCreateWithoutProspectInput> | ProspectActivityCreateWithoutProspectInput[] | ProspectActivityUncheckedCreateWithoutProspectInput[]
    connectOrCreate?: ProspectActivityCreateOrConnectWithoutProspectInput | ProspectActivityCreateOrConnectWithoutProspectInput[]
    upsert?: ProspectActivityUpsertWithWhereUniqueWithoutProspectInput | ProspectActivityUpsertWithWhereUniqueWithoutProspectInput[]
    createMany?: ProspectActivityCreateManyProspectInputEnvelope
    set?: ProspectActivityWhereUniqueInput | ProspectActivityWhereUniqueInput[]
    disconnect?: ProspectActivityWhereUniqueInput | ProspectActivityWhereUniqueInput[]
    delete?: ProspectActivityWhereUniqueInput | ProspectActivityWhereUniqueInput[]
    connect?: ProspectActivityWhereUniqueInput | ProspectActivityWhereUniqueInput[]
    update?: ProspectActivityUpdateWithWhereUniqueWithoutProspectInput | ProspectActivityUpdateWithWhereUniqueWithoutProspectInput[]
    updateMany?: ProspectActivityUpdateManyWithWhereWithoutProspectInput | ProspectActivityUpdateManyWithWhereWithoutProspectInput[]
    deleteMany?: ProspectActivityScalarWhereInput | ProspectActivityScalarWhereInput[]
  }

  export type ProspectActivityUncheckedUpdateManyWithoutProspectNestedInput = {
    create?: XOR<ProspectActivityCreateWithoutProspectInput, ProspectActivityUncheckedCreateWithoutProspectInput> | ProspectActivityCreateWithoutProspectInput[] | ProspectActivityUncheckedCreateWithoutProspectInput[]
    connectOrCreate?: ProspectActivityCreateOrConnectWithoutProspectInput | ProspectActivityCreateOrConnectWithoutProspectInput[]
    upsert?: ProspectActivityUpsertWithWhereUniqueWithoutProspectInput | ProspectActivityUpsertWithWhereUniqueWithoutProspectInput[]
    createMany?: ProspectActivityCreateManyProspectInputEnvelope
    set?: ProspectActivityWhereUniqueInput | ProspectActivityWhereUniqueInput[]
    disconnect?: ProspectActivityWhereUniqueInput | ProspectActivityWhereUniqueInput[]
    delete?: ProspectActivityWhereUniqueInput | ProspectActivityWhereUniqueInput[]
    connect?: ProspectActivityWhereUniqueInput | ProspectActivityWhereUniqueInput[]
    update?: ProspectActivityUpdateWithWhereUniqueWithoutProspectInput | ProspectActivityUpdateWithWhereUniqueWithoutProspectInput[]
    updateMany?: ProspectActivityUpdateManyWithWhereWithoutProspectInput | ProspectActivityUpdateManyWithWhereWithoutProspectInput[]
    deleteMany?: ProspectActivityScalarWhereInput | ProspectActivityScalarWhereInput[]
  }

  export type ProspectCreateNestedOneWithoutActivitiesInput = {
    create?: XOR<ProspectCreateWithoutActivitiesInput, ProspectUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: ProspectCreateOrConnectWithoutActivitiesInput
    connect?: ProspectWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedProspectActivitiesInput = {
    create?: XOR<UserCreateWithoutCreatedProspectActivitiesInput, UserUncheckedCreateWithoutCreatedProspectActivitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedProspectActivitiesInput
    connect?: UserWhereUniqueInput
  }

  export type ProspectUpdateOneRequiredWithoutActivitiesNestedInput = {
    create?: XOR<ProspectCreateWithoutActivitiesInput, ProspectUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: ProspectCreateOrConnectWithoutActivitiesInput
    upsert?: ProspectUpsertWithoutActivitiesInput
    connect?: ProspectWhereUniqueInput
    update?: XOR<XOR<ProspectUpdateToOneWithWhereWithoutActivitiesInput, ProspectUpdateWithoutActivitiesInput>, ProspectUncheckedUpdateWithoutActivitiesInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedProspectActivitiesNestedInput = {
    create?: XOR<UserCreateWithoutCreatedProspectActivitiesInput, UserUncheckedCreateWithoutCreatedProspectActivitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedProspectActivitiesInput
    upsert?: UserUpsertWithoutCreatedProspectActivitiesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedProspectActivitiesInput, UserUpdateWithoutCreatedProspectActivitiesInput>, UserUncheckedUpdateWithoutCreatedProspectActivitiesInput>
  }

  export type EmployeeCreateNestedOneWithoutLoansInput = {
    create?: XOR<EmployeeCreateWithoutLoansInput, EmployeeUncheckedCreateWithoutLoansInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutLoansInput
    connect?: EmployeeWhereUniqueInput
  }

  export type LoanPaymentCreateNestedManyWithoutLoanInput = {
    create?: XOR<LoanPaymentCreateWithoutLoanInput, LoanPaymentUncheckedCreateWithoutLoanInput> | LoanPaymentCreateWithoutLoanInput[] | LoanPaymentUncheckedCreateWithoutLoanInput[]
    connectOrCreate?: LoanPaymentCreateOrConnectWithoutLoanInput | LoanPaymentCreateOrConnectWithoutLoanInput[]
    createMany?: LoanPaymentCreateManyLoanInputEnvelope
    connect?: LoanPaymentWhereUniqueInput | LoanPaymentWhereUniqueInput[]
  }

  export type LoanPaymentUncheckedCreateNestedManyWithoutLoanInput = {
    create?: XOR<LoanPaymentCreateWithoutLoanInput, LoanPaymentUncheckedCreateWithoutLoanInput> | LoanPaymentCreateWithoutLoanInput[] | LoanPaymentUncheckedCreateWithoutLoanInput[]
    connectOrCreate?: LoanPaymentCreateOrConnectWithoutLoanInput | LoanPaymentCreateOrConnectWithoutLoanInput[]
    createMany?: LoanPaymentCreateManyLoanInputEnvelope
    connect?: LoanPaymentWhereUniqueInput | LoanPaymentWhereUniqueInput[]
  }

  export type EnumLoanStatusFieldUpdateOperationsInput = {
    set?: $Enums.LoanStatus
  }

  export type EmployeeUpdateOneRequiredWithoutLoansNestedInput = {
    create?: XOR<EmployeeCreateWithoutLoansInput, EmployeeUncheckedCreateWithoutLoansInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutLoansInput
    upsert?: EmployeeUpsertWithoutLoansInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutLoansInput, EmployeeUpdateWithoutLoansInput>, EmployeeUncheckedUpdateWithoutLoansInput>
  }

  export type LoanPaymentUpdateManyWithoutLoanNestedInput = {
    create?: XOR<LoanPaymentCreateWithoutLoanInput, LoanPaymentUncheckedCreateWithoutLoanInput> | LoanPaymentCreateWithoutLoanInput[] | LoanPaymentUncheckedCreateWithoutLoanInput[]
    connectOrCreate?: LoanPaymentCreateOrConnectWithoutLoanInput | LoanPaymentCreateOrConnectWithoutLoanInput[]
    upsert?: LoanPaymentUpsertWithWhereUniqueWithoutLoanInput | LoanPaymentUpsertWithWhereUniqueWithoutLoanInput[]
    createMany?: LoanPaymentCreateManyLoanInputEnvelope
    set?: LoanPaymentWhereUniqueInput | LoanPaymentWhereUniqueInput[]
    disconnect?: LoanPaymentWhereUniqueInput | LoanPaymentWhereUniqueInput[]
    delete?: LoanPaymentWhereUniqueInput | LoanPaymentWhereUniqueInput[]
    connect?: LoanPaymentWhereUniqueInput | LoanPaymentWhereUniqueInput[]
    update?: LoanPaymentUpdateWithWhereUniqueWithoutLoanInput | LoanPaymentUpdateWithWhereUniqueWithoutLoanInput[]
    updateMany?: LoanPaymentUpdateManyWithWhereWithoutLoanInput | LoanPaymentUpdateManyWithWhereWithoutLoanInput[]
    deleteMany?: LoanPaymentScalarWhereInput | LoanPaymentScalarWhereInput[]
  }

  export type LoanPaymentUncheckedUpdateManyWithoutLoanNestedInput = {
    create?: XOR<LoanPaymentCreateWithoutLoanInput, LoanPaymentUncheckedCreateWithoutLoanInput> | LoanPaymentCreateWithoutLoanInput[] | LoanPaymentUncheckedCreateWithoutLoanInput[]
    connectOrCreate?: LoanPaymentCreateOrConnectWithoutLoanInput | LoanPaymentCreateOrConnectWithoutLoanInput[]
    upsert?: LoanPaymentUpsertWithWhereUniqueWithoutLoanInput | LoanPaymentUpsertWithWhereUniqueWithoutLoanInput[]
    createMany?: LoanPaymentCreateManyLoanInputEnvelope
    set?: LoanPaymentWhereUniqueInput | LoanPaymentWhereUniqueInput[]
    disconnect?: LoanPaymentWhereUniqueInput | LoanPaymentWhereUniqueInput[]
    delete?: LoanPaymentWhereUniqueInput | LoanPaymentWhereUniqueInput[]
    connect?: LoanPaymentWhereUniqueInput | LoanPaymentWhereUniqueInput[]
    update?: LoanPaymentUpdateWithWhereUniqueWithoutLoanInput | LoanPaymentUpdateWithWhereUniqueWithoutLoanInput[]
    updateMany?: LoanPaymentUpdateManyWithWhereWithoutLoanInput | LoanPaymentUpdateManyWithWhereWithoutLoanInput[]
    deleteMany?: LoanPaymentScalarWhereInput | LoanPaymentScalarWhereInput[]
  }

  export type TechnicienCreateNestedManyWithoutSpecialiteInput = {
    create?: XOR<TechnicienCreateWithoutSpecialiteInput, TechnicienUncheckedCreateWithoutSpecialiteInput> | TechnicienCreateWithoutSpecialiteInput[] | TechnicienUncheckedCreateWithoutSpecialiteInput[]
    connectOrCreate?: TechnicienCreateOrConnectWithoutSpecialiteInput | TechnicienCreateOrConnectWithoutSpecialiteInput[]
    createMany?: TechnicienCreateManySpecialiteInputEnvelope
    connect?: TechnicienWhereUniqueInput | TechnicienWhereUniqueInput[]
  }

  export type TechnicienUncheckedCreateNestedManyWithoutSpecialiteInput = {
    create?: XOR<TechnicienCreateWithoutSpecialiteInput, TechnicienUncheckedCreateWithoutSpecialiteInput> | TechnicienCreateWithoutSpecialiteInput[] | TechnicienUncheckedCreateWithoutSpecialiteInput[]
    connectOrCreate?: TechnicienCreateOrConnectWithoutSpecialiteInput | TechnicienCreateOrConnectWithoutSpecialiteInput[]
    createMany?: TechnicienCreateManySpecialiteInputEnvelope
    connect?: TechnicienWhereUniqueInput | TechnicienWhereUniqueInput[]
  }

  export type TechnicienUpdateManyWithoutSpecialiteNestedInput = {
    create?: XOR<TechnicienCreateWithoutSpecialiteInput, TechnicienUncheckedCreateWithoutSpecialiteInput> | TechnicienCreateWithoutSpecialiteInput[] | TechnicienUncheckedCreateWithoutSpecialiteInput[]
    connectOrCreate?: TechnicienCreateOrConnectWithoutSpecialiteInput | TechnicienCreateOrConnectWithoutSpecialiteInput[]
    upsert?: TechnicienUpsertWithWhereUniqueWithoutSpecialiteInput | TechnicienUpsertWithWhereUniqueWithoutSpecialiteInput[]
    createMany?: TechnicienCreateManySpecialiteInputEnvelope
    set?: TechnicienWhereUniqueInput | TechnicienWhereUniqueInput[]
    disconnect?: TechnicienWhereUniqueInput | TechnicienWhereUniqueInput[]
    delete?: TechnicienWhereUniqueInput | TechnicienWhereUniqueInput[]
    connect?: TechnicienWhereUniqueInput | TechnicienWhereUniqueInput[]
    update?: TechnicienUpdateWithWhereUniqueWithoutSpecialiteInput | TechnicienUpdateWithWhereUniqueWithoutSpecialiteInput[]
    updateMany?: TechnicienUpdateManyWithWhereWithoutSpecialiteInput | TechnicienUpdateManyWithWhereWithoutSpecialiteInput[]
    deleteMany?: TechnicienScalarWhereInput | TechnicienScalarWhereInput[]
  }

  export type TechnicienUncheckedUpdateManyWithoutSpecialiteNestedInput = {
    create?: XOR<TechnicienCreateWithoutSpecialiteInput, TechnicienUncheckedCreateWithoutSpecialiteInput> | TechnicienCreateWithoutSpecialiteInput[] | TechnicienUncheckedCreateWithoutSpecialiteInput[]
    connectOrCreate?: TechnicienCreateOrConnectWithoutSpecialiteInput | TechnicienCreateOrConnectWithoutSpecialiteInput[]
    upsert?: TechnicienUpsertWithWhereUniqueWithoutSpecialiteInput | TechnicienUpsertWithWhereUniqueWithoutSpecialiteInput[]
    createMany?: TechnicienCreateManySpecialiteInputEnvelope
    set?: TechnicienWhereUniqueInput | TechnicienWhereUniqueInput[]
    disconnect?: TechnicienWhereUniqueInput | TechnicienWhereUniqueInput[]
    delete?: TechnicienWhereUniqueInput | TechnicienWhereUniqueInput[]
    connect?: TechnicienWhereUniqueInput | TechnicienWhereUniqueInput[]
    update?: TechnicienUpdateWithWhereUniqueWithoutSpecialiteInput | TechnicienUpdateWithWhereUniqueWithoutSpecialiteInput[]
    updateMany?: TechnicienUpdateManyWithWhereWithoutSpecialiteInput | TechnicienUpdateManyWithWhereWithoutSpecialiteInput[]
    deleteMany?: TechnicienScalarWhereInput | TechnicienScalarWhereInput[]
  }

  export type SpecialiteCreateNestedOneWithoutTechniciensInput = {
    create?: XOR<SpecialiteCreateWithoutTechniciensInput, SpecialiteUncheckedCreateWithoutTechniciensInput>
    connectOrCreate?: SpecialiteCreateOrConnectWithoutTechniciensInput
    connect?: SpecialiteWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTechnicienInput = {
    create?: XOR<UserCreateWithoutTechnicienInput, UserUncheckedCreateWithoutTechnicienInput>
    connectOrCreate?: UserCreateOrConnectWithoutTechnicienInput
    connect?: UserWhereUniqueInput
  }

  export type TechnicienInterventionCreateNestedManyWithoutTechnicienInput = {
    create?: XOR<TechnicienInterventionCreateWithoutTechnicienInput, TechnicienInterventionUncheckedCreateWithoutTechnicienInput> | TechnicienInterventionCreateWithoutTechnicienInput[] | TechnicienInterventionUncheckedCreateWithoutTechnicienInput[]
    connectOrCreate?: TechnicienInterventionCreateOrConnectWithoutTechnicienInput | TechnicienInterventionCreateOrConnectWithoutTechnicienInput[]
    createMany?: TechnicienInterventionCreateManyTechnicienInputEnvelope
    connect?: TechnicienInterventionWhereUniqueInput | TechnicienInterventionWhereUniqueInput[]
  }

  export type RapportMissionCreateNestedManyWithoutTechnicienInput = {
    create?: XOR<RapportMissionCreateWithoutTechnicienInput, RapportMissionUncheckedCreateWithoutTechnicienInput> | RapportMissionCreateWithoutTechnicienInput[] | RapportMissionUncheckedCreateWithoutTechnicienInput[]
    connectOrCreate?: RapportMissionCreateOrConnectWithoutTechnicienInput | RapportMissionCreateOrConnectWithoutTechnicienInput[]
    createMany?: RapportMissionCreateManyTechnicienInputEnvelope
    connect?: RapportMissionWhereUniqueInput | RapportMissionWhereUniqueInput[]
  }

  export type SortieMaterielCreateNestedManyWithoutTechnicienInput = {
    create?: XOR<SortieMaterielCreateWithoutTechnicienInput, SortieMaterielUncheckedCreateWithoutTechnicienInput> | SortieMaterielCreateWithoutTechnicienInput[] | SortieMaterielUncheckedCreateWithoutTechnicienInput[]
    connectOrCreate?: SortieMaterielCreateOrConnectWithoutTechnicienInput | SortieMaterielCreateOrConnectWithoutTechnicienInput[]
    createMany?: SortieMaterielCreateManyTechnicienInputEnvelope
    connect?: SortieMaterielWhereUniqueInput | SortieMaterielWhereUniqueInput[]
  }

  export type TechnicienInterventionUncheckedCreateNestedManyWithoutTechnicienInput = {
    create?: XOR<TechnicienInterventionCreateWithoutTechnicienInput, TechnicienInterventionUncheckedCreateWithoutTechnicienInput> | TechnicienInterventionCreateWithoutTechnicienInput[] | TechnicienInterventionUncheckedCreateWithoutTechnicienInput[]
    connectOrCreate?: TechnicienInterventionCreateOrConnectWithoutTechnicienInput | TechnicienInterventionCreateOrConnectWithoutTechnicienInput[]
    createMany?: TechnicienInterventionCreateManyTechnicienInputEnvelope
    connect?: TechnicienInterventionWhereUniqueInput | TechnicienInterventionWhereUniqueInput[]
  }

  export type RapportMissionUncheckedCreateNestedManyWithoutTechnicienInput = {
    create?: XOR<RapportMissionCreateWithoutTechnicienInput, RapportMissionUncheckedCreateWithoutTechnicienInput> | RapportMissionCreateWithoutTechnicienInput[] | RapportMissionUncheckedCreateWithoutTechnicienInput[]
    connectOrCreate?: RapportMissionCreateOrConnectWithoutTechnicienInput | RapportMissionCreateOrConnectWithoutTechnicienInput[]
    createMany?: RapportMissionCreateManyTechnicienInputEnvelope
    connect?: RapportMissionWhereUniqueInput | RapportMissionWhereUniqueInput[]
  }

  export type SortieMaterielUncheckedCreateNestedManyWithoutTechnicienInput = {
    create?: XOR<SortieMaterielCreateWithoutTechnicienInput, SortieMaterielUncheckedCreateWithoutTechnicienInput> | SortieMaterielCreateWithoutTechnicienInput[] | SortieMaterielUncheckedCreateWithoutTechnicienInput[]
    connectOrCreate?: SortieMaterielCreateOrConnectWithoutTechnicienInput | SortieMaterielCreateOrConnectWithoutTechnicienInput[]
    createMany?: SortieMaterielCreateManyTechnicienInputEnvelope
    connect?: SortieMaterielWhereUniqueInput | SortieMaterielWhereUniqueInput[]
  }

  export type SpecialiteUpdateOneRequiredWithoutTechniciensNestedInput = {
    create?: XOR<SpecialiteCreateWithoutTechniciensInput, SpecialiteUncheckedCreateWithoutTechniciensInput>
    connectOrCreate?: SpecialiteCreateOrConnectWithoutTechniciensInput
    upsert?: SpecialiteUpsertWithoutTechniciensInput
    connect?: SpecialiteWhereUniqueInput
    update?: XOR<XOR<SpecialiteUpdateToOneWithWhereWithoutTechniciensInput, SpecialiteUpdateWithoutTechniciensInput>, SpecialiteUncheckedUpdateWithoutTechniciensInput>
  }

  export type UserUpdateOneWithoutTechnicienNestedInput = {
    create?: XOR<UserCreateWithoutTechnicienInput, UserUncheckedCreateWithoutTechnicienInput>
    connectOrCreate?: UserCreateOrConnectWithoutTechnicienInput
    upsert?: UserUpsertWithoutTechnicienInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTechnicienInput, UserUpdateWithoutTechnicienInput>, UserUncheckedUpdateWithoutTechnicienInput>
  }

  export type TechnicienInterventionUpdateManyWithoutTechnicienNestedInput = {
    create?: XOR<TechnicienInterventionCreateWithoutTechnicienInput, TechnicienInterventionUncheckedCreateWithoutTechnicienInput> | TechnicienInterventionCreateWithoutTechnicienInput[] | TechnicienInterventionUncheckedCreateWithoutTechnicienInput[]
    connectOrCreate?: TechnicienInterventionCreateOrConnectWithoutTechnicienInput | TechnicienInterventionCreateOrConnectWithoutTechnicienInput[]
    upsert?: TechnicienInterventionUpsertWithWhereUniqueWithoutTechnicienInput | TechnicienInterventionUpsertWithWhereUniqueWithoutTechnicienInput[]
    createMany?: TechnicienInterventionCreateManyTechnicienInputEnvelope
    set?: TechnicienInterventionWhereUniqueInput | TechnicienInterventionWhereUniqueInput[]
    disconnect?: TechnicienInterventionWhereUniqueInput | TechnicienInterventionWhereUniqueInput[]
    delete?: TechnicienInterventionWhereUniqueInput | TechnicienInterventionWhereUniqueInput[]
    connect?: TechnicienInterventionWhereUniqueInput | TechnicienInterventionWhereUniqueInput[]
    update?: TechnicienInterventionUpdateWithWhereUniqueWithoutTechnicienInput | TechnicienInterventionUpdateWithWhereUniqueWithoutTechnicienInput[]
    updateMany?: TechnicienInterventionUpdateManyWithWhereWithoutTechnicienInput | TechnicienInterventionUpdateManyWithWhereWithoutTechnicienInput[]
    deleteMany?: TechnicienInterventionScalarWhereInput | TechnicienInterventionScalarWhereInput[]
  }

  export type RapportMissionUpdateManyWithoutTechnicienNestedInput = {
    create?: XOR<RapportMissionCreateWithoutTechnicienInput, RapportMissionUncheckedCreateWithoutTechnicienInput> | RapportMissionCreateWithoutTechnicienInput[] | RapportMissionUncheckedCreateWithoutTechnicienInput[]
    connectOrCreate?: RapportMissionCreateOrConnectWithoutTechnicienInput | RapportMissionCreateOrConnectWithoutTechnicienInput[]
    upsert?: RapportMissionUpsertWithWhereUniqueWithoutTechnicienInput | RapportMissionUpsertWithWhereUniqueWithoutTechnicienInput[]
    createMany?: RapportMissionCreateManyTechnicienInputEnvelope
    set?: RapportMissionWhereUniqueInput | RapportMissionWhereUniqueInput[]
    disconnect?: RapportMissionWhereUniqueInput | RapportMissionWhereUniqueInput[]
    delete?: RapportMissionWhereUniqueInput | RapportMissionWhereUniqueInput[]
    connect?: RapportMissionWhereUniqueInput | RapportMissionWhereUniqueInput[]
    update?: RapportMissionUpdateWithWhereUniqueWithoutTechnicienInput | RapportMissionUpdateWithWhereUniqueWithoutTechnicienInput[]
    updateMany?: RapportMissionUpdateManyWithWhereWithoutTechnicienInput | RapportMissionUpdateManyWithWhereWithoutTechnicienInput[]
    deleteMany?: RapportMissionScalarWhereInput | RapportMissionScalarWhereInput[]
  }

  export type SortieMaterielUpdateManyWithoutTechnicienNestedInput = {
    create?: XOR<SortieMaterielCreateWithoutTechnicienInput, SortieMaterielUncheckedCreateWithoutTechnicienInput> | SortieMaterielCreateWithoutTechnicienInput[] | SortieMaterielUncheckedCreateWithoutTechnicienInput[]
    connectOrCreate?: SortieMaterielCreateOrConnectWithoutTechnicienInput | SortieMaterielCreateOrConnectWithoutTechnicienInput[]
    upsert?: SortieMaterielUpsertWithWhereUniqueWithoutTechnicienInput | SortieMaterielUpsertWithWhereUniqueWithoutTechnicienInput[]
    createMany?: SortieMaterielCreateManyTechnicienInputEnvelope
    set?: SortieMaterielWhereUniqueInput | SortieMaterielWhereUniqueInput[]
    disconnect?: SortieMaterielWhereUniqueInput | SortieMaterielWhereUniqueInput[]
    delete?: SortieMaterielWhereUniqueInput | SortieMaterielWhereUniqueInput[]
    connect?: SortieMaterielWhereUniqueInput | SortieMaterielWhereUniqueInput[]
    update?: SortieMaterielUpdateWithWhereUniqueWithoutTechnicienInput | SortieMaterielUpdateWithWhereUniqueWithoutTechnicienInput[]
    updateMany?: SortieMaterielUpdateManyWithWhereWithoutTechnicienInput | SortieMaterielUpdateManyWithWhereWithoutTechnicienInput[]
    deleteMany?: SortieMaterielScalarWhereInput | SortieMaterielScalarWhereInput[]
  }

  export type TechnicienInterventionUncheckedUpdateManyWithoutTechnicienNestedInput = {
    create?: XOR<TechnicienInterventionCreateWithoutTechnicienInput, TechnicienInterventionUncheckedCreateWithoutTechnicienInput> | TechnicienInterventionCreateWithoutTechnicienInput[] | TechnicienInterventionUncheckedCreateWithoutTechnicienInput[]
    connectOrCreate?: TechnicienInterventionCreateOrConnectWithoutTechnicienInput | TechnicienInterventionCreateOrConnectWithoutTechnicienInput[]
    upsert?: TechnicienInterventionUpsertWithWhereUniqueWithoutTechnicienInput | TechnicienInterventionUpsertWithWhereUniqueWithoutTechnicienInput[]
    createMany?: TechnicienInterventionCreateManyTechnicienInputEnvelope
    set?: TechnicienInterventionWhereUniqueInput | TechnicienInterventionWhereUniqueInput[]
    disconnect?: TechnicienInterventionWhereUniqueInput | TechnicienInterventionWhereUniqueInput[]
    delete?: TechnicienInterventionWhereUniqueInput | TechnicienInterventionWhereUniqueInput[]
    connect?: TechnicienInterventionWhereUniqueInput | TechnicienInterventionWhereUniqueInput[]
    update?: TechnicienInterventionUpdateWithWhereUniqueWithoutTechnicienInput | TechnicienInterventionUpdateWithWhereUniqueWithoutTechnicienInput[]
    updateMany?: TechnicienInterventionUpdateManyWithWhereWithoutTechnicienInput | TechnicienInterventionUpdateManyWithWhereWithoutTechnicienInput[]
    deleteMany?: TechnicienInterventionScalarWhereInput | TechnicienInterventionScalarWhereInput[]
  }

  export type RapportMissionUncheckedUpdateManyWithoutTechnicienNestedInput = {
    create?: XOR<RapportMissionCreateWithoutTechnicienInput, RapportMissionUncheckedCreateWithoutTechnicienInput> | RapportMissionCreateWithoutTechnicienInput[] | RapportMissionUncheckedCreateWithoutTechnicienInput[]
    connectOrCreate?: RapportMissionCreateOrConnectWithoutTechnicienInput | RapportMissionCreateOrConnectWithoutTechnicienInput[]
    upsert?: RapportMissionUpsertWithWhereUniqueWithoutTechnicienInput | RapportMissionUpsertWithWhereUniqueWithoutTechnicienInput[]
    createMany?: RapportMissionCreateManyTechnicienInputEnvelope
    set?: RapportMissionWhereUniqueInput | RapportMissionWhereUniqueInput[]
    disconnect?: RapportMissionWhereUniqueInput | RapportMissionWhereUniqueInput[]
    delete?: RapportMissionWhereUniqueInput | RapportMissionWhereUniqueInput[]
    connect?: RapportMissionWhereUniqueInput | RapportMissionWhereUniqueInput[]
    update?: RapportMissionUpdateWithWhereUniqueWithoutTechnicienInput | RapportMissionUpdateWithWhereUniqueWithoutTechnicienInput[]
    updateMany?: RapportMissionUpdateManyWithWhereWithoutTechnicienInput | RapportMissionUpdateManyWithWhereWithoutTechnicienInput[]
    deleteMany?: RapportMissionScalarWhereInput | RapportMissionScalarWhereInput[]
  }

  export type SortieMaterielUncheckedUpdateManyWithoutTechnicienNestedInput = {
    create?: XOR<SortieMaterielCreateWithoutTechnicienInput, SortieMaterielUncheckedCreateWithoutTechnicienInput> | SortieMaterielCreateWithoutTechnicienInput[] | SortieMaterielUncheckedCreateWithoutTechnicienInput[]
    connectOrCreate?: SortieMaterielCreateOrConnectWithoutTechnicienInput | SortieMaterielCreateOrConnectWithoutTechnicienInput[]
    upsert?: SortieMaterielUpsertWithWhereUniqueWithoutTechnicienInput | SortieMaterielUpsertWithWhereUniqueWithoutTechnicienInput[]
    createMany?: SortieMaterielCreateManyTechnicienInputEnvelope
    set?: SortieMaterielWhereUniqueInput | SortieMaterielWhereUniqueInput[]
    disconnect?: SortieMaterielWhereUniqueInput | SortieMaterielWhereUniqueInput[]
    delete?: SortieMaterielWhereUniqueInput | SortieMaterielWhereUniqueInput[]
    connect?: SortieMaterielWhereUniqueInput | SortieMaterielWhereUniqueInput[]
    update?: SortieMaterielUpdateWithWhereUniqueWithoutTechnicienInput | SortieMaterielUpdateWithWhereUniqueWithoutTechnicienInput[]
    updateMany?: SortieMaterielUpdateManyWithWhereWithoutTechnicienInput | SortieMaterielUpdateManyWithWhereWithoutTechnicienInput[]
    deleteMany?: SortieMaterielScalarWhereInput | SortieMaterielScalarWhereInput[]
  }

  export type CustomerCreateNestedOneWithoutMissionsInput = {
    create?: XOR<CustomerCreateWithoutMissionsInput, CustomerUncheckedCreateWithoutMissionsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutMissionsInput
    connect?: CustomerWhereUniqueInput
  }

  export type InterventionCreateNestedManyWithoutMissionInput = {
    create?: XOR<InterventionCreateWithoutMissionInput, InterventionUncheckedCreateWithoutMissionInput> | InterventionCreateWithoutMissionInput[] | InterventionUncheckedCreateWithoutMissionInput[]
    connectOrCreate?: InterventionCreateOrConnectWithoutMissionInput | InterventionCreateOrConnectWithoutMissionInput[]
    createMany?: InterventionCreateManyMissionInputEnvelope
    connect?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
  }

  export type RapportMissionCreateNestedManyWithoutMissionInput = {
    create?: XOR<RapportMissionCreateWithoutMissionInput, RapportMissionUncheckedCreateWithoutMissionInput> | RapportMissionCreateWithoutMissionInput[] | RapportMissionUncheckedCreateWithoutMissionInput[]
    connectOrCreate?: RapportMissionCreateOrConnectWithoutMissionInput | RapportMissionCreateOrConnectWithoutMissionInput[]
    createMany?: RapportMissionCreateManyMissionInputEnvelope
    connect?: RapportMissionWhereUniqueInput | RapportMissionWhereUniqueInput[]
  }

  export type QuoteCreateNestedManyWithoutMissionsInput = {
    create?: XOR<QuoteCreateWithoutMissionsInput, QuoteUncheckedCreateWithoutMissionsInput> | QuoteCreateWithoutMissionsInput[] | QuoteUncheckedCreateWithoutMissionsInput[]
    connectOrCreate?: QuoteCreateOrConnectWithoutMissionsInput | QuoteCreateOrConnectWithoutMissionsInput[]
    connect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
  }

  export type InterventionUncheckedCreateNestedManyWithoutMissionInput = {
    create?: XOR<InterventionCreateWithoutMissionInput, InterventionUncheckedCreateWithoutMissionInput> | InterventionCreateWithoutMissionInput[] | InterventionUncheckedCreateWithoutMissionInput[]
    connectOrCreate?: InterventionCreateOrConnectWithoutMissionInput | InterventionCreateOrConnectWithoutMissionInput[]
    createMany?: InterventionCreateManyMissionInputEnvelope
    connect?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
  }

  export type RapportMissionUncheckedCreateNestedManyWithoutMissionInput = {
    create?: XOR<RapportMissionCreateWithoutMissionInput, RapportMissionUncheckedCreateWithoutMissionInput> | RapportMissionCreateWithoutMissionInput[] | RapportMissionUncheckedCreateWithoutMissionInput[]
    connectOrCreate?: RapportMissionCreateOrConnectWithoutMissionInput | RapportMissionCreateOrConnectWithoutMissionInput[]
    createMany?: RapportMissionCreateManyMissionInputEnvelope
    connect?: RapportMissionWhereUniqueInput | RapportMissionWhereUniqueInput[]
  }

  export type QuoteUncheckedCreateNestedManyWithoutMissionsInput = {
    create?: XOR<QuoteCreateWithoutMissionsInput, QuoteUncheckedCreateWithoutMissionsInput> | QuoteCreateWithoutMissionsInput[] | QuoteUncheckedCreateWithoutMissionsInput[]
    connectOrCreate?: QuoteCreateOrConnectWithoutMissionsInput | QuoteCreateOrConnectWithoutMissionsInput[]
    connect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
  }

  export type CustomerUpdateOneRequiredWithoutMissionsNestedInput = {
    create?: XOR<CustomerCreateWithoutMissionsInput, CustomerUncheckedCreateWithoutMissionsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutMissionsInput
    upsert?: CustomerUpsertWithoutMissionsInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutMissionsInput, CustomerUpdateWithoutMissionsInput>, CustomerUncheckedUpdateWithoutMissionsInput>
  }

  export type InterventionUpdateManyWithoutMissionNestedInput = {
    create?: XOR<InterventionCreateWithoutMissionInput, InterventionUncheckedCreateWithoutMissionInput> | InterventionCreateWithoutMissionInput[] | InterventionUncheckedCreateWithoutMissionInput[]
    connectOrCreate?: InterventionCreateOrConnectWithoutMissionInput | InterventionCreateOrConnectWithoutMissionInput[]
    upsert?: InterventionUpsertWithWhereUniqueWithoutMissionInput | InterventionUpsertWithWhereUniqueWithoutMissionInput[]
    createMany?: InterventionCreateManyMissionInputEnvelope
    set?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
    disconnect?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
    delete?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
    connect?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
    update?: InterventionUpdateWithWhereUniqueWithoutMissionInput | InterventionUpdateWithWhereUniqueWithoutMissionInput[]
    updateMany?: InterventionUpdateManyWithWhereWithoutMissionInput | InterventionUpdateManyWithWhereWithoutMissionInput[]
    deleteMany?: InterventionScalarWhereInput | InterventionScalarWhereInput[]
  }

  export type RapportMissionUpdateManyWithoutMissionNestedInput = {
    create?: XOR<RapportMissionCreateWithoutMissionInput, RapportMissionUncheckedCreateWithoutMissionInput> | RapportMissionCreateWithoutMissionInput[] | RapportMissionUncheckedCreateWithoutMissionInput[]
    connectOrCreate?: RapportMissionCreateOrConnectWithoutMissionInput | RapportMissionCreateOrConnectWithoutMissionInput[]
    upsert?: RapportMissionUpsertWithWhereUniqueWithoutMissionInput | RapportMissionUpsertWithWhereUniqueWithoutMissionInput[]
    createMany?: RapportMissionCreateManyMissionInputEnvelope
    set?: RapportMissionWhereUniqueInput | RapportMissionWhereUniqueInput[]
    disconnect?: RapportMissionWhereUniqueInput | RapportMissionWhereUniqueInput[]
    delete?: RapportMissionWhereUniqueInput | RapportMissionWhereUniqueInput[]
    connect?: RapportMissionWhereUniqueInput | RapportMissionWhereUniqueInput[]
    update?: RapportMissionUpdateWithWhereUniqueWithoutMissionInput | RapportMissionUpdateWithWhereUniqueWithoutMissionInput[]
    updateMany?: RapportMissionUpdateManyWithWhereWithoutMissionInput | RapportMissionUpdateManyWithWhereWithoutMissionInput[]
    deleteMany?: RapportMissionScalarWhereInput | RapportMissionScalarWhereInput[]
  }

  export type QuoteUpdateManyWithoutMissionsNestedInput = {
    create?: XOR<QuoteCreateWithoutMissionsInput, QuoteUncheckedCreateWithoutMissionsInput> | QuoteCreateWithoutMissionsInput[] | QuoteUncheckedCreateWithoutMissionsInput[]
    connectOrCreate?: QuoteCreateOrConnectWithoutMissionsInput | QuoteCreateOrConnectWithoutMissionsInput[]
    upsert?: QuoteUpsertWithWhereUniqueWithoutMissionsInput | QuoteUpsertWithWhereUniqueWithoutMissionsInput[]
    set?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    disconnect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    delete?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    connect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    update?: QuoteUpdateWithWhereUniqueWithoutMissionsInput | QuoteUpdateWithWhereUniqueWithoutMissionsInput[]
    updateMany?: QuoteUpdateManyWithWhereWithoutMissionsInput | QuoteUpdateManyWithWhereWithoutMissionsInput[]
    deleteMany?: QuoteScalarWhereInput | QuoteScalarWhereInput[]
  }

  export type InterventionUncheckedUpdateManyWithoutMissionNestedInput = {
    create?: XOR<InterventionCreateWithoutMissionInput, InterventionUncheckedCreateWithoutMissionInput> | InterventionCreateWithoutMissionInput[] | InterventionUncheckedCreateWithoutMissionInput[]
    connectOrCreate?: InterventionCreateOrConnectWithoutMissionInput | InterventionCreateOrConnectWithoutMissionInput[]
    upsert?: InterventionUpsertWithWhereUniqueWithoutMissionInput | InterventionUpsertWithWhereUniqueWithoutMissionInput[]
    createMany?: InterventionCreateManyMissionInputEnvelope
    set?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
    disconnect?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
    delete?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
    connect?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
    update?: InterventionUpdateWithWhereUniqueWithoutMissionInput | InterventionUpdateWithWhereUniqueWithoutMissionInput[]
    updateMany?: InterventionUpdateManyWithWhereWithoutMissionInput | InterventionUpdateManyWithWhereWithoutMissionInput[]
    deleteMany?: InterventionScalarWhereInput | InterventionScalarWhereInput[]
  }

  export type RapportMissionUncheckedUpdateManyWithoutMissionNestedInput = {
    create?: XOR<RapportMissionCreateWithoutMissionInput, RapportMissionUncheckedCreateWithoutMissionInput> | RapportMissionCreateWithoutMissionInput[] | RapportMissionUncheckedCreateWithoutMissionInput[]
    connectOrCreate?: RapportMissionCreateOrConnectWithoutMissionInput | RapportMissionCreateOrConnectWithoutMissionInput[]
    upsert?: RapportMissionUpsertWithWhereUniqueWithoutMissionInput | RapportMissionUpsertWithWhereUniqueWithoutMissionInput[]
    createMany?: RapportMissionCreateManyMissionInputEnvelope
    set?: RapportMissionWhereUniqueInput | RapportMissionWhereUniqueInput[]
    disconnect?: RapportMissionWhereUniqueInput | RapportMissionWhereUniqueInput[]
    delete?: RapportMissionWhereUniqueInput | RapportMissionWhereUniqueInput[]
    connect?: RapportMissionWhereUniqueInput | RapportMissionWhereUniqueInput[]
    update?: RapportMissionUpdateWithWhereUniqueWithoutMissionInput | RapportMissionUpdateWithWhereUniqueWithoutMissionInput[]
    updateMany?: RapportMissionUpdateManyWithWhereWithoutMissionInput | RapportMissionUpdateManyWithWhereWithoutMissionInput[]
    deleteMany?: RapportMissionScalarWhereInput | RapportMissionScalarWhereInput[]
  }

  export type QuoteUncheckedUpdateManyWithoutMissionsNestedInput = {
    create?: XOR<QuoteCreateWithoutMissionsInput, QuoteUncheckedCreateWithoutMissionsInput> | QuoteCreateWithoutMissionsInput[] | QuoteUncheckedCreateWithoutMissionsInput[]
    connectOrCreate?: QuoteCreateOrConnectWithoutMissionsInput | QuoteCreateOrConnectWithoutMissionsInput[]
    upsert?: QuoteUpsertWithWhereUniqueWithoutMissionsInput | QuoteUpsertWithWhereUniqueWithoutMissionsInput[]
    set?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    disconnect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    delete?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    connect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    update?: QuoteUpdateWithWhereUniqueWithoutMissionsInput | QuoteUpdateWithWhereUniqueWithoutMissionsInput[]
    updateMany?: QuoteUpdateManyWithWhereWithoutMissionsInput | QuoteUpdateManyWithWhereWithoutMissionsInput[]
    deleteMany?: QuoteScalarWhereInput | QuoteScalarWhereInput[]
  }

  export type MissionCreateNestedOneWithoutInterventionsInput = {
    create?: XOR<MissionCreateWithoutInterventionsInput, MissionUncheckedCreateWithoutInterventionsInput>
    connectOrCreate?: MissionCreateOrConnectWithoutInterventionsInput
    connect?: MissionWhereUniqueInput
  }

  export type TechnicienInterventionCreateNestedManyWithoutInterventionInput = {
    create?: XOR<TechnicienInterventionCreateWithoutInterventionInput, TechnicienInterventionUncheckedCreateWithoutInterventionInput> | TechnicienInterventionCreateWithoutInterventionInput[] | TechnicienInterventionUncheckedCreateWithoutInterventionInput[]
    connectOrCreate?: TechnicienInterventionCreateOrConnectWithoutInterventionInput | TechnicienInterventionCreateOrConnectWithoutInterventionInput[]
    createMany?: TechnicienInterventionCreateManyInterventionInputEnvelope
    connect?: TechnicienInterventionWhereUniqueInput | TechnicienInterventionWhereUniqueInput[]
  }

  export type RapportMissionCreateNestedManyWithoutInterventionInput = {
    create?: XOR<RapportMissionCreateWithoutInterventionInput, RapportMissionUncheckedCreateWithoutInterventionInput> | RapportMissionCreateWithoutInterventionInput[] | RapportMissionUncheckedCreateWithoutInterventionInput[]
    connectOrCreate?: RapportMissionCreateOrConnectWithoutInterventionInput | RapportMissionCreateOrConnectWithoutInterventionInput[]
    createMany?: RapportMissionCreateManyInterventionInputEnvelope
    connect?: RapportMissionWhereUniqueInput | RapportMissionWhereUniqueInput[]
  }

  export type SortieMaterielCreateNestedManyWithoutInterventionInput = {
    create?: XOR<SortieMaterielCreateWithoutInterventionInput, SortieMaterielUncheckedCreateWithoutInterventionInput> | SortieMaterielCreateWithoutInterventionInput[] | SortieMaterielUncheckedCreateWithoutInterventionInput[]
    connectOrCreate?: SortieMaterielCreateOrConnectWithoutInterventionInput | SortieMaterielCreateOrConnectWithoutInterventionInput[]
    createMany?: SortieMaterielCreateManyInterventionInputEnvelope
    connect?: SortieMaterielWhereUniqueInput | SortieMaterielWhereUniqueInput[]
  }

  export type TechnicienInterventionUncheckedCreateNestedManyWithoutInterventionInput = {
    create?: XOR<TechnicienInterventionCreateWithoutInterventionInput, TechnicienInterventionUncheckedCreateWithoutInterventionInput> | TechnicienInterventionCreateWithoutInterventionInput[] | TechnicienInterventionUncheckedCreateWithoutInterventionInput[]
    connectOrCreate?: TechnicienInterventionCreateOrConnectWithoutInterventionInput | TechnicienInterventionCreateOrConnectWithoutInterventionInput[]
    createMany?: TechnicienInterventionCreateManyInterventionInputEnvelope
    connect?: TechnicienInterventionWhereUniqueInput | TechnicienInterventionWhereUniqueInput[]
  }

  export type RapportMissionUncheckedCreateNestedManyWithoutInterventionInput = {
    create?: XOR<RapportMissionCreateWithoutInterventionInput, RapportMissionUncheckedCreateWithoutInterventionInput> | RapportMissionCreateWithoutInterventionInput[] | RapportMissionUncheckedCreateWithoutInterventionInput[]
    connectOrCreate?: RapportMissionCreateOrConnectWithoutInterventionInput | RapportMissionCreateOrConnectWithoutInterventionInput[]
    createMany?: RapportMissionCreateManyInterventionInputEnvelope
    connect?: RapportMissionWhereUniqueInput | RapportMissionWhereUniqueInput[]
  }

  export type SortieMaterielUncheckedCreateNestedManyWithoutInterventionInput = {
    create?: XOR<SortieMaterielCreateWithoutInterventionInput, SortieMaterielUncheckedCreateWithoutInterventionInput> | SortieMaterielCreateWithoutInterventionInput[] | SortieMaterielUncheckedCreateWithoutInterventionInput[]
    connectOrCreate?: SortieMaterielCreateOrConnectWithoutInterventionInput | SortieMaterielCreateOrConnectWithoutInterventionInput[]
    createMany?: SortieMaterielCreateManyInterventionInputEnvelope
    connect?: SortieMaterielWhereUniqueInput | SortieMaterielWhereUniqueInput[]
  }

  export type MissionUpdateOneRequiredWithoutInterventionsNestedInput = {
    create?: XOR<MissionCreateWithoutInterventionsInput, MissionUncheckedCreateWithoutInterventionsInput>
    connectOrCreate?: MissionCreateOrConnectWithoutInterventionsInput
    upsert?: MissionUpsertWithoutInterventionsInput
    connect?: MissionWhereUniqueInput
    update?: XOR<XOR<MissionUpdateToOneWithWhereWithoutInterventionsInput, MissionUpdateWithoutInterventionsInput>, MissionUncheckedUpdateWithoutInterventionsInput>
  }

  export type TechnicienInterventionUpdateManyWithoutInterventionNestedInput = {
    create?: XOR<TechnicienInterventionCreateWithoutInterventionInput, TechnicienInterventionUncheckedCreateWithoutInterventionInput> | TechnicienInterventionCreateWithoutInterventionInput[] | TechnicienInterventionUncheckedCreateWithoutInterventionInput[]
    connectOrCreate?: TechnicienInterventionCreateOrConnectWithoutInterventionInput | TechnicienInterventionCreateOrConnectWithoutInterventionInput[]
    upsert?: TechnicienInterventionUpsertWithWhereUniqueWithoutInterventionInput | TechnicienInterventionUpsertWithWhereUniqueWithoutInterventionInput[]
    createMany?: TechnicienInterventionCreateManyInterventionInputEnvelope
    set?: TechnicienInterventionWhereUniqueInput | TechnicienInterventionWhereUniqueInput[]
    disconnect?: TechnicienInterventionWhereUniqueInput | TechnicienInterventionWhereUniqueInput[]
    delete?: TechnicienInterventionWhereUniqueInput | TechnicienInterventionWhereUniqueInput[]
    connect?: TechnicienInterventionWhereUniqueInput | TechnicienInterventionWhereUniqueInput[]
    update?: TechnicienInterventionUpdateWithWhereUniqueWithoutInterventionInput | TechnicienInterventionUpdateWithWhereUniqueWithoutInterventionInput[]
    updateMany?: TechnicienInterventionUpdateManyWithWhereWithoutInterventionInput | TechnicienInterventionUpdateManyWithWhereWithoutInterventionInput[]
    deleteMany?: TechnicienInterventionScalarWhereInput | TechnicienInterventionScalarWhereInput[]
  }

  export type RapportMissionUpdateManyWithoutInterventionNestedInput = {
    create?: XOR<RapportMissionCreateWithoutInterventionInput, RapportMissionUncheckedCreateWithoutInterventionInput> | RapportMissionCreateWithoutInterventionInput[] | RapportMissionUncheckedCreateWithoutInterventionInput[]
    connectOrCreate?: RapportMissionCreateOrConnectWithoutInterventionInput | RapportMissionCreateOrConnectWithoutInterventionInput[]
    upsert?: RapportMissionUpsertWithWhereUniqueWithoutInterventionInput | RapportMissionUpsertWithWhereUniqueWithoutInterventionInput[]
    createMany?: RapportMissionCreateManyInterventionInputEnvelope
    set?: RapportMissionWhereUniqueInput | RapportMissionWhereUniqueInput[]
    disconnect?: RapportMissionWhereUniqueInput | RapportMissionWhereUniqueInput[]
    delete?: RapportMissionWhereUniqueInput | RapportMissionWhereUniqueInput[]
    connect?: RapportMissionWhereUniqueInput | RapportMissionWhereUniqueInput[]
    update?: RapportMissionUpdateWithWhereUniqueWithoutInterventionInput | RapportMissionUpdateWithWhereUniqueWithoutInterventionInput[]
    updateMany?: RapportMissionUpdateManyWithWhereWithoutInterventionInput | RapportMissionUpdateManyWithWhereWithoutInterventionInput[]
    deleteMany?: RapportMissionScalarWhereInput | RapportMissionScalarWhereInput[]
  }

  export type SortieMaterielUpdateManyWithoutInterventionNestedInput = {
    create?: XOR<SortieMaterielCreateWithoutInterventionInput, SortieMaterielUncheckedCreateWithoutInterventionInput> | SortieMaterielCreateWithoutInterventionInput[] | SortieMaterielUncheckedCreateWithoutInterventionInput[]
    connectOrCreate?: SortieMaterielCreateOrConnectWithoutInterventionInput | SortieMaterielCreateOrConnectWithoutInterventionInput[]
    upsert?: SortieMaterielUpsertWithWhereUniqueWithoutInterventionInput | SortieMaterielUpsertWithWhereUniqueWithoutInterventionInput[]
    createMany?: SortieMaterielCreateManyInterventionInputEnvelope
    set?: SortieMaterielWhereUniqueInput | SortieMaterielWhereUniqueInput[]
    disconnect?: SortieMaterielWhereUniqueInput | SortieMaterielWhereUniqueInput[]
    delete?: SortieMaterielWhereUniqueInput | SortieMaterielWhereUniqueInput[]
    connect?: SortieMaterielWhereUniqueInput | SortieMaterielWhereUniqueInput[]
    update?: SortieMaterielUpdateWithWhereUniqueWithoutInterventionInput | SortieMaterielUpdateWithWhereUniqueWithoutInterventionInput[]
    updateMany?: SortieMaterielUpdateManyWithWhereWithoutInterventionInput | SortieMaterielUpdateManyWithWhereWithoutInterventionInput[]
    deleteMany?: SortieMaterielScalarWhereInput | SortieMaterielScalarWhereInput[]
  }

  export type TechnicienInterventionUncheckedUpdateManyWithoutInterventionNestedInput = {
    create?: XOR<TechnicienInterventionCreateWithoutInterventionInput, TechnicienInterventionUncheckedCreateWithoutInterventionInput> | TechnicienInterventionCreateWithoutInterventionInput[] | TechnicienInterventionUncheckedCreateWithoutInterventionInput[]
    connectOrCreate?: TechnicienInterventionCreateOrConnectWithoutInterventionInput | TechnicienInterventionCreateOrConnectWithoutInterventionInput[]
    upsert?: TechnicienInterventionUpsertWithWhereUniqueWithoutInterventionInput | TechnicienInterventionUpsertWithWhereUniqueWithoutInterventionInput[]
    createMany?: TechnicienInterventionCreateManyInterventionInputEnvelope
    set?: TechnicienInterventionWhereUniqueInput | TechnicienInterventionWhereUniqueInput[]
    disconnect?: TechnicienInterventionWhereUniqueInput | TechnicienInterventionWhereUniqueInput[]
    delete?: TechnicienInterventionWhereUniqueInput | TechnicienInterventionWhereUniqueInput[]
    connect?: TechnicienInterventionWhereUniqueInput | TechnicienInterventionWhereUniqueInput[]
    update?: TechnicienInterventionUpdateWithWhereUniqueWithoutInterventionInput | TechnicienInterventionUpdateWithWhereUniqueWithoutInterventionInput[]
    updateMany?: TechnicienInterventionUpdateManyWithWhereWithoutInterventionInput | TechnicienInterventionUpdateManyWithWhereWithoutInterventionInput[]
    deleteMany?: TechnicienInterventionScalarWhereInput | TechnicienInterventionScalarWhereInput[]
  }

  export type RapportMissionUncheckedUpdateManyWithoutInterventionNestedInput = {
    create?: XOR<RapportMissionCreateWithoutInterventionInput, RapportMissionUncheckedCreateWithoutInterventionInput> | RapportMissionCreateWithoutInterventionInput[] | RapportMissionUncheckedCreateWithoutInterventionInput[]
    connectOrCreate?: RapportMissionCreateOrConnectWithoutInterventionInput | RapportMissionCreateOrConnectWithoutInterventionInput[]
    upsert?: RapportMissionUpsertWithWhereUniqueWithoutInterventionInput | RapportMissionUpsertWithWhereUniqueWithoutInterventionInput[]
    createMany?: RapportMissionCreateManyInterventionInputEnvelope
    set?: RapportMissionWhereUniqueInput | RapportMissionWhereUniqueInput[]
    disconnect?: RapportMissionWhereUniqueInput | RapportMissionWhereUniqueInput[]
    delete?: RapportMissionWhereUniqueInput | RapportMissionWhereUniqueInput[]
    connect?: RapportMissionWhereUniqueInput | RapportMissionWhereUniqueInput[]
    update?: RapportMissionUpdateWithWhereUniqueWithoutInterventionInput | RapportMissionUpdateWithWhereUniqueWithoutInterventionInput[]
    updateMany?: RapportMissionUpdateManyWithWhereWithoutInterventionInput | RapportMissionUpdateManyWithWhereWithoutInterventionInput[]
    deleteMany?: RapportMissionScalarWhereInput | RapportMissionScalarWhereInput[]
  }

  export type SortieMaterielUncheckedUpdateManyWithoutInterventionNestedInput = {
    create?: XOR<SortieMaterielCreateWithoutInterventionInput, SortieMaterielUncheckedCreateWithoutInterventionInput> | SortieMaterielCreateWithoutInterventionInput[] | SortieMaterielUncheckedCreateWithoutInterventionInput[]
    connectOrCreate?: SortieMaterielCreateOrConnectWithoutInterventionInput | SortieMaterielCreateOrConnectWithoutInterventionInput[]
    upsert?: SortieMaterielUpsertWithWhereUniqueWithoutInterventionInput | SortieMaterielUpsertWithWhereUniqueWithoutInterventionInput[]
    createMany?: SortieMaterielCreateManyInterventionInputEnvelope
    set?: SortieMaterielWhereUniqueInput | SortieMaterielWhereUniqueInput[]
    disconnect?: SortieMaterielWhereUniqueInput | SortieMaterielWhereUniqueInput[]
    delete?: SortieMaterielWhereUniqueInput | SortieMaterielWhereUniqueInput[]
    connect?: SortieMaterielWhereUniqueInput | SortieMaterielWhereUniqueInput[]
    update?: SortieMaterielUpdateWithWhereUniqueWithoutInterventionInput | SortieMaterielUpdateWithWhereUniqueWithoutInterventionInput[]
    updateMany?: SortieMaterielUpdateManyWithWhereWithoutInterventionInput | SortieMaterielUpdateManyWithWhereWithoutInterventionInput[]
    deleteMany?: SortieMaterielScalarWhereInput | SortieMaterielScalarWhereInput[]
  }

  export type TechnicienCreateNestedOneWithoutInterventionsInput = {
    create?: XOR<TechnicienCreateWithoutInterventionsInput, TechnicienUncheckedCreateWithoutInterventionsInput>
    connectOrCreate?: TechnicienCreateOrConnectWithoutInterventionsInput
    connect?: TechnicienWhereUniqueInput
  }

  export type InterventionCreateNestedOneWithoutTechniciensInput = {
    create?: XOR<InterventionCreateWithoutTechniciensInput, InterventionUncheckedCreateWithoutTechniciensInput>
    connectOrCreate?: InterventionCreateOrConnectWithoutTechniciensInput
    connect?: InterventionWhereUniqueInput
  }

  export type TechnicienUpdateOneRequiredWithoutInterventionsNestedInput = {
    create?: XOR<TechnicienCreateWithoutInterventionsInput, TechnicienUncheckedCreateWithoutInterventionsInput>
    connectOrCreate?: TechnicienCreateOrConnectWithoutInterventionsInput
    upsert?: TechnicienUpsertWithoutInterventionsInput
    connect?: TechnicienWhereUniqueInput
    update?: XOR<XOR<TechnicienUpdateToOneWithWhereWithoutInterventionsInput, TechnicienUpdateWithoutInterventionsInput>, TechnicienUncheckedUpdateWithoutInterventionsInput>
  }

  export type InterventionUpdateOneRequiredWithoutTechniciensNestedInput = {
    create?: XOR<InterventionCreateWithoutTechniciensInput, InterventionUncheckedCreateWithoutTechniciensInput>
    connectOrCreate?: InterventionCreateOrConnectWithoutTechniciensInput
    upsert?: InterventionUpsertWithoutTechniciensInput
    connect?: InterventionWhereUniqueInput
    update?: XOR<XOR<InterventionUpdateToOneWithWhereWithoutTechniciensInput, InterventionUpdateWithoutTechniciensInput>, InterventionUncheckedUpdateWithoutTechniciensInput>
  }

  export type InterventionCreateNestedOneWithoutRapportsInput = {
    create?: XOR<InterventionCreateWithoutRapportsInput, InterventionUncheckedCreateWithoutRapportsInput>
    connectOrCreate?: InterventionCreateOrConnectWithoutRapportsInput
    connect?: InterventionWhereUniqueInput
  }

  export type TechnicienCreateNestedOneWithoutRapportsInput = {
    create?: XOR<TechnicienCreateWithoutRapportsInput, TechnicienUncheckedCreateWithoutRapportsInput>
    connectOrCreate?: TechnicienCreateOrConnectWithoutRapportsInput
    connect?: TechnicienWhereUniqueInput
  }

  export type MissionCreateNestedOneWithoutRapportsInput = {
    create?: XOR<MissionCreateWithoutRapportsInput, MissionUncheckedCreateWithoutRapportsInput>
    connectOrCreate?: MissionCreateOrConnectWithoutRapportsInput
    connect?: MissionWhereUniqueInput
  }

  export type RapportImageCreateNestedManyWithoutRapportInput = {
    create?: XOR<RapportImageCreateWithoutRapportInput, RapportImageUncheckedCreateWithoutRapportInput> | RapportImageCreateWithoutRapportInput[] | RapportImageUncheckedCreateWithoutRapportInput[]
    connectOrCreate?: RapportImageCreateOrConnectWithoutRapportInput | RapportImageCreateOrConnectWithoutRapportInput[]
    createMany?: RapportImageCreateManyRapportInputEnvelope
    connect?: RapportImageWhereUniqueInput | RapportImageWhereUniqueInput[]
  }

  export type RapportImageUncheckedCreateNestedManyWithoutRapportInput = {
    create?: XOR<RapportImageCreateWithoutRapportInput, RapportImageUncheckedCreateWithoutRapportInput> | RapportImageCreateWithoutRapportInput[] | RapportImageUncheckedCreateWithoutRapportInput[]
    connectOrCreate?: RapportImageCreateOrConnectWithoutRapportInput | RapportImageCreateOrConnectWithoutRapportInput[]
    createMany?: RapportImageCreateManyRapportInputEnvelope
    connect?: RapportImageWhereUniqueInput | RapportImageWhereUniqueInput[]
  }

  export type InterventionUpdateOneWithoutRapportsNestedInput = {
    create?: XOR<InterventionCreateWithoutRapportsInput, InterventionUncheckedCreateWithoutRapportsInput>
    connectOrCreate?: InterventionCreateOrConnectWithoutRapportsInput
    upsert?: InterventionUpsertWithoutRapportsInput
    disconnect?: InterventionWhereInput | boolean
    delete?: InterventionWhereInput | boolean
    connect?: InterventionWhereUniqueInput
    update?: XOR<XOR<InterventionUpdateToOneWithWhereWithoutRapportsInput, InterventionUpdateWithoutRapportsInput>, InterventionUncheckedUpdateWithoutRapportsInput>
  }

  export type TechnicienUpdateOneRequiredWithoutRapportsNestedInput = {
    create?: XOR<TechnicienCreateWithoutRapportsInput, TechnicienUncheckedCreateWithoutRapportsInput>
    connectOrCreate?: TechnicienCreateOrConnectWithoutRapportsInput
    upsert?: TechnicienUpsertWithoutRapportsInput
    connect?: TechnicienWhereUniqueInput
    update?: XOR<XOR<TechnicienUpdateToOneWithWhereWithoutRapportsInput, TechnicienUpdateWithoutRapportsInput>, TechnicienUncheckedUpdateWithoutRapportsInput>
  }

  export type MissionUpdateOneRequiredWithoutRapportsNestedInput = {
    create?: XOR<MissionCreateWithoutRapportsInput, MissionUncheckedCreateWithoutRapportsInput>
    connectOrCreate?: MissionCreateOrConnectWithoutRapportsInput
    upsert?: MissionUpsertWithoutRapportsInput
    connect?: MissionWhereUniqueInput
    update?: XOR<XOR<MissionUpdateToOneWithWhereWithoutRapportsInput, MissionUpdateWithoutRapportsInput>, MissionUncheckedUpdateWithoutRapportsInput>
  }

  export type RapportImageUpdateManyWithoutRapportNestedInput = {
    create?: XOR<RapportImageCreateWithoutRapportInput, RapportImageUncheckedCreateWithoutRapportInput> | RapportImageCreateWithoutRapportInput[] | RapportImageUncheckedCreateWithoutRapportInput[]
    connectOrCreate?: RapportImageCreateOrConnectWithoutRapportInput | RapportImageCreateOrConnectWithoutRapportInput[]
    upsert?: RapportImageUpsertWithWhereUniqueWithoutRapportInput | RapportImageUpsertWithWhereUniqueWithoutRapportInput[]
    createMany?: RapportImageCreateManyRapportInputEnvelope
    set?: RapportImageWhereUniqueInput | RapportImageWhereUniqueInput[]
    disconnect?: RapportImageWhereUniqueInput | RapportImageWhereUniqueInput[]
    delete?: RapportImageWhereUniqueInput | RapportImageWhereUniqueInput[]
    connect?: RapportImageWhereUniqueInput | RapportImageWhereUniqueInput[]
    update?: RapportImageUpdateWithWhereUniqueWithoutRapportInput | RapportImageUpdateWithWhereUniqueWithoutRapportInput[]
    updateMany?: RapportImageUpdateManyWithWhereWithoutRapportInput | RapportImageUpdateManyWithWhereWithoutRapportInput[]
    deleteMany?: RapportImageScalarWhereInput | RapportImageScalarWhereInput[]
  }

  export type RapportImageUncheckedUpdateManyWithoutRapportNestedInput = {
    create?: XOR<RapportImageCreateWithoutRapportInput, RapportImageUncheckedCreateWithoutRapportInput> | RapportImageCreateWithoutRapportInput[] | RapportImageUncheckedCreateWithoutRapportInput[]
    connectOrCreate?: RapportImageCreateOrConnectWithoutRapportInput | RapportImageCreateOrConnectWithoutRapportInput[]
    upsert?: RapportImageUpsertWithWhereUniqueWithoutRapportInput | RapportImageUpsertWithWhereUniqueWithoutRapportInput[]
    createMany?: RapportImageCreateManyRapportInputEnvelope
    set?: RapportImageWhereUniqueInput | RapportImageWhereUniqueInput[]
    disconnect?: RapportImageWhereUniqueInput | RapportImageWhereUniqueInput[]
    delete?: RapportImageWhereUniqueInput | RapportImageWhereUniqueInput[]
    connect?: RapportImageWhereUniqueInput | RapportImageWhereUniqueInput[]
    update?: RapportImageUpdateWithWhereUniqueWithoutRapportInput | RapportImageUpdateWithWhereUniqueWithoutRapportInput[]
    updateMany?: RapportImageUpdateManyWithWhereWithoutRapportInput | RapportImageUpdateManyWithWhereWithoutRapportInput[]
    deleteMany?: RapportImageScalarWhereInput | RapportImageScalarWhereInput[]
  }

  export type RapportMissionCreateNestedOneWithoutImagesInput = {
    create?: XOR<RapportMissionCreateWithoutImagesInput, RapportMissionUncheckedCreateWithoutImagesInput>
    connectOrCreate?: RapportMissionCreateOrConnectWithoutImagesInput
    connect?: RapportMissionWhereUniqueInput
  }

  export type RapportMissionUpdateOneRequiredWithoutImagesNestedInput = {
    create?: XOR<RapportMissionCreateWithoutImagesInput, RapportMissionUncheckedCreateWithoutImagesInput>
    connectOrCreate?: RapportMissionCreateOrConnectWithoutImagesInput
    upsert?: RapportMissionUpsertWithoutImagesInput
    connect?: RapportMissionWhereUniqueInput
    update?: XOR<XOR<RapportMissionUpdateToOneWithWhereWithoutImagesInput, RapportMissionUpdateWithoutImagesInput>, RapportMissionUncheckedUpdateWithoutImagesInput>
  }

  export type SortieMaterielCreateNestedManyWithoutMaterielInput = {
    create?: XOR<SortieMaterielCreateWithoutMaterielInput, SortieMaterielUncheckedCreateWithoutMaterielInput> | SortieMaterielCreateWithoutMaterielInput[] | SortieMaterielUncheckedCreateWithoutMaterielInput[]
    connectOrCreate?: SortieMaterielCreateOrConnectWithoutMaterielInput | SortieMaterielCreateOrConnectWithoutMaterielInput[]
    createMany?: SortieMaterielCreateManyMaterielInputEnvelope
    connect?: SortieMaterielWhereUniqueInput | SortieMaterielWhereUniqueInput[]
  }

  export type EntreeMaterielCreateNestedManyWithoutMaterielInput = {
    create?: XOR<EntreeMaterielCreateWithoutMaterielInput, EntreeMaterielUncheckedCreateWithoutMaterielInput> | EntreeMaterielCreateWithoutMaterielInput[] | EntreeMaterielUncheckedCreateWithoutMaterielInput[]
    connectOrCreate?: EntreeMaterielCreateOrConnectWithoutMaterielInput | EntreeMaterielCreateOrConnectWithoutMaterielInput[]
    createMany?: EntreeMaterielCreateManyMaterielInputEnvelope
    connect?: EntreeMaterielWhereUniqueInput | EntreeMaterielWhereUniqueInput[]
  }

  export type SortieMaterielUncheckedCreateNestedManyWithoutMaterielInput = {
    create?: XOR<SortieMaterielCreateWithoutMaterielInput, SortieMaterielUncheckedCreateWithoutMaterielInput> | SortieMaterielCreateWithoutMaterielInput[] | SortieMaterielUncheckedCreateWithoutMaterielInput[]
    connectOrCreate?: SortieMaterielCreateOrConnectWithoutMaterielInput | SortieMaterielCreateOrConnectWithoutMaterielInput[]
    createMany?: SortieMaterielCreateManyMaterielInputEnvelope
    connect?: SortieMaterielWhereUniqueInput | SortieMaterielWhereUniqueInput[]
  }

  export type EntreeMaterielUncheckedCreateNestedManyWithoutMaterielInput = {
    create?: XOR<EntreeMaterielCreateWithoutMaterielInput, EntreeMaterielUncheckedCreateWithoutMaterielInput> | EntreeMaterielCreateWithoutMaterielInput[] | EntreeMaterielUncheckedCreateWithoutMaterielInput[]
    connectOrCreate?: EntreeMaterielCreateOrConnectWithoutMaterielInput | EntreeMaterielCreateOrConnectWithoutMaterielInput[]
    createMany?: EntreeMaterielCreateManyMaterielInputEnvelope
    connect?: EntreeMaterielWhereUniqueInput | EntreeMaterielWhereUniqueInput[]
  }

  export type SortieMaterielUpdateManyWithoutMaterielNestedInput = {
    create?: XOR<SortieMaterielCreateWithoutMaterielInput, SortieMaterielUncheckedCreateWithoutMaterielInput> | SortieMaterielCreateWithoutMaterielInput[] | SortieMaterielUncheckedCreateWithoutMaterielInput[]
    connectOrCreate?: SortieMaterielCreateOrConnectWithoutMaterielInput | SortieMaterielCreateOrConnectWithoutMaterielInput[]
    upsert?: SortieMaterielUpsertWithWhereUniqueWithoutMaterielInput | SortieMaterielUpsertWithWhereUniqueWithoutMaterielInput[]
    createMany?: SortieMaterielCreateManyMaterielInputEnvelope
    set?: SortieMaterielWhereUniqueInput | SortieMaterielWhereUniqueInput[]
    disconnect?: SortieMaterielWhereUniqueInput | SortieMaterielWhereUniqueInput[]
    delete?: SortieMaterielWhereUniqueInput | SortieMaterielWhereUniqueInput[]
    connect?: SortieMaterielWhereUniqueInput | SortieMaterielWhereUniqueInput[]
    update?: SortieMaterielUpdateWithWhereUniqueWithoutMaterielInput | SortieMaterielUpdateWithWhereUniqueWithoutMaterielInput[]
    updateMany?: SortieMaterielUpdateManyWithWhereWithoutMaterielInput | SortieMaterielUpdateManyWithWhereWithoutMaterielInput[]
    deleteMany?: SortieMaterielScalarWhereInput | SortieMaterielScalarWhereInput[]
  }

  export type EntreeMaterielUpdateManyWithoutMaterielNestedInput = {
    create?: XOR<EntreeMaterielCreateWithoutMaterielInput, EntreeMaterielUncheckedCreateWithoutMaterielInput> | EntreeMaterielCreateWithoutMaterielInput[] | EntreeMaterielUncheckedCreateWithoutMaterielInput[]
    connectOrCreate?: EntreeMaterielCreateOrConnectWithoutMaterielInput | EntreeMaterielCreateOrConnectWithoutMaterielInput[]
    upsert?: EntreeMaterielUpsertWithWhereUniqueWithoutMaterielInput | EntreeMaterielUpsertWithWhereUniqueWithoutMaterielInput[]
    createMany?: EntreeMaterielCreateManyMaterielInputEnvelope
    set?: EntreeMaterielWhereUniqueInput | EntreeMaterielWhereUniqueInput[]
    disconnect?: EntreeMaterielWhereUniqueInput | EntreeMaterielWhereUniqueInput[]
    delete?: EntreeMaterielWhereUniqueInput | EntreeMaterielWhereUniqueInput[]
    connect?: EntreeMaterielWhereUniqueInput | EntreeMaterielWhereUniqueInput[]
    update?: EntreeMaterielUpdateWithWhereUniqueWithoutMaterielInput | EntreeMaterielUpdateWithWhereUniqueWithoutMaterielInput[]
    updateMany?: EntreeMaterielUpdateManyWithWhereWithoutMaterielInput | EntreeMaterielUpdateManyWithWhereWithoutMaterielInput[]
    deleteMany?: EntreeMaterielScalarWhereInput | EntreeMaterielScalarWhereInput[]
  }

  export type SortieMaterielUncheckedUpdateManyWithoutMaterielNestedInput = {
    create?: XOR<SortieMaterielCreateWithoutMaterielInput, SortieMaterielUncheckedCreateWithoutMaterielInput> | SortieMaterielCreateWithoutMaterielInput[] | SortieMaterielUncheckedCreateWithoutMaterielInput[]
    connectOrCreate?: SortieMaterielCreateOrConnectWithoutMaterielInput | SortieMaterielCreateOrConnectWithoutMaterielInput[]
    upsert?: SortieMaterielUpsertWithWhereUniqueWithoutMaterielInput | SortieMaterielUpsertWithWhereUniqueWithoutMaterielInput[]
    createMany?: SortieMaterielCreateManyMaterielInputEnvelope
    set?: SortieMaterielWhereUniqueInput | SortieMaterielWhereUniqueInput[]
    disconnect?: SortieMaterielWhereUniqueInput | SortieMaterielWhereUniqueInput[]
    delete?: SortieMaterielWhereUniqueInput | SortieMaterielWhereUniqueInput[]
    connect?: SortieMaterielWhereUniqueInput | SortieMaterielWhereUniqueInput[]
    update?: SortieMaterielUpdateWithWhereUniqueWithoutMaterielInput | SortieMaterielUpdateWithWhereUniqueWithoutMaterielInput[]
    updateMany?: SortieMaterielUpdateManyWithWhereWithoutMaterielInput | SortieMaterielUpdateManyWithWhereWithoutMaterielInput[]
    deleteMany?: SortieMaterielScalarWhereInput | SortieMaterielScalarWhereInput[]
  }

  export type EntreeMaterielUncheckedUpdateManyWithoutMaterielNestedInput = {
    create?: XOR<EntreeMaterielCreateWithoutMaterielInput, EntreeMaterielUncheckedCreateWithoutMaterielInput> | EntreeMaterielCreateWithoutMaterielInput[] | EntreeMaterielUncheckedCreateWithoutMaterielInput[]
    connectOrCreate?: EntreeMaterielCreateOrConnectWithoutMaterielInput | EntreeMaterielCreateOrConnectWithoutMaterielInput[]
    upsert?: EntreeMaterielUpsertWithWhereUniqueWithoutMaterielInput | EntreeMaterielUpsertWithWhereUniqueWithoutMaterielInput[]
    createMany?: EntreeMaterielCreateManyMaterielInputEnvelope
    set?: EntreeMaterielWhereUniqueInput | EntreeMaterielWhereUniqueInput[]
    disconnect?: EntreeMaterielWhereUniqueInput | EntreeMaterielWhereUniqueInput[]
    delete?: EntreeMaterielWhereUniqueInput | EntreeMaterielWhereUniqueInput[]
    connect?: EntreeMaterielWhereUniqueInput | EntreeMaterielWhereUniqueInput[]
    update?: EntreeMaterielUpdateWithWhereUniqueWithoutMaterielInput | EntreeMaterielUpdateWithWhereUniqueWithoutMaterielInput[]
    updateMany?: EntreeMaterielUpdateManyWithWhereWithoutMaterielInput | EntreeMaterielUpdateManyWithWhereWithoutMaterielInput[]
    deleteMany?: EntreeMaterielScalarWhereInput | EntreeMaterielScalarWhereInput[]
  }

  export type MaterielCreateNestedOneWithoutSortiesInput = {
    create?: XOR<MaterielCreateWithoutSortiesInput, MaterielUncheckedCreateWithoutSortiesInput>
    connectOrCreate?: MaterielCreateOrConnectWithoutSortiesInput
    connect?: MaterielWhereUniqueInput
  }

  export type InterventionCreateNestedOneWithoutSortiesMaterielsInput = {
    create?: XOR<InterventionCreateWithoutSortiesMaterielsInput, InterventionUncheckedCreateWithoutSortiesMaterielsInput>
    connectOrCreate?: InterventionCreateOrConnectWithoutSortiesMaterielsInput
    connect?: InterventionWhereUniqueInput
  }

  export type TechnicienCreateNestedOneWithoutSortiesMaterielsInput = {
    create?: XOR<TechnicienCreateWithoutSortiesMaterielsInput, TechnicienUncheckedCreateWithoutSortiesMaterielsInput>
    connectOrCreate?: TechnicienCreateOrConnectWithoutSortiesMaterielsInput
    connect?: TechnicienWhereUniqueInput
  }

  export type MaterielUpdateOneRequiredWithoutSortiesNestedInput = {
    create?: XOR<MaterielCreateWithoutSortiesInput, MaterielUncheckedCreateWithoutSortiesInput>
    connectOrCreate?: MaterielCreateOrConnectWithoutSortiesInput
    upsert?: MaterielUpsertWithoutSortiesInput
    connect?: MaterielWhereUniqueInput
    update?: XOR<XOR<MaterielUpdateToOneWithWhereWithoutSortiesInput, MaterielUpdateWithoutSortiesInput>, MaterielUncheckedUpdateWithoutSortiesInput>
  }

  export type InterventionUpdateOneRequiredWithoutSortiesMaterielsNestedInput = {
    create?: XOR<InterventionCreateWithoutSortiesMaterielsInput, InterventionUncheckedCreateWithoutSortiesMaterielsInput>
    connectOrCreate?: InterventionCreateOrConnectWithoutSortiesMaterielsInput
    upsert?: InterventionUpsertWithoutSortiesMaterielsInput
    connect?: InterventionWhereUniqueInput
    update?: XOR<XOR<InterventionUpdateToOneWithWhereWithoutSortiesMaterielsInput, InterventionUpdateWithoutSortiesMaterielsInput>, InterventionUncheckedUpdateWithoutSortiesMaterielsInput>
  }

  export type TechnicienUpdateOneRequiredWithoutSortiesMaterielsNestedInput = {
    create?: XOR<TechnicienCreateWithoutSortiesMaterielsInput, TechnicienUncheckedCreateWithoutSortiesMaterielsInput>
    connectOrCreate?: TechnicienCreateOrConnectWithoutSortiesMaterielsInput
    upsert?: TechnicienUpsertWithoutSortiesMaterielsInput
    connect?: TechnicienWhereUniqueInput
    update?: XOR<XOR<TechnicienUpdateToOneWithWhereWithoutSortiesMaterielsInput, TechnicienUpdateWithoutSortiesMaterielsInput>, TechnicienUncheckedUpdateWithoutSortiesMaterielsInput>
  }

  export type MaterielCreateNestedOneWithoutEntreesInput = {
    create?: XOR<MaterielCreateWithoutEntreesInput, MaterielUncheckedCreateWithoutEntreesInput>
    connectOrCreate?: MaterielCreateOrConnectWithoutEntreesInput
    connect?: MaterielWhereUniqueInput
  }

  export type MaterielUpdateOneRequiredWithoutEntreesNestedInput = {
    create?: XOR<MaterielCreateWithoutEntreesInput, MaterielUncheckedCreateWithoutEntreesInput>
    connectOrCreate?: MaterielCreateOrConnectWithoutEntreesInput
    upsert?: MaterielUpsertWithoutEntreesInput
    connect?: MaterielWhereUniqueInput
    update?: XOR<XOR<MaterielUpdateToOneWithWhereWithoutEntreesInput, MaterielUpdateWithoutEntreesInput>, MaterielUncheckedUpdateWithoutEntreesInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumCustomerTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CustomerType | EnumCustomerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CustomerType[] | ListEnumCustomerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CustomerType[] | ListEnumCustomerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCustomerTypeFilter<$PrismaModel> | $Enums.CustomerType
  }

  export type NestedEnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type NestedEnumCustomerTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CustomerType | EnumCustomerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CustomerType[] | ListEnumCustomerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CustomerType[] | ListEnumCustomerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCustomerTypeWithAggregatesFilter<$PrismaModel> | $Enums.CustomerType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCustomerTypeFilter<$PrismaModel>
    _max?: NestedEnumCustomerTypeFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumAddressTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AddressType | EnumAddressTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AddressType[] | ListEnumAddressTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AddressType[] | ListEnumAddressTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAddressTypeFilter<$PrismaModel> | $Enums.AddressType
  }

  export type NestedEnumAddressTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AddressType | EnumAddressTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AddressType[] | ListEnumAddressTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AddressType[] | ListEnumAddressTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAddressTypeWithAggregatesFilter<$PrismaModel> | $Enums.AddressType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAddressTypeFilter<$PrismaModel>
    _max?: NestedEnumAddressTypeFilter<$PrismaModel>
  }

  export type NestedEnumProductTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductType | EnumProductTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProductTypeFilter<$PrismaModel> | $Enums.ProductType
  }

  export type NestedEnumProductTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductType | EnumProductTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProductTypeWithAggregatesFilter<$PrismaModel> | $Enums.ProductType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProductTypeFilter<$PrismaModel>
    _max?: NestedEnumProductTypeFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumQuoteStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.QuoteStatus | EnumQuoteStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QuoteStatus[] | ListEnumQuoteStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuoteStatus[] | ListEnumQuoteStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQuoteStatusFilter<$PrismaModel> | $Enums.QuoteStatus
  }

  export type NestedEnumQuoteStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuoteStatus | EnumQuoteStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QuoteStatus[] | ListEnumQuoteStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuoteStatus[] | ListEnumQuoteStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQuoteStatusWithAggregatesFilter<$PrismaModel> | $Enums.QuoteStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuoteStatusFilter<$PrismaModel>
    _max?: NestedEnumQuoteStatusFilter<$PrismaModel>
  }

  export type NestedEnumApprovalLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.ApprovalLevel | EnumApprovalLevelFieldRefInput<$PrismaModel>
    in?: $Enums.ApprovalLevel[] | ListEnumApprovalLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApprovalLevel[] | ListEnumApprovalLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumApprovalLevelFilter<$PrismaModel> | $Enums.ApprovalLevel
  }

  export type NestedEnumApprovalStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ApprovalStatus | EnumApprovalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApprovalStatusFilter<$PrismaModel> | $Enums.ApprovalStatus
  }

  export type NestedEnumApprovalLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApprovalLevel | EnumApprovalLevelFieldRefInput<$PrismaModel>
    in?: $Enums.ApprovalLevel[] | ListEnumApprovalLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApprovalLevel[] | ListEnumApprovalLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumApprovalLevelWithAggregatesFilter<$PrismaModel> | $Enums.ApprovalLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApprovalLevelFilter<$PrismaModel>
    _max?: NestedEnumApprovalLevelFilter<$PrismaModel>
  }

  export type NestedEnumApprovalStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApprovalStatus | EnumApprovalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApprovalStatusWithAggregatesFilter<$PrismaModel> | $Enums.ApprovalStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApprovalStatusFilter<$PrismaModel>
    _max?: NestedEnumApprovalStatusFilter<$PrismaModel>
  }

  export type NestedEnumInvoiceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceType | EnumInvoiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceType[] | ListEnumInvoiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceType[] | ListEnumInvoiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceTypeFilter<$PrismaModel> | $Enums.InvoiceType
  }

  export type NestedEnumInvoiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusFilter<$PrismaModel> | $Enums.InvoiceStatus
  }

  export type NestedEnumInvoiceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceType | EnumInvoiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceType[] | ListEnumInvoiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceType[] | ListEnumInvoiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceTypeWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceTypeFilter<$PrismaModel>
    _max?: NestedEnumInvoiceTypeFilter<$PrismaModel>
  }

  export type NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceStatusFilter<$PrismaModel>
    _max?: NestedEnumInvoiceStatusFilter<$PrismaModel>
  }

  export type NestedEnumRecurringFrequencyFilter<$PrismaModel = never> = {
    equals?: $Enums.RecurringFrequency | EnumRecurringFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.RecurringFrequency[] | ListEnumRecurringFrequencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.RecurringFrequency[] | ListEnumRecurringFrequencyFieldRefInput<$PrismaModel>
    not?: NestedEnumRecurringFrequencyFilter<$PrismaModel> | $Enums.RecurringFrequency
  }

  export type NestedEnumRecurringFrequencyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RecurringFrequency | EnumRecurringFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.RecurringFrequency[] | ListEnumRecurringFrequencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.RecurringFrequency[] | ListEnumRecurringFrequencyFieldRefInput<$PrismaModel>
    not?: NestedEnumRecurringFrequencyWithAggregatesFilter<$PrismaModel> | $Enums.RecurringFrequency
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRecurringFrequencyFilter<$PrismaModel>
    _max?: NestedEnumRecurringFrequencyFilter<$PrismaModel>
  }

  export type NestedEnumReminderTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ReminderType | EnumReminderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReminderType[] | ListEnumReminderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReminderType[] | ListEnumReminderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReminderTypeFilter<$PrismaModel> | $Enums.ReminderType
  }

  export type NestedEnumReminderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReminderStatus | EnumReminderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReminderStatus[] | ListEnumReminderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReminderStatus[] | ListEnumReminderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReminderStatusFilter<$PrismaModel> | $Enums.ReminderStatus
  }

  export type NestedEnumReminderTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReminderType | EnumReminderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReminderType[] | ListEnumReminderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReminderType[] | ListEnumReminderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReminderTypeWithAggregatesFilter<$PrismaModel> | $Enums.ReminderType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReminderTypeFilter<$PrismaModel>
    _max?: NestedEnumReminderTypeFilter<$PrismaModel>
  }

  export type NestedEnumReminderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReminderStatus | EnumReminderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReminderStatus[] | ListEnumReminderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReminderStatus[] | ListEnumReminderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReminderStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReminderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReminderStatusFilter<$PrismaModel>
    _max?: NestedEnumReminderStatusFilter<$PrismaModel>
  }

  export type NestedEnumDocumentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeFilter<$PrismaModel> | $Enums.DocumentType
  }

  export type NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel> | $Enums.DocumentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentTypeFilter<$PrismaModel>
    _max?: NestedEnumDocumentTypeFilter<$PrismaModel>
  }

  export type NestedEnumExpenseStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ExpenseStatus | EnumExpenseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ExpenseStatus[] | ListEnumExpenseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExpenseStatus[] | ListEnumExpenseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumExpenseStatusFilter<$PrismaModel> | $Enums.ExpenseStatus
  }

  export type NestedEnumExpenseStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExpenseStatus | EnumExpenseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ExpenseStatus[] | ListEnumExpenseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExpenseStatus[] | ListEnumExpenseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumExpenseStatusWithAggregatesFilter<$PrismaModel> | $Enums.ExpenseStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumExpenseStatusFilter<$PrismaModel>
    _max?: NestedEnumExpenseStatusFilter<$PrismaModel>
  }

  export type NestedEnumSourceDocumentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SourceDocumentType | EnumSourceDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SourceDocumentType[] | ListEnumSourceDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SourceDocumentType[] | ListEnumSourceDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSourceDocumentTypeFilter<$PrismaModel> | $Enums.SourceDocumentType
  }

  export type NestedEnumSourceDocumentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SourceDocumentType | EnumSourceDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SourceDocumentType[] | ListEnumSourceDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SourceDocumentType[] | ListEnumSourceDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSourceDocumentTypeWithAggregatesFilter<$PrismaModel> | $Enums.SourceDocumentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSourceDocumentTypeFilter<$PrismaModel>
    _max?: NestedEnumSourceDocumentTypeFilter<$PrismaModel>
  }

  export type NestedEnumCashFlowTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CashFlowType | EnumCashFlowTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CashFlowType[] | ListEnumCashFlowTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CashFlowType[] | ListEnumCashFlowTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCashFlowTypeFilter<$PrismaModel> | $Enums.CashFlowType
  }

  export type NestedEnumCashFlowTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CashFlowType | EnumCashFlowTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CashFlowType[] | ListEnumCashFlowTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CashFlowType[] | ListEnumCashFlowTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCashFlowTypeWithAggregatesFilter<$PrismaModel> | $Enums.CashFlowType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCashFlowTypeFilter<$PrismaModel>
    _max?: NestedEnumCashFlowTypeFilter<$PrismaModel>
  }

  export type NestedEnumContractTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ContractType | EnumContractTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContractType[] | ListEnumContractTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContractType[] | ListEnumContractTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContractTypeFilter<$PrismaModel> | $Enums.ContractType
  }

  export type NestedEnumContractTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContractType | EnumContractTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContractType[] | ListEnumContractTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContractType[] | ListEnumContractTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContractTypeWithAggregatesFilter<$PrismaModel> | $Enums.ContractType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContractTypeFilter<$PrismaModel>
    _max?: NestedEnumContractTypeFilter<$PrismaModel>
  }

  export type NestedEnumSalaryStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SalaryStatus | EnumSalaryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SalaryStatus[] | ListEnumSalaryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SalaryStatus[] | ListEnumSalaryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSalaryStatusFilter<$PrismaModel> | $Enums.SalaryStatus
  }

  export type NestedEnumPaymentMethodNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentMethodNullableFilter<$PrismaModel> | $Enums.PaymentMethod | null
  }

  export type NestedEnumSalaryStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SalaryStatus | EnumSalaryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SalaryStatus[] | ListEnumSalaryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SalaryStatus[] | ListEnumSalaryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSalaryStatusWithAggregatesFilter<$PrismaModel> | $Enums.SalaryStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSalaryStatusFilter<$PrismaModel>
    _max?: NestedEnumSalaryStatusFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentMethodNullableWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodNullableFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodNullableFilter<$PrismaModel>
  }

  export type NestedEnumLeaveTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveType | EnumLeaveTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveType[] | ListEnumLeaveTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaveType[] | ListEnumLeaveTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaveTypeFilter<$PrismaModel> | $Enums.LeaveType
  }

  export type NestedEnumLeaveStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveStatus | EnumLeaveStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveStatus[] | ListEnumLeaveStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaveStatus[] | ListEnumLeaveStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaveStatusFilter<$PrismaModel> | $Enums.LeaveStatus
  }

  export type NestedEnumLeaveTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveType | EnumLeaveTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveType[] | ListEnumLeaveTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaveType[] | ListEnumLeaveTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaveTypeWithAggregatesFilter<$PrismaModel> | $Enums.LeaveType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeaveTypeFilter<$PrismaModel>
    _max?: NestedEnumLeaveTypeFilter<$PrismaModel>
  }

  export type NestedEnumLeaveStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveStatus | EnumLeaveStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveStatus[] | ListEnumLeaveStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaveStatus[] | ListEnumLeaveStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaveStatusWithAggregatesFilter<$PrismaModel> | $Enums.LeaveStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeaveStatusFilter<$PrismaModel>
    _max?: NestedEnumLeaveStatusFilter<$PrismaModel>
  }

  export type NestedEnumLoanStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LoanStatus | EnumLoanStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LoanStatus[] | ListEnumLoanStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LoanStatus[] | ListEnumLoanStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLoanStatusFilter<$PrismaModel> | $Enums.LoanStatus
  }

  export type NestedEnumLoanStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LoanStatus | EnumLoanStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LoanStatus[] | ListEnumLoanStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LoanStatus[] | ListEnumLoanStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLoanStatusWithAggregatesFilter<$PrismaModel> | $Enums.LoanStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLoanStatusFilter<$PrismaModel>
    _max?: NestedEnumLoanStatusFilter<$PrismaModel>
  }

  export type UserCreateWithoutServiceInput = {
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    preferences?: string | null
    permissions?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdCustomers?: CustomerCreateNestedManyWithoutCreatorInput
    createdQuotes?: QuoteCreateNestedManyWithoutCreatorInput
    createdInvoices?: InvoiceCreateNestedManyWithoutCreatorInput
    createdPayments?: PaymentCreateNestedManyWithoutCreatorInput
    serviceApprovals?: QuoteCreateNestedManyWithoutServiceManagerInput
    dgApprovals?: QuoteCreateNestedManyWithoutDgApproverInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    quoteApprovals?: QuoteApprovalCreateNestedManyWithoutApproverInput
    createdExpenses?: ExpenseCreateNestedManyWithoutCreatorInput
    accountingEntries?: AccountingEntryCreateNestedManyWithoutCreatorInput
    cashFlowEntries?: CashFlowCreateNestedManyWithoutCreatorInput
    createdReminders?: ReminderCreateNestedManyWithoutCreatorInput
    createdRecurringInvoices?: RecurringInvoiceCreateNestedManyWithoutCreatorInput
    employee?: EmployeeCreateNestedOneWithoutUserInput
    leaveApprovals?: LeaveRequestCreateNestedManyWithoutApprovedByInput
    assignedProspects?: ProspectCreateNestedManyWithoutAssignedUserInput
    createdProspects?: ProspectCreateNestedManyWithoutCreatorInput
    createdProspectActivities?: ProspectActivityCreateNestedManyWithoutCreatorInput
    technicien?: TechnicienCreateNestedOneWithoutUtilisateurInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutServiceInput = {
    id?: number
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    preferences?: string | null
    permissions?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdCustomers?: CustomerUncheckedCreateNestedManyWithoutCreatorInput
    createdQuotes?: QuoteUncheckedCreateNestedManyWithoutCreatorInput
    createdInvoices?: InvoiceUncheckedCreateNestedManyWithoutCreatorInput
    createdPayments?: PaymentUncheckedCreateNestedManyWithoutCreatorInput
    serviceApprovals?: QuoteUncheckedCreateNestedManyWithoutServiceManagerInput
    dgApprovals?: QuoteUncheckedCreateNestedManyWithoutDgApproverInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    quoteApprovals?: QuoteApprovalUncheckedCreateNestedManyWithoutApproverInput
    createdExpenses?: ExpenseUncheckedCreateNestedManyWithoutCreatorInput
    accountingEntries?: AccountingEntryUncheckedCreateNestedManyWithoutCreatorInput
    cashFlowEntries?: CashFlowUncheckedCreateNestedManyWithoutCreatorInput
    createdReminders?: ReminderUncheckedCreateNestedManyWithoutCreatorInput
    createdRecurringInvoices?: RecurringInvoiceUncheckedCreateNestedManyWithoutCreatorInput
    employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    leaveApprovals?: LeaveRequestUncheckedCreateNestedManyWithoutApprovedByInput
    assignedProspects?: ProspectUncheckedCreateNestedManyWithoutAssignedUserInput
    createdProspects?: ProspectUncheckedCreateNestedManyWithoutCreatorInput
    createdProspectActivities?: ProspectActivityUncheckedCreateNestedManyWithoutCreatorInput
    technicien?: TechnicienUncheckedCreateNestedOneWithoutUtilisateurInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutServiceInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutServiceInput, UserUncheckedCreateWithoutServiceInput>
  }

  export type UserCreateManyServiceInputEnvelope = {
    data: UserCreateManyServiceInput | UserCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type CustomerCreateWithoutServiceInput = {
    customerNumber: string
    type?: $Enums.CustomerType
    name: string
    legalName?: string | null
    siret?: string | null
    vatNumber?: string | null
    email?: string | null
    phone?: string | null
    mobile?: string | null
    website?: string | null
    paymentTerms?: number
    paymentMethod?: $Enums.PaymentMethod
    creditLimit?: number
    discountRate?: number
    category?: string | null
    tags?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedCustomersInput
    addresses?: CustomerAddressCreateNestedManyWithoutCustomerInput
    quotes?: QuoteCreateNestedManyWithoutCustomerInput
    invoices?: InvoiceCreateNestedManyWithoutCustomerInput
    payments?: PaymentCreateNestedManyWithoutCustomerInput
    recurringInvoices?: RecurringInvoiceCreateNestedManyWithoutCustomerInput
    missions?: MissionCreateNestedManyWithoutClientInput
  }

  export type CustomerUncheckedCreateWithoutServiceInput = {
    id?: number
    customerNumber: string
    type?: $Enums.CustomerType
    name: string
    legalName?: string | null
    siret?: string | null
    vatNumber?: string | null
    email?: string | null
    phone?: string | null
    mobile?: string | null
    website?: string | null
    paymentTerms?: number
    paymentMethod?: $Enums.PaymentMethod
    creditLimit?: number
    discountRate?: number
    category?: string | null
    tags?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: number
    addresses?: CustomerAddressUncheckedCreateNestedManyWithoutCustomerInput
    quotes?: QuoteUncheckedCreateNestedManyWithoutCustomerInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCustomerInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCustomerInput
    recurringInvoices?: RecurringInvoiceUncheckedCreateNestedManyWithoutCustomerInput
    missions?: MissionUncheckedCreateNestedManyWithoutClientInput
  }

  export type CustomerCreateOrConnectWithoutServiceInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutServiceInput, CustomerUncheckedCreateWithoutServiceInput>
  }

  export type CustomerCreateManyServiceInputEnvelope = {
    data: CustomerCreateManyServiceInput | CustomerCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeCreateWithoutServiceInput = {
    employeeNumber: string
    registrationNumber?: string | null
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    address?: string | null
    dateOfBirth: Date | string
    placeOfBirth?: string | null
    nationality?: string | null
    socialSecurityNumber?: string | null
    cnpsNumber?: string | null
    cnamNumber?: string | null
    bankAccount?: string | null
    emergencyContact?: string | null
    position: string
    department?: string | null
    category?: string | null
    level?: string | null
    manager?: string | null
    hireDate: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutEmployeeInput
    contracts?: ContractCreateNestedManyWithoutEmployeeInput
    salaries?: SalaryCreateNestedManyWithoutEmployeeInput
    leaveRequests?: LeaveRequestCreateNestedManyWithoutEmployeeInput
    loans?: LoanCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutServiceInput = {
    id?: number
    employeeNumber: string
    registrationNumber?: string | null
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    address?: string | null
    dateOfBirth: Date | string
    placeOfBirth?: string | null
    nationality?: string | null
    socialSecurityNumber?: string | null
    cnpsNumber?: string | null
    cnamNumber?: string | null
    bankAccount?: string | null
    emergencyContact?: string | null
    position: string
    department?: string | null
    category?: string | null
    level?: string | null
    manager?: string | null
    hireDate: Date | string
    isActive?: boolean
    userId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contracts?: ContractUncheckedCreateNestedManyWithoutEmployeeInput
    salaries?: SalaryUncheckedCreateNestedManyWithoutEmployeeInput
    leaveRequests?: LeaveRequestUncheckedCreateNestedManyWithoutEmployeeInput
    loans?: LoanUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutServiceInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutServiceInput, EmployeeUncheckedCreateWithoutServiceInput>
  }

  export type EmployeeCreateManyServiceInputEnvelope = {
    data: EmployeeCreateManyServiceInput | EmployeeCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutServiceInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutServiceInput, UserUncheckedUpdateWithoutServiceInput>
    create: XOR<UserCreateWithoutServiceInput, UserUncheckedCreateWithoutServiceInput>
  }

  export type UserUpdateWithWhereUniqueWithoutServiceInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutServiceInput, UserUncheckedUpdateWithoutServiceInput>
  }

  export type UserUpdateManyWithWhereWithoutServiceInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutServiceInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: IntFilter<"User"> | number
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    serviceId?: IntNullableFilter<"User"> | number | null
    isActive?: BoolFilter<"User"> | boolean
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    preferences?: StringNullableFilter<"User"> | string | null
    permissions?: StringNullableFilter<"User"> | string | null
    avatarUrl?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type CustomerUpsertWithWhereUniqueWithoutServiceInput = {
    where: CustomerWhereUniqueInput
    update: XOR<CustomerUpdateWithoutServiceInput, CustomerUncheckedUpdateWithoutServiceInput>
    create: XOR<CustomerCreateWithoutServiceInput, CustomerUncheckedCreateWithoutServiceInput>
  }

  export type CustomerUpdateWithWhereUniqueWithoutServiceInput = {
    where: CustomerWhereUniqueInput
    data: XOR<CustomerUpdateWithoutServiceInput, CustomerUncheckedUpdateWithoutServiceInput>
  }

  export type CustomerUpdateManyWithWhereWithoutServiceInput = {
    where: CustomerScalarWhereInput
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyWithoutServiceInput>
  }

  export type CustomerScalarWhereInput = {
    AND?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
    OR?: CustomerScalarWhereInput[]
    NOT?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
    id?: IntFilter<"Customer"> | number
    customerNumber?: StringFilter<"Customer"> | string
    type?: EnumCustomerTypeFilter<"Customer"> | $Enums.CustomerType
    name?: StringFilter<"Customer"> | string
    legalName?: StringNullableFilter<"Customer"> | string | null
    siret?: StringNullableFilter<"Customer"> | string | null
    vatNumber?: StringNullableFilter<"Customer"> | string | null
    email?: StringNullableFilter<"Customer"> | string | null
    phone?: StringNullableFilter<"Customer"> | string | null
    mobile?: StringNullableFilter<"Customer"> | string | null
    website?: StringNullableFilter<"Customer"> | string | null
    paymentTerms?: IntFilter<"Customer"> | number
    paymentMethod?: EnumPaymentMethodFilter<"Customer"> | $Enums.PaymentMethod
    creditLimit?: FloatFilter<"Customer"> | number
    discountRate?: FloatFilter<"Customer"> | number
    category?: StringNullableFilter<"Customer"> | string | null
    tags?: StringNullableFilter<"Customer"> | string | null
    notes?: StringNullableFilter<"Customer"> | string | null
    isActive?: BoolFilter<"Customer"> | boolean
    serviceId?: IntNullableFilter<"Customer"> | number | null
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    createdBy?: IntFilter<"Customer"> | number
  }

  export type EmployeeUpsertWithWhereUniqueWithoutServiceInput = {
    where: EmployeeWhereUniqueInput
    update: XOR<EmployeeUpdateWithoutServiceInput, EmployeeUncheckedUpdateWithoutServiceInput>
    create: XOR<EmployeeCreateWithoutServiceInput, EmployeeUncheckedCreateWithoutServiceInput>
  }

  export type EmployeeUpdateWithWhereUniqueWithoutServiceInput = {
    where: EmployeeWhereUniqueInput
    data: XOR<EmployeeUpdateWithoutServiceInput, EmployeeUncheckedUpdateWithoutServiceInput>
  }

  export type EmployeeUpdateManyWithWhereWithoutServiceInput = {
    where: EmployeeScalarWhereInput
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyWithoutServiceInput>
  }

  export type EmployeeScalarWhereInput = {
    AND?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
    OR?: EmployeeScalarWhereInput[]
    NOT?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
    id?: IntFilter<"Employee"> | number
    employeeNumber?: StringFilter<"Employee"> | string
    registrationNumber?: StringNullableFilter<"Employee"> | string | null
    firstName?: StringFilter<"Employee"> | string
    lastName?: StringFilter<"Employee"> | string
    email?: StringNullableFilter<"Employee"> | string | null
    phone?: StringNullableFilter<"Employee"> | string | null
    address?: StringNullableFilter<"Employee"> | string | null
    dateOfBirth?: DateTimeFilter<"Employee"> | Date | string
    placeOfBirth?: StringNullableFilter<"Employee"> | string | null
    nationality?: StringNullableFilter<"Employee"> | string | null
    socialSecurityNumber?: StringNullableFilter<"Employee"> | string | null
    cnpsNumber?: StringNullableFilter<"Employee"> | string | null
    cnamNumber?: StringNullableFilter<"Employee"> | string | null
    bankAccount?: StringNullableFilter<"Employee"> | string | null
    emergencyContact?: StringNullableFilter<"Employee"> | string | null
    serviceId?: IntNullableFilter<"Employee"> | number | null
    position?: StringFilter<"Employee"> | string
    department?: StringNullableFilter<"Employee"> | string | null
    category?: StringNullableFilter<"Employee"> | string | null
    level?: StringNullableFilter<"Employee"> | string | null
    manager?: StringNullableFilter<"Employee"> | string | null
    hireDate?: DateTimeFilter<"Employee"> | Date | string
    isActive?: BoolFilter<"Employee"> | boolean
    userId?: IntNullableFilter<"Employee"> | number | null
    createdAt?: DateTimeFilter<"Employee"> | Date | string
    updatedAt?: DateTimeFilter<"Employee"> | Date | string
  }

  export type ServiceCreateWithoutUsersInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customers?: CustomerCreateNestedManyWithoutServiceInput
    employees?: EmployeeCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutUsersInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customers?: CustomerUncheckedCreateNestedManyWithoutServiceInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutUsersInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutUsersInput, ServiceUncheckedCreateWithoutUsersInput>
  }

  export type CustomerCreateWithoutCreatorInput = {
    customerNumber: string
    type?: $Enums.CustomerType
    name: string
    legalName?: string | null
    siret?: string | null
    vatNumber?: string | null
    email?: string | null
    phone?: string | null
    mobile?: string | null
    website?: string | null
    paymentTerms?: number
    paymentMethod?: $Enums.PaymentMethod
    creditLimit?: number
    discountRate?: number
    category?: string | null
    tags?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    service?: ServiceCreateNestedOneWithoutCustomersInput
    addresses?: CustomerAddressCreateNestedManyWithoutCustomerInput
    quotes?: QuoteCreateNestedManyWithoutCustomerInput
    invoices?: InvoiceCreateNestedManyWithoutCustomerInput
    payments?: PaymentCreateNestedManyWithoutCustomerInput
    recurringInvoices?: RecurringInvoiceCreateNestedManyWithoutCustomerInput
    missions?: MissionCreateNestedManyWithoutClientInput
  }

  export type CustomerUncheckedCreateWithoutCreatorInput = {
    id?: number
    customerNumber: string
    type?: $Enums.CustomerType
    name: string
    legalName?: string | null
    siret?: string | null
    vatNumber?: string | null
    email?: string | null
    phone?: string | null
    mobile?: string | null
    website?: string | null
    paymentTerms?: number
    paymentMethod?: $Enums.PaymentMethod
    creditLimit?: number
    discountRate?: number
    category?: string | null
    tags?: string | null
    notes?: string | null
    isActive?: boolean
    serviceId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    addresses?: CustomerAddressUncheckedCreateNestedManyWithoutCustomerInput
    quotes?: QuoteUncheckedCreateNestedManyWithoutCustomerInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCustomerInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCustomerInput
    recurringInvoices?: RecurringInvoiceUncheckedCreateNestedManyWithoutCustomerInput
    missions?: MissionUncheckedCreateNestedManyWithoutClientInput
  }

  export type CustomerCreateOrConnectWithoutCreatorInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutCreatorInput, CustomerUncheckedCreateWithoutCreatorInput>
  }

  export type CustomerCreateManyCreatorInputEnvelope = {
    data: CustomerCreateManyCreatorInput | CustomerCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type QuoteCreateWithoutCreatorInput = {
    quoteNumber: string
    status?: $Enums.QuoteStatus
    quoteDate: Date | string
    validUntil: Date | string
    subtotalHt?: number
    discountAmount?: number
    totalVat?: number
    totalTtc?: number
    terms?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt?: Date | string | null
    submittedForServiceApprovalAt?: Date | string | null
    serviceManagerApprovalDate?: Date | string | null
    serviceManagerComments?: string | null
    dgApprovalDate?: Date | string | null
    dgComments?: string | null
    acceptedAt?: Date | string | null
    customer: CustomerCreateNestedOneWithoutQuotesInput
    customerAddress?: CustomerAddressCreateNestedOneWithoutQuotesInput
    serviceManager?: UserCreateNestedOneWithoutServiceApprovalsInput
    dgApprover?: UserCreateNestedOneWithoutDgApprovalsInput
    items?: QuoteItemCreateNestedManyWithoutQuoteInput
    invoices?: InvoiceCreateNestedManyWithoutQuoteInput
    approvals?: QuoteApprovalCreateNestedManyWithoutQuoteInput
    missions?: MissionCreateNestedManyWithoutDevisInput
  }

  export type QuoteUncheckedCreateWithoutCreatorInput = {
    id?: number
    quoteNumber: string
    customerId: number
    customerAddressId?: number | null
    status?: $Enums.QuoteStatus
    quoteDate: Date | string
    validUntil: Date | string
    subtotalHt?: number
    discountAmount?: number
    totalVat?: number
    totalTtc?: number
    terms?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt?: Date | string | null
    submittedForServiceApprovalAt?: Date | string | null
    serviceManagerApprovedBy?: number | null
    serviceManagerApprovalDate?: Date | string | null
    serviceManagerComments?: string | null
    dgApprovedBy?: number | null
    dgApprovalDate?: Date | string | null
    dgComments?: string | null
    acceptedAt?: Date | string | null
    items?: QuoteItemUncheckedCreateNestedManyWithoutQuoteInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutQuoteInput
    approvals?: QuoteApprovalUncheckedCreateNestedManyWithoutQuoteInput
    missions?: MissionUncheckedCreateNestedManyWithoutDevisInput
  }

  export type QuoteCreateOrConnectWithoutCreatorInput = {
    where: QuoteWhereUniqueInput
    create: XOR<QuoteCreateWithoutCreatorInput, QuoteUncheckedCreateWithoutCreatorInput>
  }

  export type QuoteCreateManyCreatorInputEnvelope = {
    data: QuoteCreateManyCreatorInput | QuoteCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutCreatorInput = {
    invoiceNumber: string
    type?: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    invoiceDate: Date | string
    dueDate: Date | string
    subtotalHt?: number
    discountAmount?: number
    totalVat?: number
    totalTtc?: number
    paidAmount?: number
    balanceDue?: number
    paymentTerms?: number
    lateFeeRate?: number
    terms?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt?: Date | string | null
    customer: CustomerCreateNestedOneWithoutInvoicesInput
    customerAddress?: CustomerAddressCreateNestedOneWithoutInvoicesInput
    quote?: QuoteCreateNestedOneWithoutInvoicesInput
    items?: InvoiceItemCreateNestedManyWithoutInvoiceInput
    paymentAllocations?: PaymentAllocationCreateNestedManyWithoutInvoiceInput
    reminders?: ReminderCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutCreatorInput = {
    id?: number
    invoiceNumber: string
    customerId: number
    customerAddressId?: number | null
    quoteId?: number | null
    type?: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    invoiceDate: Date | string
    dueDate: Date | string
    subtotalHt?: number
    discountAmount?: number
    totalVat?: number
    totalTtc?: number
    paidAmount?: number
    balanceDue?: number
    paymentTerms?: number
    lateFeeRate?: number
    terms?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt?: Date | string | null
    items?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
    paymentAllocations?: PaymentAllocationUncheckedCreateNestedManyWithoutInvoiceInput
    reminders?: ReminderUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutCreatorInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutCreatorInput, InvoiceUncheckedCreateWithoutCreatorInput>
  }

  export type InvoiceCreateManyCreatorInputEnvelope = {
    data: InvoiceCreateManyCreatorInput | InvoiceCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutCreatorInput = {
    paymentNumber: string
    amount: number
    paymentDate: Date | string
    paymentMethod: $Enums.PaymentMethod
    reference?: string | null
    notes?: string | null
    createdAt?: Date | string
    customer: CustomerCreateNestedOneWithoutPaymentsInput
    allocations?: PaymentAllocationCreateNestedManyWithoutPaymentInput
  }

  export type PaymentUncheckedCreateWithoutCreatorInput = {
    id?: number
    paymentNumber: string
    customerId: number
    amount: number
    paymentDate: Date | string
    paymentMethod: $Enums.PaymentMethod
    reference?: string | null
    notes?: string | null
    createdAt?: Date | string
    allocations?: PaymentAllocationUncheckedCreateNestedManyWithoutPaymentInput
  }

  export type PaymentCreateOrConnectWithoutCreatorInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutCreatorInput, PaymentUncheckedCreateWithoutCreatorInput>
  }

  export type PaymentCreateManyCreatorInputEnvelope = {
    data: PaymentCreateManyCreatorInput | PaymentCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type QuoteCreateWithoutServiceManagerInput = {
    quoteNumber: string
    status?: $Enums.QuoteStatus
    quoteDate: Date | string
    validUntil: Date | string
    subtotalHt?: number
    discountAmount?: number
    totalVat?: number
    totalTtc?: number
    terms?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt?: Date | string | null
    submittedForServiceApprovalAt?: Date | string | null
    serviceManagerApprovalDate?: Date | string | null
    serviceManagerComments?: string | null
    dgApprovalDate?: Date | string | null
    dgComments?: string | null
    acceptedAt?: Date | string | null
    customer: CustomerCreateNestedOneWithoutQuotesInput
    customerAddress?: CustomerAddressCreateNestedOneWithoutQuotesInput
    creator: UserCreateNestedOneWithoutCreatedQuotesInput
    dgApprover?: UserCreateNestedOneWithoutDgApprovalsInput
    items?: QuoteItemCreateNestedManyWithoutQuoteInput
    invoices?: InvoiceCreateNestedManyWithoutQuoteInput
    approvals?: QuoteApprovalCreateNestedManyWithoutQuoteInput
    missions?: MissionCreateNestedManyWithoutDevisInput
  }

  export type QuoteUncheckedCreateWithoutServiceManagerInput = {
    id?: number
    quoteNumber: string
    customerId: number
    customerAddressId?: number | null
    status?: $Enums.QuoteStatus
    quoteDate: Date | string
    validUntil: Date | string
    subtotalHt?: number
    discountAmount?: number
    totalVat?: number
    totalTtc?: number
    terms?: string | null
    notes?: string | null
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt?: Date | string | null
    submittedForServiceApprovalAt?: Date | string | null
    serviceManagerApprovalDate?: Date | string | null
    serviceManagerComments?: string | null
    dgApprovedBy?: number | null
    dgApprovalDate?: Date | string | null
    dgComments?: string | null
    acceptedAt?: Date | string | null
    items?: QuoteItemUncheckedCreateNestedManyWithoutQuoteInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutQuoteInput
    approvals?: QuoteApprovalUncheckedCreateNestedManyWithoutQuoteInput
    missions?: MissionUncheckedCreateNestedManyWithoutDevisInput
  }

  export type QuoteCreateOrConnectWithoutServiceManagerInput = {
    where: QuoteWhereUniqueInput
    create: XOR<QuoteCreateWithoutServiceManagerInput, QuoteUncheckedCreateWithoutServiceManagerInput>
  }

  export type QuoteCreateManyServiceManagerInputEnvelope = {
    data: QuoteCreateManyServiceManagerInput | QuoteCreateManyServiceManagerInput[]
    skipDuplicates?: boolean
  }

  export type QuoteCreateWithoutDgApproverInput = {
    quoteNumber: string
    status?: $Enums.QuoteStatus
    quoteDate: Date | string
    validUntil: Date | string
    subtotalHt?: number
    discountAmount?: number
    totalVat?: number
    totalTtc?: number
    terms?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt?: Date | string | null
    submittedForServiceApprovalAt?: Date | string | null
    serviceManagerApprovalDate?: Date | string | null
    serviceManagerComments?: string | null
    dgApprovalDate?: Date | string | null
    dgComments?: string | null
    acceptedAt?: Date | string | null
    customer: CustomerCreateNestedOneWithoutQuotesInput
    customerAddress?: CustomerAddressCreateNestedOneWithoutQuotesInput
    creator: UserCreateNestedOneWithoutCreatedQuotesInput
    serviceManager?: UserCreateNestedOneWithoutServiceApprovalsInput
    items?: QuoteItemCreateNestedManyWithoutQuoteInput
    invoices?: InvoiceCreateNestedManyWithoutQuoteInput
    approvals?: QuoteApprovalCreateNestedManyWithoutQuoteInput
    missions?: MissionCreateNestedManyWithoutDevisInput
  }

  export type QuoteUncheckedCreateWithoutDgApproverInput = {
    id?: number
    quoteNumber: string
    customerId: number
    customerAddressId?: number | null
    status?: $Enums.QuoteStatus
    quoteDate: Date | string
    validUntil: Date | string
    subtotalHt?: number
    discountAmount?: number
    totalVat?: number
    totalTtc?: number
    terms?: string | null
    notes?: string | null
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt?: Date | string | null
    submittedForServiceApprovalAt?: Date | string | null
    serviceManagerApprovedBy?: number | null
    serviceManagerApprovalDate?: Date | string | null
    serviceManagerComments?: string | null
    dgApprovalDate?: Date | string | null
    dgComments?: string | null
    acceptedAt?: Date | string | null
    items?: QuoteItemUncheckedCreateNestedManyWithoutQuoteInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutQuoteInput
    approvals?: QuoteApprovalUncheckedCreateNestedManyWithoutQuoteInput
    missions?: MissionUncheckedCreateNestedManyWithoutDevisInput
  }

  export type QuoteCreateOrConnectWithoutDgApproverInput = {
    where: QuoteWhereUniqueInput
    create: XOR<QuoteCreateWithoutDgApproverInput, QuoteUncheckedCreateWithoutDgApproverInput>
  }

  export type QuoteCreateManyDgApproverInputEnvelope = {
    data: QuoteCreateManyDgApproverInput | QuoteCreateManyDgApproverInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutUserInput = {
    action: string
    details?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: number
    action: string
    details?: string | null
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type QuoteApprovalCreateWithoutApproverInput = {
    approvalLevel: $Enums.ApprovalLevel
    status?: $Enums.ApprovalStatus
    approvalDate?: Date | string | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    quote: QuoteCreateNestedOneWithoutApprovalsInput
  }

  export type QuoteApprovalUncheckedCreateWithoutApproverInput = {
    id?: number
    quoteId: number
    approvalLevel: $Enums.ApprovalLevel
    status?: $Enums.ApprovalStatus
    approvalDate?: Date | string | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuoteApprovalCreateOrConnectWithoutApproverInput = {
    where: QuoteApprovalWhereUniqueInput
    create: XOR<QuoteApprovalCreateWithoutApproverInput, QuoteApprovalUncheckedCreateWithoutApproverInput>
  }

  export type QuoteApprovalCreateManyApproverInputEnvelope = {
    data: QuoteApprovalCreateManyApproverInput | QuoteApprovalCreateManyApproverInput[]
    skipDuplicates?: boolean
  }

  export type ExpenseCreateWithoutCreatorInput = {
    expenseNumber: string
    category: string
    description?: string | null
    amountHt: number
    vatAmount?: number
    totalTtc: number
    expenseDate: Date | string
    paymentDate?: Date | string | null
    paymentMethod?: $Enums.PaymentMethod
    status?: $Enums.ExpenseStatus
    receiptUrl?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    supplier?: SupplierCreateNestedOneWithoutExpensesInput
  }

  export type ExpenseUncheckedCreateWithoutCreatorInput = {
    id?: number
    expenseNumber: string
    supplierId?: number | null
    category: string
    description?: string | null
    amountHt: number
    vatAmount?: number
    totalTtc: number
    expenseDate: Date | string
    paymentDate?: Date | string | null
    paymentMethod?: $Enums.PaymentMethod
    status?: $Enums.ExpenseStatus
    receiptUrl?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseCreateOrConnectWithoutCreatorInput = {
    where: ExpenseWhereUniqueInput
    create: XOR<ExpenseCreateWithoutCreatorInput, ExpenseUncheckedCreateWithoutCreatorInput>
  }

  export type ExpenseCreateManyCreatorInputEnvelope = {
    data: ExpenseCreateManyCreatorInput | ExpenseCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type AccountingEntryCreateWithoutCreatorInput = {
    entryDate: Date | string
    accountNumber: string
    debit?: number
    credit?: number
    description?: string | null
    sourceDocumentType: $Enums.SourceDocumentType
    sourceDocumentId: number
    createdAt?: Date | string
  }

  export type AccountingEntryUncheckedCreateWithoutCreatorInput = {
    id?: number
    entryDate: Date | string
    accountNumber: string
    debit?: number
    credit?: number
    description?: string | null
    sourceDocumentType: $Enums.SourceDocumentType
    sourceDocumentId: number
    createdAt?: Date | string
  }

  export type AccountingEntryCreateOrConnectWithoutCreatorInput = {
    where: AccountingEntryWhereUniqueInput
    create: XOR<AccountingEntryCreateWithoutCreatorInput, AccountingEntryUncheckedCreateWithoutCreatorInput>
  }

  export type AccountingEntryCreateManyCreatorInputEnvelope = {
    data: AccountingEntryCreateManyCreatorInput | AccountingEntryCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type CashFlowCreateWithoutCreatorInput = {
    transactionDate: Date | string
    type: $Enums.CashFlowType
    amount: number
    description?: string | null
    category?: string | null
    sourceDocumentType: $Enums.SourceDocumentType
    sourceDocumentId: number
    createdAt?: Date | string
  }

  export type CashFlowUncheckedCreateWithoutCreatorInput = {
    id?: number
    transactionDate: Date | string
    type: $Enums.CashFlowType
    amount: number
    description?: string | null
    category?: string | null
    sourceDocumentType: $Enums.SourceDocumentType
    sourceDocumentId: number
    createdAt?: Date | string
  }

  export type CashFlowCreateOrConnectWithoutCreatorInput = {
    where: CashFlowWhereUniqueInput
    create: XOR<CashFlowCreateWithoutCreatorInput, CashFlowUncheckedCreateWithoutCreatorInput>
  }

  export type CashFlowCreateManyCreatorInputEnvelope = {
    data: CashFlowCreateManyCreatorInput | CashFlowCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type ReminderCreateWithoutCreatorInput = {
    type: $Enums.ReminderType
    sentDate: Date | string
    dueDate?: Date | string | null
    amountDue: number
    lateFees?: number
    status?: $Enums.ReminderStatus
    emailSubject?: string | null
    emailBody?: string | null
    createdAt?: Date | string
    invoice: InvoiceCreateNestedOneWithoutRemindersInput
  }

  export type ReminderUncheckedCreateWithoutCreatorInput = {
    id?: number
    invoiceId: number
    type: $Enums.ReminderType
    sentDate: Date | string
    dueDate?: Date | string | null
    amountDue: number
    lateFees?: number
    status?: $Enums.ReminderStatus
    emailSubject?: string | null
    emailBody?: string | null
    createdAt?: Date | string
  }

  export type ReminderCreateOrConnectWithoutCreatorInput = {
    where: ReminderWhereUniqueInput
    create: XOR<ReminderCreateWithoutCreatorInput, ReminderUncheckedCreateWithoutCreatorInput>
  }

  export type ReminderCreateManyCreatorInputEnvelope = {
    data: ReminderCreateManyCreatorInput | ReminderCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type RecurringInvoiceCreateWithoutCreatorInput = {
    templateName: string
    frequency: $Enums.RecurringFrequency
    startDate: Date | string
    endDate?: Date | string | null
    nextInvoiceDate: Date | string
    isActive?: boolean
    subtotalHt?: number
    totalVat?: number
    totalTtc?: number
    terms?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutRecurringInvoicesInput
    items?: RecurringInvoiceItemCreateNestedManyWithoutRecurringInvoiceInput
  }

  export type RecurringInvoiceUncheckedCreateWithoutCreatorInput = {
    id?: number
    customerId: number
    templateName: string
    frequency: $Enums.RecurringFrequency
    startDate: Date | string
    endDate?: Date | string | null
    nextInvoiceDate: Date | string
    isActive?: boolean
    subtotalHt?: number
    totalVat?: number
    totalTtc?: number
    terms?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: RecurringInvoiceItemUncheckedCreateNestedManyWithoutRecurringInvoiceInput
  }

  export type RecurringInvoiceCreateOrConnectWithoutCreatorInput = {
    where: RecurringInvoiceWhereUniqueInput
    create: XOR<RecurringInvoiceCreateWithoutCreatorInput, RecurringInvoiceUncheckedCreateWithoutCreatorInput>
  }

  export type RecurringInvoiceCreateManyCreatorInputEnvelope = {
    data: RecurringInvoiceCreateManyCreatorInput | RecurringInvoiceCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeCreateWithoutUserInput = {
    employeeNumber: string
    registrationNumber?: string | null
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    address?: string | null
    dateOfBirth: Date | string
    placeOfBirth?: string | null
    nationality?: string | null
    socialSecurityNumber?: string | null
    cnpsNumber?: string | null
    cnamNumber?: string | null
    bankAccount?: string | null
    emergencyContact?: string | null
    position: string
    department?: string | null
    category?: string | null
    level?: string | null
    manager?: string | null
    hireDate: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    service?: ServiceCreateNestedOneWithoutEmployeesInput
    contracts?: ContractCreateNestedManyWithoutEmployeeInput
    salaries?: SalaryCreateNestedManyWithoutEmployeeInput
    leaveRequests?: LeaveRequestCreateNestedManyWithoutEmployeeInput
    loans?: LoanCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutUserInput = {
    id?: number
    employeeNumber: string
    registrationNumber?: string | null
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    address?: string | null
    dateOfBirth: Date | string
    placeOfBirth?: string | null
    nationality?: string | null
    socialSecurityNumber?: string | null
    cnpsNumber?: string | null
    cnamNumber?: string | null
    bankAccount?: string | null
    emergencyContact?: string | null
    serviceId?: number | null
    position: string
    department?: string | null
    category?: string | null
    level?: string | null
    manager?: string | null
    hireDate: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contracts?: ContractUncheckedCreateNestedManyWithoutEmployeeInput
    salaries?: SalaryUncheckedCreateNestedManyWithoutEmployeeInput
    leaveRequests?: LeaveRequestUncheckedCreateNestedManyWithoutEmployeeInput
    loans?: LoanUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutUserInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutUserInput, EmployeeUncheckedCreateWithoutUserInput>
  }

  export type LeaveRequestCreateWithoutApprovedByInput = {
    leaveType: $Enums.LeaveType
    startDate: Date | string
    endDate: Date | string
    days: number
    reason: string
    notes?: string | null
    status?: $Enums.LeaveStatus
    approvedAt?: Date | string | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutLeaveRequestsInput
  }

  export type LeaveRequestUncheckedCreateWithoutApprovedByInput = {
    id?: number
    employeeId: number
    leaveType: $Enums.LeaveType
    startDate: Date | string
    endDate: Date | string
    days: number
    reason: string
    notes?: string | null
    status?: $Enums.LeaveStatus
    approvedAt?: Date | string | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaveRequestCreateOrConnectWithoutApprovedByInput = {
    where: LeaveRequestWhereUniqueInput
    create: XOR<LeaveRequestCreateWithoutApprovedByInput, LeaveRequestUncheckedCreateWithoutApprovedByInput>
  }

  export type LeaveRequestCreateManyApprovedByInputEnvelope = {
    data: LeaveRequestCreateManyApprovedByInput | LeaveRequestCreateManyApprovedByInput[]
    skipDuplicates?: boolean
  }

  export type ProspectCreateWithoutAssignedUserInput = {
    companyName: string
    contactName: string
    position?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    website?: string | null
    industry?: string | null
    companySize?: string | null
    estimatedValue?: number | null
    priority?: string
    stage?: string
    source?: string | null
    notes?: string | null
    hasBudget?: boolean
    isDecisionMaker?: boolean
    hasNeed?: boolean
    timeline?: string | null
    lastContact?: Date | string
    nextAction?: string | null
    nextActionDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedProspectsInput
    activities?: ProspectActivityCreateNestedManyWithoutProspectInput
  }

  export type ProspectUncheckedCreateWithoutAssignedUserInput = {
    id?: number
    companyName: string
    contactName: string
    position?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    website?: string | null
    industry?: string | null
    companySize?: string | null
    estimatedValue?: number | null
    priority?: string
    stage?: string
    source?: string | null
    notes?: string | null
    hasBudget?: boolean
    isDecisionMaker?: boolean
    hasNeed?: boolean
    timeline?: string | null
    lastContact?: Date | string
    nextAction?: string | null
    nextActionDate?: Date | string | null
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: ProspectActivityUncheckedCreateNestedManyWithoutProspectInput
  }

  export type ProspectCreateOrConnectWithoutAssignedUserInput = {
    where: ProspectWhereUniqueInput
    create: XOR<ProspectCreateWithoutAssignedUserInput, ProspectUncheckedCreateWithoutAssignedUserInput>
  }

  export type ProspectCreateManyAssignedUserInputEnvelope = {
    data: ProspectCreateManyAssignedUserInput | ProspectCreateManyAssignedUserInput[]
    skipDuplicates?: boolean
  }

  export type ProspectCreateWithoutCreatorInput = {
    companyName: string
    contactName: string
    position?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    website?: string | null
    industry?: string | null
    companySize?: string | null
    estimatedValue?: number | null
    priority?: string
    stage?: string
    source?: string | null
    notes?: string | null
    hasBudget?: boolean
    isDecisionMaker?: boolean
    hasNeed?: boolean
    timeline?: string | null
    lastContact?: Date | string
    nextAction?: string | null
    nextActionDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedUser?: UserCreateNestedOneWithoutAssignedProspectsInput
    activities?: ProspectActivityCreateNestedManyWithoutProspectInput
  }

  export type ProspectUncheckedCreateWithoutCreatorInput = {
    id?: number
    companyName: string
    contactName: string
    position?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    website?: string | null
    industry?: string | null
    companySize?: string | null
    estimatedValue?: number | null
    priority?: string
    stage?: string
    source?: string | null
    notes?: string | null
    hasBudget?: boolean
    isDecisionMaker?: boolean
    hasNeed?: boolean
    timeline?: string | null
    lastContact?: Date | string
    nextAction?: string | null
    nextActionDate?: Date | string | null
    assignedTo?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: ProspectActivityUncheckedCreateNestedManyWithoutProspectInput
  }

  export type ProspectCreateOrConnectWithoutCreatorInput = {
    where: ProspectWhereUniqueInput
    create: XOR<ProspectCreateWithoutCreatorInput, ProspectUncheckedCreateWithoutCreatorInput>
  }

  export type ProspectCreateManyCreatorInputEnvelope = {
    data: ProspectCreateManyCreatorInput | ProspectCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type ProspectActivityCreateWithoutCreatorInput = {
    type: string
    subject?: string | null
    description?: string | null
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    outcome?: string | null
    nextAction?: string | null
    createdAt?: Date | string
    prospect: ProspectCreateNestedOneWithoutActivitiesInput
  }

  export type ProspectActivityUncheckedCreateWithoutCreatorInput = {
    id?: number
    prospectId: number
    type: string
    subject?: string | null
    description?: string | null
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    outcome?: string | null
    nextAction?: string | null
    createdAt?: Date | string
  }

  export type ProspectActivityCreateOrConnectWithoutCreatorInput = {
    where: ProspectActivityWhereUniqueInput
    create: XOR<ProspectActivityCreateWithoutCreatorInput, ProspectActivityUncheckedCreateWithoutCreatorInput>
  }

  export type ProspectActivityCreateManyCreatorInputEnvelope = {
    data: ProspectActivityCreateManyCreatorInput | ProspectActivityCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type TechnicienCreateWithoutUtilisateurInput = {
    nom: string
    prenom: string
    contact: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    specialite: SpecialiteCreateNestedOneWithoutTechniciensInput
    interventions?: TechnicienInterventionCreateNestedManyWithoutTechnicienInput
    rapports?: RapportMissionCreateNestedManyWithoutTechnicienInput
    sortiesMateriels?: SortieMaterielCreateNestedManyWithoutTechnicienInput
  }

  export type TechnicienUncheckedCreateWithoutUtilisateurInput = {
    id?: number
    nom: string
    prenom: string
    contact: string
    specialiteId: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    interventions?: TechnicienInterventionUncheckedCreateNestedManyWithoutTechnicienInput
    rapports?: RapportMissionUncheckedCreateNestedManyWithoutTechnicienInput
    sortiesMateriels?: SortieMaterielUncheckedCreateNestedManyWithoutTechnicienInput
  }

  export type TechnicienCreateOrConnectWithoutUtilisateurInput = {
    where: TechnicienWhereUniqueInput
    create: XOR<TechnicienCreateWithoutUtilisateurInput, TechnicienUncheckedCreateWithoutUtilisateurInput>
  }

  export type NotificationCreateWithoutUserInput = {
    type: string
    message: string
    data?: string | null
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: number
    type: string
    message: string
    data?: string | null
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ServiceUpsertWithoutUsersInput = {
    update: XOR<ServiceUpdateWithoutUsersInput, ServiceUncheckedUpdateWithoutUsersInput>
    create: XOR<ServiceCreateWithoutUsersInput, ServiceUncheckedCreateWithoutUsersInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutUsersInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutUsersInput, ServiceUncheckedUpdateWithoutUsersInput>
  }

  export type ServiceUpdateWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customers?: CustomerUpdateManyWithoutServiceNestedInput
    employees?: EmployeeUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customers?: CustomerUncheckedUpdateManyWithoutServiceNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type CustomerUpsertWithWhereUniqueWithoutCreatorInput = {
    where: CustomerWhereUniqueInput
    update: XOR<CustomerUpdateWithoutCreatorInput, CustomerUncheckedUpdateWithoutCreatorInput>
    create: XOR<CustomerCreateWithoutCreatorInput, CustomerUncheckedCreateWithoutCreatorInput>
  }

  export type CustomerUpdateWithWhereUniqueWithoutCreatorInput = {
    where: CustomerWhereUniqueInput
    data: XOR<CustomerUpdateWithoutCreatorInput, CustomerUncheckedUpdateWithoutCreatorInput>
  }

  export type CustomerUpdateManyWithWhereWithoutCreatorInput = {
    where: CustomerScalarWhereInput
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyWithoutCreatorInput>
  }

  export type QuoteUpsertWithWhereUniqueWithoutCreatorInput = {
    where: QuoteWhereUniqueInput
    update: XOR<QuoteUpdateWithoutCreatorInput, QuoteUncheckedUpdateWithoutCreatorInput>
    create: XOR<QuoteCreateWithoutCreatorInput, QuoteUncheckedCreateWithoutCreatorInput>
  }

  export type QuoteUpdateWithWhereUniqueWithoutCreatorInput = {
    where: QuoteWhereUniqueInput
    data: XOR<QuoteUpdateWithoutCreatorInput, QuoteUncheckedUpdateWithoutCreatorInput>
  }

  export type QuoteUpdateManyWithWhereWithoutCreatorInput = {
    where: QuoteScalarWhereInput
    data: XOR<QuoteUpdateManyMutationInput, QuoteUncheckedUpdateManyWithoutCreatorInput>
  }

  export type QuoteScalarWhereInput = {
    AND?: QuoteScalarWhereInput | QuoteScalarWhereInput[]
    OR?: QuoteScalarWhereInput[]
    NOT?: QuoteScalarWhereInput | QuoteScalarWhereInput[]
    id?: IntFilter<"Quote"> | number
    quoteNumber?: StringFilter<"Quote"> | string
    customerId?: IntFilter<"Quote"> | number
    customerAddressId?: IntNullableFilter<"Quote"> | number | null
    status?: EnumQuoteStatusFilter<"Quote"> | $Enums.QuoteStatus
    quoteDate?: DateTimeFilter<"Quote"> | Date | string
    validUntil?: DateTimeFilter<"Quote"> | Date | string
    subtotalHt?: FloatFilter<"Quote"> | number
    discountAmount?: FloatFilter<"Quote"> | number
    totalVat?: FloatFilter<"Quote"> | number
    totalTtc?: FloatFilter<"Quote"> | number
    terms?: StringNullableFilter<"Quote"> | string | null
    notes?: StringNullableFilter<"Quote"> | string | null
    createdBy?: IntFilter<"Quote"> | number
    createdAt?: DateTimeFilter<"Quote"> | Date | string
    updatedAt?: DateTimeFilter<"Quote"> | Date | string
    sentAt?: DateTimeNullableFilter<"Quote"> | Date | string | null
    submittedForServiceApprovalAt?: DateTimeNullableFilter<"Quote"> | Date | string | null
    serviceManagerApprovedBy?: IntNullableFilter<"Quote"> | number | null
    serviceManagerApprovalDate?: DateTimeNullableFilter<"Quote"> | Date | string | null
    serviceManagerComments?: StringNullableFilter<"Quote"> | string | null
    dgApprovedBy?: IntNullableFilter<"Quote"> | number | null
    dgApprovalDate?: DateTimeNullableFilter<"Quote"> | Date | string | null
    dgComments?: StringNullableFilter<"Quote"> | string | null
    acceptedAt?: DateTimeNullableFilter<"Quote"> | Date | string | null
  }

  export type InvoiceUpsertWithWhereUniqueWithoutCreatorInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutCreatorInput, InvoiceUncheckedUpdateWithoutCreatorInput>
    create: XOR<InvoiceCreateWithoutCreatorInput, InvoiceUncheckedCreateWithoutCreatorInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutCreatorInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutCreatorInput, InvoiceUncheckedUpdateWithoutCreatorInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutCreatorInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutCreatorInput>
  }

  export type InvoiceScalarWhereInput = {
    AND?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    OR?: InvoiceScalarWhereInput[]
    NOT?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    id?: IntFilter<"Invoice"> | number
    invoiceNumber?: StringFilter<"Invoice"> | string
    customerId?: IntFilter<"Invoice"> | number
    customerAddressId?: IntNullableFilter<"Invoice"> | number | null
    quoteId?: IntNullableFilter<"Invoice"> | number | null
    type?: EnumInvoiceTypeFilter<"Invoice"> | $Enums.InvoiceType
    status?: EnumInvoiceStatusFilter<"Invoice"> | $Enums.InvoiceStatus
    invoiceDate?: DateTimeFilter<"Invoice"> | Date | string
    dueDate?: DateTimeFilter<"Invoice"> | Date | string
    subtotalHt?: FloatFilter<"Invoice"> | number
    discountAmount?: FloatFilter<"Invoice"> | number
    totalVat?: FloatFilter<"Invoice"> | number
    totalTtc?: FloatFilter<"Invoice"> | number
    paidAmount?: FloatFilter<"Invoice"> | number
    balanceDue?: FloatFilter<"Invoice"> | number
    paymentTerms?: IntFilter<"Invoice"> | number
    lateFeeRate?: FloatFilter<"Invoice"> | number
    terms?: StringNullableFilter<"Invoice"> | string | null
    notes?: StringNullableFilter<"Invoice"> | string | null
    createdBy?: IntFilter<"Invoice"> | number
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    sentAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
  }

  export type PaymentUpsertWithWhereUniqueWithoutCreatorInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutCreatorInput, PaymentUncheckedUpdateWithoutCreatorInput>
    create: XOR<PaymentCreateWithoutCreatorInput, PaymentUncheckedCreateWithoutCreatorInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutCreatorInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutCreatorInput, PaymentUncheckedUpdateWithoutCreatorInput>
  }

  export type PaymentUpdateManyWithWhereWithoutCreatorInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutCreatorInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: IntFilter<"Payment"> | number
    paymentNumber?: StringFilter<"Payment"> | string
    customerId?: IntFilter<"Payment"> | number
    amount?: FloatFilter<"Payment"> | number
    paymentDate?: DateTimeFilter<"Payment"> | Date | string
    paymentMethod?: EnumPaymentMethodFilter<"Payment"> | $Enums.PaymentMethod
    reference?: StringNullableFilter<"Payment"> | string | null
    notes?: StringNullableFilter<"Payment"> | string | null
    createdBy?: IntFilter<"Payment"> | number
    createdAt?: DateTimeFilter<"Payment"> | Date | string
  }

  export type QuoteUpsertWithWhereUniqueWithoutServiceManagerInput = {
    where: QuoteWhereUniqueInput
    update: XOR<QuoteUpdateWithoutServiceManagerInput, QuoteUncheckedUpdateWithoutServiceManagerInput>
    create: XOR<QuoteCreateWithoutServiceManagerInput, QuoteUncheckedCreateWithoutServiceManagerInput>
  }

  export type QuoteUpdateWithWhereUniqueWithoutServiceManagerInput = {
    where: QuoteWhereUniqueInput
    data: XOR<QuoteUpdateWithoutServiceManagerInput, QuoteUncheckedUpdateWithoutServiceManagerInput>
  }

  export type QuoteUpdateManyWithWhereWithoutServiceManagerInput = {
    where: QuoteScalarWhereInput
    data: XOR<QuoteUpdateManyMutationInput, QuoteUncheckedUpdateManyWithoutServiceManagerInput>
  }

  export type QuoteUpsertWithWhereUniqueWithoutDgApproverInput = {
    where: QuoteWhereUniqueInput
    update: XOR<QuoteUpdateWithoutDgApproverInput, QuoteUncheckedUpdateWithoutDgApproverInput>
    create: XOR<QuoteCreateWithoutDgApproverInput, QuoteUncheckedCreateWithoutDgApproverInput>
  }

  export type QuoteUpdateWithWhereUniqueWithoutDgApproverInput = {
    where: QuoteWhereUniqueInput
    data: XOR<QuoteUpdateWithoutDgApproverInput, QuoteUncheckedUpdateWithoutDgApproverInput>
  }

  export type QuoteUpdateManyWithWhereWithoutDgApproverInput = {
    where: QuoteScalarWhereInput
    data: XOR<QuoteUpdateManyMutationInput, QuoteUncheckedUpdateManyWithoutDgApproverInput>
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: IntFilter<"AuditLog"> | number
    userId?: IntFilter<"AuditLog"> | number
    action?: StringFilter<"AuditLog"> | string
    details?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type QuoteApprovalUpsertWithWhereUniqueWithoutApproverInput = {
    where: QuoteApprovalWhereUniqueInput
    update: XOR<QuoteApprovalUpdateWithoutApproverInput, QuoteApprovalUncheckedUpdateWithoutApproverInput>
    create: XOR<QuoteApprovalCreateWithoutApproverInput, QuoteApprovalUncheckedCreateWithoutApproverInput>
  }

  export type QuoteApprovalUpdateWithWhereUniqueWithoutApproverInput = {
    where: QuoteApprovalWhereUniqueInput
    data: XOR<QuoteApprovalUpdateWithoutApproverInput, QuoteApprovalUncheckedUpdateWithoutApproverInput>
  }

  export type QuoteApprovalUpdateManyWithWhereWithoutApproverInput = {
    where: QuoteApprovalScalarWhereInput
    data: XOR<QuoteApprovalUpdateManyMutationInput, QuoteApprovalUncheckedUpdateManyWithoutApproverInput>
  }

  export type QuoteApprovalScalarWhereInput = {
    AND?: QuoteApprovalScalarWhereInput | QuoteApprovalScalarWhereInput[]
    OR?: QuoteApprovalScalarWhereInput[]
    NOT?: QuoteApprovalScalarWhereInput | QuoteApprovalScalarWhereInput[]
    id?: IntFilter<"QuoteApproval"> | number
    quoteId?: IntFilter<"QuoteApproval"> | number
    approverId?: IntFilter<"QuoteApproval"> | number
    approvalLevel?: EnumApprovalLevelFilter<"QuoteApproval"> | $Enums.ApprovalLevel
    status?: EnumApprovalStatusFilter<"QuoteApproval"> | $Enums.ApprovalStatus
    approvalDate?: DateTimeNullableFilter<"QuoteApproval"> | Date | string | null
    comments?: StringNullableFilter<"QuoteApproval"> | string | null
    createdAt?: DateTimeFilter<"QuoteApproval"> | Date | string
    updatedAt?: DateTimeFilter<"QuoteApproval"> | Date | string
  }

  export type ExpenseUpsertWithWhereUniqueWithoutCreatorInput = {
    where: ExpenseWhereUniqueInput
    update: XOR<ExpenseUpdateWithoutCreatorInput, ExpenseUncheckedUpdateWithoutCreatorInput>
    create: XOR<ExpenseCreateWithoutCreatorInput, ExpenseUncheckedCreateWithoutCreatorInput>
  }

  export type ExpenseUpdateWithWhereUniqueWithoutCreatorInput = {
    where: ExpenseWhereUniqueInput
    data: XOR<ExpenseUpdateWithoutCreatorInput, ExpenseUncheckedUpdateWithoutCreatorInput>
  }

  export type ExpenseUpdateManyWithWhereWithoutCreatorInput = {
    where: ExpenseScalarWhereInput
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyWithoutCreatorInput>
  }

  export type ExpenseScalarWhereInput = {
    AND?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
    OR?: ExpenseScalarWhereInput[]
    NOT?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
    id?: IntFilter<"Expense"> | number
    expenseNumber?: StringFilter<"Expense"> | string
    supplierId?: IntNullableFilter<"Expense"> | number | null
    category?: StringFilter<"Expense"> | string
    description?: StringNullableFilter<"Expense"> | string | null
    amountHt?: FloatFilter<"Expense"> | number
    vatAmount?: FloatFilter<"Expense"> | number
    totalTtc?: FloatFilter<"Expense"> | number
    expenseDate?: DateTimeFilter<"Expense"> | Date | string
    paymentDate?: DateTimeNullableFilter<"Expense"> | Date | string | null
    paymentMethod?: EnumPaymentMethodFilter<"Expense"> | $Enums.PaymentMethod
    status?: EnumExpenseStatusFilter<"Expense"> | $Enums.ExpenseStatus
    receiptUrl?: StringNullableFilter<"Expense"> | string | null
    notes?: StringNullableFilter<"Expense"> | string | null
    createdBy?: IntFilter<"Expense"> | number
    createdAt?: DateTimeFilter<"Expense"> | Date | string
    updatedAt?: DateTimeFilter<"Expense"> | Date | string
  }

  export type AccountingEntryUpsertWithWhereUniqueWithoutCreatorInput = {
    where: AccountingEntryWhereUniqueInput
    update: XOR<AccountingEntryUpdateWithoutCreatorInput, AccountingEntryUncheckedUpdateWithoutCreatorInput>
    create: XOR<AccountingEntryCreateWithoutCreatorInput, AccountingEntryUncheckedCreateWithoutCreatorInput>
  }

  export type AccountingEntryUpdateWithWhereUniqueWithoutCreatorInput = {
    where: AccountingEntryWhereUniqueInput
    data: XOR<AccountingEntryUpdateWithoutCreatorInput, AccountingEntryUncheckedUpdateWithoutCreatorInput>
  }

  export type AccountingEntryUpdateManyWithWhereWithoutCreatorInput = {
    where: AccountingEntryScalarWhereInput
    data: XOR<AccountingEntryUpdateManyMutationInput, AccountingEntryUncheckedUpdateManyWithoutCreatorInput>
  }

  export type AccountingEntryScalarWhereInput = {
    AND?: AccountingEntryScalarWhereInput | AccountingEntryScalarWhereInput[]
    OR?: AccountingEntryScalarWhereInput[]
    NOT?: AccountingEntryScalarWhereInput | AccountingEntryScalarWhereInput[]
    id?: IntFilter<"AccountingEntry"> | number
    entryDate?: DateTimeFilter<"AccountingEntry"> | Date | string
    accountNumber?: StringFilter<"AccountingEntry"> | string
    debit?: FloatFilter<"AccountingEntry"> | number
    credit?: FloatFilter<"AccountingEntry"> | number
    description?: StringNullableFilter<"AccountingEntry"> | string | null
    sourceDocumentType?: EnumSourceDocumentTypeFilter<"AccountingEntry"> | $Enums.SourceDocumentType
    sourceDocumentId?: IntFilter<"AccountingEntry"> | number
    createdBy?: IntFilter<"AccountingEntry"> | number
    createdAt?: DateTimeFilter<"AccountingEntry"> | Date | string
  }

  export type CashFlowUpsertWithWhereUniqueWithoutCreatorInput = {
    where: CashFlowWhereUniqueInput
    update: XOR<CashFlowUpdateWithoutCreatorInput, CashFlowUncheckedUpdateWithoutCreatorInput>
    create: XOR<CashFlowCreateWithoutCreatorInput, CashFlowUncheckedCreateWithoutCreatorInput>
  }

  export type CashFlowUpdateWithWhereUniqueWithoutCreatorInput = {
    where: CashFlowWhereUniqueInput
    data: XOR<CashFlowUpdateWithoutCreatorInput, CashFlowUncheckedUpdateWithoutCreatorInput>
  }

  export type CashFlowUpdateManyWithWhereWithoutCreatorInput = {
    where: CashFlowScalarWhereInput
    data: XOR<CashFlowUpdateManyMutationInput, CashFlowUncheckedUpdateManyWithoutCreatorInput>
  }

  export type CashFlowScalarWhereInput = {
    AND?: CashFlowScalarWhereInput | CashFlowScalarWhereInput[]
    OR?: CashFlowScalarWhereInput[]
    NOT?: CashFlowScalarWhereInput | CashFlowScalarWhereInput[]
    id?: IntFilter<"CashFlow"> | number
    transactionDate?: DateTimeFilter<"CashFlow"> | Date | string
    type?: EnumCashFlowTypeFilter<"CashFlow"> | $Enums.CashFlowType
    amount?: FloatFilter<"CashFlow"> | number
    description?: StringNullableFilter<"CashFlow"> | string | null
    category?: StringNullableFilter<"CashFlow"> | string | null
    sourceDocumentType?: EnumSourceDocumentTypeFilter<"CashFlow"> | $Enums.SourceDocumentType
    sourceDocumentId?: IntFilter<"CashFlow"> | number
    createdBy?: IntFilter<"CashFlow"> | number
    createdAt?: DateTimeFilter<"CashFlow"> | Date | string
  }

  export type ReminderUpsertWithWhereUniqueWithoutCreatorInput = {
    where: ReminderWhereUniqueInput
    update: XOR<ReminderUpdateWithoutCreatorInput, ReminderUncheckedUpdateWithoutCreatorInput>
    create: XOR<ReminderCreateWithoutCreatorInput, ReminderUncheckedCreateWithoutCreatorInput>
  }

  export type ReminderUpdateWithWhereUniqueWithoutCreatorInput = {
    where: ReminderWhereUniqueInput
    data: XOR<ReminderUpdateWithoutCreatorInput, ReminderUncheckedUpdateWithoutCreatorInput>
  }

  export type ReminderUpdateManyWithWhereWithoutCreatorInput = {
    where: ReminderScalarWhereInput
    data: XOR<ReminderUpdateManyMutationInput, ReminderUncheckedUpdateManyWithoutCreatorInput>
  }

  export type ReminderScalarWhereInput = {
    AND?: ReminderScalarWhereInput | ReminderScalarWhereInput[]
    OR?: ReminderScalarWhereInput[]
    NOT?: ReminderScalarWhereInput | ReminderScalarWhereInput[]
    id?: IntFilter<"Reminder"> | number
    invoiceId?: IntFilter<"Reminder"> | number
    type?: EnumReminderTypeFilter<"Reminder"> | $Enums.ReminderType
    sentDate?: DateTimeFilter<"Reminder"> | Date | string
    dueDate?: DateTimeNullableFilter<"Reminder"> | Date | string | null
    amountDue?: FloatFilter<"Reminder"> | number
    lateFees?: FloatFilter<"Reminder"> | number
    status?: EnumReminderStatusFilter<"Reminder"> | $Enums.ReminderStatus
    emailSubject?: StringNullableFilter<"Reminder"> | string | null
    emailBody?: StringNullableFilter<"Reminder"> | string | null
    createdBy?: IntFilter<"Reminder"> | number
    createdAt?: DateTimeFilter<"Reminder"> | Date | string
  }

  export type RecurringInvoiceUpsertWithWhereUniqueWithoutCreatorInput = {
    where: RecurringInvoiceWhereUniqueInput
    update: XOR<RecurringInvoiceUpdateWithoutCreatorInput, RecurringInvoiceUncheckedUpdateWithoutCreatorInput>
    create: XOR<RecurringInvoiceCreateWithoutCreatorInput, RecurringInvoiceUncheckedCreateWithoutCreatorInput>
  }

  export type RecurringInvoiceUpdateWithWhereUniqueWithoutCreatorInput = {
    where: RecurringInvoiceWhereUniqueInput
    data: XOR<RecurringInvoiceUpdateWithoutCreatorInput, RecurringInvoiceUncheckedUpdateWithoutCreatorInput>
  }

  export type RecurringInvoiceUpdateManyWithWhereWithoutCreatorInput = {
    where: RecurringInvoiceScalarWhereInput
    data: XOR<RecurringInvoiceUpdateManyMutationInput, RecurringInvoiceUncheckedUpdateManyWithoutCreatorInput>
  }

  export type RecurringInvoiceScalarWhereInput = {
    AND?: RecurringInvoiceScalarWhereInput | RecurringInvoiceScalarWhereInput[]
    OR?: RecurringInvoiceScalarWhereInput[]
    NOT?: RecurringInvoiceScalarWhereInput | RecurringInvoiceScalarWhereInput[]
    id?: IntFilter<"RecurringInvoice"> | number
    customerId?: IntFilter<"RecurringInvoice"> | number
    templateName?: StringFilter<"RecurringInvoice"> | string
    frequency?: EnumRecurringFrequencyFilter<"RecurringInvoice"> | $Enums.RecurringFrequency
    startDate?: DateTimeFilter<"RecurringInvoice"> | Date | string
    endDate?: DateTimeNullableFilter<"RecurringInvoice"> | Date | string | null
    nextInvoiceDate?: DateTimeFilter<"RecurringInvoice"> | Date | string
    isActive?: BoolFilter<"RecurringInvoice"> | boolean
    subtotalHt?: FloatFilter<"RecurringInvoice"> | number
    totalVat?: FloatFilter<"RecurringInvoice"> | number
    totalTtc?: FloatFilter<"RecurringInvoice"> | number
    terms?: StringNullableFilter<"RecurringInvoice"> | string | null
    notes?: StringNullableFilter<"RecurringInvoice"> | string | null
    createdBy?: IntFilter<"RecurringInvoice"> | number
    createdAt?: DateTimeFilter<"RecurringInvoice"> | Date | string
    updatedAt?: DateTimeFilter<"RecurringInvoice"> | Date | string
  }

  export type EmployeeUpsertWithoutUserInput = {
    update: XOR<EmployeeUpdateWithoutUserInput, EmployeeUncheckedUpdateWithoutUserInput>
    create: XOR<EmployeeCreateWithoutUserInput, EmployeeUncheckedCreateWithoutUserInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutUserInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutUserInput, EmployeeUncheckedUpdateWithoutUserInput>
  }

  export type EmployeeUpdateWithoutUserInput = {
    employeeNumber?: StringFieldUpdateOperationsInput | string
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    placeOfBirth?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    socialSecurityNumber?: NullableStringFieldUpdateOperationsInput | string | null
    cnpsNumber?: NullableStringFieldUpdateOperationsInput | string | null
    cnamNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    position?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    manager?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneWithoutEmployeesNestedInput
    contracts?: ContractUpdateManyWithoutEmployeeNestedInput
    salaries?: SalaryUpdateManyWithoutEmployeeNestedInput
    leaveRequests?: LeaveRequestUpdateManyWithoutEmployeeNestedInput
    loans?: LoanUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeNumber?: StringFieldUpdateOperationsInput | string
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    placeOfBirth?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    socialSecurityNumber?: NullableStringFieldUpdateOperationsInput | string | null
    cnpsNumber?: NullableStringFieldUpdateOperationsInput | string | null
    cnamNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: NullableIntFieldUpdateOperationsInput | number | null
    position?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    manager?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contracts?: ContractUncheckedUpdateManyWithoutEmployeeNestedInput
    salaries?: SalaryUncheckedUpdateManyWithoutEmployeeNestedInput
    leaveRequests?: LeaveRequestUncheckedUpdateManyWithoutEmployeeNestedInput
    loans?: LoanUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type LeaveRequestUpsertWithWhereUniqueWithoutApprovedByInput = {
    where: LeaveRequestWhereUniqueInput
    update: XOR<LeaveRequestUpdateWithoutApprovedByInput, LeaveRequestUncheckedUpdateWithoutApprovedByInput>
    create: XOR<LeaveRequestCreateWithoutApprovedByInput, LeaveRequestUncheckedCreateWithoutApprovedByInput>
  }

  export type LeaveRequestUpdateWithWhereUniqueWithoutApprovedByInput = {
    where: LeaveRequestWhereUniqueInput
    data: XOR<LeaveRequestUpdateWithoutApprovedByInput, LeaveRequestUncheckedUpdateWithoutApprovedByInput>
  }

  export type LeaveRequestUpdateManyWithWhereWithoutApprovedByInput = {
    where: LeaveRequestScalarWhereInput
    data: XOR<LeaveRequestUpdateManyMutationInput, LeaveRequestUncheckedUpdateManyWithoutApprovedByInput>
  }

  export type LeaveRequestScalarWhereInput = {
    AND?: LeaveRequestScalarWhereInput | LeaveRequestScalarWhereInput[]
    OR?: LeaveRequestScalarWhereInput[]
    NOT?: LeaveRequestScalarWhereInput | LeaveRequestScalarWhereInput[]
    id?: IntFilter<"LeaveRequest"> | number
    employeeId?: IntFilter<"LeaveRequest"> | number
    leaveType?: EnumLeaveTypeFilter<"LeaveRequest"> | $Enums.LeaveType
    startDate?: DateTimeFilter<"LeaveRequest"> | Date | string
    endDate?: DateTimeFilter<"LeaveRequest"> | Date | string
    days?: IntFilter<"LeaveRequest"> | number
    reason?: StringFilter<"LeaveRequest"> | string
    notes?: StringNullableFilter<"LeaveRequest"> | string | null
    status?: EnumLeaveStatusFilter<"LeaveRequest"> | $Enums.LeaveStatus
    approvedById?: IntNullableFilter<"LeaveRequest"> | number | null
    approvedAt?: DateTimeNullableFilter<"LeaveRequest"> | Date | string | null
    comments?: StringNullableFilter<"LeaveRequest"> | string | null
    createdAt?: DateTimeFilter<"LeaveRequest"> | Date | string
    updatedAt?: DateTimeFilter<"LeaveRequest"> | Date | string
  }

  export type ProspectUpsertWithWhereUniqueWithoutAssignedUserInput = {
    where: ProspectWhereUniqueInput
    update: XOR<ProspectUpdateWithoutAssignedUserInput, ProspectUncheckedUpdateWithoutAssignedUserInput>
    create: XOR<ProspectCreateWithoutAssignedUserInput, ProspectUncheckedCreateWithoutAssignedUserInput>
  }

  export type ProspectUpdateWithWhereUniqueWithoutAssignedUserInput = {
    where: ProspectWhereUniqueInput
    data: XOR<ProspectUpdateWithoutAssignedUserInput, ProspectUncheckedUpdateWithoutAssignedUserInput>
  }

  export type ProspectUpdateManyWithWhereWithoutAssignedUserInput = {
    where: ProspectScalarWhereInput
    data: XOR<ProspectUpdateManyMutationInput, ProspectUncheckedUpdateManyWithoutAssignedUserInput>
  }

  export type ProspectScalarWhereInput = {
    AND?: ProspectScalarWhereInput | ProspectScalarWhereInput[]
    OR?: ProspectScalarWhereInput[]
    NOT?: ProspectScalarWhereInput | ProspectScalarWhereInput[]
    id?: IntFilter<"Prospect"> | number
    companyName?: StringFilter<"Prospect"> | string
    contactName?: StringFilter<"Prospect"> | string
    position?: StringNullableFilter<"Prospect"> | string | null
    email?: StringNullableFilter<"Prospect"> | string | null
    phone?: StringNullableFilter<"Prospect"> | string | null
    address?: StringNullableFilter<"Prospect"> | string | null
    website?: StringNullableFilter<"Prospect"> | string | null
    industry?: StringNullableFilter<"Prospect"> | string | null
    companySize?: StringNullableFilter<"Prospect"> | string | null
    estimatedValue?: FloatNullableFilter<"Prospect"> | number | null
    priority?: StringFilter<"Prospect"> | string
    stage?: StringFilter<"Prospect"> | string
    source?: StringNullableFilter<"Prospect"> | string | null
    notes?: StringNullableFilter<"Prospect"> | string | null
    hasBudget?: BoolFilter<"Prospect"> | boolean
    isDecisionMaker?: BoolFilter<"Prospect"> | boolean
    hasNeed?: BoolFilter<"Prospect"> | boolean
    timeline?: StringNullableFilter<"Prospect"> | string | null
    lastContact?: DateTimeFilter<"Prospect"> | Date | string
    nextAction?: StringNullableFilter<"Prospect"> | string | null
    nextActionDate?: DateTimeNullableFilter<"Prospect"> | Date | string | null
    assignedTo?: IntNullableFilter<"Prospect"> | number | null
    createdBy?: IntFilter<"Prospect"> | number
    createdAt?: DateTimeFilter<"Prospect"> | Date | string
    updatedAt?: DateTimeFilter<"Prospect"> | Date | string
  }

  export type ProspectUpsertWithWhereUniqueWithoutCreatorInput = {
    where: ProspectWhereUniqueInput
    update: XOR<ProspectUpdateWithoutCreatorInput, ProspectUncheckedUpdateWithoutCreatorInput>
    create: XOR<ProspectCreateWithoutCreatorInput, ProspectUncheckedCreateWithoutCreatorInput>
  }

  export type ProspectUpdateWithWhereUniqueWithoutCreatorInput = {
    where: ProspectWhereUniqueInput
    data: XOR<ProspectUpdateWithoutCreatorInput, ProspectUncheckedUpdateWithoutCreatorInput>
  }

  export type ProspectUpdateManyWithWhereWithoutCreatorInput = {
    where: ProspectScalarWhereInput
    data: XOR<ProspectUpdateManyMutationInput, ProspectUncheckedUpdateManyWithoutCreatorInput>
  }

  export type ProspectActivityUpsertWithWhereUniqueWithoutCreatorInput = {
    where: ProspectActivityWhereUniqueInput
    update: XOR<ProspectActivityUpdateWithoutCreatorInput, ProspectActivityUncheckedUpdateWithoutCreatorInput>
    create: XOR<ProspectActivityCreateWithoutCreatorInput, ProspectActivityUncheckedCreateWithoutCreatorInput>
  }

  export type ProspectActivityUpdateWithWhereUniqueWithoutCreatorInput = {
    where: ProspectActivityWhereUniqueInput
    data: XOR<ProspectActivityUpdateWithoutCreatorInput, ProspectActivityUncheckedUpdateWithoutCreatorInput>
  }

  export type ProspectActivityUpdateManyWithWhereWithoutCreatorInput = {
    where: ProspectActivityScalarWhereInput
    data: XOR<ProspectActivityUpdateManyMutationInput, ProspectActivityUncheckedUpdateManyWithoutCreatorInput>
  }

  export type ProspectActivityScalarWhereInput = {
    AND?: ProspectActivityScalarWhereInput | ProspectActivityScalarWhereInput[]
    OR?: ProspectActivityScalarWhereInput[]
    NOT?: ProspectActivityScalarWhereInput | ProspectActivityScalarWhereInput[]
    id?: IntFilter<"ProspectActivity"> | number
    prospectId?: IntFilter<"ProspectActivity"> | number
    type?: StringFilter<"ProspectActivity"> | string
    subject?: StringNullableFilter<"ProspectActivity"> | string | null
    description?: StringNullableFilter<"ProspectActivity"> | string | null
    scheduledAt?: DateTimeNullableFilter<"ProspectActivity"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"ProspectActivity"> | Date | string | null
    outcome?: StringNullableFilter<"ProspectActivity"> | string | null
    nextAction?: StringNullableFilter<"ProspectActivity"> | string | null
    createdBy?: IntFilter<"ProspectActivity"> | number
    createdAt?: DateTimeFilter<"ProspectActivity"> | Date | string
  }

  export type TechnicienUpsertWithoutUtilisateurInput = {
    update: XOR<TechnicienUpdateWithoutUtilisateurInput, TechnicienUncheckedUpdateWithoutUtilisateurInput>
    create: XOR<TechnicienCreateWithoutUtilisateurInput, TechnicienUncheckedCreateWithoutUtilisateurInput>
    where?: TechnicienWhereInput
  }

  export type TechnicienUpdateToOneWithWhereWithoutUtilisateurInput = {
    where?: TechnicienWhereInput
    data: XOR<TechnicienUpdateWithoutUtilisateurInput, TechnicienUncheckedUpdateWithoutUtilisateurInput>
  }

  export type TechnicienUpdateWithoutUtilisateurInput = {
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    specialite?: SpecialiteUpdateOneRequiredWithoutTechniciensNestedInput
    interventions?: TechnicienInterventionUpdateManyWithoutTechnicienNestedInput
    rapports?: RapportMissionUpdateManyWithoutTechnicienNestedInput
    sortiesMateriels?: SortieMaterielUpdateManyWithoutTechnicienNestedInput
  }

  export type TechnicienUncheckedUpdateWithoutUtilisateurInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    specialiteId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interventions?: TechnicienInterventionUncheckedUpdateManyWithoutTechnicienNestedInput
    rapports?: RapportMissionUncheckedUpdateManyWithoutTechnicienNestedInput
    sortiesMateriels?: SortieMaterielUncheckedUpdateManyWithoutTechnicienNestedInput
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: IntFilter<"Notification"> | number
    type?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    data?: StringNullableFilter<"Notification"> | string | null
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    userId?: IntFilter<"Notification"> | number
  }

  export type ServiceCreateWithoutCustomersInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutServiceInput
    employees?: EmployeeCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutCustomersInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutServiceInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutCustomersInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutCustomersInput, ServiceUncheckedCreateWithoutCustomersInput>
  }

  export type UserCreateWithoutCreatedCustomersInput = {
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    preferences?: string | null
    permissions?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    service?: ServiceCreateNestedOneWithoutUsersInput
    createdQuotes?: QuoteCreateNestedManyWithoutCreatorInput
    createdInvoices?: InvoiceCreateNestedManyWithoutCreatorInput
    createdPayments?: PaymentCreateNestedManyWithoutCreatorInput
    serviceApprovals?: QuoteCreateNestedManyWithoutServiceManagerInput
    dgApprovals?: QuoteCreateNestedManyWithoutDgApproverInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    quoteApprovals?: QuoteApprovalCreateNestedManyWithoutApproverInput
    createdExpenses?: ExpenseCreateNestedManyWithoutCreatorInput
    accountingEntries?: AccountingEntryCreateNestedManyWithoutCreatorInput
    cashFlowEntries?: CashFlowCreateNestedManyWithoutCreatorInput
    createdReminders?: ReminderCreateNestedManyWithoutCreatorInput
    createdRecurringInvoices?: RecurringInvoiceCreateNestedManyWithoutCreatorInput
    employee?: EmployeeCreateNestedOneWithoutUserInput
    leaveApprovals?: LeaveRequestCreateNestedManyWithoutApprovedByInput
    assignedProspects?: ProspectCreateNestedManyWithoutAssignedUserInput
    createdProspects?: ProspectCreateNestedManyWithoutCreatorInput
    createdProspectActivities?: ProspectActivityCreateNestedManyWithoutCreatorInput
    technicien?: TechnicienCreateNestedOneWithoutUtilisateurInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedCustomersInput = {
    id?: number
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    serviceId?: number | null
    isActive?: boolean
    lastLogin?: Date | string | null
    preferences?: string | null
    permissions?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdQuotes?: QuoteUncheckedCreateNestedManyWithoutCreatorInput
    createdInvoices?: InvoiceUncheckedCreateNestedManyWithoutCreatorInput
    createdPayments?: PaymentUncheckedCreateNestedManyWithoutCreatorInput
    serviceApprovals?: QuoteUncheckedCreateNestedManyWithoutServiceManagerInput
    dgApprovals?: QuoteUncheckedCreateNestedManyWithoutDgApproverInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    quoteApprovals?: QuoteApprovalUncheckedCreateNestedManyWithoutApproverInput
    createdExpenses?: ExpenseUncheckedCreateNestedManyWithoutCreatorInput
    accountingEntries?: AccountingEntryUncheckedCreateNestedManyWithoutCreatorInput
    cashFlowEntries?: CashFlowUncheckedCreateNestedManyWithoutCreatorInput
    createdReminders?: ReminderUncheckedCreateNestedManyWithoutCreatorInput
    createdRecurringInvoices?: RecurringInvoiceUncheckedCreateNestedManyWithoutCreatorInput
    employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    leaveApprovals?: LeaveRequestUncheckedCreateNestedManyWithoutApprovedByInput
    assignedProspects?: ProspectUncheckedCreateNestedManyWithoutAssignedUserInput
    createdProspects?: ProspectUncheckedCreateNestedManyWithoutCreatorInput
    createdProspectActivities?: ProspectActivityUncheckedCreateNestedManyWithoutCreatorInput
    technicien?: TechnicienUncheckedCreateNestedOneWithoutUtilisateurInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedCustomersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedCustomersInput, UserUncheckedCreateWithoutCreatedCustomersInput>
  }

  export type CustomerAddressCreateWithoutCustomerInput = {
    type: $Enums.AddressType
    name?: string | null
    addressLine1: string
    addressLine2?: string | null
    postalCode: string
    city: string
    country?: string
    isDefault?: boolean
    createdAt?: Date | string
    quotes?: QuoteCreateNestedManyWithoutCustomerAddressInput
    invoices?: InvoiceCreateNestedManyWithoutCustomerAddressInput
  }

  export type CustomerAddressUncheckedCreateWithoutCustomerInput = {
    id?: number
    type: $Enums.AddressType
    name?: string | null
    addressLine1: string
    addressLine2?: string | null
    postalCode: string
    city: string
    country?: string
    isDefault?: boolean
    createdAt?: Date | string
    quotes?: QuoteUncheckedCreateNestedManyWithoutCustomerAddressInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCustomerAddressInput
  }

  export type CustomerAddressCreateOrConnectWithoutCustomerInput = {
    where: CustomerAddressWhereUniqueInput
    create: XOR<CustomerAddressCreateWithoutCustomerInput, CustomerAddressUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerAddressCreateManyCustomerInputEnvelope = {
    data: CustomerAddressCreateManyCustomerInput | CustomerAddressCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type QuoteCreateWithoutCustomerInput = {
    quoteNumber: string
    status?: $Enums.QuoteStatus
    quoteDate: Date | string
    validUntil: Date | string
    subtotalHt?: number
    discountAmount?: number
    totalVat?: number
    totalTtc?: number
    terms?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt?: Date | string | null
    submittedForServiceApprovalAt?: Date | string | null
    serviceManagerApprovalDate?: Date | string | null
    serviceManagerComments?: string | null
    dgApprovalDate?: Date | string | null
    dgComments?: string | null
    acceptedAt?: Date | string | null
    customerAddress?: CustomerAddressCreateNestedOneWithoutQuotesInput
    creator: UserCreateNestedOneWithoutCreatedQuotesInput
    serviceManager?: UserCreateNestedOneWithoutServiceApprovalsInput
    dgApprover?: UserCreateNestedOneWithoutDgApprovalsInput
    items?: QuoteItemCreateNestedManyWithoutQuoteInput
    invoices?: InvoiceCreateNestedManyWithoutQuoteInput
    approvals?: QuoteApprovalCreateNestedManyWithoutQuoteInput
    missions?: MissionCreateNestedManyWithoutDevisInput
  }

  export type QuoteUncheckedCreateWithoutCustomerInput = {
    id?: number
    quoteNumber: string
    customerAddressId?: number | null
    status?: $Enums.QuoteStatus
    quoteDate: Date | string
    validUntil: Date | string
    subtotalHt?: number
    discountAmount?: number
    totalVat?: number
    totalTtc?: number
    terms?: string | null
    notes?: string | null
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt?: Date | string | null
    submittedForServiceApprovalAt?: Date | string | null
    serviceManagerApprovedBy?: number | null
    serviceManagerApprovalDate?: Date | string | null
    serviceManagerComments?: string | null
    dgApprovedBy?: number | null
    dgApprovalDate?: Date | string | null
    dgComments?: string | null
    acceptedAt?: Date | string | null
    items?: QuoteItemUncheckedCreateNestedManyWithoutQuoteInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutQuoteInput
    approvals?: QuoteApprovalUncheckedCreateNestedManyWithoutQuoteInput
    missions?: MissionUncheckedCreateNestedManyWithoutDevisInput
  }

  export type QuoteCreateOrConnectWithoutCustomerInput = {
    where: QuoteWhereUniqueInput
    create: XOR<QuoteCreateWithoutCustomerInput, QuoteUncheckedCreateWithoutCustomerInput>
  }

  export type QuoteCreateManyCustomerInputEnvelope = {
    data: QuoteCreateManyCustomerInput | QuoteCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutCustomerInput = {
    invoiceNumber: string
    type?: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    invoiceDate: Date | string
    dueDate: Date | string
    subtotalHt?: number
    discountAmount?: number
    totalVat?: number
    totalTtc?: number
    paidAmount?: number
    balanceDue?: number
    paymentTerms?: number
    lateFeeRate?: number
    terms?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt?: Date | string | null
    customerAddress?: CustomerAddressCreateNestedOneWithoutInvoicesInput
    quote?: QuoteCreateNestedOneWithoutInvoicesInput
    creator: UserCreateNestedOneWithoutCreatedInvoicesInput
    items?: InvoiceItemCreateNestedManyWithoutInvoiceInput
    paymentAllocations?: PaymentAllocationCreateNestedManyWithoutInvoiceInput
    reminders?: ReminderCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutCustomerInput = {
    id?: number
    invoiceNumber: string
    customerAddressId?: number | null
    quoteId?: number | null
    type?: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    invoiceDate: Date | string
    dueDate: Date | string
    subtotalHt?: number
    discountAmount?: number
    totalVat?: number
    totalTtc?: number
    paidAmount?: number
    balanceDue?: number
    paymentTerms?: number
    lateFeeRate?: number
    terms?: string | null
    notes?: string | null
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt?: Date | string | null
    items?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
    paymentAllocations?: PaymentAllocationUncheckedCreateNestedManyWithoutInvoiceInput
    reminders?: ReminderUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutCustomerInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutCustomerInput, InvoiceUncheckedCreateWithoutCustomerInput>
  }

  export type InvoiceCreateManyCustomerInputEnvelope = {
    data: InvoiceCreateManyCustomerInput | InvoiceCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutCustomerInput = {
    paymentNumber: string
    amount: number
    paymentDate: Date | string
    paymentMethod: $Enums.PaymentMethod
    reference?: string | null
    notes?: string | null
    createdAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedPaymentsInput
    allocations?: PaymentAllocationCreateNestedManyWithoutPaymentInput
  }

  export type PaymentUncheckedCreateWithoutCustomerInput = {
    id?: number
    paymentNumber: string
    amount: number
    paymentDate: Date | string
    paymentMethod: $Enums.PaymentMethod
    reference?: string | null
    notes?: string | null
    createdBy: number
    createdAt?: Date | string
    allocations?: PaymentAllocationUncheckedCreateNestedManyWithoutPaymentInput
  }

  export type PaymentCreateOrConnectWithoutCustomerInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutCustomerInput, PaymentUncheckedCreateWithoutCustomerInput>
  }

  export type PaymentCreateManyCustomerInputEnvelope = {
    data: PaymentCreateManyCustomerInput | PaymentCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type RecurringInvoiceCreateWithoutCustomerInput = {
    templateName: string
    frequency: $Enums.RecurringFrequency
    startDate: Date | string
    endDate?: Date | string | null
    nextInvoiceDate: Date | string
    isActive?: boolean
    subtotalHt?: number
    totalVat?: number
    totalTtc?: number
    terms?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedRecurringInvoicesInput
    items?: RecurringInvoiceItemCreateNestedManyWithoutRecurringInvoiceInput
  }

  export type RecurringInvoiceUncheckedCreateWithoutCustomerInput = {
    id?: number
    templateName: string
    frequency: $Enums.RecurringFrequency
    startDate: Date | string
    endDate?: Date | string | null
    nextInvoiceDate: Date | string
    isActive?: boolean
    subtotalHt?: number
    totalVat?: number
    totalTtc?: number
    terms?: string | null
    notes?: string | null
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: RecurringInvoiceItemUncheckedCreateNestedManyWithoutRecurringInvoiceInput
  }

  export type RecurringInvoiceCreateOrConnectWithoutCustomerInput = {
    where: RecurringInvoiceWhereUniqueInput
    create: XOR<RecurringInvoiceCreateWithoutCustomerInput, RecurringInvoiceUncheckedCreateWithoutCustomerInput>
  }

  export type RecurringInvoiceCreateManyCustomerInputEnvelope = {
    data: RecurringInvoiceCreateManyCustomerInput | RecurringInvoiceCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type MissionCreateWithoutClientInput = {
    numIntervention: string
    natureIntervention: string
    objectifDuContrat: string
    description?: string | null
    priorite?: string | null
    statut?: string | null
    dateSortieFicheIntervention: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    interventions?: InterventionCreateNestedManyWithoutMissionInput
    rapports?: RapportMissionCreateNestedManyWithoutMissionInput
    devis?: QuoteCreateNestedManyWithoutMissionsInput
  }

  export type MissionUncheckedCreateWithoutClientInput = {
    numIntervention: string
    natureIntervention: string
    objectifDuContrat: string
    description?: string | null
    priorite?: string | null
    statut?: string | null
    dateSortieFicheIntervention: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    interventions?: InterventionUncheckedCreateNestedManyWithoutMissionInput
    rapports?: RapportMissionUncheckedCreateNestedManyWithoutMissionInput
    devis?: QuoteUncheckedCreateNestedManyWithoutMissionsInput
  }

  export type MissionCreateOrConnectWithoutClientInput = {
    where: MissionWhereUniqueInput
    create: XOR<MissionCreateWithoutClientInput, MissionUncheckedCreateWithoutClientInput>
  }

  export type MissionCreateManyClientInputEnvelope = {
    data: MissionCreateManyClientInput | MissionCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type ServiceUpsertWithoutCustomersInput = {
    update: XOR<ServiceUpdateWithoutCustomersInput, ServiceUncheckedUpdateWithoutCustomersInput>
    create: XOR<ServiceCreateWithoutCustomersInput, ServiceUncheckedCreateWithoutCustomersInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutCustomersInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutCustomersInput, ServiceUncheckedUpdateWithoutCustomersInput>
  }

  export type ServiceUpdateWithoutCustomersInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutServiceNestedInput
    employees?: EmployeeUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutCustomersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutServiceNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type UserUpsertWithoutCreatedCustomersInput = {
    update: XOR<UserUpdateWithoutCreatedCustomersInput, UserUncheckedUpdateWithoutCreatedCustomersInput>
    create: XOR<UserCreateWithoutCreatedCustomersInput, UserUncheckedCreateWithoutCreatedCustomersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedCustomersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedCustomersInput, UserUncheckedUpdateWithoutCreatedCustomersInput>
  }

  export type UserUpdateWithoutCreatedCustomersInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneWithoutUsersNestedInput
    createdQuotes?: QuoteUpdateManyWithoutCreatorNestedInput
    createdInvoices?: InvoiceUpdateManyWithoutCreatorNestedInput
    createdPayments?: PaymentUpdateManyWithoutCreatorNestedInput
    serviceApprovals?: QuoteUpdateManyWithoutServiceManagerNestedInput
    dgApprovals?: QuoteUpdateManyWithoutDgApproverNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    quoteApprovals?: QuoteApprovalUpdateManyWithoutApproverNestedInput
    createdExpenses?: ExpenseUpdateManyWithoutCreatorNestedInput
    accountingEntries?: AccountingEntryUpdateManyWithoutCreatorNestedInput
    cashFlowEntries?: CashFlowUpdateManyWithoutCreatorNestedInput
    createdReminders?: ReminderUpdateManyWithoutCreatorNestedInput
    createdRecurringInvoices?: RecurringInvoiceUpdateManyWithoutCreatorNestedInput
    employee?: EmployeeUpdateOneWithoutUserNestedInput
    leaveApprovals?: LeaveRequestUpdateManyWithoutApprovedByNestedInput
    assignedProspects?: ProspectUpdateManyWithoutAssignedUserNestedInput
    createdProspects?: ProspectUpdateManyWithoutCreatorNestedInput
    createdProspectActivities?: ProspectActivityUpdateManyWithoutCreatorNestedInput
    technicien?: TechnicienUpdateOneWithoutUtilisateurNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedCustomersInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    serviceId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdQuotes?: QuoteUncheckedUpdateManyWithoutCreatorNestedInput
    createdInvoices?: InvoiceUncheckedUpdateManyWithoutCreatorNestedInput
    createdPayments?: PaymentUncheckedUpdateManyWithoutCreatorNestedInput
    serviceApprovals?: QuoteUncheckedUpdateManyWithoutServiceManagerNestedInput
    dgApprovals?: QuoteUncheckedUpdateManyWithoutDgApproverNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    quoteApprovals?: QuoteApprovalUncheckedUpdateManyWithoutApproverNestedInput
    createdExpenses?: ExpenseUncheckedUpdateManyWithoutCreatorNestedInput
    accountingEntries?: AccountingEntryUncheckedUpdateManyWithoutCreatorNestedInput
    cashFlowEntries?: CashFlowUncheckedUpdateManyWithoutCreatorNestedInput
    createdReminders?: ReminderUncheckedUpdateManyWithoutCreatorNestedInput
    createdRecurringInvoices?: RecurringInvoiceUncheckedUpdateManyWithoutCreatorNestedInput
    employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    leaveApprovals?: LeaveRequestUncheckedUpdateManyWithoutApprovedByNestedInput
    assignedProspects?: ProspectUncheckedUpdateManyWithoutAssignedUserNestedInput
    createdProspects?: ProspectUncheckedUpdateManyWithoutCreatorNestedInput
    createdProspectActivities?: ProspectActivityUncheckedUpdateManyWithoutCreatorNestedInput
    technicien?: TechnicienUncheckedUpdateOneWithoutUtilisateurNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CustomerAddressUpsertWithWhereUniqueWithoutCustomerInput = {
    where: CustomerAddressWhereUniqueInput
    update: XOR<CustomerAddressUpdateWithoutCustomerInput, CustomerAddressUncheckedUpdateWithoutCustomerInput>
    create: XOR<CustomerAddressCreateWithoutCustomerInput, CustomerAddressUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerAddressUpdateWithWhereUniqueWithoutCustomerInput = {
    where: CustomerAddressWhereUniqueInput
    data: XOR<CustomerAddressUpdateWithoutCustomerInput, CustomerAddressUncheckedUpdateWithoutCustomerInput>
  }

  export type CustomerAddressUpdateManyWithWhereWithoutCustomerInput = {
    where: CustomerAddressScalarWhereInput
    data: XOR<CustomerAddressUpdateManyMutationInput, CustomerAddressUncheckedUpdateManyWithoutCustomerInput>
  }

  export type CustomerAddressScalarWhereInput = {
    AND?: CustomerAddressScalarWhereInput | CustomerAddressScalarWhereInput[]
    OR?: CustomerAddressScalarWhereInput[]
    NOT?: CustomerAddressScalarWhereInput | CustomerAddressScalarWhereInput[]
    id?: IntFilter<"CustomerAddress"> | number
    customerId?: IntFilter<"CustomerAddress"> | number
    type?: EnumAddressTypeFilter<"CustomerAddress"> | $Enums.AddressType
    name?: StringNullableFilter<"CustomerAddress"> | string | null
    addressLine1?: StringFilter<"CustomerAddress"> | string
    addressLine2?: StringNullableFilter<"CustomerAddress"> | string | null
    postalCode?: StringFilter<"CustomerAddress"> | string
    city?: StringFilter<"CustomerAddress"> | string
    country?: StringFilter<"CustomerAddress"> | string
    isDefault?: BoolFilter<"CustomerAddress"> | boolean
    createdAt?: DateTimeFilter<"CustomerAddress"> | Date | string
  }

  export type QuoteUpsertWithWhereUniqueWithoutCustomerInput = {
    where: QuoteWhereUniqueInput
    update: XOR<QuoteUpdateWithoutCustomerInput, QuoteUncheckedUpdateWithoutCustomerInput>
    create: XOR<QuoteCreateWithoutCustomerInput, QuoteUncheckedCreateWithoutCustomerInput>
  }

  export type QuoteUpdateWithWhereUniqueWithoutCustomerInput = {
    where: QuoteWhereUniqueInput
    data: XOR<QuoteUpdateWithoutCustomerInput, QuoteUncheckedUpdateWithoutCustomerInput>
  }

  export type QuoteUpdateManyWithWhereWithoutCustomerInput = {
    where: QuoteScalarWhereInput
    data: XOR<QuoteUpdateManyMutationInput, QuoteUncheckedUpdateManyWithoutCustomerInput>
  }

  export type InvoiceUpsertWithWhereUniqueWithoutCustomerInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutCustomerInput, InvoiceUncheckedUpdateWithoutCustomerInput>
    create: XOR<InvoiceCreateWithoutCustomerInput, InvoiceUncheckedCreateWithoutCustomerInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutCustomerInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutCustomerInput, InvoiceUncheckedUpdateWithoutCustomerInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutCustomerInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutCustomerInput>
  }

  export type PaymentUpsertWithWhereUniqueWithoutCustomerInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutCustomerInput, PaymentUncheckedUpdateWithoutCustomerInput>
    create: XOR<PaymentCreateWithoutCustomerInput, PaymentUncheckedCreateWithoutCustomerInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutCustomerInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutCustomerInput, PaymentUncheckedUpdateWithoutCustomerInput>
  }

  export type PaymentUpdateManyWithWhereWithoutCustomerInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutCustomerInput>
  }

  export type RecurringInvoiceUpsertWithWhereUniqueWithoutCustomerInput = {
    where: RecurringInvoiceWhereUniqueInput
    update: XOR<RecurringInvoiceUpdateWithoutCustomerInput, RecurringInvoiceUncheckedUpdateWithoutCustomerInput>
    create: XOR<RecurringInvoiceCreateWithoutCustomerInput, RecurringInvoiceUncheckedCreateWithoutCustomerInput>
  }

  export type RecurringInvoiceUpdateWithWhereUniqueWithoutCustomerInput = {
    where: RecurringInvoiceWhereUniqueInput
    data: XOR<RecurringInvoiceUpdateWithoutCustomerInput, RecurringInvoiceUncheckedUpdateWithoutCustomerInput>
  }

  export type RecurringInvoiceUpdateManyWithWhereWithoutCustomerInput = {
    where: RecurringInvoiceScalarWhereInput
    data: XOR<RecurringInvoiceUpdateManyMutationInput, RecurringInvoiceUncheckedUpdateManyWithoutCustomerInput>
  }

  export type MissionUpsertWithWhereUniqueWithoutClientInput = {
    where: MissionWhereUniqueInput
    update: XOR<MissionUpdateWithoutClientInput, MissionUncheckedUpdateWithoutClientInput>
    create: XOR<MissionCreateWithoutClientInput, MissionUncheckedCreateWithoutClientInput>
  }

  export type MissionUpdateWithWhereUniqueWithoutClientInput = {
    where: MissionWhereUniqueInput
    data: XOR<MissionUpdateWithoutClientInput, MissionUncheckedUpdateWithoutClientInput>
  }

  export type MissionUpdateManyWithWhereWithoutClientInput = {
    where: MissionScalarWhereInput
    data: XOR<MissionUpdateManyMutationInput, MissionUncheckedUpdateManyWithoutClientInput>
  }

  export type MissionScalarWhereInput = {
    AND?: MissionScalarWhereInput | MissionScalarWhereInput[]
    OR?: MissionScalarWhereInput[]
    NOT?: MissionScalarWhereInput | MissionScalarWhereInput[]
    numIntervention?: StringFilter<"Mission"> | string
    natureIntervention?: StringFilter<"Mission"> | string
    objectifDuContrat?: StringFilter<"Mission"> | string
    description?: StringNullableFilter<"Mission"> | string | null
    priorite?: StringNullableFilter<"Mission"> | string | null
    statut?: StringNullableFilter<"Mission"> | string | null
    dateSortieFicheIntervention?: DateTimeFilter<"Mission"> | Date | string
    clientId?: IntFilter<"Mission"> | number
    createdAt?: DateTimeFilter<"Mission"> | Date | string
    updatedAt?: DateTimeFilter<"Mission"> | Date | string
  }

  export type CustomerCreateWithoutAddressesInput = {
    customerNumber: string
    type?: $Enums.CustomerType
    name: string
    legalName?: string | null
    siret?: string | null
    vatNumber?: string | null
    email?: string | null
    phone?: string | null
    mobile?: string | null
    website?: string | null
    paymentTerms?: number
    paymentMethod?: $Enums.PaymentMethod
    creditLimit?: number
    discountRate?: number
    category?: string | null
    tags?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    service?: ServiceCreateNestedOneWithoutCustomersInput
    creator: UserCreateNestedOneWithoutCreatedCustomersInput
    quotes?: QuoteCreateNestedManyWithoutCustomerInput
    invoices?: InvoiceCreateNestedManyWithoutCustomerInput
    payments?: PaymentCreateNestedManyWithoutCustomerInput
    recurringInvoices?: RecurringInvoiceCreateNestedManyWithoutCustomerInput
    missions?: MissionCreateNestedManyWithoutClientInput
  }

  export type CustomerUncheckedCreateWithoutAddressesInput = {
    id?: number
    customerNumber: string
    type?: $Enums.CustomerType
    name: string
    legalName?: string | null
    siret?: string | null
    vatNumber?: string | null
    email?: string | null
    phone?: string | null
    mobile?: string | null
    website?: string | null
    paymentTerms?: number
    paymentMethod?: $Enums.PaymentMethod
    creditLimit?: number
    discountRate?: number
    category?: string | null
    tags?: string | null
    notes?: string | null
    isActive?: boolean
    serviceId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: number
    quotes?: QuoteUncheckedCreateNestedManyWithoutCustomerInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCustomerInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCustomerInput
    recurringInvoices?: RecurringInvoiceUncheckedCreateNestedManyWithoutCustomerInput
    missions?: MissionUncheckedCreateNestedManyWithoutClientInput
  }

  export type CustomerCreateOrConnectWithoutAddressesInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutAddressesInput, CustomerUncheckedCreateWithoutAddressesInput>
  }

  export type QuoteCreateWithoutCustomerAddressInput = {
    quoteNumber: string
    status?: $Enums.QuoteStatus
    quoteDate: Date | string
    validUntil: Date | string
    subtotalHt?: number
    discountAmount?: number
    totalVat?: number
    totalTtc?: number
    terms?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt?: Date | string | null
    submittedForServiceApprovalAt?: Date | string | null
    serviceManagerApprovalDate?: Date | string | null
    serviceManagerComments?: string | null
    dgApprovalDate?: Date | string | null
    dgComments?: string | null
    acceptedAt?: Date | string | null
    customer: CustomerCreateNestedOneWithoutQuotesInput
    creator: UserCreateNestedOneWithoutCreatedQuotesInput
    serviceManager?: UserCreateNestedOneWithoutServiceApprovalsInput
    dgApprover?: UserCreateNestedOneWithoutDgApprovalsInput
    items?: QuoteItemCreateNestedManyWithoutQuoteInput
    invoices?: InvoiceCreateNestedManyWithoutQuoteInput
    approvals?: QuoteApprovalCreateNestedManyWithoutQuoteInput
    missions?: MissionCreateNestedManyWithoutDevisInput
  }

  export type QuoteUncheckedCreateWithoutCustomerAddressInput = {
    id?: number
    quoteNumber: string
    customerId: number
    status?: $Enums.QuoteStatus
    quoteDate: Date | string
    validUntil: Date | string
    subtotalHt?: number
    discountAmount?: number
    totalVat?: number
    totalTtc?: number
    terms?: string | null
    notes?: string | null
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt?: Date | string | null
    submittedForServiceApprovalAt?: Date | string | null
    serviceManagerApprovedBy?: number | null
    serviceManagerApprovalDate?: Date | string | null
    serviceManagerComments?: string | null
    dgApprovedBy?: number | null
    dgApprovalDate?: Date | string | null
    dgComments?: string | null
    acceptedAt?: Date | string | null
    items?: QuoteItemUncheckedCreateNestedManyWithoutQuoteInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutQuoteInput
    approvals?: QuoteApprovalUncheckedCreateNestedManyWithoutQuoteInput
    missions?: MissionUncheckedCreateNestedManyWithoutDevisInput
  }

  export type QuoteCreateOrConnectWithoutCustomerAddressInput = {
    where: QuoteWhereUniqueInput
    create: XOR<QuoteCreateWithoutCustomerAddressInput, QuoteUncheckedCreateWithoutCustomerAddressInput>
  }

  export type QuoteCreateManyCustomerAddressInputEnvelope = {
    data: QuoteCreateManyCustomerAddressInput | QuoteCreateManyCustomerAddressInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutCustomerAddressInput = {
    invoiceNumber: string
    type?: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    invoiceDate: Date | string
    dueDate: Date | string
    subtotalHt?: number
    discountAmount?: number
    totalVat?: number
    totalTtc?: number
    paidAmount?: number
    balanceDue?: number
    paymentTerms?: number
    lateFeeRate?: number
    terms?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt?: Date | string | null
    customer: CustomerCreateNestedOneWithoutInvoicesInput
    quote?: QuoteCreateNestedOneWithoutInvoicesInput
    creator: UserCreateNestedOneWithoutCreatedInvoicesInput
    items?: InvoiceItemCreateNestedManyWithoutInvoiceInput
    paymentAllocations?: PaymentAllocationCreateNestedManyWithoutInvoiceInput
    reminders?: ReminderCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutCustomerAddressInput = {
    id?: number
    invoiceNumber: string
    customerId: number
    quoteId?: number | null
    type?: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    invoiceDate: Date | string
    dueDate: Date | string
    subtotalHt?: number
    discountAmount?: number
    totalVat?: number
    totalTtc?: number
    paidAmount?: number
    balanceDue?: number
    paymentTerms?: number
    lateFeeRate?: number
    terms?: string | null
    notes?: string | null
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt?: Date | string | null
    items?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
    paymentAllocations?: PaymentAllocationUncheckedCreateNestedManyWithoutInvoiceInput
    reminders?: ReminderUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutCustomerAddressInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutCustomerAddressInput, InvoiceUncheckedCreateWithoutCustomerAddressInput>
  }

  export type InvoiceCreateManyCustomerAddressInputEnvelope = {
    data: InvoiceCreateManyCustomerAddressInput | InvoiceCreateManyCustomerAddressInput[]
    skipDuplicates?: boolean
  }

  export type CustomerUpsertWithoutAddressesInput = {
    update: XOR<CustomerUpdateWithoutAddressesInput, CustomerUncheckedUpdateWithoutAddressesInput>
    create: XOR<CustomerCreateWithoutAddressesInput, CustomerUncheckedCreateWithoutAddressesInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutAddressesInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutAddressesInput, CustomerUncheckedUpdateWithoutAddressesInput>
  }

  export type CustomerUpdateWithoutAddressesInput = {
    customerNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    siret?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: IntFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    creditLimit?: FloatFieldUpdateOperationsInput | number
    discountRate?: FloatFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneWithoutCustomersNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedCustomersNestedInput
    quotes?: QuoteUpdateManyWithoutCustomerNestedInput
    invoices?: InvoiceUpdateManyWithoutCustomerNestedInput
    payments?: PaymentUpdateManyWithoutCustomerNestedInput
    recurringInvoices?: RecurringInvoiceUpdateManyWithoutCustomerNestedInput
    missions?: MissionUpdateManyWithoutClientNestedInput
  }

  export type CustomerUncheckedUpdateWithoutAddressesInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    siret?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: IntFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    creditLimit?: FloatFieldUpdateOperationsInput | number
    discountRate?: FloatFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    serviceId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    quotes?: QuoteUncheckedUpdateManyWithoutCustomerNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCustomerNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCustomerNestedInput
    recurringInvoices?: RecurringInvoiceUncheckedUpdateManyWithoutCustomerNestedInput
    missions?: MissionUncheckedUpdateManyWithoutClientNestedInput
  }

  export type QuoteUpsertWithWhereUniqueWithoutCustomerAddressInput = {
    where: QuoteWhereUniqueInput
    update: XOR<QuoteUpdateWithoutCustomerAddressInput, QuoteUncheckedUpdateWithoutCustomerAddressInput>
    create: XOR<QuoteCreateWithoutCustomerAddressInput, QuoteUncheckedCreateWithoutCustomerAddressInput>
  }

  export type QuoteUpdateWithWhereUniqueWithoutCustomerAddressInput = {
    where: QuoteWhereUniqueInput
    data: XOR<QuoteUpdateWithoutCustomerAddressInput, QuoteUncheckedUpdateWithoutCustomerAddressInput>
  }

  export type QuoteUpdateManyWithWhereWithoutCustomerAddressInput = {
    where: QuoteScalarWhereInput
    data: XOR<QuoteUpdateManyMutationInput, QuoteUncheckedUpdateManyWithoutCustomerAddressInput>
  }

  export type InvoiceUpsertWithWhereUniqueWithoutCustomerAddressInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutCustomerAddressInput, InvoiceUncheckedUpdateWithoutCustomerAddressInput>
    create: XOR<InvoiceCreateWithoutCustomerAddressInput, InvoiceUncheckedCreateWithoutCustomerAddressInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutCustomerAddressInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutCustomerAddressInput, InvoiceUncheckedUpdateWithoutCustomerAddressInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutCustomerAddressInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutCustomerAddressInput>
  }

  export type ProductPriceCreateWithoutProductInput = {
    customerCategory?: string | null
    minQuantity?: number
    priceHt: number
    validFrom?: Date | string | null
    validUntil?: Date | string | null
    createdAt?: Date | string
  }

  export type ProductPriceUncheckedCreateWithoutProductInput = {
    id?: number
    customerCategory?: string | null
    minQuantity?: number
    priceHt: number
    validFrom?: Date | string | null
    validUntil?: Date | string | null
    createdAt?: Date | string
  }

  export type ProductPriceCreateOrConnectWithoutProductInput = {
    where: ProductPriceWhereUniqueInput
    create: XOR<ProductPriceCreateWithoutProductInput, ProductPriceUncheckedCreateWithoutProductInput>
  }

  export type ProductPriceCreateManyProductInputEnvelope = {
    data: ProductPriceCreateManyProductInput | ProductPriceCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type QuoteItemCreateWithoutProductInput = {
    description: string
    quantity: number
    unitPriceHt: number
    discountRate?: number
    vatRate: number
    totalHt: number
    sortOrder?: number
    quote: QuoteCreateNestedOneWithoutItemsInput
  }

  export type QuoteItemUncheckedCreateWithoutProductInput = {
    id?: number
    quoteId: number
    description: string
    quantity: number
    unitPriceHt: number
    discountRate?: number
    vatRate: number
    totalHt: number
    sortOrder?: number
  }

  export type QuoteItemCreateOrConnectWithoutProductInput = {
    where: QuoteItemWhereUniqueInput
    create: XOR<QuoteItemCreateWithoutProductInput, QuoteItemUncheckedCreateWithoutProductInput>
  }

  export type QuoteItemCreateManyProductInputEnvelope = {
    data: QuoteItemCreateManyProductInput | QuoteItemCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceItemCreateWithoutProductInput = {
    description: string
    quantity: number
    unitPriceHt: number
    discountRate?: number
    vatRate: number
    totalHt: number
    sortOrder?: number
    invoice: InvoiceCreateNestedOneWithoutItemsInput
  }

  export type InvoiceItemUncheckedCreateWithoutProductInput = {
    id?: number
    invoiceId: number
    description: string
    quantity: number
    unitPriceHt: number
    discountRate?: number
    vatRate: number
    totalHt: number
    sortOrder?: number
  }

  export type InvoiceItemCreateOrConnectWithoutProductInput = {
    where: InvoiceItemWhereUniqueInput
    create: XOR<InvoiceItemCreateWithoutProductInput, InvoiceItemUncheckedCreateWithoutProductInput>
  }

  export type InvoiceItemCreateManyProductInputEnvelope = {
    data: InvoiceItemCreateManyProductInput | InvoiceItemCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type RecurringInvoiceItemCreateWithoutProductInput = {
    description: string
    quantity: number
    unitPriceHt: number
    vatRate: number
    totalHt: number
    sortOrder?: number
    recurringInvoice: RecurringInvoiceCreateNestedOneWithoutItemsInput
  }

  export type RecurringInvoiceItemUncheckedCreateWithoutProductInput = {
    id?: number
    recurringInvoiceId: number
    description: string
    quantity: number
    unitPriceHt: number
    vatRate: number
    totalHt: number
    sortOrder?: number
  }

  export type RecurringInvoiceItemCreateOrConnectWithoutProductInput = {
    where: RecurringInvoiceItemWhereUniqueInput
    create: XOR<RecurringInvoiceItemCreateWithoutProductInput, RecurringInvoiceItemUncheckedCreateWithoutProductInput>
  }

  export type RecurringInvoiceItemCreateManyProductInputEnvelope = {
    data: RecurringInvoiceItemCreateManyProductInput | RecurringInvoiceItemCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ProductPriceUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductPriceWhereUniqueInput
    update: XOR<ProductPriceUpdateWithoutProductInput, ProductPriceUncheckedUpdateWithoutProductInput>
    create: XOR<ProductPriceCreateWithoutProductInput, ProductPriceUncheckedCreateWithoutProductInput>
  }

  export type ProductPriceUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductPriceWhereUniqueInput
    data: XOR<ProductPriceUpdateWithoutProductInput, ProductPriceUncheckedUpdateWithoutProductInput>
  }

  export type ProductPriceUpdateManyWithWhereWithoutProductInput = {
    where: ProductPriceScalarWhereInput
    data: XOR<ProductPriceUpdateManyMutationInput, ProductPriceUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductPriceScalarWhereInput = {
    AND?: ProductPriceScalarWhereInput | ProductPriceScalarWhereInput[]
    OR?: ProductPriceScalarWhereInput[]
    NOT?: ProductPriceScalarWhereInput | ProductPriceScalarWhereInput[]
    id?: IntFilter<"ProductPrice"> | number
    productId?: IntFilter<"ProductPrice"> | number
    customerCategory?: StringNullableFilter<"ProductPrice"> | string | null
    minQuantity?: IntFilter<"ProductPrice"> | number
    priceHt?: FloatFilter<"ProductPrice"> | number
    validFrom?: DateTimeNullableFilter<"ProductPrice"> | Date | string | null
    validUntil?: DateTimeNullableFilter<"ProductPrice"> | Date | string | null
    createdAt?: DateTimeFilter<"ProductPrice"> | Date | string
  }

  export type QuoteItemUpsertWithWhereUniqueWithoutProductInput = {
    where: QuoteItemWhereUniqueInput
    update: XOR<QuoteItemUpdateWithoutProductInput, QuoteItemUncheckedUpdateWithoutProductInput>
    create: XOR<QuoteItemCreateWithoutProductInput, QuoteItemUncheckedCreateWithoutProductInput>
  }

  export type QuoteItemUpdateWithWhereUniqueWithoutProductInput = {
    where: QuoteItemWhereUniqueInput
    data: XOR<QuoteItemUpdateWithoutProductInput, QuoteItemUncheckedUpdateWithoutProductInput>
  }

  export type QuoteItemUpdateManyWithWhereWithoutProductInput = {
    where: QuoteItemScalarWhereInput
    data: XOR<QuoteItemUpdateManyMutationInput, QuoteItemUncheckedUpdateManyWithoutProductInput>
  }

  export type QuoteItemScalarWhereInput = {
    AND?: QuoteItemScalarWhereInput | QuoteItemScalarWhereInput[]
    OR?: QuoteItemScalarWhereInput[]
    NOT?: QuoteItemScalarWhereInput | QuoteItemScalarWhereInput[]
    id?: IntFilter<"QuoteItem"> | number
    quoteId?: IntFilter<"QuoteItem"> | number
    productId?: IntNullableFilter<"QuoteItem"> | number | null
    description?: StringFilter<"QuoteItem"> | string
    quantity?: FloatFilter<"QuoteItem"> | number
    unitPriceHt?: FloatFilter<"QuoteItem"> | number
    discountRate?: FloatFilter<"QuoteItem"> | number
    vatRate?: FloatFilter<"QuoteItem"> | number
    totalHt?: FloatFilter<"QuoteItem"> | number
    sortOrder?: IntFilter<"QuoteItem"> | number
  }

  export type InvoiceItemUpsertWithWhereUniqueWithoutProductInput = {
    where: InvoiceItemWhereUniqueInput
    update: XOR<InvoiceItemUpdateWithoutProductInput, InvoiceItemUncheckedUpdateWithoutProductInput>
    create: XOR<InvoiceItemCreateWithoutProductInput, InvoiceItemUncheckedCreateWithoutProductInput>
  }

  export type InvoiceItemUpdateWithWhereUniqueWithoutProductInput = {
    where: InvoiceItemWhereUniqueInput
    data: XOR<InvoiceItemUpdateWithoutProductInput, InvoiceItemUncheckedUpdateWithoutProductInput>
  }

  export type InvoiceItemUpdateManyWithWhereWithoutProductInput = {
    where: InvoiceItemScalarWhereInput
    data: XOR<InvoiceItemUpdateManyMutationInput, InvoiceItemUncheckedUpdateManyWithoutProductInput>
  }

  export type InvoiceItemScalarWhereInput = {
    AND?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
    OR?: InvoiceItemScalarWhereInput[]
    NOT?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
    id?: IntFilter<"InvoiceItem"> | number
    invoiceId?: IntFilter<"InvoiceItem"> | number
    productId?: IntNullableFilter<"InvoiceItem"> | number | null
    description?: StringFilter<"InvoiceItem"> | string
    quantity?: FloatFilter<"InvoiceItem"> | number
    unitPriceHt?: FloatFilter<"InvoiceItem"> | number
    discountRate?: FloatFilter<"InvoiceItem"> | number
    vatRate?: FloatFilter<"InvoiceItem"> | number
    totalHt?: FloatFilter<"InvoiceItem"> | number
    sortOrder?: IntFilter<"InvoiceItem"> | number
  }

  export type RecurringInvoiceItemUpsertWithWhereUniqueWithoutProductInput = {
    where: RecurringInvoiceItemWhereUniqueInput
    update: XOR<RecurringInvoiceItemUpdateWithoutProductInput, RecurringInvoiceItemUncheckedUpdateWithoutProductInput>
    create: XOR<RecurringInvoiceItemCreateWithoutProductInput, RecurringInvoiceItemUncheckedCreateWithoutProductInput>
  }

  export type RecurringInvoiceItemUpdateWithWhereUniqueWithoutProductInput = {
    where: RecurringInvoiceItemWhereUniqueInput
    data: XOR<RecurringInvoiceItemUpdateWithoutProductInput, RecurringInvoiceItemUncheckedUpdateWithoutProductInput>
  }

  export type RecurringInvoiceItemUpdateManyWithWhereWithoutProductInput = {
    where: RecurringInvoiceItemScalarWhereInput
    data: XOR<RecurringInvoiceItemUpdateManyMutationInput, RecurringInvoiceItemUncheckedUpdateManyWithoutProductInput>
  }

  export type RecurringInvoiceItemScalarWhereInput = {
    AND?: RecurringInvoiceItemScalarWhereInput | RecurringInvoiceItemScalarWhereInput[]
    OR?: RecurringInvoiceItemScalarWhereInput[]
    NOT?: RecurringInvoiceItemScalarWhereInput | RecurringInvoiceItemScalarWhereInput[]
    id?: IntFilter<"RecurringInvoiceItem"> | number
    recurringInvoiceId?: IntFilter<"RecurringInvoiceItem"> | number
    productId?: IntNullableFilter<"RecurringInvoiceItem"> | number | null
    description?: StringFilter<"RecurringInvoiceItem"> | string
    quantity?: FloatFilter<"RecurringInvoiceItem"> | number
    unitPriceHt?: FloatFilter<"RecurringInvoiceItem"> | number
    vatRate?: FloatFilter<"RecurringInvoiceItem"> | number
    totalHt?: FloatFilter<"RecurringInvoiceItem"> | number
    sortOrder?: IntFilter<"RecurringInvoiceItem"> | number
  }

  export type ProductCreateWithoutPricesInput = {
    sku: string
    name: string
    description?: string | null
    type?: $Enums.ProductType
    category?: string | null
    unit?: string
    priceHt: number
    vatRate?: number
    costPrice?: number | null
    stockQuantity?: number
    stockAlertThreshold?: number
    isActive?: boolean
    weight?: number | null
    dimensions?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    quoteItems?: QuoteItemCreateNestedManyWithoutProductInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutProductInput
    recurringInvoiceItems?: RecurringInvoiceItemCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutPricesInput = {
    id?: number
    sku: string
    name: string
    description?: string | null
    type?: $Enums.ProductType
    category?: string | null
    unit?: string
    priceHt: number
    vatRate?: number
    costPrice?: number | null
    stockQuantity?: number
    stockAlertThreshold?: number
    isActive?: boolean
    weight?: number | null
    dimensions?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    quoteItems?: QuoteItemUncheckedCreateNestedManyWithoutProductInput
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutProductInput
    recurringInvoiceItems?: RecurringInvoiceItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutPricesInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutPricesInput, ProductUncheckedCreateWithoutPricesInput>
  }

  export type ProductUpsertWithoutPricesInput = {
    update: XOR<ProductUpdateWithoutPricesInput, ProductUncheckedUpdateWithoutPricesInput>
    create: XOR<ProductCreateWithoutPricesInput, ProductUncheckedCreateWithoutPricesInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutPricesInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutPricesInput, ProductUncheckedUpdateWithoutPricesInput>
  }

  export type ProductUpdateWithoutPricesInput = {
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    category?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    priceHt?: FloatFieldUpdateOperationsInput | number
    vatRate?: FloatFieldUpdateOperationsInput | number
    costPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    stockAlertThreshold?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    dimensions?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quoteItems?: QuoteItemUpdateManyWithoutProductNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutProductNestedInput
    recurringInvoiceItems?: RecurringInvoiceItemUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutPricesInput = {
    id?: IntFieldUpdateOperationsInput | number
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    category?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    priceHt?: FloatFieldUpdateOperationsInput | number
    vatRate?: FloatFieldUpdateOperationsInput | number
    costPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    stockAlertThreshold?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    dimensions?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quoteItems?: QuoteItemUncheckedUpdateManyWithoutProductNestedInput
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutProductNestedInput
    recurringInvoiceItems?: RecurringInvoiceItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type CustomerCreateWithoutQuotesInput = {
    customerNumber: string
    type?: $Enums.CustomerType
    name: string
    legalName?: string | null
    siret?: string | null
    vatNumber?: string | null
    email?: string | null
    phone?: string | null
    mobile?: string | null
    website?: string | null
    paymentTerms?: number
    paymentMethod?: $Enums.PaymentMethod
    creditLimit?: number
    discountRate?: number
    category?: string | null
    tags?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    service?: ServiceCreateNestedOneWithoutCustomersInput
    creator: UserCreateNestedOneWithoutCreatedCustomersInput
    addresses?: CustomerAddressCreateNestedManyWithoutCustomerInput
    invoices?: InvoiceCreateNestedManyWithoutCustomerInput
    payments?: PaymentCreateNestedManyWithoutCustomerInput
    recurringInvoices?: RecurringInvoiceCreateNestedManyWithoutCustomerInput
    missions?: MissionCreateNestedManyWithoutClientInput
  }

  export type CustomerUncheckedCreateWithoutQuotesInput = {
    id?: number
    customerNumber: string
    type?: $Enums.CustomerType
    name: string
    legalName?: string | null
    siret?: string | null
    vatNumber?: string | null
    email?: string | null
    phone?: string | null
    mobile?: string | null
    website?: string | null
    paymentTerms?: number
    paymentMethod?: $Enums.PaymentMethod
    creditLimit?: number
    discountRate?: number
    category?: string | null
    tags?: string | null
    notes?: string | null
    isActive?: boolean
    serviceId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: number
    addresses?: CustomerAddressUncheckedCreateNestedManyWithoutCustomerInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCustomerInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCustomerInput
    recurringInvoices?: RecurringInvoiceUncheckedCreateNestedManyWithoutCustomerInput
    missions?: MissionUncheckedCreateNestedManyWithoutClientInput
  }

  export type CustomerCreateOrConnectWithoutQuotesInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutQuotesInput, CustomerUncheckedCreateWithoutQuotesInput>
  }

  export type CustomerAddressCreateWithoutQuotesInput = {
    type: $Enums.AddressType
    name?: string | null
    addressLine1: string
    addressLine2?: string | null
    postalCode: string
    city: string
    country?: string
    isDefault?: boolean
    createdAt?: Date | string
    customer: CustomerCreateNestedOneWithoutAddressesInput
    invoices?: InvoiceCreateNestedManyWithoutCustomerAddressInput
  }

  export type CustomerAddressUncheckedCreateWithoutQuotesInput = {
    id?: number
    customerId: number
    type: $Enums.AddressType
    name?: string | null
    addressLine1: string
    addressLine2?: string | null
    postalCode: string
    city: string
    country?: string
    isDefault?: boolean
    createdAt?: Date | string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCustomerAddressInput
  }

  export type CustomerAddressCreateOrConnectWithoutQuotesInput = {
    where: CustomerAddressWhereUniqueInput
    create: XOR<CustomerAddressCreateWithoutQuotesInput, CustomerAddressUncheckedCreateWithoutQuotesInput>
  }

  export type UserCreateWithoutCreatedQuotesInput = {
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    preferences?: string | null
    permissions?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    service?: ServiceCreateNestedOneWithoutUsersInput
    createdCustomers?: CustomerCreateNestedManyWithoutCreatorInput
    createdInvoices?: InvoiceCreateNestedManyWithoutCreatorInput
    createdPayments?: PaymentCreateNestedManyWithoutCreatorInput
    serviceApprovals?: QuoteCreateNestedManyWithoutServiceManagerInput
    dgApprovals?: QuoteCreateNestedManyWithoutDgApproverInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    quoteApprovals?: QuoteApprovalCreateNestedManyWithoutApproverInput
    createdExpenses?: ExpenseCreateNestedManyWithoutCreatorInput
    accountingEntries?: AccountingEntryCreateNestedManyWithoutCreatorInput
    cashFlowEntries?: CashFlowCreateNestedManyWithoutCreatorInput
    createdReminders?: ReminderCreateNestedManyWithoutCreatorInput
    createdRecurringInvoices?: RecurringInvoiceCreateNestedManyWithoutCreatorInput
    employee?: EmployeeCreateNestedOneWithoutUserInput
    leaveApprovals?: LeaveRequestCreateNestedManyWithoutApprovedByInput
    assignedProspects?: ProspectCreateNestedManyWithoutAssignedUserInput
    createdProspects?: ProspectCreateNestedManyWithoutCreatorInput
    createdProspectActivities?: ProspectActivityCreateNestedManyWithoutCreatorInput
    technicien?: TechnicienCreateNestedOneWithoutUtilisateurInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedQuotesInput = {
    id?: number
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    serviceId?: number | null
    isActive?: boolean
    lastLogin?: Date | string | null
    preferences?: string | null
    permissions?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdCustomers?: CustomerUncheckedCreateNestedManyWithoutCreatorInput
    createdInvoices?: InvoiceUncheckedCreateNestedManyWithoutCreatorInput
    createdPayments?: PaymentUncheckedCreateNestedManyWithoutCreatorInput
    serviceApprovals?: QuoteUncheckedCreateNestedManyWithoutServiceManagerInput
    dgApprovals?: QuoteUncheckedCreateNestedManyWithoutDgApproverInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    quoteApprovals?: QuoteApprovalUncheckedCreateNestedManyWithoutApproverInput
    createdExpenses?: ExpenseUncheckedCreateNestedManyWithoutCreatorInput
    accountingEntries?: AccountingEntryUncheckedCreateNestedManyWithoutCreatorInput
    cashFlowEntries?: CashFlowUncheckedCreateNestedManyWithoutCreatorInput
    createdReminders?: ReminderUncheckedCreateNestedManyWithoutCreatorInput
    createdRecurringInvoices?: RecurringInvoiceUncheckedCreateNestedManyWithoutCreatorInput
    employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    leaveApprovals?: LeaveRequestUncheckedCreateNestedManyWithoutApprovedByInput
    assignedProspects?: ProspectUncheckedCreateNestedManyWithoutAssignedUserInput
    createdProspects?: ProspectUncheckedCreateNestedManyWithoutCreatorInput
    createdProspectActivities?: ProspectActivityUncheckedCreateNestedManyWithoutCreatorInput
    technicien?: TechnicienUncheckedCreateNestedOneWithoutUtilisateurInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedQuotesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedQuotesInput, UserUncheckedCreateWithoutCreatedQuotesInput>
  }

  export type UserCreateWithoutServiceApprovalsInput = {
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    preferences?: string | null
    permissions?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    service?: ServiceCreateNestedOneWithoutUsersInput
    createdCustomers?: CustomerCreateNestedManyWithoutCreatorInput
    createdQuotes?: QuoteCreateNestedManyWithoutCreatorInput
    createdInvoices?: InvoiceCreateNestedManyWithoutCreatorInput
    createdPayments?: PaymentCreateNestedManyWithoutCreatorInput
    dgApprovals?: QuoteCreateNestedManyWithoutDgApproverInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    quoteApprovals?: QuoteApprovalCreateNestedManyWithoutApproverInput
    createdExpenses?: ExpenseCreateNestedManyWithoutCreatorInput
    accountingEntries?: AccountingEntryCreateNestedManyWithoutCreatorInput
    cashFlowEntries?: CashFlowCreateNestedManyWithoutCreatorInput
    createdReminders?: ReminderCreateNestedManyWithoutCreatorInput
    createdRecurringInvoices?: RecurringInvoiceCreateNestedManyWithoutCreatorInput
    employee?: EmployeeCreateNestedOneWithoutUserInput
    leaveApprovals?: LeaveRequestCreateNestedManyWithoutApprovedByInput
    assignedProspects?: ProspectCreateNestedManyWithoutAssignedUserInput
    createdProspects?: ProspectCreateNestedManyWithoutCreatorInput
    createdProspectActivities?: ProspectActivityCreateNestedManyWithoutCreatorInput
    technicien?: TechnicienCreateNestedOneWithoutUtilisateurInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutServiceApprovalsInput = {
    id?: number
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    serviceId?: number | null
    isActive?: boolean
    lastLogin?: Date | string | null
    preferences?: string | null
    permissions?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdCustomers?: CustomerUncheckedCreateNestedManyWithoutCreatorInput
    createdQuotes?: QuoteUncheckedCreateNestedManyWithoutCreatorInput
    createdInvoices?: InvoiceUncheckedCreateNestedManyWithoutCreatorInput
    createdPayments?: PaymentUncheckedCreateNestedManyWithoutCreatorInput
    dgApprovals?: QuoteUncheckedCreateNestedManyWithoutDgApproverInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    quoteApprovals?: QuoteApprovalUncheckedCreateNestedManyWithoutApproverInput
    createdExpenses?: ExpenseUncheckedCreateNestedManyWithoutCreatorInput
    accountingEntries?: AccountingEntryUncheckedCreateNestedManyWithoutCreatorInput
    cashFlowEntries?: CashFlowUncheckedCreateNestedManyWithoutCreatorInput
    createdReminders?: ReminderUncheckedCreateNestedManyWithoutCreatorInput
    createdRecurringInvoices?: RecurringInvoiceUncheckedCreateNestedManyWithoutCreatorInput
    employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    leaveApprovals?: LeaveRequestUncheckedCreateNestedManyWithoutApprovedByInput
    assignedProspects?: ProspectUncheckedCreateNestedManyWithoutAssignedUserInput
    createdProspects?: ProspectUncheckedCreateNestedManyWithoutCreatorInput
    createdProspectActivities?: ProspectActivityUncheckedCreateNestedManyWithoutCreatorInput
    technicien?: TechnicienUncheckedCreateNestedOneWithoutUtilisateurInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutServiceApprovalsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutServiceApprovalsInput, UserUncheckedCreateWithoutServiceApprovalsInput>
  }

  export type UserCreateWithoutDgApprovalsInput = {
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    preferences?: string | null
    permissions?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    service?: ServiceCreateNestedOneWithoutUsersInput
    createdCustomers?: CustomerCreateNestedManyWithoutCreatorInput
    createdQuotes?: QuoteCreateNestedManyWithoutCreatorInput
    createdInvoices?: InvoiceCreateNestedManyWithoutCreatorInput
    createdPayments?: PaymentCreateNestedManyWithoutCreatorInput
    serviceApprovals?: QuoteCreateNestedManyWithoutServiceManagerInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    quoteApprovals?: QuoteApprovalCreateNestedManyWithoutApproverInput
    createdExpenses?: ExpenseCreateNestedManyWithoutCreatorInput
    accountingEntries?: AccountingEntryCreateNestedManyWithoutCreatorInput
    cashFlowEntries?: CashFlowCreateNestedManyWithoutCreatorInput
    createdReminders?: ReminderCreateNestedManyWithoutCreatorInput
    createdRecurringInvoices?: RecurringInvoiceCreateNestedManyWithoutCreatorInput
    employee?: EmployeeCreateNestedOneWithoutUserInput
    leaveApprovals?: LeaveRequestCreateNestedManyWithoutApprovedByInput
    assignedProspects?: ProspectCreateNestedManyWithoutAssignedUserInput
    createdProspects?: ProspectCreateNestedManyWithoutCreatorInput
    createdProspectActivities?: ProspectActivityCreateNestedManyWithoutCreatorInput
    technicien?: TechnicienCreateNestedOneWithoutUtilisateurInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDgApprovalsInput = {
    id?: number
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    serviceId?: number | null
    isActive?: boolean
    lastLogin?: Date | string | null
    preferences?: string | null
    permissions?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdCustomers?: CustomerUncheckedCreateNestedManyWithoutCreatorInput
    createdQuotes?: QuoteUncheckedCreateNestedManyWithoutCreatorInput
    createdInvoices?: InvoiceUncheckedCreateNestedManyWithoutCreatorInput
    createdPayments?: PaymentUncheckedCreateNestedManyWithoutCreatorInput
    serviceApprovals?: QuoteUncheckedCreateNestedManyWithoutServiceManagerInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    quoteApprovals?: QuoteApprovalUncheckedCreateNestedManyWithoutApproverInput
    createdExpenses?: ExpenseUncheckedCreateNestedManyWithoutCreatorInput
    accountingEntries?: AccountingEntryUncheckedCreateNestedManyWithoutCreatorInput
    cashFlowEntries?: CashFlowUncheckedCreateNestedManyWithoutCreatorInput
    createdReminders?: ReminderUncheckedCreateNestedManyWithoutCreatorInput
    createdRecurringInvoices?: RecurringInvoiceUncheckedCreateNestedManyWithoutCreatorInput
    employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    leaveApprovals?: LeaveRequestUncheckedCreateNestedManyWithoutApprovedByInput
    assignedProspects?: ProspectUncheckedCreateNestedManyWithoutAssignedUserInput
    createdProspects?: ProspectUncheckedCreateNestedManyWithoutCreatorInput
    createdProspectActivities?: ProspectActivityUncheckedCreateNestedManyWithoutCreatorInput
    technicien?: TechnicienUncheckedCreateNestedOneWithoutUtilisateurInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDgApprovalsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDgApprovalsInput, UserUncheckedCreateWithoutDgApprovalsInput>
  }

  export type QuoteItemCreateWithoutQuoteInput = {
    description: string
    quantity: number
    unitPriceHt: number
    discountRate?: number
    vatRate: number
    totalHt: number
    sortOrder?: number
    product?: ProductCreateNestedOneWithoutQuoteItemsInput
  }

  export type QuoteItemUncheckedCreateWithoutQuoteInput = {
    id?: number
    productId?: number | null
    description: string
    quantity: number
    unitPriceHt: number
    discountRate?: number
    vatRate: number
    totalHt: number
    sortOrder?: number
  }

  export type QuoteItemCreateOrConnectWithoutQuoteInput = {
    where: QuoteItemWhereUniqueInput
    create: XOR<QuoteItemCreateWithoutQuoteInput, QuoteItemUncheckedCreateWithoutQuoteInput>
  }

  export type QuoteItemCreateManyQuoteInputEnvelope = {
    data: QuoteItemCreateManyQuoteInput | QuoteItemCreateManyQuoteInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutQuoteInput = {
    invoiceNumber: string
    type?: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    invoiceDate: Date | string
    dueDate: Date | string
    subtotalHt?: number
    discountAmount?: number
    totalVat?: number
    totalTtc?: number
    paidAmount?: number
    balanceDue?: number
    paymentTerms?: number
    lateFeeRate?: number
    terms?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt?: Date | string | null
    customer: CustomerCreateNestedOneWithoutInvoicesInput
    customerAddress?: CustomerAddressCreateNestedOneWithoutInvoicesInput
    creator: UserCreateNestedOneWithoutCreatedInvoicesInput
    items?: InvoiceItemCreateNestedManyWithoutInvoiceInput
    paymentAllocations?: PaymentAllocationCreateNestedManyWithoutInvoiceInput
    reminders?: ReminderCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutQuoteInput = {
    id?: number
    invoiceNumber: string
    customerId: number
    customerAddressId?: number | null
    type?: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    invoiceDate: Date | string
    dueDate: Date | string
    subtotalHt?: number
    discountAmount?: number
    totalVat?: number
    totalTtc?: number
    paidAmount?: number
    balanceDue?: number
    paymentTerms?: number
    lateFeeRate?: number
    terms?: string | null
    notes?: string | null
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt?: Date | string | null
    items?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
    paymentAllocations?: PaymentAllocationUncheckedCreateNestedManyWithoutInvoiceInput
    reminders?: ReminderUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutQuoteInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutQuoteInput, InvoiceUncheckedCreateWithoutQuoteInput>
  }

  export type InvoiceCreateManyQuoteInputEnvelope = {
    data: InvoiceCreateManyQuoteInput | InvoiceCreateManyQuoteInput[]
    skipDuplicates?: boolean
  }

  export type QuoteApprovalCreateWithoutQuoteInput = {
    approvalLevel: $Enums.ApprovalLevel
    status?: $Enums.ApprovalStatus
    approvalDate?: Date | string | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approver: UserCreateNestedOneWithoutQuoteApprovalsInput
  }

  export type QuoteApprovalUncheckedCreateWithoutQuoteInput = {
    id?: number
    approverId: number
    approvalLevel: $Enums.ApprovalLevel
    status?: $Enums.ApprovalStatus
    approvalDate?: Date | string | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuoteApprovalCreateOrConnectWithoutQuoteInput = {
    where: QuoteApprovalWhereUniqueInput
    create: XOR<QuoteApprovalCreateWithoutQuoteInput, QuoteApprovalUncheckedCreateWithoutQuoteInput>
  }

  export type QuoteApprovalCreateManyQuoteInputEnvelope = {
    data: QuoteApprovalCreateManyQuoteInput | QuoteApprovalCreateManyQuoteInput[]
    skipDuplicates?: boolean
  }

  export type MissionCreateWithoutDevisInput = {
    numIntervention: string
    natureIntervention: string
    objectifDuContrat: string
    description?: string | null
    priorite?: string | null
    statut?: string | null
    dateSortieFicheIntervention: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    client: CustomerCreateNestedOneWithoutMissionsInput
    interventions?: InterventionCreateNestedManyWithoutMissionInput
    rapports?: RapportMissionCreateNestedManyWithoutMissionInput
  }

  export type MissionUncheckedCreateWithoutDevisInput = {
    numIntervention: string
    natureIntervention: string
    objectifDuContrat: string
    description?: string | null
    priorite?: string | null
    statut?: string | null
    dateSortieFicheIntervention: Date | string
    clientId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    interventions?: InterventionUncheckedCreateNestedManyWithoutMissionInput
    rapports?: RapportMissionUncheckedCreateNestedManyWithoutMissionInput
  }

  export type MissionCreateOrConnectWithoutDevisInput = {
    where: MissionWhereUniqueInput
    create: XOR<MissionCreateWithoutDevisInput, MissionUncheckedCreateWithoutDevisInput>
  }

  export type CustomerUpsertWithoutQuotesInput = {
    update: XOR<CustomerUpdateWithoutQuotesInput, CustomerUncheckedUpdateWithoutQuotesInput>
    create: XOR<CustomerCreateWithoutQuotesInput, CustomerUncheckedCreateWithoutQuotesInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutQuotesInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutQuotesInput, CustomerUncheckedUpdateWithoutQuotesInput>
  }

  export type CustomerUpdateWithoutQuotesInput = {
    customerNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    siret?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: IntFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    creditLimit?: FloatFieldUpdateOperationsInput | number
    discountRate?: FloatFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneWithoutCustomersNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedCustomersNestedInput
    addresses?: CustomerAddressUpdateManyWithoutCustomerNestedInput
    invoices?: InvoiceUpdateManyWithoutCustomerNestedInput
    payments?: PaymentUpdateManyWithoutCustomerNestedInput
    recurringInvoices?: RecurringInvoiceUpdateManyWithoutCustomerNestedInput
    missions?: MissionUpdateManyWithoutClientNestedInput
  }

  export type CustomerUncheckedUpdateWithoutQuotesInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    siret?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: IntFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    creditLimit?: FloatFieldUpdateOperationsInput | number
    discountRate?: FloatFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    serviceId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    addresses?: CustomerAddressUncheckedUpdateManyWithoutCustomerNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCustomerNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCustomerNestedInput
    recurringInvoices?: RecurringInvoiceUncheckedUpdateManyWithoutCustomerNestedInput
    missions?: MissionUncheckedUpdateManyWithoutClientNestedInput
  }

  export type CustomerAddressUpsertWithoutQuotesInput = {
    update: XOR<CustomerAddressUpdateWithoutQuotesInput, CustomerAddressUncheckedUpdateWithoutQuotesInput>
    create: XOR<CustomerAddressCreateWithoutQuotesInput, CustomerAddressUncheckedCreateWithoutQuotesInput>
    where?: CustomerAddressWhereInput
  }

  export type CustomerAddressUpdateToOneWithWhereWithoutQuotesInput = {
    where?: CustomerAddressWhereInput
    data: XOR<CustomerAddressUpdateWithoutQuotesInput, CustomerAddressUncheckedUpdateWithoutQuotesInput>
  }

  export type CustomerAddressUpdateWithoutQuotesInput = {
    type?: EnumAddressTypeFieldUpdateOperationsInput | $Enums.AddressType
    name?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutAddressesNestedInput
    invoices?: InvoiceUpdateManyWithoutCustomerAddressNestedInput
  }

  export type CustomerAddressUncheckedUpdateWithoutQuotesInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    type?: EnumAddressTypeFieldUpdateOperationsInput | $Enums.AddressType
    name?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUncheckedUpdateManyWithoutCustomerAddressNestedInput
  }

  export type UserUpsertWithoutCreatedQuotesInput = {
    update: XOR<UserUpdateWithoutCreatedQuotesInput, UserUncheckedUpdateWithoutCreatedQuotesInput>
    create: XOR<UserCreateWithoutCreatedQuotesInput, UserUncheckedCreateWithoutCreatedQuotesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedQuotesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedQuotesInput, UserUncheckedUpdateWithoutCreatedQuotesInput>
  }

  export type UserUpdateWithoutCreatedQuotesInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneWithoutUsersNestedInput
    createdCustomers?: CustomerUpdateManyWithoutCreatorNestedInput
    createdInvoices?: InvoiceUpdateManyWithoutCreatorNestedInput
    createdPayments?: PaymentUpdateManyWithoutCreatorNestedInput
    serviceApprovals?: QuoteUpdateManyWithoutServiceManagerNestedInput
    dgApprovals?: QuoteUpdateManyWithoutDgApproverNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    quoteApprovals?: QuoteApprovalUpdateManyWithoutApproverNestedInput
    createdExpenses?: ExpenseUpdateManyWithoutCreatorNestedInput
    accountingEntries?: AccountingEntryUpdateManyWithoutCreatorNestedInput
    cashFlowEntries?: CashFlowUpdateManyWithoutCreatorNestedInput
    createdReminders?: ReminderUpdateManyWithoutCreatorNestedInput
    createdRecurringInvoices?: RecurringInvoiceUpdateManyWithoutCreatorNestedInput
    employee?: EmployeeUpdateOneWithoutUserNestedInput
    leaveApprovals?: LeaveRequestUpdateManyWithoutApprovedByNestedInput
    assignedProspects?: ProspectUpdateManyWithoutAssignedUserNestedInput
    createdProspects?: ProspectUpdateManyWithoutCreatorNestedInput
    createdProspectActivities?: ProspectActivityUpdateManyWithoutCreatorNestedInput
    technicien?: TechnicienUpdateOneWithoutUtilisateurNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedQuotesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    serviceId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdCustomers?: CustomerUncheckedUpdateManyWithoutCreatorNestedInput
    createdInvoices?: InvoiceUncheckedUpdateManyWithoutCreatorNestedInput
    createdPayments?: PaymentUncheckedUpdateManyWithoutCreatorNestedInput
    serviceApprovals?: QuoteUncheckedUpdateManyWithoutServiceManagerNestedInput
    dgApprovals?: QuoteUncheckedUpdateManyWithoutDgApproverNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    quoteApprovals?: QuoteApprovalUncheckedUpdateManyWithoutApproverNestedInput
    createdExpenses?: ExpenseUncheckedUpdateManyWithoutCreatorNestedInput
    accountingEntries?: AccountingEntryUncheckedUpdateManyWithoutCreatorNestedInput
    cashFlowEntries?: CashFlowUncheckedUpdateManyWithoutCreatorNestedInput
    createdReminders?: ReminderUncheckedUpdateManyWithoutCreatorNestedInput
    createdRecurringInvoices?: RecurringInvoiceUncheckedUpdateManyWithoutCreatorNestedInput
    employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    leaveApprovals?: LeaveRequestUncheckedUpdateManyWithoutApprovedByNestedInput
    assignedProspects?: ProspectUncheckedUpdateManyWithoutAssignedUserNestedInput
    createdProspects?: ProspectUncheckedUpdateManyWithoutCreatorNestedInput
    createdProspectActivities?: ProspectActivityUncheckedUpdateManyWithoutCreatorNestedInput
    technicien?: TechnicienUncheckedUpdateOneWithoutUtilisateurNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutServiceApprovalsInput = {
    update: XOR<UserUpdateWithoutServiceApprovalsInput, UserUncheckedUpdateWithoutServiceApprovalsInput>
    create: XOR<UserCreateWithoutServiceApprovalsInput, UserUncheckedCreateWithoutServiceApprovalsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutServiceApprovalsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutServiceApprovalsInput, UserUncheckedUpdateWithoutServiceApprovalsInput>
  }

  export type UserUpdateWithoutServiceApprovalsInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneWithoutUsersNestedInput
    createdCustomers?: CustomerUpdateManyWithoutCreatorNestedInput
    createdQuotes?: QuoteUpdateManyWithoutCreatorNestedInput
    createdInvoices?: InvoiceUpdateManyWithoutCreatorNestedInput
    createdPayments?: PaymentUpdateManyWithoutCreatorNestedInput
    dgApprovals?: QuoteUpdateManyWithoutDgApproverNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    quoteApprovals?: QuoteApprovalUpdateManyWithoutApproverNestedInput
    createdExpenses?: ExpenseUpdateManyWithoutCreatorNestedInput
    accountingEntries?: AccountingEntryUpdateManyWithoutCreatorNestedInput
    cashFlowEntries?: CashFlowUpdateManyWithoutCreatorNestedInput
    createdReminders?: ReminderUpdateManyWithoutCreatorNestedInput
    createdRecurringInvoices?: RecurringInvoiceUpdateManyWithoutCreatorNestedInput
    employee?: EmployeeUpdateOneWithoutUserNestedInput
    leaveApprovals?: LeaveRequestUpdateManyWithoutApprovedByNestedInput
    assignedProspects?: ProspectUpdateManyWithoutAssignedUserNestedInput
    createdProspects?: ProspectUpdateManyWithoutCreatorNestedInput
    createdProspectActivities?: ProspectActivityUpdateManyWithoutCreatorNestedInput
    technicien?: TechnicienUpdateOneWithoutUtilisateurNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutServiceApprovalsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    serviceId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdCustomers?: CustomerUncheckedUpdateManyWithoutCreatorNestedInput
    createdQuotes?: QuoteUncheckedUpdateManyWithoutCreatorNestedInput
    createdInvoices?: InvoiceUncheckedUpdateManyWithoutCreatorNestedInput
    createdPayments?: PaymentUncheckedUpdateManyWithoutCreatorNestedInput
    dgApprovals?: QuoteUncheckedUpdateManyWithoutDgApproverNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    quoteApprovals?: QuoteApprovalUncheckedUpdateManyWithoutApproverNestedInput
    createdExpenses?: ExpenseUncheckedUpdateManyWithoutCreatorNestedInput
    accountingEntries?: AccountingEntryUncheckedUpdateManyWithoutCreatorNestedInput
    cashFlowEntries?: CashFlowUncheckedUpdateManyWithoutCreatorNestedInput
    createdReminders?: ReminderUncheckedUpdateManyWithoutCreatorNestedInput
    createdRecurringInvoices?: RecurringInvoiceUncheckedUpdateManyWithoutCreatorNestedInput
    employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    leaveApprovals?: LeaveRequestUncheckedUpdateManyWithoutApprovedByNestedInput
    assignedProspects?: ProspectUncheckedUpdateManyWithoutAssignedUserNestedInput
    createdProspects?: ProspectUncheckedUpdateManyWithoutCreatorNestedInput
    createdProspectActivities?: ProspectActivityUncheckedUpdateManyWithoutCreatorNestedInput
    technicien?: TechnicienUncheckedUpdateOneWithoutUtilisateurNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutDgApprovalsInput = {
    update: XOR<UserUpdateWithoutDgApprovalsInput, UserUncheckedUpdateWithoutDgApprovalsInput>
    create: XOR<UserCreateWithoutDgApprovalsInput, UserUncheckedCreateWithoutDgApprovalsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDgApprovalsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDgApprovalsInput, UserUncheckedUpdateWithoutDgApprovalsInput>
  }

  export type UserUpdateWithoutDgApprovalsInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneWithoutUsersNestedInput
    createdCustomers?: CustomerUpdateManyWithoutCreatorNestedInput
    createdQuotes?: QuoteUpdateManyWithoutCreatorNestedInput
    createdInvoices?: InvoiceUpdateManyWithoutCreatorNestedInput
    createdPayments?: PaymentUpdateManyWithoutCreatorNestedInput
    serviceApprovals?: QuoteUpdateManyWithoutServiceManagerNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    quoteApprovals?: QuoteApprovalUpdateManyWithoutApproverNestedInput
    createdExpenses?: ExpenseUpdateManyWithoutCreatorNestedInput
    accountingEntries?: AccountingEntryUpdateManyWithoutCreatorNestedInput
    cashFlowEntries?: CashFlowUpdateManyWithoutCreatorNestedInput
    createdReminders?: ReminderUpdateManyWithoutCreatorNestedInput
    createdRecurringInvoices?: RecurringInvoiceUpdateManyWithoutCreatorNestedInput
    employee?: EmployeeUpdateOneWithoutUserNestedInput
    leaveApprovals?: LeaveRequestUpdateManyWithoutApprovedByNestedInput
    assignedProspects?: ProspectUpdateManyWithoutAssignedUserNestedInput
    createdProspects?: ProspectUpdateManyWithoutCreatorNestedInput
    createdProspectActivities?: ProspectActivityUpdateManyWithoutCreatorNestedInput
    technicien?: TechnicienUpdateOneWithoutUtilisateurNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDgApprovalsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    serviceId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdCustomers?: CustomerUncheckedUpdateManyWithoutCreatorNestedInput
    createdQuotes?: QuoteUncheckedUpdateManyWithoutCreatorNestedInput
    createdInvoices?: InvoiceUncheckedUpdateManyWithoutCreatorNestedInput
    createdPayments?: PaymentUncheckedUpdateManyWithoutCreatorNestedInput
    serviceApprovals?: QuoteUncheckedUpdateManyWithoutServiceManagerNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    quoteApprovals?: QuoteApprovalUncheckedUpdateManyWithoutApproverNestedInput
    createdExpenses?: ExpenseUncheckedUpdateManyWithoutCreatorNestedInput
    accountingEntries?: AccountingEntryUncheckedUpdateManyWithoutCreatorNestedInput
    cashFlowEntries?: CashFlowUncheckedUpdateManyWithoutCreatorNestedInput
    createdReminders?: ReminderUncheckedUpdateManyWithoutCreatorNestedInput
    createdRecurringInvoices?: RecurringInvoiceUncheckedUpdateManyWithoutCreatorNestedInput
    employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    leaveApprovals?: LeaveRequestUncheckedUpdateManyWithoutApprovedByNestedInput
    assignedProspects?: ProspectUncheckedUpdateManyWithoutAssignedUserNestedInput
    createdProspects?: ProspectUncheckedUpdateManyWithoutCreatorNestedInput
    createdProspectActivities?: ProspectActivityUncheckedUpdateManyWithoutCreatorNestedInput
    technicien?: TechnicienUncheckedUpdateOneWithoutUtilisateurNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type QuoteItemUpsertWithWhereUniqueWithoutQuoteInput = {
    where: QuoteItemWhereUniqueInput
    update: XOR<QuoteItemUpdateWithoutQuoteInput, QuoteItemUncheckedUpdateWithoutQuoteInput>
    create: XOR<QuoteItemCreateWithoutQuoteInput, QuoteItemUncheckedCreateWithoutQuoteInput>
  }

  export type QuoteItemUpdateWithWhereUniqueWithoutQuoteInput = {
    where: QuoteItemWhereUniqueInput
    data: XOR<QuoteItemUpdateWithoutQuoteInput, QuoteItemUncheckedUpdateWithoutQuoteInput>
  }

  export type QuoteItemUpdateManyWithWhereWithoutQuoteInput = {
    where: QuoteItemScalarWhereInput
    data: XOR<QuoteItemUpdateManyMutationInput, QuoteItemUncheckedUpdateManyWithoutQuoteInput>
  }

  export type InvoiceUpsertWithWhereUniqueWithoutQuoteInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutQuoteInput, InvoiceUncheckedUpdateWithoutQuoteInput>
    create: XOR<InvoiceCreateWithoutQuoteInput, InvoiceUncheckedCreateWithoutQuoteInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutQuoteInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutQuoteInput, InvoiceUncheckedUpdateWithoutQuoteInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutQuoteInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutQuoteInput>
  }

  export type QuoteApprovalUpsertWithWhereUniqueWithoutQuoteInput = {
    where: QuoteApprovalWhereUniqueInput
    update: XOR<QuoteApprovalUpdateWithoutQuoteInput, QuoteApprovalUncheckedUpdateWithoutQuoteInput>
    create: XOR<QuoteApprovalCreateWithoutQuoteInput, QuoteApprovalUncheckedCreateWithoutQuoteInput>
  }

  export type QuoteApprovalUpdateWithWhereUniqueWithoutQuoteInput = {
    where: QuoteApprovalWhereUniqueInput
    data: XOR<QuoteApprovalUpdateWithoutQuoteInput, QuoteApprovalUncheckedUpdateWithoutQuoteInput>
  }

  export type QuoteApprovalUpdateManyWithWhereWithoutQuoteInput = {
    where: QuoteApprovalScalarWhereInput
    data: XOR<QuoteApprovalUpdateManyMutationInput, QuoteApprovalUncheckedUpdateManyWithoutQuoteInput>
  }

  export type MissionUpsertWithWhereUniqueWithoutDevisInput = {
    where: MissionWhereUniqueInput
    update: XOR<MissionUpdateWithoutDevisInput, MissionUncheckedUpdateWithoutDevisInput>
    create: XOR<MissionCreateWithoutDevisInput, MissionUncheckedCreateWithoutDevisInput>
  }

  export type MissionUpdateWithWhereUniqueWithoutDevisInput = {
    where: MissionWhereUniqueInput
    data: XOR<MissionUpdateWithoutDevisInput, MissionUncheckedUpdateWithoutDevisInput>
  }

  export type MissionUpdateManyWithWhereWithoutDevisInput = {
    where: MissionScalarWhereInput
    data: XOR<MissionUpdateManyMutationInput, MissionUncheckedUpdateManyWithoutDevisInput>
  }

  export type QuoteCreateWithoutItemsInput = {
    quoteNumber: string
    status?: $Enums.QuoteStatus
    quoteDate: Date | string
    validUntil: Date | string
    subtotalHt?: number
    discountAmount?: number
    totalVat?: number
    totalTtc?: number
    terms?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt?: Date | string | null
    submittedForServiceApprovalAt?: Date | string | null
    serviceManagerApprovalDate?: Date | string | null
    serviceManagerComments?: string | null
    dgApprovalDate?: Date | string | null
    dgComments?: string | null
    acceptedAt?: Date | string | null
    customer: CustomerCreateNestedOneWithoutQuotesInput
    customerAddress?: CustomerAddressCreateNestedOneWithoutQuotesInput
    creator: UserCreateNestedOneWithoutCreatedQuotesInput
    serviceManager?: UserCreateNestedOneWithoutServiceApprovalsInput
    dgApprover?: UserCreateNestedOneWithoutDgApprovalsInput
    invoices?: InvoiceCreateNestedManyWithoutQuoteInput
    approvals?: QuoteApprovalCreateNestedManyWithoutQuoteInput
    missions?: MissionCreateNestedManyWithoutDevisInput
  }

  export type QuoteUncheckedCreateWithoutItemsInput = {
    id?: number
    quoteNumber: string
    customerId: number
    customerAddressId?: number | null
    status?: $Enums.QuoteStatus
    quoteDate: Date | string
    validUntil: Date | string
    subtotalHt?: number
    discountAmount?: number
    totalVat?: number
    totalTtc?: number
    terms?: string | null
    notes?: string | null
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt?: Date | string | null
    submittedForServiceApprovalAt?: Date | string | null
    serviceManagerApprovedBy?: number | null
    serviceManagerApprovalDate?: Date | string | null
    serviceManagerComments?: string | null
    dgApprovedBy?: number | null
    dgApprovalDate?: Date | string | null
    dgComments?: string | null
    acceptedAt?: Date | string | null
    invoices?: InvoiceUncheckedCreateNestedManyWithoutQuoteInput
    approvals?: QuoteApprovalUncheckedCreateNestedManyWithoutQuoteInput
    missions?: MissionUncheckedCreateNestedManyWithoutDevisInput
  }

  export type QuoteCreateOrConnectWithoutItemsInput = {
    where: QuoteWhereUniqueInput
    create: XOR<QuoteCreateWithoutItemsInput, QuoteUncheckedCreateWithoutItemsInput>
  }

  export type ProductCreateWithoutQuoteItemsInput = {
    sku: string
    name: string
    description?: string | null
    type?: $Enums.ProductType
    category?: string | null
    unit?: string
    priceHt: number
    vatRate?: number
    costPrice?: number | null
    stockQuantity?: number
    stockAlertThreshold?: number
    isActive?: boolean
    weight?: number | null
    dimensions?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    prices?: ProductPriceCreateNestedManyWithoutProductInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutProductInput
    recurringInvoiceItems?: RecurringInvoiceItemCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutQuoteItemsInput = {
    id?: number
    sku: string
    name: string
    description?: string | null
    type?: $Enums.ProductType
    category?: string | null
    unit?: string
    priceHt: number
    vatRate?: number
    costPrice?: number | null
    stockQuantity?: number
    stockAlertThreshold?: number
    isActive?: boolean
    weight?: number | null
    dimensions?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    prices?: ProductPriceUncheckedCreateNestedManyWithoutProductInput
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutProductInput
    recurringInvoiceItems?: RecurringInvoiceItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutQuoteItemsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutQuoteItemsInput, ProductUncheckedCreateWithoutQuoteItemsInput>
  }

  export type QuoteUpsertWithoutItemsInput = {
    update: XOR<QuoteUpdateWithoutItemsInput, QuoteUncheckedUpdateWithoutItemsInput>
    create: XOR<QuoteCreateWithoutItemsInput, QuoteUncheckedCreateWithoutItemsInput>
    where?: QuoteWhereInput
  }

  export type QuoteUpdateToOneWithWhereWithoutItemsInput = {
    where?: QuoteWhereInput
    data: XOR<QuoteUpdateWithoutItemsInput, QuoteUncheckedUpdateWithoutItemsInput>
  }

  export type QuoteUpdateWithoutItemsInput = {
    quoteNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    quoteDate?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotalHt?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalVat?: FloatFieldUpdateOperationsInput | number
    totalTtc?: FloatFieldUpdateOperationsInput | number
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedForServiceApprovalAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceManagerApprovalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceManagerComments?: NullableStringFieldUpdateOperationsInput | string | null
    dgApprovalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dgComments?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customer?: CustomerUpdateOneRequiredWithoutQuotesNestedInput
    customerAddress?: CustomerAddressUpdateOneWithoutQuotesNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedQuotesNestedInput
    serviceManager?: UserUpdateOneWithoutServiceApprovalsNestedInput
    dgApprover?: UserUpdateOneWithoutDgApprovalsNestedInput
    invoices?: InvoiceUpdateManyWithoutQuoteNestedInput
    approvals?: QuoteApprovalUpdateManyWithoutQuoteNestedInput
    missions?: MissionUpdateManyWithoutDevisNestedInput
  }

  export type QuoteUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    quoteNumber?: StringFieldUpdateOperationsInput | string
    customerId?: IntFieldUpdateOperationsInput | number
    customerAddressId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    quoteDate?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotalHt?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalVat?: FloatFieldUpdateOperationsInput | number
    totalTtc?: FloatFieldUpdateOperationsInput | number
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedForServiceApprovalAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceManagerApprovedBy?: NullableIntFieldUpdateOperationsInput | number | null
    serviceManagerApprovalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceManagerComments?: NullableStringFieldUpdateOperationsInput | string | null
    dgApprovedBy?: NullableIntFieldUpdateOperationsInput | number | null
    dgApprovalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dgComments?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoices?: InvoiceUncheckedUpdateManyWithoutQuoteNestedInput
    approvals?: QuoteApprovalUncheckedUpdateManyWithoutQuoteNestedInput
    missions?: MissionUncheckedUpdateManyWithoutDevisNestedInput
  }

  export type ProductUpsertWithoutQuoteItemsInput = {
    update: XOR<ProductUpdateWithoutQuoteItemsInput, ProductUncheckedUpdateWithoutQuoteItemsInput>
    create: XOR<ProductCreateWithoutQuoteItemsInput, ProductUncheckedCreateWithoutQuoteItemsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutQuoteItemsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutQuoteItemsInput, ProductUncheckedUpdateWithoutQuoteItemsInput>
  }

  export type ProductUpdateWithoutQuoteItemsInput = {
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    category?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    priceHt?: FloatFieldUpdateOperationsInput | number
    vatRate?: FloatFieldUpdateOperationsInput | number
    costPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    stockAlertThreshold?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    dimensions?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prices?: ProductPriceUpdateManyWithoutProductNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutProductNestedInput
    recurringInvoiceItems?: RecurringInvoiceItemUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutQuoteItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    category?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    priceHt?: FloatFieldUpdateOperationsInput | number
    vatRate?: FloatFieldUpdateOperationsInput | number
    costPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    stockAlertThreshold?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    dimensions?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prices?: ProductPriceUncheckedUpdateManyWithoutProductNestedInput
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutProductNestedInput
    recurringInvoiceItems?: RecurringInvoiceItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type QuoteCreateWithoutApprovalsInput = {
    quoteNumber: string
    status?: $Enums.QuoteStatus
    quoteDate: Date | string
    validUntil: Date | string
    subtotalHt?: number
    discountAmount?: number
    totalVat?: number
    totalTtc?: number
    terms?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt?: Date | string | null
    submittedForServiceApprovalAt?: Date | string | null
    serviceManagerApprovalDate?: Date | string | null
    serviceManagerComments?: string | null
    dgApprovalDate?: Date | string | null
    dgComments?: string | null
    acceptedAt?: Date | string | null
    customer: CustomerCreateNestedOneWithoutQuotesInput
    customerAddress?: CustomerAddressCreateNestedOneWithoutQuotesInput
    creator: UserCreateNestedOneWithoutCreatedQuotesInput
    serviceManager?: UserCreateNestedOneWithoutServiceApprovalsInput
    dgApprover?: UserCreateNestedOneWithoutDgApprovalsInput
    items?: QuoteItemCreateNestedManyWithoutQuoteInput
    invoices?: InvoiceCreateNestedManyWithoutQuoteInput
    missions?: MissionCreateNestedManyWithoutDevisInput
  }

  export type QuoteUncheckedCreateWithoutApprovalsInput = {
    id?: number
    quoteNumber: string
    customerId: number
    customerAddressId?: number | null
    status?: $Enums.QuoteStatus
    quoteDate: Date | string
    validUntil: Date | string
    subtotalHt?: number
    discountAmount?: number
    totalVat?: number
    totalTtc?: number
    terms?: string | null
    notes?: string | null
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt?: Date | string | null
    submittedForServiceApprovalAt?: Date | string | null
    serviceManagerApprovedBy?: number | null
    serviceManagerApprovalDate?: Date | string | null
    serviceManagerComments?: string | null
    dgApprovedBy?: number | null
    dgApprovalDate?: Date | string | null
    dgComments?: string | null
    acceptedAt?: Date | string | null
    items?: QuoteItemUncheckedCreateNestedManyWithoutQuoteInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutQuoteInput
    missions?: MissionUncheckedCreateNestedManyWithoutDevisInput
  }

  export type QuoteCreateOrConnectWithoutApprovalsInput = {
    where: QuoteWhereUniqueInput
    create: XOR<QuoteCreateWithoutApprovalsInput, QuoteUncheckedCreateWithoutApprovalsInput>
  }

  export type UserCreateWithoutQuoteApprovalsInput = {
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    preferences?: string | null
    permissions?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    service?: ServiceCreateNestedOneWithoutUsersInput
    createdCustomers?: CustomerCreateNestedManyWithoutCreatorInput
    createdQuotes?: QuoteCreateNestedManyWithoutCreatorInput
    createdInvoices?: InvoiceCreateNestedManyWithoutCreatorInput
    createdPayments?: PaymentCreateNestedManyWithoutCreatorInput
    serviceApprovals?: QuoteCreateNestedManyWithoutServiceManagerInput
    dgApprovals?: QuoteCreateNestedManyWithoutDgApproverInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    createdExpenses?: ExpenseCreateNestedManyWithoutCreatorInput
    accountingEntries?: AccountingEntryCreateNestedManyWithoutCreatorInput
    cashFlowEntries?: CashFlowCreateNestedManyWithoutCreatorInput
    createdReminders?: ReminderCreateNestedManyWithoutCreatorInput
    createdRecurringInvoices?: RecurringInvoiceCreateNestedManyWithoutCreatorInput
    employee?: EmployeeCreateNestedOneWithoutUserInput
    leaveApprovals?: LeaveRequestCreateNestedManyWithoutApprovedByInput
    assignedProspects?: ProspectCreateNestedManyWithoutAssignedUserInput
    createdProspects?: ProspectCreateNestedManyWithoutCreatorInput
    createdProspectActivities?: ProspectActivityCreateNestedManyWithoutCreatorInput
    technicien?: TechnicienCreateNestedOneWithoutUtilisateurInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutQuoteApprovalsInput = {
    id?: number
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    serviceId?: number | null
    isActive?: boolean
    lastLogin?: Date | string | null
    preferences?: string | null
    permissions?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdCustomers?: CustomerUncheckedCreateNestedManyWithoutCreatorInput
    createdQuotes?: QuoteUncheckedCreateNestedManyWithoutCreatorInput
    createdInvoices?: InvoiceUncheckedCreateNestedManyWithoutCreatorInput
    createdPayments?: PaymentUncheckedCreateNestedManyWithoutCreatorInput
    serviceApprovals?: QuoteUncheckedCreateNestedManyWithoutServiceManagerInput
    dgApprovals?: QuoteUncheckedCreateNestedManyWithoutDgApproverInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    createdExpenses?: ExpenseUncheckedCreateNestedManyWithoutCreatorInput
    accountingEntries?: AccountingEntryUncheckedCreateNestedManyWithoutCreatorInput
    cashFlowEntries?: CashFlowUncheckedCreateNestedManyWithoutCreatorInput
    createdReminders?: ReminderUncheckedCreateNestedManyWithoutCreatorInput
    createdRecurringInvoices?: RecurringInvoiceUncheckedCreateNestedManyWithoutCreatorInput
    employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    leaveApprovals?: LeaveRequestUncheckedCreateNestedManyWithoutApprovedByInput
    assignedProspects?: ProspectUncheckedCreateNestedManyWithoutAssignedUserInput
    createdProspects?: ProspectUncheckedCreateNestedManyWithoutCreatorInput
    createdProspectActivities?: ProspectActivityUncheckedCreateNestedManyWithoutCreatorInput
    technicien?: TechnicienUncheckedCreateNestedOneWithoutUtilisateurInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutQuoteApprovalsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutQuoteApprovalsInput, UserUncheckedCreateWithoutQuoteApprovalsInput>
  }

  export type QuoteUpsertWithoutApprovalsInput = {
    update: XOR<QuoteUpdateWithoutApprovalsInput, QuoteUncheckedUpdateWithoutApprovalsInput>
    create: XOR<QuoteCreateWithoutApprovalsInput, QuoteUncheckedCreateWithoutApprovalsInput>
    where?: QuoteWhereInput
  }

  export type QuoteUpdateToOneWithWhereWithoutApprovalsInput = {
    where?: QuoteWhereInput
    data: XOR<QuoteUpdateWithoutApprovalsInput, QuoteUncheckedUpdateWithoutApprovalsInput>
  }

  export type QuoteUpdateWithoutApprovalsInput = {
    quoteNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    quoteDate?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotalHt?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalVat?: FloatFieldUpdateOperationsInput | number
    totalTtc?: FloatFieldUpdateOperationsInput | number
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedForServiceApprovalAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceManagerApprovalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceManagerComments?: NullableStringFieldUpdateOperationsInput | string | null
    dgApprovalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dgComments?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customer?: CustomerUpdateOneRequiredWithoutQuotesNestedInput
    customerAddress?: CustomerAddressUpdateOneWithoutQuotesNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedQuotesNestedInput
    serviceManager?: UserUpdateOneWithoutServiceApprovalsNestedInput
    dgApprover?: UserUpdateOneWithoutDgApprovalsNestedInput
    items?: QuoteItemUpdateManyWithoutQuoteNestedInput
    invoices?: InvoiceUpdateManyWithoutQuoteNestedInput
    missions?: MissionUpdateManyWithoutDevisNestedInput
  }

  export type QuoteUncheckedUpdateWithoutApprovalsInput = {
    id?: IntFieldUpdateOperationsInput | number
    quoteNumber?: StringFieldUpdateOperationsInput | string
    customerId?: IntFieldUpdateOperationsInput | number
    customerAddressId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    quoteDate?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotalHt?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalVat?: FloatFieldUpdateOperationsInput | number
    totalTtc?: FloatFieldUpdateOperationsInput | number
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedForServiceApprovalAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceManagerApprovedBy?: NullableIntFieldUpdateOperationsInput | number | null
    serviceManagerApprovalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceManagerComments?: NullableStringFieldUpdateOperationsInput | string | null
    dgApprovedBy?: NullableIntFieldUpdateOperationsInput | number | null
    dgApprovalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dgComments?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: QuoteItemUncheckedUpdateManyWithoutQuoteNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutQuoteNestedInput
    missions?: MissionUncheckedUpdateManyWithoutDevisNestedInput
  }

  export type UserUpsertWithoutQuoteApprovalsInput = {
    update: XOR<UserUpdateWithoutQuoteApprovalsInput, UserUncheckedUpdateWithoutQuoteApprovalsInput>
    create: XOR<UserCreateWithoutQuoteApprovalsInput, UserUncheckedCreateWithoutQuoteApprovalsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutQuoteApprovalsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutQuoteApprovalsInput, UserUncheckedUpdateWithoutQuoteApprovalsInput>
  }

  export type UserUpdateWithoutQuoteApprovalsInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneWithoutUsersNestedInput
    createdCustomers?: CustomerUpdateManyWithoutCreatorNestedInput
    createdQuotes?: QuoteUpdateManyWithoutCreatorNestedInput
    createdInvoices?: InvoiceUpdateManyWithoutCreatorNestedInput
    createdPayments?: PaymentUpdateManyWithoutCreatorNestedInput
    serviceApprovals?: QuoteUpdateManyWithoutServiceManagerNestedInput
    dgApprovals?: QuoteUpdateManyWithoutDgApproverNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    createdExpenses?: ExpenseUpdateManyWithoutCreatorNestedInput
    accountingEntries?: AccountingEntryUpdateManyWithoutCreatorNestedInput
    cashFlowEntries?: CashFlowUpdateManyWithoutCreatorNestedInput
    createdReminders?: ReminderUpdateManyWithoutCreatorNestedInput
    createdRecurringInvoices?: RecurringInvoiceUpdateManyWithoutCreatorNestedInput
    employee?: EmployeeUpdateOneWithoutUserNestedInput
    leaveApprovals?: LeaveRequestUpdateManyWithoutApprovedByNestedInput
    assignedProspects?: ProspectUpdateManyWithoutAssignedUserNestedInput
    createdProspects?: ProspectUpdateManyWithoutCreatorNestedInput
    createdProspectActivities?: ProspectActivityUpdateManyWithoutCreatorNestedInput
    technicien?: TechnicienUpdateOneWithoutUtilisateurNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutQuoteApprovalsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    serviceId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdCustomers?: CustomerUncheckedUpdateManyWithoutCreatorNestedInput
    createdQuotes?: QuoteUncheckedUpdateManyWithoutCreatorNestedInput
    createdInvoices?: InvoiceUncheckedUpdateManyWithoutCreatorNestedInput
    createdPayments?: PaymentUncheckedUpdateManyWithoutCreatorNestedInput
    serviceApprovals?: QuoteUncheckedUpdateManyWithoutServiceManagerNestedInput
    dgApprovals?: QuoteUncheckedUpdateManyWithoutDgApproverNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    createdExpenses?: ExpenseUncheckedUpdateManyWithoutCreatorNestedInput
    accountingEntries?: AccountingEntryUncheckedUpdateManyWithoutCreatorNestedInput
    cashFlowEntries?: CashFlowUncheckedUpdateManyWithoutCreatorNestedInput
    createdReminders?: ReminderUncheckedUpdateManyWithoutCreatorNestedInput
    createdRecurringInvoices?: RecurringInvoiceUncheckedUpdateManyWithoutCreatorNestedInput
    employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    leaveApprovals?: LeaveRequestUncheckedUpdateManyWithoutApprovedByNestedInput
    assignedProspects?: ProspectUncheckedUpdateManyWithoutAssignedUserNestedInput
    createdProspects?: ProspectUncheckedUpdateManyWithoutCreatorNestedInput
    createdProspectActivities?: ProspectActivityUncheckedUpdateManyWithoutCreatorNestedInput
    technicien?: TechnicienUncheckedUpdateOneWithoutUtilisateurNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CustomerCreateWithoutInvoicesInput = {
    customerNumber: string
    type?: $Enums.CustomerType
    name: string
    legalName?: string | null
    siret?: string | null
    vatNumber?: string | null
    email?: string | null
    phone?: string | null
    mobile?: string | null
    website?: string | null
    paymentTerms?: number
    paymentMethod?: $Enums.PaymentMethod
    creditLimit?: number
    discountRate?: number
    category?: string | null
    tags?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    service?: ServiceCreateNestedOneWithoutCustomersInput
    creator: UserCreateNestedOneWithoutCreatedCustomersInput
    addresses?: CustomerAddressCreateNestedManyWithoutCustomerInput
    quotes?: QuoteCreateNestedManyWithoutCustomerInput
    payments?: PaymentCreateNestedManyWithoutCustomerInput
    recurringInvoices?: RecurringInvoiceCreateNestedManyWithoutCustomerInput
    missions?: MissionCreateNestedManyWithoutClientInput
  }

  export type CustomerUncheckedCreateWithoutInvoicesInput = {
    id?: number
    customerNumber: string
    type?: $Enums.CustomerType
    name: string
    legalName?: string | null
    siret?: string | null
    vatNumber?: string | null
    email?: string | null
    phone?: string | null
    mobile?: string | null
    website?: string | null
    paymentTerms?: number
    paymentMethod?: $Enums.PaymentMethod
    creditLimit?: number
    discountRate?: number
    category?: string | null
    tags?: string | null
    notes?: string | null
    isActive?: boolean
    serviceId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: number
    addresses?: CustomerAddressUncheckedCreateNestedManyWithoutCustomerInput
    quotes?: QuoteUncheckedCreateNestedManyWithoutCustomerInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCustomerInput
    recurringInvoices?: RecurringInvoiceUncheckedCreateNestedManyWithoutCustomerInput
    missions?: MissionUncheckedCreateNestedManyWithoutClientInput
  }

  export type CustomerCreateOrConnectWithoutInvoicesInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutInvoicesInput, CustomerUncheckedCreateWithoutInvoicesInput>
  }

  export type CustomerAddressCreateWithoutInvoicesInput = {
    type: $Enums.AddressType
    name?: string | null
    addressLine1: string
    addressLine2?: string | null
    postalCode: string
    city: string
    country?: string
    isDefault?: boolean
    createdAt?: Date | string
    customer: CustomerCreateNestedOneWithoutAddressesInput
    quotes?: QuoteCreateNestedManyWithoutCustomerAddressInput
  }

  export type CustomerAddressUncheckedCreateWithoutInvoicesInput = {
    id?: number
    customerId: number
    type: $Enums.AddressType
    name?: string | null
    addressLine1: string
    addressLine2?: string | null
    postalCode: string
    city: string
    country?: string
    isDefault?: boolean
    createdAt?: Date | string
    quotes?: QuoteUncheckedCreateNestedManyWithoutCustomerAddressInput
  }

  export type CustomerAddressCreateOrConnectWithoutInvoicesInput = {
    where: CustomerAddressWhereUniqueInput
    create: XOR<CustomerAddressCreateWithoutInvoicesInput, CustomerAddressUncheckedCreateWithoutInvoicesInput>
  }

  export type QuoteCreateWithoutInvoicesInput = {
    quoteNumber: string
    status?: $Enums.QuoteStatus
    quoteDate: Date | string
    validUntil: Date | string
    subtotalHt?: number
    discountAmount?: number
    totalVat?: number
    totalTtc?: number
    terms?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt?: Date | string | null
    submittedForServiceApprovalAt?: Date | string | null
    serviceManagerApprovalDate?: Date | string | null
    serviceManagerComments?: string | null
    dgApprovalDate?: Date | string | null
    dgComments?: string | null
    acceptedAt?: Date | string | null
    customer: CustomerCreateNestedOneWithoutQuotesInput
    customerAddress?: CustomerAddressCreateNestedOneWithoutQuotesInput
    creator: UserCreateNestedOneWithoutCreatedQuotesInput
    serviceManager?: UserCreateNestedOneWithoutServiceApprovalsInput
    dgApprover?: UserCreateNestedOneWithoutDgApprovalsInput
    items?: QuoteItemCreateNestedManyWithoutQuoteInput
    approvals?: QuoteApprovalCreateNestedManyWithoutQuoteInput
    missions?: MissionCreateNestedManyWithoutDevisInput
  }

  export type QuoteUncheckedCreateWithoutInvoicesInput = {
    id?: number
    quoteNumber: string
    customerId: number
    customerAddressId?: number | null
    status?: $Enums.QuoteStatus
    quoteDate: Date | string
    validUntil: Date | string
    subtotalHt?: number
    discountAmount?: number
    totalVat?: number
    totalTtc?: number
    terms?: string | null
    notes?: string | null
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt?: Date | string | null
    submittedForServiceApprovalAt?: Date | string | null
    serviceManagerApprovedBy?: number | null
    serviceManagerApprovalDate?: Date | string | null
    serviceManagerComments?: string | null
    dgApprovedBy?: number | null
    dgApprovalDate?: Date | string | null
    dgComments?: string | null
    acceptedAt?: Date | string | null
    items?: QuoteItemUncheckedCreateNestedManyWithoutQuoteInput
    approvals?: QuoteApprovalUncheckedCreateNestedManyWithoutQuoteInput
    missions?: MissionUncheckedCreateNestedManyWithoutDevisInput
  }

  export type QuoteCreateOrConnectWithoutInvoicesInput = {
    where: QuoteWhereUniqueInput
    create: XOR<QuoteCreateWithoutInvoicesInput, QuoteUncheckedCreateWithoutInvoicesInput>
  }

  export type UserCreateWithoutCreatedInvoicesInput = {
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    preferences?: string | null
    permissions?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    service?: ServiceCreateNestedOneWithoutUsersInput
    createdCustomers?: CustomerCreateNestedManyWithoutCreatorInput
    createdQuotes?: QuoteCreateNestedManyWithoutCreatorInput
    createdPayments?: PaymentCreateNestedManyWithoutCreatorInput
    serviceApprovals?: QuoteCreateNestedManyWithoutServiceManagerInput
    dgApprovals?: QuoteCreateNestedManyWithoutDgApproverInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    quoteApprovals?: QuoteApprovalCreateNestedManyWithoutApproverInput
    createdExpenses?: ExpenseCreateNestedManyWithoutCreatorInput
    accountingEntries?: AccountingEntryCreateNestedManyWithoutCreatorInput
    cashFlowEntries?: CashFlowCreateNestedManyWithoutCreatorInput
    createdReminders?: ReminderCreateNestedManyWithoutCreatorInput
    createdRecurringInvoices?: RecurringInvoiceCreateNestedManyWithoutCreatorInput
    employee?: EmployeeCreateNestedOneWithoutUserInput
    leaveApprovals?: LeaveRequestCreateNestedManyWithoutApprovedByInput
    assignedProspects?: ProspectCreateNestedManyWithoutAssignedUserInput
    createdProspects?: ProspectCreateNestedManyWithoutCreatorInput
    createdProspectActivities?: ProspectActivityCreateNestedManyWithoutCreatorInput
    technicien?: TechnicienCreateNestedOneWithoutUtilisateurInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedInvoicesInput = {
    id?: number
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    serviceId?: number | null
    isActive?: boolean
    lastLogin?: Date | string | null
    preferences?: string | null
    permissions?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdCustomers?: CustomerUncheckedCreateNestedManyWithoutCreatorInput
    createdQuotes?: QuoteUncheckedCreateNestedManyWithoutCreatorInput
    createdPayments?: PaymentUncheckedCreateNestedManyWithoutCreatorInput
    serviceApprovals?: QuoteUncheckedCreateNestedManyWithoutServiceManagerInput
    dgApprovals?: QuoteUncheckedCreateNestedManyWithoutDgApproverInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    quoteApprovals?: QuoteApprovalUncheckedCreateNestedManyWithoutApproverInput
    createdExpenses?: ExpenseUncheckedCreateNestedManyWithoutCreatorInput
    accountingEntries?: AccountingEntryUncheckedCreateNestedManyWithoutCreatorInput
    cashFlowEntries?: CashFlowUncheckedCreateNestedManyWithoutCreatorInput
    createdReminders?: ReminderUncheckedCreateNestedManyWithoutCreatorInput
    createdRecurringInvoices?: RecurringInvoiceUncheckedCreateNestedManyWithoutCreatorInput
    employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    leaveApprovals?: LeaveRequestUncheckedCreateNestedManyWithoutApprovedByInput
    assignedProspects?: ProspectUncheckedCreateNestedManyWithoutAssignedUserInput
    createdProspects?: ProspectUncheckedCreateNestedManyWithoutCreatorInput
    createdProspectActivities?: ProspectActivityUncheckedCreateNestedManyWithoutCreatorInput
    technicien?: TechnicienUncheckedCreateNestedOneWithoutUtilisateurInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedInvoicesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedInvoicesInput, UserUncheckedCreateWithoutCreatedInvoicesInput>
  }

  export type InvoiceItemCreateWithoutInvoiceInput = {
    description: string
    quantity: number
    unitPriceHt: number
    discountRate?: number
    vatRate: number
    totalHt: number
    sortOrder?: number
    product?: ProductCreateNestedOneWithoutInvoiceItemsInput
  }

  export type InvoiceItemUncheckedCreateWithoutInvoiceInput = {
    id?: number
    productId?: number | null
    description: string
    quantity: number
    unitPriceHt: number
    discountRate?: number
    vatRate: number
    totalHt: number
    sortOrder?: number
  }

  export type InvoiceItemCreateOrConnectWithoutInvoiceInput = {
    where: InvoiceItemWhereUniqueInput
    create: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput>
  }

  export type InvoiceItemCreateManyInvoiceInputEnvelope = {
    data: InvoiceItemCreateManyInvoiceInput | InvoiceItemCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type PaymentAllocationCreateWithoutInvoiceInput = {
    amount: number
    createdAt?: Date | string
    payment: PaymentCreateNestedOneWithoutAllocationsInput
  }

  export type PaymentAllocationUncheckedCreateWithoutInvoiceInput = {
    id?: number
    paymentId: number
    amount: number
    createdAt?: Date | string
  }

  export type PaymentAllocationCreateOrConnectWithoutInvoiceInput = {
    where: PaymentAllocationWhereUniqueInput
    create: XOR<PaymentAllocationCreateWithoutInvoiceInput, PaymentAllocationUncheckedCreateWithoutInvoiceInput>
  }

  export type PaymentAllocationCreateManyInvoiceInputEnvelope = {
    data: PaymentAllocationCreateManyInvoiceInput | PaymentAllocationCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type ReminderCreateWithoutInvoiceInput = {
    type: $Enums.ReminderType
    sentDate: Date | string
    dueDate?: Date | string | null
    amountDue: number
    lateFees?: number
    status?: $Enums.ReminderStatus
    emailSubject?: string | null
    emailBody?: string | null
    createdAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedRemindersInput
  }

  export type ReminderUncheckedCreateWithoutInvoiceInput = {
    id?: number
    type: $Enums.ReminderType
    sentDate: Date | string
    dueDate?: Date | string | null
    amountDue: number
    lateFees?: number
    status?: $Enums.ReminderStatus
    emailSubject?: string | null
    emailBody?: string | null
    createdBy: number
    createdAt?: Date | string
  }

  export type ReminderCreateOrConnectWithoutInvoiceInput = {
    where: ReminderWhereUniqueInput
    create: XOR<ReminderCreateWithoutInvoiceInput, ReminderUncheckedCreateWithoutInvoiceInput>
  }

  export type ReminderCreateManyInvoiceInputEnvelope = {
    data: ReminderCreateManyInvoiceInput | ReminderCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type CustomerUpsertWithoutInvoicesInput = {
    update: XOR<CustomerUpdateWithoutInvoicesInput, CustomerUncheckedUpdateWithoutInvoicesInput>
    create: XOR<CustomerCreateWithoutInvoicesInput, CustomerUncheckedCreateWithoutInvoicesInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutInvoicesInput, CustomerUncheckedUpdateWithoutInvoicesInput>
  }

  export type CustomerUpdateWithoutInvoicesInput = {
    customerNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    siret?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: IntFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    creditLimit?: FloatFieldUpdateOperationsInput | number
    discountRate?: FloatFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneWithoutCustomersNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedCustomersNestedInput
    addresses?: CustomerAddressUpdateManyWithoutCustomerNestedInput
    quotes?: QuoteUpdateManyWithoutCustomerNestedInput
    payments?: PaymentUpdateManyWithoutCustomerNestedInput
    recurringInvoices?: RecurringInvoiceUpdateManyWithoutCustomerNestedInput
    missions?: MissionUpdateManyWithoutClientNestedInput
  }

  export type CustomerUncheckedUpdateWithoutInvoicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    siret?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: IntFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    creditLimit?: FloatFieldUpdateOperationsInput | number
    discountRate?: FloatFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    serviceId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    addresses?: CustomerAddressUncheckedUpdateManyWithoutCustomerNestedInput
    quotes?: QuoteUncheckedUpdateManyWithoutCustomerNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCustomerNestedInput
    recurringInvoices?: RecurringInvoiceUncheckedUpdateManyWithoutCustomerNestedInput
    missions?: MissionUncheckedUpdateManyWithoutClientNestedInput
  }

  export type CustomerAddressUpsertWithoutInvoicesInput = {
    update: XOR<CustomerAddressUpdateWithoutInvoicesInput, CustomerAddressUncheckedUpdateWithoutInvoicesInput>
    create: XOR<CustomerAddressCreateWithoutInvoicesInput, CustomerAddressUncheckedCreateWithoutInvoicesInput>
    where?: CustomerAddressWhereInput
  }

  export type CustomerAddressUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: CustomerAddressWhereInput
    data: XOR<CustomerAddressUpdateWithoutInvoicesInput, CustomerAddressUncheckedUpdateWithoutInvoicesInput>
  }

  export type CustomerAddressUpdateWithoutInvoicesInput = {
    type?: EnumAddressTypeFieldUpdateOperationsInput | $Enums.AddressType
    name?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutAddressesNestedInput
    quotes?: QuoteUpdateManyWithoutCustomerAddressNestedInput
  }

  export type CustomerAddressUncheckedUpdateWithoutInvoicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    type?: EnumAddressTypeFieldUpdateOperationsInput | $Enums.AddressType
    name?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotes?: QuoteUncheckedUpdateManyWithoutCustomerAddressNestedInput
  }

  export type QuoteUpsertWithoutInvoicesInput = {
    update: XOR<QuoteUpdateWithoutInvoicesInput, QuoteUncheckedUpdateWithoutInvoicesInput>
    create: XOR<QuoteCreateWithoutInvoicesInput, QuoteUncheckedCreateWithoutInvoicesInput>
    where?: QuoteWhereInput
  }

  export type QuoteUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: QuoteWhereInput
    data: XOR<QuoteUpdateWithoutInvoicesInput, QuoteUncheckedUpdateWithoutInvoicesInput>
  }

  export type QuoteUpdateWithoutInvoicesInput = {
    quoteNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    quoteDate?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotalHt?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalVat?: FloatFieldUpdateOperationsInput | number
    totalTtc?: FloatFieldUpdateOperationsInput | number
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedForServiceApprovalAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceManagerApprovalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceManagerComments?: NullableStringFieldUpdateOperationsInput | string | null
    dgApprovalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dgComments?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customer?: CustomerUpdateOneRequiredWithoutQuotesNestedInput
    customerAddress?: CustomerAddressUpdateOneWithoutQuotesNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedQuotesNestedInput
    serviceManager?: UserUpdateOneWithoutServiceApprovalsNestedInput
    dgApprover?: UserUpdateOneWithoutDgApprovalsNestedInput
    items?: QuoteItemUpdateManyWithoutQuoteNestedInput
    approvals?: QuoteApprovalUpdateManyWithoutQuoteNestedInput
    missions?: MissionUpdateManyWithoutDevisNestedInput
  }

  export type QuoteUncheckedUpdateWithoutInvoicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    quoteNumber?: StringFieldUpdateOperationsInput | string
    customerId?: IntFieldUpdateOperationsInput | number
    customerAddressId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    quoteDate?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotalHt?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalVat?: FloatFieldUpdateOperationsInput | number
    totalTtc?: FloatFieldUpdateOperationsInput | number
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedForServiceApprovalAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceManagerApprovedBy?: NullableIntFieldUpdateOperationsInput | number | null
    serviceManagerApprovalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceManagerComments?: NullableStringFieldUpdateOperationsInput | string | null
    dgApprovedBy?: NullableIntFieldUpdateOperationsInput | number | null
    dgApprovalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dgComments?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: QuoteItemUncheckedUpdateManyWithoutQuoteNestedInput
    approvals?: QuoteApprovalUncheckedUpdateManyWithoutQuoteNestedInput
    missions?: MissionUncheckedUpdateManyWithoutDevisNestedInput
  }

  export type UserUpsertWithoutCreatedInvoicesInput = {
    update: XOR<UserUpdateWithoutCreatedInvoicesInput, UserUncheckedUpdateWithoutCreatedInvoicesInput>
    create: XOR<UserCreateWithoutCreatedInvoicesInput, UserUncheckedCreateWithoutCreatedInvoicesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedInvoicesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedInvoicesInput, UserUncheckedUpdateWithoutCreatedInvoicesInput>
  }

  export type UserUpdateWithoutCreatedInvoicesInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneWithoutUsersNestedInput
    createdCustomers?: CustomerUpdateManyWithoutCreatorNestedInput
    createdQuotes?: QuoteUpdateManyWithoutCreatorNestedInput
    createdPayments?: PaymentUpdateManyWithoutCreatorNestedInput
    serviceApprovals?: QuoteUpdateManyWithoutServiceManagerNestedInput
    dgApprovals?: QuoteUpdateManyWithoutDgApproverNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    quoteApprovals?: QuoteApprovalUpdateManyWithoutApproverNestedInput
    createdExpenses?: ExpenseUpdateManyWithoutCreatorNestedInput
    accountingEntries?: AccountingEntryUpdateManyWithoutCreatorNestedInput
    cashFlowEntries?: CashFlowUpdateManyWithoutCreatorNestedInput
    createdReminders?: ReminderUpdateManyWithoutCreatorNestedInput
    createdRecurringInvoices?: RecurringInvoiceUpdateManyWithoutCreatorNestedInput
    employee?: EmployeeUpdateOneWithoutUserNestedInput
    leaveApprovals?: LeaveRequestUpdateManyWithoutApprovedByNestedInput
    assignedProspects?: ProspectUpdateManyWithoutAssignedUserNestedInput
    createdProspects?: ProspectUpdateManyWithoutCreatorNestedInput
    createdProspectActivities?: ProspectActivityUpdateManyWithoutCreatorNestedInput
    technicien?: TechnicienUpdateOneWithoutUtilisateurNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedInvoicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    serviceId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdCustomers?: CustomerUncheckedUpdateManyWithoutCreatorNestedInput
    createdQuotes?: QuoteUncheckedUpdateManyWithoutCreatorNestedInput
    createdPayments?: PaymentUncheckedUpdateManyWithoutCreatorNestedInput
    serviceApprovals?: QuoteUncheckedUpdateManyWithoutServiceManagerNestedInput
    dgApprovals?: QuoteUncheckedUpdateManyWithoutDgApproverNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    quoteApprovals?: QuoteApprovalUncheckedUpdateManyWithoutApproverNestedInput
    createdExpenses?: ExpenseUncheckedUpdateManyWithoutCreatorNestedInput
    accountingEntries?: AccountingEntryUncheckedUpdateManyWithoutCreatorNestedInput
    cashFlowEntries?: CashFlowUncheckedUpdateManyWithoutCreatorNestedInput
    createdReminders?: ReminderUncheckedUpdateManyWithoutCreatorNestedInput
    createdRecurringInvoices?: RecurringInvoiceUncheckedUpdateManyWithoutCreatorNestedInput
    employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    leaveApprovals?: LeaveRequestUncheckedUpdateManyWithoutApprovedByNestedInput
    assignedProspects?: ProspectUncheckedUpdateManyWithoutAssignedUserNestedInput
    createdProspects?: ProspectUncheckedUpdateManyWithoutCreatorNestedInput
    createdProspectActivities?: ProspectActivityUncheckedUpdateManyWithoutCreatorNestedInput
    technicien?: TechnicienUncheckedUpdateOneWithoutUtilisateurNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: InvoiceItemWhereUniqueInput
    update: XOR<InvoiceItemUpdateWithoutInvoiceInput, InvoiceItemUncheckedUpdateWithoutInvoiceInput>
    create: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput>
  }

  export type InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: InvoiceItemWhereUniqueInput
    data: XOR<InvoiceItemUpdateWithoutInvoiceInput, InvoiceItemUncheckedUpdateWithoutInvoiceInput>
  }

  export type InvoiceItemUpdateManyWithWhereWithoutInvoiceInput = {
    where: InvoiceItemScalarWhereInput
    data: XOR<InvoiceItemUpdateManyMutationInput, InvoiceItemUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type PaymentAllocationUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: PaymentAllocationWhereUniqueInput
    update: XOR<PaymentAllocationUpdateWithoutInvoiceInput, PaymentAllocationUncheckedUpdateWithoutInvoiceInput>
    create: XOR<PaymentAllocationCreateWithoutInvoiceInput, PaymentAllocationUncheckedCreateWithoutInvoiceInput>
  }

  export type PaymentAllocationUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: PaymentAllocationWhereUniqueInput
    data: XOR<PaymentAllocationUpdateWithoutInvoiceInput, PaymentAllocationUncheckedUpdateWithoutInvoiceInput>
  }

  export type PaymentAllocationUpdateManyWithWhereWithoutInvoiceInput = {
    where: PaymentAllocationScalarWhereInput
    data: XOR<PaymentAllocationUpdateManyMutationInput, PaymentAllocationUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type PaymentAllocationScalarWhereInput = {
    AND?: PaymentAllocationScalarWhereInput | PaymentAllocationScalarWhereInput[]
    OR?: PaymentAllocationScalarWhereInput[]
    NOT?: PaymentAllocationScalarWhereInput | PaymentAllocationScalarWhereInput[]
    id?: IntFilter<"PaymentAllocation"> | number
    paymentId?: IntFilter<"PaymentAllocation"> | number
    invoiceId?: IntFilter<"PaymentAllocation"> | number
    amount?: FloatFilter<"PaymentAllocation"> | number
    createdAt?: DateTimeFilter<"PaymentAllocation"> | Date | string
  }

  export type ReminderUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: ReminderWhereUniqueInput
    update: XOR<ReminderUpdateWithoutInvoiceInput, ReminderUncheckedUpdateWithoutInvoiceInput>
    create: XOR<ReminderCreateWithoutInvoiceInput, ReminderUncheckedCreateWithoutInvoiceInput>
  }

  export type ReminderUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: ReminderWhereUniqueInput
    data: XOR<ReminderUpdateWithoutInvoiceInput, ReminderUncheckedUpdateWithoutInvoiceInput>
  }

  export type ReminderUpdateManyWithWhereWithoutInvoiceInput = {
    where: ReminderScalarWhereInput
    data: XOR<ReminderUpdateManyMutationInput, ReminderUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type InvoiceCreateWithoutItemsInput = {
    invoiceNumber: string
    type?: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    invoiceDate: Date | string
    dueDate: Date | string
    subtotalHt?: number
    discountAmount?: number
    totalVat?: number
    totalTtc?: number
    paidAmount?: number
    balanceDue?: number
    paymentTerms?: number
    lateFeeRate?: number
    terms?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt?: Date | string | null
    customer: CustomerCreateNestedOneWithoutInvoicesInput
    customerAddress?: CustomerAddressCreateNestedOneWithoutInvoicesInput
    quote?: QuoteCreateNestedOneWithoutInvoicesInput
    creator: UserCreateNestedOneWithoutCreatedInvoicesInput
    paymentAllocations?: PaymentAllocationCreateNestedManyWithoutInvoiceInput
    reminders?: ReminderCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutItemsInput = {
    id?: number
    invoiceNumber: string
    customerId: number
    customerAddressId?: number | null
    quoteId?: number | null
    type?: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    invoiceDate: Date | string
    dueDate: Date | string
    subtotalHt?: number
    discountAmount?: number
    totalVat?: number
    totalTtc?: number
    paidAmount?: number
    balanceDue?: number
    paymentTerms?: number
    lateFeeRate?: number
    terms?: string | null
    notes?: string | null
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt?: Date | string | null
    paymentAllocations?: PaymentAllocationUncheckedCreateNestedManyWithoutInvoiceInput
    reminders?: ReminderUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutItemsInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutItemsInput, InvoiceUncheckedCreateWithoutItemsInput>
  }

  export type ProductCreateWithoutInvoiceItemsInput = {
    sku: string
    name: string
    description?: string | null
    type?: $Enums.ProductType
    category?: string | null
    unit?: string
    priceHt: number
    vatRate?: number
    costPrice?: number | null
    stockQuantity?: number
    stockAlertThreshold?: number
    isActive?: boolean
    weight?: number | null
    dimensions?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    prices?: ProductPriceCreateNestedManyWithoutProductInput
    quoteItems?: QuoteItemCreateNestedManyWithoutProductInput
    recurringInvoiceItems?: RecurringInvoiceItemCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutInvoiceItemsInput = {
    id?: number
    sku: string
    name: string
    description?: string | null
    type?: $Enums.ProductType
    category?: string | null
    unit?: string
    priceHt: number
    vatRate?: number
    costPrice?: number | null
    stockQuantity?: number
    stockAlertThreshold?: number
    isActive?: boolean
    weight?: number | null
    dimensions?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    prices?: ProductPriceUncheckedCreateNestedManyWithoutProductInput
    quoteItems?: QuoteItemUncheckedCreateNestedManyWithoutProductInput
    recurringInvoiceItems?: RecurringInvoiceItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutInvoiceItemsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutInvoiceItemsInput, ProductUncheckedCreateWithoutInvoiceItemsInput>
  }

  export type InvoiceUpsertWithoutItemsInput = {
    update: XOR<InvoiceUpdateWithoutItemsInput, InvoiceUncheckedUpdateWithoutItemsInput>
    create: XOR<InvoiceCreateWithoutItemsInput, InvoiceUncheckedCreateWithoutItemsInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutItemsInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutItemsInput, InvoiceUncheckedUpdateWithoutItemsInput>
  }

  export type InvoiceUpdateWithoutItemsInput = {
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotalHt?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalVat?: FloatFieldUpdateOperationsInput | number
    totalTtc?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    balanceDue?: FloatFieldUpdateOperationsInput | number
    paymentTerms?: IntFieldUpdateOperationsInput | number
    lateFeeRate?: FloatFieldUpdateOperationsInput | number
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customer?: CustomerUpdateOneRequiredWithoutInvoicesNestedInput
    customerAddress?: CustomerAddressUpdateOneWithoutInvoicesNestedInput
    quote?: QuoteUpdateOneWithoutInvoicesNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedInvoicesNestedInput
    paymentAllocations?: PaymentAllocationUpdateManyWithoutInvoiceNestedInput
    reminders?: ReminderUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    customerId?: IntFieldUpdateOperationsInput | number
    customerAddressId?: NullableIntFieldUpdateOperationsInput | number | null
    quoteId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotalHt?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalVat?: FloatFieldUpdateOperationsInput | number
    totalTtc?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    balanceDue?: FloatFieldUpdateOperationsInput | number
    paymentTerms?: IntFieldUpdateOperationsInput | number
    lateFeeRate?: FloatFieldUpdateOperationsInput | number
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentAllocations?: PaymentAllocationUncheckedUpdateManyWithoutInvoiceNestedInput
    reminders?: ReminderUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type ProductUpsertWithoutInvoiceItemsInput = {
    update: XOR<ProductUpdateWithoutInvoiceItemsInput, ProductUncheckedUpdateWithoutInvoiceItemsInput>
    create: XOR<ProductCreateWithoutInvoiceItemsInput, ProductUncheckedCreateWithoutInvoiceItemsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutInvoiceItemsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutInvoiceItemsInput, ProductUncheckedUpdateWithoutInvoiceItemsInput>
  }

  export type ProductUpdateWithoutInvoiceItemsInput = {
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    category?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    priceHt?: FloatFieldUpdateOperationsInput | number
    vatRate?: FloatFieldUpdateOperationsInput | number
    costPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    stockAlertThreshold?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    dimensions?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prices?: ProductPriceUpdateManyWithoutProductNestedInput
    quoteItems?: QuoteItemUpdateManyWithoutProductNestedInput
    recurringInvoiceItems?: RecurringInvoiceItemUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutInvoiceItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    category?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    priceHt?: FloatFieldUpdateOperationsInput | number
    vatRate?: FloatFieldUpdateOperationsInput | number
    costPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    stockAlertThreshold?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    dimensions?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prices?: ProductPriceUncheckedUpdateManyWithoutProductNestedInput
    quoteItems?: QuoteItemUncheckedUpdateManyWithoutProductNestedInput
    recurringInvoiceItems?: RecurringInvoiceItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type CustomerCreateWithoutPaymentsInput = {
    customerNumber: string
    type?: $Enums.CustomerType
    name: string
    legalName?: string | null
    siret?: string | null
    vatNumber?: string | null
    email?: string | null
    phone?: string | null
    mobile?: string | null
    website?: string | null
    paymentTerms?: number
    paymentMethod?: $Enums.PaymentMethod
    creditLimit?: number
    discountRate?: number
    category?: string | null
    tags?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    service?: ServiceCreateNestedOneWithoutCustomersInput
    creator: UserCreateNestedOneWithoutCreatedCustomersInput
    addresses?: CustomerAddressCreateNestedManyWithoutCustomerInput
    quotes?: QuoteCreateNestedManyWithoutCustomerInput
    invoices?: InvoiceCreateNestedManyWithoutCustomerInput
    recurringInvoices?: RecurringInvoiceCreateNestedManyWithoutCustomerInput
    missions?: MissionCreateNestedManyWithoutClientInput
  }

  export type CustomerUncheckedCreateWithoutPaymentsInput = {
    id?: number
    customerNumber: string
    type?: $Enums.CustomerType
    name: string
    legalName?: string | null
    siret?: string | null
    vatNumber?: string | null
    email?: string | null
    phone?: string | null
    mobile?: string | null
    website?: string | null
    paymentTerms?: number
    paymentMethod?: $Enums.PaymentMethod
    creditLimit?: number
    discountRate?: number
    category?: string | null
    tags?: string | null
    notes?: string | null
    isActive?: boolean
    serviceId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: number
    addresses?: CustomerAddressUncheckedCreateNestedManyWithoutCustomerInput
    quotes?: QuoteUncheckedCreateNestedManyWithoutCustomerInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCustomerInput
    recurringInvoices?: RecurringInvoiceUncheckedCreateNestedManyWithoutCustomerInput
    missions?: MissionUncheckedCreateNestedManyWithoutClientInput
  }

  export type CustomerCreateOrConnectWithoutPaymentsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutPaymentsInput, CustomerUncheckedCreateWithoutPaymentsInput>
  }

  export type UserCreateWithoutCreatedPaymentsInput = {
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    preferences?: string | null
    permissions?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    service?: ServiceCreateNestedOneWithoutUsersInput
    createdCustomers?: CustomerCreateNestedManyWithoutCreatorInput
    createdQuotes?: QuoteCreateNestedManyWithoutCreatorInput
    createdInvoices?: InvoiceCreateNestedManyWithoutCreatorInput
    serviceApprovals?: QuoteCreateNestedManyWithoutServiceManagerInput
    dgApprovals?: QuoteCreateNestedManyWithoutDgApproverInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    quoteApprovals?: QuoteApprovalCreateNestedManyWithoutApproverInput
    createdExpenses?: ExpenseCreateNestedManyWithoutCreatorInput
    accountingEntries?: AccountingEntryCreateNestedManyWithoutCreatorInput
    cashFlowEntries?: CashFlowCreateNestedManyWithoutCreatorInput
    createdReminders?: ReminderCreateNestedManyWithoutCreatorInput
    createdRecurringInvoices?: RecurringInvoiceCreateNestedManyWithoutCreatorInput
    employee?: EmployeeCreateNestedOneWithoutUserInput
    leaveApprovals?: LeaveRequestCreateNestedManyWithoutApprovedByInput
    assignedProspects?: ProspectCreateNestedManyWithoutAssignedUserInput
    createdProspects?: ProspectCreateNestedManyWithoutCreatorInput
    createdProspectActivities?: ProspectActivityCreateNestedManyWithoutCreatorInput
    technicien?: TechnicienCreateNestedOneWithoutUtilisateurInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedPaymentsInput = {
    id?: number
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    serviceId?: number | null
    isActive?: boolean
    lastLogin?: Date | string | null
    preferences?: string | null
    permissions?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdCustomers?: CustomerUncheckedCreateNestedManyWithoutCreatorInput
    createdQuotes?: QuoteUncheckedCreateNestedManyWithoutCreatorInput
    createdInvoices?: InvoiceUncheckedCreateNestedManyWithoutCreatorInput
    serviceApprovals?: QuoteUncheckedCreateNestedManyWithoutServiceManagerInput
    dgApprovals?: QuoteUncheckedCreateNestedManyWithoutDgApproverInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    quoteApprovals?: QuoteApprovalUncheckedCreateNestedManyWithoutApproverInput
    createdExpenses?: ExpenseUncheckedCreateNestedManyWithoutCreatorInput
    accountingEntries?: AccountingEntryUncheckedCreateNestedManyWithoutCreatorInput
    cashFlowEntries?: CashFlowUncheckedCreateNestedManyWithoutCreatorInput
    createdReminders?: ReminderUncheckedCreateNestedManyWithoutCreatorInput
    createdRecurringInvoices?: RecurringInvoiceUncheckedCreateNestedManyWithoutCreatorInput
    employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    leaveApprovals?: LeaveRequestUncheckedCreateNestedManyWithoutApprovedByInput
    assignedProspects?: ProspectUncheckedCreateNestedManyWithoutAssignedUserInput
    createdProspects?: ProspectUncheckedCreateNestedManyWithoutCreatorInput
    createdProspectActivities?: ProspectActivityUncheckedCreateNestedManyWithoutCreatorInput
    technicien?: TechnicienUncheckedCreateNestedOneWithoutUtilisateurInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedPaymentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedPaymentsInput, UserUncheckedCreateWithoutCreatedPaymentsInput>
  }

  export type PaymentAllocationCreateWithoutPaymentInput = {
    amount: number
    createdAt?: Date | string
    invoice: InvoiceCreateNestedOneWithoutPaymentAllocationsInput
  }

  export type PaymentAllocationUncheckedCreateWithoutPaymentInput = {
    id?: number
    invoiceId: number
    amount: number
    createdAt?: Date | string
  }

  export type PaymentAllocationCreateOrConnectWithoutPaymentInput = {
    where: PaymentAllocationWhereUniqueInput
    create: XOR<PaymentAllocationCreateWithoutPaymentInput, PaymentAllocationUncheckedCreateWithoutPaymentInput>
  }

  export type PaymentAllocationCreateManyPaymentInputEnvelope = {
    data: PaymentAllocationCreateManyPaymentInput | PaymentAllocationCreateManyPaymentInput[]
    skipDuplicates?: boolean
  }

  export type CustomerUpsertWithoutPaymentsInput = {
    update: XOR<CustomerUpdateWithoutPaymentsInput, CustomerUncheckedUpdateWithoutPaymentsInput>
    create: XOR<CustomerCreateWithoutPaymentsInput, CustomerUncheckedCreateWithoutPaymentsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutPaymentsInput, CustomerUncheckedUpdateWithoutPaymentsInput>
  }

  export type CustomerUpdateWithoutPaymentsInput = {
    customerNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    siret?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: IntFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    creditLimit?: FloatFieldUpdateOperationsInput | number
    discountRate?: FloatFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneWithoutCustomersNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedCustomersNestedInput
    addresses?: CustomerAddressUpdateManyWithoutCustomerNestedInput
    quotes?: QuoteUpdateManyWithoutCustomerNestedInput
    invoices?: InvoiceUpdateManyWithoutCustomerNestedInput
    recurringInvoices?: RecurringInvoiceUpdateManyWithoutCustomerNestedInput
    missions?: MissionUpdateManyWithoutClientNestedInput
  }

  export type CustomerUncheckedUpdateWithoutPaymentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    siret?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: IntFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    creditLimit?: FloatFieldUpdateOperationsInput | number
    discountRate?: FloatFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    serviceId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    addresses?: CustomerAddressUncheckedUpdateManyWithoutCustomerNestedInput
    quotes?: QuoteUncheckedUpdateManyWithoutCustomerNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCustomerNestedInput
    recurringInvoices?: RecurringInvoiceUncheckedUpdateManyWithoutCustomerNestedInput
    missions?: MissionUncheckedUpdateManyWithoutClientNestedInput
  }

  export type UserUpsertWithoutCreatedPaymentsInput = {
    update: XOR<UserUpdateWithoutCreatedPaymentsInput, UserUncheckedUpdateWithoutCreatedPaymentsInput>
    create: XOR<UserCreateWithoutCreatedPaymentsInput, UserUncheckedCreateWithoutCreatedPaymentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedPaymentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedPaymentsInput, UserUncheckedUpdateWithoutCreatedPaymentsInput>
  }

  export type UserUpdateWithoutCreatedPaymentsInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneWithoutUsersNestedInput
    createdCustomers?: CustomerUpdateManyWithoutCreatorNestedInput
    createdQuotes?: QuoteUpdateManyWithoutCreatorNestedInput
    createdInvoices?: InvoiceUpdateManyWithoutCreatorNestedInput
    serviceApprovals?: QuoteUpdateManyWithoutServiceManagerNestedInput
    dgApprovals?: QuoteUpdateManyWithoutDgApproverNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    quoteApprovals?: QuoteApprovalUpdateManyWithoutApproverNestedInput
    createdExpenses?: ExpenseUpdateManyWithoutCreatorNestedInput
    accountingEntries?: AccountingEntryUpdateManyWithoutCreatorNestedInput
    cashFlowEntries?: CashFlowUpdateManyWithoutCreatorNestedInput
    createdReminders?: ReminderUpdateManyWithoutCreatorNestedInput
    createdRecurringInvoices?: RecurringInvoiceUpdateManyWithoutCreatorNestedInput
    employee?: EmployeeUpdateOneWithoutUserNestedInput
    leaveApprovals?: LeaveRequestUpdateManyWithoutApprovedByNestedInput
    assignedProspects?: ProspectUpdateManyWithoutAssignedUserNestedInput
    createdProspects?: ProspectUpdateManyWithoutCreatorNestedInput
    createdProspectActivities?: ProspectActivityUpdateManyWithoutCreatorNestedInput
    technicien?: TechnicienUpdateOneWithoutUtilisateurNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedPaymentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    serviceId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdCustomers?: CustomerUncheckedUpdateManyWithoutCreatorNestedInput
    createdQuotes?: QuoteUncheckedUpdateManyWithoutCreatorNestedInput
    createdInvoices?: InvoiceUncheckedUpdateManyWithoutCreatorNestedInput
    serviceApprovals?: QuoteUncheckedUpdateManyWithoutServiceManagerNestedInput
    dgApprovals?: QuoteUncheckedUpdateManyWithoutDgApproverNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    quoteApprovals?: QuoteApprovalUncheckedUpdateManyWithoutApproverNestedInput
    createdExpenses?: ExpenseUncheckedUpdateManyWithoutCreatorNestedInput
    accountingEntries?: AccountingEntryUncheckedUpdateManyWithoutCreatorNestedInput
    cashFlowEntries?: CashFlowUncheckedUpdateManyWithoutCreatorNestedInput
    createdReminders?: ReminderUncheckedUpdateManyWithoutCreatorNestedInput
    createdRecurringInvoices?: RecurringInvoiceUncheckedUpdateManyWithoutCreatorNestedInput
    employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    leaveApprovals?: LeaveRequestUncheckedUpdateManyWithoutApprovedByNestedInput
    assignedProspects?: ProspectUncheckedUpdateManyWithoutAssignedUserNestedInput
    createdProspects?: ProspectUncheckedUpdateManyWithoutCreatorNestedInput
    createdProspectActivities?: ProspectActivityUncheckedUpdateManyWithoutCreatorNestedInput
    technicien?: TechnicienUncheckedUpdateOneWithoutUtilisateurNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PaymentAllocationUpsertWithWhereUniqueWithoutPaymentInput = {
    where: PaymentAllocationWhereUniqueInput
    update: XOR<PaymentAllocationUpdateWithoutPaymentInput, PaymentAllocationUncheckedUpdateWithoutPaymentInput>
    create: XOR<PaymentAllocationCreateWithoutPaymentInput, PaymentAllocationUncheckedCreateWithoutPaymentInput>
  }

  export type PaymentAllocationUpdateWithWhereUniqueWithoutPaymentInput = {
    where: PaymentAllocationWhereUniqueInput
    data: XOR<PaymentAllocationUpdateWithoutPaymentInput, PaymentAllocationUncheckedUpdateWithoutPaymentInput>
  }

  export type PaymentAllocationUpdateManyWithWhereWithoutPaymentInput = {
    where: PaymentAllocationScalarWhereInput
    data: XOR<PaymentAllocationUpdateManyMutationInput, PaymentAllocationUncheckedUpdateManyWithoutPaymentInput>
  }

  export type PaymentCreateWithoutAllocationsInput = {
    paymentNumber: string
    amount: number
    paymentDate: Date | string
    paymentMethod: $Enums.PaymentMethod
    reference?: string | null
    notes?: string | null
    createdAt?: Date | string
    customer: CustomerCreateNestedOneWithoutPaymentsInput
    creator: UserCreateNestedOneWithoutCreatedPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutAllocationsInput = {
    id?: number
    paymentNumber: string
    customerId: number
    amount: number
    paymentDate: Date | string
    paymentMethod: $Enums.PaymentMethod
    reference?: string | null
    notes?: string | null
    createdBy: number
    createdAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutAllocationsInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutAllocationsInput, PaymentUncheckedCreateWithoutAllocationsInput>
  }

  export type InvoiceCreateWithoutPaymentAllocationsInput = {
    invoiceNumber: string
    type?: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    invoiceDate: Date | string
    dueDate: Date | string
    subtotalHt?: number
    discountAmount?: number
    totalVat?: number
    totalTtc?: number
    paidAmount?: number
    balanceDue?: number
    paymentTerms?: number
    lateFeeRate?: number
    terms?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt?: Date | string | null
    customer: CustomerCreateNestedOneWithoutInvoicesInput
    customerAddress?: CustomerAddressCreateNestedOneWithoutInvoicesInput
    quote?: QuoteCreateNestedOneWithoutInvoicesInput
    creator: UserCreateNestedOneWithoutCreatedInvoicesInput
    items?: InvoiceItemCreateNestedManyWithoutInvoiceInput
    reminders?: ReminderCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutPaymentAllocationsInput = {
    id?: number
    invoiceNumber: string
    customerId: number
    customerAddressId?: number | null
    quoteId?: number | null
    type?: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    invoiceDate: Date | string
    dueDate: Date | string
    subtotalHt?: number
    discountAmount?: number
    totalVat?: number
    totalTtc?: number
    paidAmount?: number
    balanceDue?: number
    paymentTerms?: number
    lateFeeRate?: number
    terms?: string | null
    notes?: string | null
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt?: Date | string | null
    items?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
    reminders?: ReminderUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutPaymentAllocationsInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutPaymentAllocationsInput, InvoiceUncheckedCreateWithoutPaymentAllocationsInput>
  }

  export type PaymentUpsertWithoutAllocationsInput = {
    update: XOR<PaymentUpdateWithoutAllocationsInput, PaymentUncheckedUpdateWithoutAllocationsInput>
    create: XOR<PaymentCreateWithoutAllocationsInput, PaymentUncheckedCreateWithoutAllocationsInput>
    where?: PaymentWhereInput
  }

  export type PaymentUpdateToOneWithWhereWithoutAllocationsInput = {
    where?: PaymentWhereInput
    data: XOR<PaymentUpdateWithoutAllocationsInput, PaymentUncheckedUpdateWithoutAllocationsInput>
  }

  export type PaymentUpdateWithoutAllocationsInput = {
    paymentNumber?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutPaymentsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutAllocationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    paymentNumber?: StringFieldUpdateOperationsInput | string
    customerId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUpsertWithoutPaymentAllocationsInput = {
    update: XOR<InvoiceUpdateWithoutPaymentAllocationsInput, InvoiceUncheckedUpdateWithoutPaymentAllocationsInput>
    create: XOR<InvoiceCreateWithoutPaymentAllocationsInput, InvoiceUncheckedCreateWithoutPaymentAllocationsInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutPaymentAllocationsInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutPaymentAllocationsInput, InvoiceUncheckedUpdateWithoutPaymentAllocationsInput>
  }

  export type InvoiceUpdateWithoutPaymentAllocationsInput = {
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotalHt?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalVat?: FloatFieldUpdateOperationsInput | number
    totalTtc?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    balanceDue?: FloatFieldUpdateOperationsInput | number
    paymentTerms?: IntFieldUpdateOperationsInput | number
    lateFeeRate?: FloatFieldUpdateOperationsInput | number
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customer?: CustomerUpdateOneRequiredWithoutInvoicesNestedInput
    customerAddress?: CustomerAddressUpdateOneWithoutInvoicesNestedInput
    quote?: QuoteUpdateOneWithoutInvoicesNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedInvoicesNestedInput
    items?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
    reminders?: ReminderUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutPaymentAllocationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    customerId?: IntFieldUpdateOperationsInput | number
    customerAddressId?: NullableIntFieldUpdateOperationsInput | number | null
    quoteId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotalHt?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalVat?: FloatFieldUpdateOperationsInput | number
    totalTtc?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    balanceDue?: FloatFieldUpdateOperationsInput | number
    paymentTerms?: IntFieldUpdateOperationsInput | number
    lateFeeRate?: FloatFieldUpdateOperationsInput | number
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
    reminders?: ReminderUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type CustomerCreateWithoutRecurringInvoicesInput = {
    customerNumber: string
    type?: $Enums.CustomerType
    name: string
    legalName?: string | null
    siret?: string | null
    vatNumber?: string | null
    email?: string | null
    phone?: string | null
    mobile?: string | null
    website?: string | null
    paymentTerms?: number
    paymentMethod?: $Enums.PaymentMethod
    creditLimit?: number
    discountRate?: number
    category?: string | null
    tags?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    service?: ServiceCreateNestedOneWithoutCustomersInput
    creator: UserCreateNestedOneWithoutCreatedCustomersInput
    addresses?: CustomerAddressCreateNestedManyWithoutCustomerInput
    quotes?: QuoteCreateNestedManyWithoutCustomerInput
    invoices?: InvoiceCreateNestedManyWithoutCustomerInput
    payments?: PaymentCreateNestedManyWithoutCustomerInput
    missions?: MissionCreateNestedManyWithoutClientInput
  }

  export type CustomerUncheckedCreateWithoutRecurringInvoicesInput = {
    id?: number
    customerNumber: string
    type?: $Enums.CustomerType
    name: string
    legalName?: string | null
    siret?: string | null
    vatNumber?: string | null
    email?: string | null
    phone?: string | null
    mobile?: string | null
    website?: string | null
    paymentTerms?: number
    paymentMethod?: $Enums.PaymentMethod
    creditLimit?: number
    discountRate?: number
    category?: string | null
    tags?: string | null
    notes?: string | null
    isActive?: boolean
    serviceId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: number
    addresses?: CustomerAddressUncheckedCreateNestedManyWithoutCustomerInput
    quotes?: QuoteUncheckedCreateNestedManyWithoutCustomerInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCustomerInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCustomerInput
    missions?: MissionUncheckedCreateNestedManyWithoutClientInput
  }

  export type CustomerCreateOrConnectWithoutRecurringInvoicesInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutRecurringInvoicesInput, CustomerUncheckedCreateWithoutRecurringInvoicesInput>
  }

  export type UserCreateWithoutCreatedRecurringInvoicesInput = {
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    preferences?: string | null
    permissions?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    service?: ServiceCreateNestedOneWithoutUsersInput
    createdCustomers?: CustomerCreateNestedManyWithoutCreatorInput
    createdQuotes?: QuoteCreateNestedManyWithoutCreatorInput
    createdInvoices?: InvoiceCreateNestedManyWithoutCreatorInput
    createdPayments?: PaymentCreateNestedManyWithoutCreatorInput
    serviceApprovals?: QuoteCreateNestedManyWithoutServiceManagerInput
    dgApprovals?: QuoteCreateNestedManyWithoutDgApproverInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    quoteApprovals?: QuoteApprovalCreateNestedManyWithoutApproverInput
    createdExpenses?: ExpenseCreateNestedManyWithoutCreatorInput
    accountingEntries?: AccountingEntryCreateNestedManyWithoutCreatorInput
    cashFlowEntries?: CashFlowCreateNestedManyWithoutCreatorInput
    createdReminders?: ReminderCreateNestedManyWithoutCreatorInput
    employee?: EmployeeCreateNestedOneWithoutUserInput
    leaveApprovals?: LeaveRequestCreateNestedManyWithoutApprovedByInput
    assignedProspects?: ProspectCreateNestedManyWithoutAssignedUserInput
    createdProspects?: ProspectCreateNestedManyWithoutCreatorInput
    createdProspectActivities?: ProspectActivityCreateNestedManyWithoutCreatorInput
    technicien?: TechnicienCreateNestedOneWithoutUtilisateurInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedRecurringInvoicesInput = {
    id?: number
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    serviceId?: number | null
    isActive?: boolean
    lastLogin?: Date | string | null
    preferences?: string | null
    permissions?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdCustomers?: CustomerUncheckedCreateNestedManyWithoutCreatorInput
    createdQuotes?: QuoteUncheckedCreateNestedManyWithoutCreatorInput
    createdInvoices?: InvoiceUncheckedCreateNestedManyWithoutCreatorInput
    createdPayments?: PaymentUncheckedCreateNestedManyWithoutCreatorInput
    serviceApprovals?: QuoteUncheckedCreateNestedManyWithoutServiceManagerInput
    dgApprovals?: QuoteUncheckedCreateNestedManyWithoutDgApproverInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    quoteApprovals?: QuoteApprovalUncheckedCreateNestedManyWithoutApproverInput
    createdExpenses?: ExpenseUncheckedCreateNestedManyWithoutCreatorInput
    accountingEntries?: AccountingEntryUncheckedCreateNestedManyWithoutCreatorInput
    cashFlowEntries?: CashFlowUncheckedCreateNestedManyWithoutCreatorInput
    createdReminders?: ReminderUncheckedCreateNestedManyWithoutCreatorInput
    employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    leaveApprovals?: LeaveRequestUncheckedCreateNestedManyWithoutApprovedByInput
    assignedProspects?: ProspectUncheckedCreateNestedManyWithoutAssignedUserInput
    createdProspects?: ProspectUncheckedCreateNestedManyWithoutCreatorInput
    createdProspectActivities?: ProspectActivityUncheckedCreateNestedManyWithoutCreatorInput
    technicien?: TechnicienUncheckedCreateNestedOneWithoutUtilisateurInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedRecurringInvoicesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedRecurringInvoicesInput, UserUncheckedCreateWithoutCreatedRecurringInvoicesInput>
  }

  export type RecurringInvoiceItemCreateWithoutRecurringInvoiceInput = {
    description: string
    quantity: number
    unitPriceHt: number
    vatRate: number
    totalHt: number
    sortOrder?: number
    product?: ProductCreateNestedOneWithoutRecurringInvoiceItemsInput
  }

  export type RecurringInvoiceItemUncheckedCreateWithoutRecurringInvoiceInput = {
    id?: number
    productId?: number | null
    description: string
    quantity: number
    unitPriceHt: number
    vatRate: number
    totalHt: number
    sortOrder?: number
  }

  export type RecurringInvoiceItemCreateOrConnectWithoutRecurringInvoiceInput = {
    where: RecurringInvoiceItemWhereUniqueInput
    create: XOR<RecurringInvoiceItemCreateWithoutRecurringInvoiceInput, RecurringInvoiceItemUncheckedCreateWithoutRecurringInvoiceInput>
  }

  export type RecurringInvoiceItemCreateManyRecurringInvoiceInputEnvelope = {
    data: RecurringInvoiceItemCreateManyRecurringInvoiceInput | RecurringInvoiceItemCreateManyRecurringInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type CustomerUpsertWithoutRecurringInvoicesInput = {
    update: XOR<CustomerUpdateWithoutRecurringInvoicesInput, CustomerUncheckedUpdateWithoutRecurringInvoicesInput>
    create: XOR<CustomerCreateWithoutRecurringInvoicesInput, CustomerUncheckedCreateWithoutRecurringInvoicesInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutRecurringInvoicesInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutRecurringInvoicesInput, CustomerUncheckedUpdateWithoutRecurringInvoicesInput>
  }

  export type CustomerUpdateWithoutRecurringInvoicesInput = {
    customerNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    siret?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: IntFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    creditLimit?: FloatFieldUpdateOperationsInput | number
    discountRate?: FloatFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneWithoutCustomersNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedCustomersNestedInput
    addresses?: CustomerAddressUpdateManyWithoutCustomerNestedInput
    quotes?: QuoteUpdateManyWithoutCustomerNestedInput
    invoices?: InvoiceUpdateManyWithoutCustomerNestedInput
    payments?: PaymentUpdateManyWithoutCustomerNestedInput
    missions?: MissionUpdateManyWithoutClientNestedInput
  }

  export type CustomerUncheckedUpdateWithoutRecurringInvoicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    siret?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: IntFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    creditLimit?: FloatFieldUpdateOperationsInput | number
    discountRate?: FloatFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    serviceId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    addresses?: CustomerAddressUncheckedUpdateManyWithoutCustomerNestedInput
    quotes?: QuoteUncheckedUpdateManyWithoutCustomerNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCustomerNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCustomerNestedInput
    missions?: MissionUncheckedUpdateManyWithoutClientNestedInput
  }

  export type UserUpsertWithoutCreatedRecurringInvoicesInput = {
    update: XOR<UserUpdateWithoutCreatedRecurringInvoicesInput, UserUncheckedUpdateWithoutCreatedRecurringInvoicesInput>
    create: XOR<UserCreateWithoutCreatedRecurringInvoicesInput, UserUncheckedCreateWithoutCreatedRecurringInvoicesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedRecurringInvoicesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedRecurringInvoicesInput, UserUncheckedUpdateWithoutCreatedRecurringInvoicesInput>
  }

  export type UserUpdateWithoutCreatedRecurringInvoicesInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneWithoutUsersNestedInput
    createdCustomers?: CustomerUpdateManyWithoutCreatorNestedInput
    createdQuotes?: QuoteUpdateManyWithoutCreatorNestedInput
    createdInvoices?: InvoiceUpdateManyWithoutCreatorNestedInput
    createdPayments?: PaymentUpdateManyWithoutCreatorNestedInput
    serviceApprovals?: QuoteUpdateManyWithoutServiceManagerNestedInput
    dgApprovals?: QuoteUpdateManyWithoutDgApproverNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    quoteApprovals?: QuoteApprovalUpdateManyWithoutApproverNestedInput
    createdExpenses?: ExpenseUpdateManyWithoutCreatorNestedInput
    accountingEntries?: AccountingEntryUpdateManyWithoutCreatorNestedInput
    cashFlowEntries?: CashFlowUpdateManyWithoutCreatorNestedInput
    createdReminders?: ReminderUpdateManyWithoutCreatorNestedInput
    employee?: EmployeeUpdateOneWithoutUserNestedInput
    leaveApprovals?: LeaveRequestUpdateManyWithoutApprovedByNestedInput
    assignedProspects?: ProspectUpdateManyWithoutAssignedUserNestedInput
    createdProspects?: ProspectUpdateManyWithoutCreatorNestedInput
    createdProspectActivities?: ProspectActivityUpdateManyWithoutCreatorNestedInput
    technicien?: TechnicienUpdateOneWithoutUtilisateurNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedRecurringInvoicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    serviceId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdCustomers?: CustomerUncheckedUpdateManyWithoutCreatorNestedInput
    createdQuotes?: QuoteUncheckedUpdateManyWithoutCreatorNestedInput
    createdInvoices?: InvoiceUncheckedUpdateManyWithoutCreatorNestedInput
    createdPayments?: PaymentUncheckedUpdateManyWithoutCreatorNestedInput
    serviceApprovals?: QuoteUncheckedUpdateManyWithoutServiceManagerNestedInput
    dgApprovals?: QuoteUncheckedUpdateManyWithoutDgApproverNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    quoteApprovals?: QuoteApprovalUncheckedUpdateManyWithoutApproverNestedInput
    createdExpenses?: ExpenseUncheckedUpdateManyWithoutCreatorNestedInput
    accountingEntries?: AccountingEntryUncheckedUpdateManyWithoutCreatorNestedInput
    cashFlowEntries?: CashFlowUncheckedUpdateManyWithoutCreatorNestedInput
    createdReminders?: ReminderUncheckedUpdateManyWithoutCreatorNestedInput
    employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    leaveApprovals?: LeaveRequestUncheckedUpdateManyWithoutApprovedByNestedInput
    assignedProspects?: ProspectUncheckedUpdateManyWithoutAssignedUserNestedInput
    createdProspects?: ProspectUncheckedUpdateManyWithoutCreatorNestedInput
    createdProspectActivities?: ProspectActivityUncheckedUpdateManyWithoutCreatorNestedInput
    technicien?: TechnicienUncheckedUpdateOneWithoutUtilisateurNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RecurringInvoiceItemUpsertWithWhereUniqueWithoutRecurringInvoiceInput = {
    where: RecurringInvoiceItemWhereUniqueInput
    update: XOR<RecurringInvoiceItemUpdateWithoutRecurringInvoiceInput, RecurringInvoiceItemUncheckedUpdateWithoutRecurringInvoiceInput>
    create: XOR<RecurringInvoiceItemCreateWithoutRecurringInvoiceInput, RecurringInvoiceItemUncheckedCreateWithoutRecurringInvoiceInput>
  }

  export type RecurringInvoiceItemUpdateWithWhereUniqueWithoutRecurringInvoiceInput = {
    where: RecurringInvoiceItemWhereUniqueInput
    data: XOR<RecurringInvoiceItemUpdateWithoutRecurringInvoiceInput, RecurringInvoiceItemUncheckedUpdateWithoutRecurringInvoiceInput>
  }

  export type RecurringInvoiceItemUpdateManyWithWhereWithoutRecurringInvoiceInput = {
    where: RecurringInvoiceItemScalarWhereInput
    data: XOR<RecurringInvoiceItemUpdateManyMutationInput, RecurringInvoiceItemUncheckedUpdateManyWithoutRecurringInvoiceInput>
  }

  export type RecurringInvoiceCreateWithoutItemsInput = {
    templateName: string
    frequency: $Enums.RecurringFrequency
    startDate: Date | string
    endDate?: Date | string | null
    nextInvoiceDate: Date | string
    isActive?: boolean
    subtotalHt?: number
    totalVat?: number
    totalTtc?: number
    terms?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutRecurringInvoicesInput
    creator: UserCreateNestedOneWithoutCreatedRecurringInvoicesInput
  }

  export type RecurringInvoiceUncheckedCreateWithoutItemsInput = {
    id?: number
    customerId: number
    templateName: string
    frequency: $Enums.RecurringFrequency
    startDate: Date | string
    endDate?: Date | string | null
    nextInvoiceDate: Date | string
    isActive?: boolean
    subtotalHt?: number
    totalVat?: number
    totalTtc?: number
    terms?: string | null
    notes?: string | null
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecurringInvoiceCreateOrConnectWithoutItemsInput = {
    where: RecurringInvoiceWhereUniqueInput
    create: XOR<RecurringInvoiceCreateWithoutItemsInput, RecurringInvoiceUncheckedCreateWithoutItemsInput>
  }

  export type ProductCreateWithoutRecurringInvoiceItemsInput = {
    sku: string
    name: string
    description?: string | null
    type?: $Enums.ProductType
    category?: string | null
    unit?: string
    priceHt: number
    vatRate?: number
    costPrice?: number | null
    stockQuantity?: number
    stockAlertThreshold?: number
    isActive?: boolean
    weight?: number | null
    dimensions?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    prices?: ProductPriceCreateNestedManyWithoutProductInput
    quoteItems?: QuoteItemCreateNestedManyWithoutProductInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutRecurringInvoiceItemsInput = {
    id?: number
    sku: string
    name: string
    description?: string | null
    type?: $Enums.ProductType
    category?: string | null
    unit?: string
    priceHt: number
    vatRate?: number
    costPrice?: number | null
    stockQuantity?: number
    stockAlertThreshold?: number
    isActive?: boolean
    weight?: number | null
    dimensions?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    prices?: ProductPriceUncheckedCreateNestedManyWithoutProductInput
    quoteItems?: QuoteItemUncheckedCreateNestedManyWithoutProductInput
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutRecurringInvoiceItemsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutRecurringInvoiceItemsInput, ProductUncheckedCreateWithoutRecurringInvoiceItemsInput>
  }

  export type RecurringInvoiceUpsertWithoutItemsInput = {
    update: XOR<RecurringInvoiceUpdateWithoutItemsInput, RecurringInvoiceUncheckedUpdateWithoutItemsInput>
    create: XOR<RecurringInvoiceCreateWithoutItemsInput, RecurringInvoiceUncheckedCreateWithoutItemsInput>
    where?: RecurringInvoiceWhereInput
  }

  export type RecurringInvoiceUpdateToOneWithWhereWithoutItemsInput = {
    where?: RecurringInvoiceWhereInput
    data: XOR<RecurringInvoiceUpdateWithoutItemsInput, RecurringInvoiceUncheckedUpdateWithoutItemsInput>
  }

  export type RecurringInvoiceUpdateWithoutItemsInput = {
    templateName?: StringFieldUpdateOperationsInput | string
    frequency?: EnumRecurringFrequencyFieldUpdateOperationsInput | $Enums.RecurringFrequency
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextInvoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subtotalHt?: FloatFieldUpdateOperationsInput | number
    totalVat?: FloatFieldUpdateOperationsInput | number
    totalTtc?: FloatFieldUpdateOperationsInput | number
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutRecurringInvoicesNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedRecurringInvoicesNestedInput
  }

  export type RecurringInvoiceUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    templateName?: StringFieldUpdateOperationsInput | string
    frequency?: EnumRecurringFrequencyFieldUpdateOperationsInput | $Enums.RecurringFrequency
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextInvoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subtotalHt?: FloatFieldUpdateOperationsInput | number
    totalVat?: FloatFieldUpdateOperationsInput | number
    totalTtc?: FloatFieldUpdateOperationsInput | number
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUpsertWithoutRecurringInvoiceItemsInput = {
    update: XOR<ProductUpdateWithoutRecurringInvoiceItemsInput, ProductUncheckedUpdateWithoutRecurringInvoiceItemsInput>
    create: XOR<ProductCreateWithoutRecurringInvoiceItemsInput, ProductUncheckedCreateWithoutRecurringInvoiceItemsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutRecurringInvoiceItemsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutRecurringInvoiceItemsInput, ProductUncheckedUpdateWithoutRecurringInvoiceItemsInput>
  }

  export type ProductUpdateWithoutRecurringInvoiceItemsInput = {
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    category?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    priceHt?: FloatFieldUpdateOperationsInput | number
    vatRate?: FloatFieldUpdateOperationsInput | number
    costPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    stockAlertThreshold?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    dimensions?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prices?: ProductPriceUpdateManyWithoutProductNestedInput
    quoteItems?: QuoteItemUpdateManyWithoutProductNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutRecurringInvoiceItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    category?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    priceHt?: FloatFieldUpdateOperationsInput | number
    vatRate?: FloatFieldUpdateOperationsInput | number
    costPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    stockAlertThreshold?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    dimensions?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prices?: ProductPriceUncheckedUpdateManyWithoutProductNestedInput
    quoteItems?: QuoteItemUncheckedUpdateManyWithoutProductNestedInput
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type InvoiceCreateWithoutRemindersInput = {
    invoiceNumber: string
    type?: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    invoiceDate: Date | string
    dueDate: Date | string
    subtotalHt?: number
    discountAmount?: number
    totalVat?: number
    totalTtc?: number
    paidAmount?: number
    balanceDue?: number
    paymentTerms?: number
    lateFeeRate?: number
    terms?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt?: Date | string | null
    customer: CustomerCreateNestedOneWithoutInvoicesInput
    customerAddress?: CustomerAddressCreateNestedOneWithoutInvoicesInput
    quote?: QuoteCreateNestedOneWithoutInvoicesInput
    creator: UserCreateNestedOneWithoutCreatedInvoicesInput
    items?: InvoiceItemCreateNestedManyWithoutInvoiceInput
    paymentAllocations?: PaymentAllocationCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutRemindersInput = {
    id?: number
    invoiceNumber: string
    customerId: number
    customerAddressId?: number | null
    quoteId?: number | null
    type?: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    invoiceDate: Date | string
    dueDate: Date | string
    subtotalHt?: number
    discountAmount?: number
    totalVat?: number
    totalTtc?: number
    paidAmount?: number
    balanceDue?: number
    paymentTerms?: number
    lateFeeRate?: number
    terms?: string | null
    notes?: string | null
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt?: Date | string | null
    items?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
    paymentAllocations?: PaymentAllocationUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutRemindersInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutRemindersInput, InvoiceUncheckedCreateWithoutRemindersInput>
  }

  export type UserCreateWithoutCreatedRemindersInput = {
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    preferences?: string | null
    permissions?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    service?: ServiceCreateNestedOneWithoutUsersInput
    createdCustomers?: CustomerCreateNestedManyWithoutCreatorInput
    createdQuotes?: QuoteCreateNestedManyWithoutCreatorInput
    createdInvoices?: InvoiceCreateNestedManyWithoutCreatorInput
    createdPayments?: PaymentCreateNestedManyWithoutCreatorInput
    serviceApprovals?: QuoteCreateNestedManyWithoutServiceManagerInput
    dgApprovals?: QuoteCreateNestedManyWithoutDgApproverInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    quoteApprovals?: QuoteApprovalCreateNestedManyWithoutApproverInput
    createdExpenses?: ExpenseCreateNestedManyWithoutCreatorInput
    accountingEntries?: AccountingEntryCreateNestedManyWithoutCreatorInput
    cashFlowEntries?: CashFlowCreateNestedManyWithoutCreatorInput
    createdRecurringInvoices?: RecurringInvoiceCreateNestedManyWithoutCreatorInput
    employee?: EmployeeCreateNestedOneWithoutUserInput
    leaveApprovals?: LeaveRequestCreateNestedManyWithoutApprovedByInput
    assignedProspects?: ProspectCreateNestedManyWithoutAssignedUserInput
    createdProspects?: ProspectCreateNestedManyWithoutCreatorInput
    createdProspectActivities?: ProspectActivityCreateNestedManyWithoutCreatorInput
    technicien?: TechnicienCreateNestedOneWithoutUtilisateurInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedRemindersInput = {
    id?: number
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    serviceId?: number | null
    isActive?: boolean
    lastLogin?: Date | string | null
    preferences?: string | null
    permissions?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdCustomers?: CustomerUncheckedCreateNestedManyWithoutCreatorInput
    createdQuotes?: QuoteUncheckedCreateNestedManyWithoutCreatorInput
    createdInvoices?: InvoiceUncheckedCreateNestedManyWithoutCreatorInput
    createdPayments?: PaymentUncheckedCreateNestedManyWithoutCreatorInput
    serviceApprovals?: QuoteUncheckedCreateNestedManyWithoutServiceManagerInput
    dgApprovals?: QuoteUncheckedCreateNestedManyWithoutDgApproverInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    quoteApprovals?: QuoteApprovalUncheckedCreateNestedManyWithoutApproverInput
    createdExpenses?: ExpenseUncheckedCreateNestedManyWithoutCreatorInput
    accountingEntries?: AccountingEntryUncheckedCreateNestedManyWithoutCreatorInput
    cashFlowEntries?: CashFlowUncheckedCreateNestedManyWithoutCreatorInput
    createdRecurringInvoices?: RecurringInvoiceUncheckedCreateNestedManyWithoutCreatorInput
    employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    leaveApprovals?: LeaveRequestUncheckedCreateNestedManyWithoutApprovedByInput
    assignedProspects?: ProspectUncheckedCreateNestedManyWithoutAssignedUserInput
    createdProspects?: ProspectUncheckedCreateNestedManyWithoutCreatorInput
    createdProspectActivities?: ProspectActivityUncheckedCreateNestedManyWithoutCreatorInput
    technicien?: TechnicienUncheckedCreateNestedOneWithoutUtilisateurInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedRemindersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedRemindersInput, UserUncheckedCreateWithoutCreatedRemindersInput>
  }

  export type InvoiceUpsertWithoutRemindersInput = {
    update: XOR<InvoiceUpdateWithoutRemindersInput, InvoiceUncheckedUpdateWithoutRemindersInput>
    create: XOR<InvoiceCreateWithoutRemindersInput, InvoiceUncheckedCreateWithoutRemindersInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutRemindersInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutRemindersInput, InvoiceUncheckedUpdateWithoutRemindersInput>
  }

  export type InvoiceUpdateWithoutRemindersInput = {
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotalHt?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalVat?: FloatFieldUpdateOperationsInput | number
    totalTtc?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    balanceDue?: FloatFieldUpdateOperationsInput | number
    paymentTerms?: IntFieldUpdateOperationsInput | number
    lateFeeRate?: FloatFieldUpdateOperationsInput | number
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customer?: CustomerUpdateOneRequiredWithoutInvoicesNestedInput
    customerAddress?: CustomerAddressUpdateOneWithoutInvoicesNestedInput
    quote?: QuoteUpdateOneWithoutInvoicesNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedInvoicesNestedInput
    items?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
    paymentAllocations?: PaymentAllocationUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutRemindersInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    customerId?: IntFieldUpdateOperationsInput | number
    customerAddressId?: NullableIntFieldUpdateOperationsInput | number | null
    quoteId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotalHt?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalVat?: FloatFieldUpdateOperationsInput | number
    totalTtc?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    balanceDue?: FloatFieldUpdateOperationsInput | number
    paymentTerms?: IntFieldUpdateOperationsInput | number
    lateFeeRate?: FloatFieldUpdateOperationsInput | number
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
    paymentAllocations?: PaymentAllocationUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type UserUpsertWithoutCreatedRemindersInput = {
    update: XOR<UserUpdateWithoutCreatedRemindersInput, UserUncheckedUpdateWithoutCreatedRemindersInput>
    create: XOR<UserCreateWithoutCreatedRemindersInput, UserUncheckedCreateWithoutCreatedRemindersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedRemindersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedRemindersInput, UserUncheckedUpdateWithoutCreatedRemindersInput>
  }

  export type UserUpdateWithoutCreatedRemindersInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneWithoutUsersNestedInput
    createdCustomers?: CustomerUpdateManyWithoutCreatorNestedInput
    createdQuotes?: QuoteUpdateManyWithoutCreatorNestedInput
    createdInvoices?: InvoiceUpdateManyWithoutCreatorNestedInput
    createdPayments?: PaymentUpdateManyWithoutCreatorNestedInput
    serviceApprovals?: QuoteUpdateManyWithoutServiceManagerNestedInput
    dgApprovals?: QuoteUpdateManyWithoutDgApproverNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    quoteApprovals?: QuoteApprovalUpdateManyWithoutApproverNestedInput
    createdExpenses?: ExpenseUpdateManyWithoutCreatorNestedInput
    accountingEntries?: AccountingEntryUpdateManyWithoutCreatorNestedInput
    cashFlowEntries?: CashFlowUpdateManyWithoutCreatorNestedInput
    createdRecurringInvoices?: RecurringInvoiceUpdateManyWithoutCreatorNestedInput
    employee?: EmployeeUpdateOneWithoutUserNestedInput
    leaveApprovals?: LeaveRequestUpdateManyWithoutApprovedByNestedInput
    assignedProspects?: ProspectUpdateManyWithoutAssignedUserNestedInput
    createdProspects?: ProspectUpdateManyWithoutCreatorNestedInput
    createdProspectActivities?: ProspectActivityUpdateManyWithoutCreatorNestedInput
    technicien?: TechnicienUpdateOneWithoutUtilisateurNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedRemindersInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    serviceId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdCustomers?: CustomerUncheckedUpdateManyWithoutCreatorNestedInput
    createdQuotes?: QuoteUncheckedUpdateManyWithoutCreatorNestedInput
    createdInvoices?: InvoiceUncheckedUpdateManyWithoutCreatorNestedInput
    createdPayments?: PaymentUncheckedUpdateManyWithoutCreatorNestedInput
    serviceApprovals?: QuoteUncheckedUpdateManyWithoutServiceManagerNestedInput
    dgApprovals?: QuoteUncheckedUpdateManyWithoutDgApproverNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    quoteApprovals?: QuoteApprovalUncheckedUpdateManyWithoutApproverNestedInput
    createdExpenses?: ExpenseUncheckedUpdateManyWithoutCreatorNestedInput
    accountingEntries?: AccountingEntryUncheckedUpdateManyWithoutCreatorNestedInput
    cashFlowEntries?: CashFlowUncheckedUpdateManyWithoutCreatorNestedInput
    createdRecurringInvoices?: RecurringInvoiceUncheckedUpdateManyWithoutCreatorNestedInput
    employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    leaveApprovals?: LeaveRequestUncheckedUpdateManyWithoutApprovedByNestedInput
    assignedProspects?: ProspectUncheckedUpdateManyWithoutAssignedUserNestedInput
    createdProspects?: ProspectUncheckedUpdateManyWithoutCreatorNestedInput
    createdProspectActivities?: ProspectActivityUncheckedUpdateManyWithoutCreatorNestedInput
    technicien?: TechnicienUncheckedUpdateOneWithoutUtilisateurNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SupplierCreateWithoutExpensesInput = {
    name: string
    contactPerson?: string | null
    email?: string | null
    phone?: string | null
    addressLine1?: string | null
    city?: string | null
    postalCode?: string | null
    country?: string | null
    vatNumber?: string | null
    bankName?: string | null
    bankIban?: string | null
    bankBic?: string | null
    paymentTerms?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupplierUncheckedCreateWithoutExpensesInput = {
    id?: number
    name: string
    contactPerson?: string | null
    email?: string | null
    phone?: string | null
    addressLine1?: string | null
    city?: string | null
    postalCode?: string | null
    country?: string | null
    vatNumber?: string | null
    bankName?: string | null
    bankIban?: string | null
    bankBic?: string | null
    paymentTerms?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupplierCreateOrConnectWithoutExpensesInput = {
    where: SupplierWhereUniqueInput
    create: XOR<SupplierCreateWithoutExpensesInput, SupplierUncheckedCreateWithoutExpensesInput>
  }

  export type UserCreateWithoutCreatedExpensesInput = {
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    preferences?: string | null
    permissions?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    service?: ServiceCreateNestedOneWithoutUsersInput
    createdCustomers?: CustomerCreateNestedManyWithoutCreatorInput
    createdQuotes?: QuoteCreateNestedManyWithoutCreatorInput
    createdInvoices?: InvoiceCreateNestedManyWithoutCreatorInput
    createdPayments?: PaymentCreateNestedManyWithoutCreatorInput
    serviceApprovals?: QuoteCreateNestedManyWithoutServiceManagerInput
    dgApprovals?: QuoteCreateNestedManyWithoutDgApproverInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    quoteApprovals?: QuoteApprovalCreateNestedManyWithoutApproverInput
    accountingEntries?: AccountingEntryCreateNestedManyWithoutCreatorInput
    cashFlowEntries?: CashFlowCreateNestedManyWithoutCreatorInput
    createdReminders?: ReminderCreateNestedManyWithoutCreatorInput
    createdRecurringInvoices?: RecurringInvoiceCreateNestedManyWithoutCreatorInput
    employee?: EmployeeCreateNestedOneWithoutUserInput
    leaveApprovals?: LeaveRequestCreateNestedManyWithoutApprovedByInput
    assignedProspects?: ProspectCreateNestedManyWithoutAssignedUserInput
    createdProspects?: ProspectCreateNestedManyWithoutCreatorInput
    createdProspectActivities?: ProspectActivityCreateNestedManyWithoutCreatorInput
    technicien?: TechnicienCreateNestedOneWithoutUtilisateurInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedExpensesInput = {
    id?: number
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    serviceId?: number | null
    isActive?: boolean
    lastLogin?: Date | string | null
    preferences?: string | null
    permissions?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdCustomers?: CustomerUncheckedCreateNestedManyWithoutCreatorInput
    createdQuotes?: QuoteUncheckedCreateNestedManyWithoutCreatorInput
    createdInvoices?: InvoiceUncheckedCreateNestedManyWithoutCreatorInput
    createdPayments?: PaymentUncheckedCreateNestedManyWithoutCreatorInput
    serviceApprovals?: QuoteUncheckedCreateNestedManyWithoutServiceManagerInput
    dgApprovals?: QuoteUncheckedCreateNestedManyWithoutDgApproverInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    quoteApprovals?: QuoteApprovalUncheckedCreateNestedManyWithoutApproverInput
    accountingEntries?: AccountingEntryUncheckedCreateNestedManyWithoutCreatorInput
    cashFlowEntries?: CashFlowUncheckedCreateNestedManyWithoutCreatorInput
    createdReminders?: ReminderUncheckedCreateNestedManyWithoutCreatorInput
    createdRecurringInvoices?: RecurringInvoiceUncheckedCreateNestedManyWithoutCreatorInput
    employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    leaveApprovals?: LeaveRequestUncheckedCreateNestedManyWithoutApprovedByInput
    assignedProspects?: ProspectUncheckedCreateNestedManyWithoutAssignedUserInput
    createdProspects?: ProspectUncheckedCreateNestedManyWithoutCreatorInput
    createdProspectActivities?: ProspectActivityUncheckedCreateNestedManyWithoutCreatorInput
    technicien?: TechnicienUncheckedCreateNestedOneWithoutUtilisateurInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedExpensesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedExpensesInput, UserUncheckedCreateWithoutCreatedExpensesInput>
  }

  export type SupplierUpsertWithoutExpensesInput = {
    update: XOR<SupplierUpdateWithoutExpensesInput, SupplierUncheckedUpdateWithoutExpensesInput>
    create: XOR<SupplierCreateWithoutExpensesInput, SupplierUncheckedCreateWithoutExpensesInput>
    where?: SupplierWhereInput
  }

  export type SupplierUpdateToOneWithWhereWithoutExpensesInput = {
    where?: SupplierWhereInput
    data: XOR<SupplierUpdateWithoutExpensesInput, SupplierUncheckedUpdateWithoutExpensesInput>
  }

  export type SupplierUpdateWithoutExpensesInput = {
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankIban?: NullableStringFieldUpdateOperationsInput | string | null
    bankBic?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierUncheckedUpdateWithoutExpensesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankIban?: NullableStringFieldUpdateOperationsInput | string | null
    bankBic?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutCreatedExpensesInput = {
    update: XOR<UserUpdateWithoutCreatedExpensesInput, UserUncheckedUpdateWithoutCreatedExpensesInput>
    create: XOR<UserCreateWithoutCreatedExpensesInput, UserUncheckedCreateWithoutCreatedExpensesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedExpensesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedExpensesInput, UserUncheckedUpdateWithoutCreatedExpensesInput>
  }

  export type UserUpdateWithoutCreatedExpensesInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneWithoutUsersNestedInput
    createdCustomers?: CustomerUpdateManyWithoutCreatorNestedInput
    createdQuotes?: QuoteUpdateManyWithoutCreatorNestedInput
    createdInvoices?: InvoiceUpdateManyWithoutCreatorNestedInput
    createdPayments?: PaymentUpdateManyWithoutCreatorNestedInput
    serviceApprovals?: QuoteUpdateManyWithoutServiceManagerNestedInput
    dgApprovals?: QuoteUpdateManyWithoutDgApproverNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    quoteApprovals?: QuoteApprovalUpdateManyWithoutApproverNestedInput
    accountingEntries?: AccountingEntryUpdateManyWithoutCreatorNestedInput
    cashFlowEntries?: CashFlowUpdateManyWithoutCreatorNestedInput
    createdReminders?: ReminderUpdateManyWithoutCreatorNestedInput
    createdRecurringInvoices?: RecurringInvoiceUpdateManyWithoutCreatorNestedInput
    employee?: EmployeeUpdateOneWithoutUserNestedInput
    leaveApprovals?: LeaveRequestUpdateManyWithoutApprovedByNestedInput
    assignedProspects?: ProspectUpdateManyWithoutAssignedUserNestedInput
    createdProspects?: ProspectUpdateManyWithoutCreatorNestedInput
    createdProspectActivities?: ProspectActivityUpdateManyWithoutCreatorNestedInput
    technicien?: TechnicienUpdateOneWithoutUtilisateurNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedExpensesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    serviceId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdCustomers?: CustomerUncheckedUpdateManyWithoutCreatorNestedInput
    createdQuotes?: QuoteUncheckedUpdateManyWithoutCreatorNestedInput
    createdInvoices?: InvoiceUncheckedUpdateManyWithoutCreatorNestedInput
    createdPayments?: PaymentUncheckedUpdateManyWithoutCreatorNestedInput
    serviceApprovals?: QuoteUncheckedUpdateManyWithoutServiceManagerNestedInput
    dgApprovals?: QuoteUncheckedUpdateManyWithoutDgApproverNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    quoteApprovals?: QuoteApprovalUncheckedUpdateManyWithoutApproverNestedInput
    accountingEntries?: AccountingEntryUncheckedUpdateManyWithoutCreatorNestedInput
    cashFlowEntries?: CashFlowUncheckedUpdateManyWithoutCreatorNestedInput
    createdReminders?: ReminderUncheckedUpdateManyWithoutCreatorNestedInput
    createdRecurringInvoices?: RecurringInvoiceUncheckedUpdateManyWithoutCreatorNestedInput
    employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    leaveApprovals?: LeaveRequestUncheckedUpdateManyWithoutApprovedByNestedInput
    assignedProspects?: ProspectUncheckedUpdateManyWithoutAssignedUserNestedInput
    createdProspects?: ProspectUncheckedUpdateManyWithoutCreatorNestedInput
    createdProspectActivities?: ProspectActivityUncheckedUpdateManyWithoutCreatorNestedInput
    technicien?: TechnicienUncheckedUpdateOneWithoutUtilisateurNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ExpenseCreateWithoutSupplierInput = {
    expenseNumber: string
    category: string
    description?: string | null
    amountHt: number
    vatAmount?: number
    totalTtc: number
    expenseDate: Date | string
    paymentDate?: Date | string | null
    paymentMethod?: $Enums.PaymentMethod
    status?: $Enums.ExpenseStatus
    receiptUrl?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedExpensesInput
  }

  export type ExpenseUncheckedCreateWithoutSupplierInput = {
    id?: number
    expenseNumber: string
    category: string
    description?: string | null
    amountHt: number
    vatAmount?: number
    totalTtc: number
    expenseDate: Date | string
    paymentDate?: Date | string | null
    paymentMethod?: $Enums.PaymentMethod
    status?: $Enums.ExpenseStatus
    receiptUrl?: string | null
    notes?: string | null
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseCreateOrConnectWithoutSupplierInput = {
    where: ExpenseWhereUniqueInput
    create: XOR<ExpenseCreateWithoutSupplierInput, ExpenseUncheckedCreateWithoutSupplierInput>
  }

  export type ExpenseCreateManySupplierInputEnvelope = {
    data: ExpenseCreateManySupplierInput | ExpenseCreateManySupplierInput[]
    skipDuplicates?: boolean
  }

  export type ExpenseUpsertWithWhereUniqueWithoutSupplierInput = {
    where: ExpenseWhereUniqueInput
    update: XOR<ExpenseUpdateWithoutSupplierInput, ExpenseUncheckedUpdateWithoutSupplierInput>
    create: XOR<ExpenseCreateWithoutSupplierInput, ExpenseUncheckedCreateWithoutSupplierInput>
  }

  export type ExpenseUpdateWithWhereUniqueWithoutSupplierInput = {
    where: ExpenseWhereUniqueInput
    data: XOR<ExpenseUpdateWithoutSupplierInput, ExpenseUncheckedUpdateWithoutSupplierInput>
  }

  export type ExpenseUpdateManyWithWhereWithoutSupplierInput = {
    where: ExpenseScalarWhereInput
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyWithoutSupplierInput>
  }

  export type UserCreateWithoutAccountingEntriesInput = {
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    preferences?: string | null
    permissions?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    service?: ServiceCreateNestedOneWithoutUsersInput
    createdCustomers?: CustomerCreateNestedManyWithoutCreatorInput
    createdQuotes?: QuoteCreateNestedManyWithoutCreatorInput
    createdInvoices?: InvoiceCreateNestedManyWithoutCreatorInput
    createdPayments?: PaymentCreateNestedManyWithoutCreatorInput
    serviceApprovals?: QuoteCreateNestedManyWithoutServiceManagerInput
    dgApprovals?: QuoteCreateNestedManyWithoutDgApproverInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    quoteApprovals?: QuoteApprovalCreateNestedManyWithoutApproverInput
    createdExpenses?: ExpenseCreateNestedManyWithoutCreatorInput
    cashFlowEntries?: CashFlowCreateNestedManyWithoutCreatorInput
    createdReminders?: ReminderCreateNestedManyWithoutCreatorInput
    createdRecurringInvoices?: RecurringInvoiceCreateNestedManyWithoutCreatorInput
    employee?: EmployeeCreateNestedOneWithoutUserInput
    leaveApprovals?: LeaveRequestCreateNestedManyWithoutApprovedByInput
    assignedProspects?: ProspectCreateNestedManyWithoutAssignedUserInput
    createdProspects?: ProspectCreateNestedManyWithoutCreatorInput
    createdProspectActivities?: ProspectActivityCreateNestedManyWithoutCreatorInput
    technicien?: TechnicienCreateNestedOneWithoutUtilisateurInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountingEntriesInput = {
    id?: number
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    serviceId?: number | null
    isActive?: boolean
    lastLogin?: Date | string | null
    preferences?: string | null
    permissions?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdCustomers?: CustomerUncheckedCreateNestedManyWithoutCreatorInput
    createdQuotes?: QuoteUncheckedCreateNestedManyWithoutCreatorInput
    createdInvoices?: InvoiceUncheckedCreateNestedManyWithoutCreatorInput
    createdPayments?: PaymentUncheckedCreateNestedManyWithoutCreatorInput
    serviceApprovals?: QuoteUncheckedCreateNestedManyWithoutServiceManagerInput
    dgApprovals?: QuoteUncheckedCreateNestedManyWithoutDgApproverInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    quoteApprovals?: QuoteApprovalUncheckedCreateNestedManyWithoutApproverInput
    createdExpenses?: ExpenseUncheckedCreateNestedManyWithoutCreatorInput
    cashFlowEntries?: CashFlowUncheckedCreateNestedManyWithoutCreatorInput
    createdReminders?: ReminderUncheckedCreateNestedManyWithoutCreatorInput
    createdRecurringInvoices?: RecurringInvoiceUncheckedCreateNestedManyWithoutCreatorInput
    employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    leaveApprovals?: LeaveRequestUncheckedCreateNestedManyWithoutApprovedByInput
    assignedProspects?: ProspectUncheckedCreateNestedManyWithoutAssignedUserInput
    createdProspects?: ProspectUncheckedCreateNestedManyWithoutCreatorInput
    createdProspectActivities?: ProspectActivityUncheckedCreateNestedManyWithoutCreatorInput
    technicien?: TechnicienUncheckedCreateNestedOneWithoutUtilisateurInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountingEntriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountingEntriesInput, UserUncheckedCreateWithoutAccountingEntriesInput>
  }

  export type UserUpsertWithoutAccountingEntriesInput = {
    update: XOR<UserUpdateWithoutAccountingEntriesInput, UserUncheckedUpdateWithoutAccountingEntriesInput>
    create: XOR<UserCreateWithoutAccountingEntriesInput, UserUncheckedCreateWithoutAccountingEntriesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountingEntriesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountingEntriesInput, UserUncheckedUpdateWithoutAccountingEntriesInput>
  }

  export type UserUpdateWithoutAccountingEntriesInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneWithoutUsersNestedInput
    createdCustomers?: CustomerUpdateManyWithoutCreatorNestedInput
    createdQuotes?: QuoteUpdateManyWithoutCreatorNestedInput
    createdInvoices?: InvoiceUpdateManyWithoutCreatorNestedInput
    createdPayments?: PaymentUpdateManyWithoutCreatorNestedInput
    serviceApprovals?: QuoteUpdateManyWithoutServiceManagerNestedInput
    dgApprovals?: QuoteUpdateManyWithoutDgApproverNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    quoteApprovals?: QuoteApprovalUpdateManyWithoutApproverNestedInput
    createdExpenses?: ExpenseUpdateManyWithoutCreatorNestedInput
    cashFlowEntries?: CashFlowUpdateManyWithoutCreatorNestedInput
    createdReminders?: ReminderUpdateManyWithoutCreatorNestedInput
    createdRecurringInvoices?: RecurringInvoiceUpdateManyWithoutCreatorNestedInput
    employee?: EmployeeUpdateOneWithoutUserNestedInput
    leaveApprovals?: LeaveRequestUpdateManyWithoutApprovedByNestedInput
    assignedProspects?: ProspectUpdateManyWithoutAssignedUserNestedInput
    createdProspects?: ProspectUpdateManyWithoutCreatorNestedInput
    createdProspectActivities?: ProspectActivityUpdateManyWithoutCreatorNestedInput
    technicien?: TechnicienUpdateOneWithoutUtilisateurNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountingEntriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    serviceId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdCustomers?: CustomerUncheckedUpdateManyWithoutCreatorNestedInput
    createdQuotes?: QuoteUncheckedUpdateManyWithoutCreatorNestedInput
    createdInvoices?: InvoiceUncheckedUpdateManyWithoutCreatorNestedInput
    createdPayments?: PaymentUncheckedUpdateManyWithoutCreatorNestedInput
    serviceApprovals?: QuoteUncheckedUpdateManyWithoutServiceManagerNestedInput
    dgApprovals?: QuoteUncheckedUpdateManyWithoutDgApproverNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    quoteApprovals?: QuoteApprovalUncheckedUpdateManyWithoutApproverNestedInput
    createdExpenses?: ExpenseUncheckedUpdateManyWithoutCreatorNestedInput
    cashFlowEntries?: CashFlowUncheckedUpdateManyWithoutCreatorNestedInput
    createdReminders?: ReminderUncheckedUpdateManyWithoutCreatorNestedInput
    createdRecurringInvoices?: RecurringInvoiceUncheckedUpdateManyWithoutCreatorNestedInput
    employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    leaveApprovals?: LeaveRequestUncheckedUpdateManyWithoutApprovedByNestedInput
    assignedProspects?: ProspectUncheckedUpdateManyWithoutAssignedUserNestedInput
    createdProspects?: ProspectUncheckedUpdateManyWithoutCreatorNestedInput
    createdProspectActivities?: ProspectActivityUncheckedUpdateManyWithoutCreatorNestedInput
    technicien?: TechnicienUncheckedUpdateOneWithoutUtilisateurNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutCashFlowEntriesInput = {
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    preferences?: string | null
    permissions?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    service?: ServiceCreateNestedOneWithoutUsersInput
    createdCustomers?: CustomerCreateNestedManyWithoutCreatorInput
    createdQuotes?: QuoteCreateNestedManyWithoutCreatorInput
    createdInvoices?: InvoiceCreateNestedManyWithoutCreatorInput
    createdPayments?: PaymentCreateNestedManyWithoutCreatorInput
    serviceApprovals?: QuoteCreateNestedManyWithoutServiceManagerInput
    dgApprovals?: QuoteCreateNestedManyWithoutDgApproverInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    quoteApprovals?: QuoteApprovalCreateNestedManyWithoutApproverInput
    createdExpenses?: ExpenseCreateNestedManyWithoutCreatorInput
    accountingEntries?: AccountingEntryCreateNestedManyWithoutCreatorInput
    createdReminders?: ReminderCreateNestedManyWithoutCreatorInput
    createdRecurringInvoices?: RecurringInvoiceCreateNestedManyWithoutCreatorInput
    employee?: EmployeeCreateNestedOneWithoutUserInput
    leaveApprovals?: LeaveRequestCreateNestedManyWithoutApprovedByInput
    assignedProspects?: ProspectCreateNestedManyWithoutAssignedUserInput
    createdProspects?: ProspectCreateNestedManyWithoutCreatorInput
    createdProspectActivities?: ProspectActivityCreateNestedManyWithoutCreatorInput
    technicien?: TechnicienCreateNestedOneWithoutUtilisateurInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCashFlowEntriesInput = {
    id?: number
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    serviceId?: number | null
    isActive?: boolean
    lastLogin?: Date | string | null
    preferences?: string | null
    permissions?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdCustomers?: CustomerUncheckedCreateNestedManyWithoutCreatorInput
    createdQuotes?: QuoteUncheckedCreateNestedManyWithoutCreatorInput
    createdInvoices?: InvoiceUncheckedCreateNestedManyWithoutCreatorInput
    createdPayments?: PaymentUncheckedCreateNestedManyWithoutCreatorInput
    serviceApprovals?: QuoteUncheckedCreateNestedManyWithoutServiceManagerInput
    dgApprovals?: QuoteUncheckedCreateNestedManyWithoutDgApproverInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    quoteApprovals?: QuoteApprovalUncheckedCreateNestedManyWithoutApproverInput
    createdExpenses?: ExpenseUncheckedCreateNestedManyWithoutCreatorInput
    accountingEntries?: AccountingEntryUncheckedCreateNestedManyWithoutCreatorInput
    createdReminders?: ReminderUncheckedCreateNestedManyWithoutCreatorInput
    createdRecurringInvoices?: RecurringInvoiceUncheckedCreateNestedManyWithoutCreatorInput
    employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    leaveApprovals?: LeaveRequestUncheckedCreateNestedManyWithoutApprovedByInput
    assignedProspects?: ProspectUncheckedCreateNestedManyWithoutAssignedUserInput
    createdProspects?: ProspectUncheckedCreateNestedManyWithoutCreatorInput
    createdProspectActivities?: ProspectActivityUncheckedCreateNestedManyWithoutCreatorInput
    technicien?: TechnicienUncheckedCreateNestedOneWithoutUtilisateurInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCashFlowEntriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCashFlowEntriesInput, UserUncheckedCreateWithoutCashFlowEntriesInput>
  }

  export type UserUpsertWithoutCashFlowEntriesInput = {
    update: XOR<UserUpdateWithoutCashFlowEntriesInput, UserUncheckedUpdateWithoutCashFlowEntriesInput>
    create: XOR<UserCreateWithoutCashFlowEntriesInput, UserUncheckedCreateWithoutCashFlowEntriesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCashFlowEntriesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCashFlowEntriesInput, UserUncheckedUpdateWithoutCashFlowEntriesInput>
  }

  export type UserUpdateWithoutCashFlowEntriesInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneWithoutUsersNestedInput
    createdCustomers?: CustomerUpdateManyWithoutCreatorNestedInput
    createdQuotes?: QuoteUpdateManyWithoutCreatorNestedInput
    createdInvoices?: InvoiceUpdateManyWithoutCreatorNestedInput
    createdPayments?: PaymentUpdateManyWithoutCreatorNestedInput
    serviceApprovals?: QuoteUpdateManyWithoutServiceManagerNestedInput
    dgApprovals?: QuoteUpdateManyWithoutDgApproverNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    quoteApprovals?: QuoteApprovalUpdateManyWithoutApproverNestedInput
    createdExpenses?: ExpenseUpdateManyWithoutCreatorNestedInput
    accountingEntries?: AccountingEntryUpdateManyWithoutCreatorNestedInput
    createdReminders?: ReminderUpdateManyWithoutCreatorNestedInput
    createdRecurringInvoices?: RecurringInvoiceUpdateManyWithoutCreatorNestedInput
    employee?: EmployeeUpdateOneWithoutUserNestedInput
    leaveApprovals?: LeaveRequestUpdateManyWithoutApprovedByNestedInput
    assignedProspects?: ProspectUpdateManyWithoutAssignedUserNestedInput
    createdProspects?: ProspectUpdateManyWithoutCreatorNestedInput
    createdProspectActivities?: ProspectActivityUpdateManyWithoutCreatorNestedInput
    technicien?: TechnicienUpdateOneWithoutUtilisateurNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCashFlowEntriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    serviceId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdCustomers?: CustomerUncheckedUpdateManyWithoutCreatorNestedInput
    createdQuotes?: QuoteUncheckedUpdateManyWithoutCreatorNestedInput
    createdInvoices?: InvoiceUncheckedUpdateManyWithoutCreatorNestedInput
    createdPayments?: PaymentUncheckedUpdateManyWithoutCreatorNestedInput
    serviceApprovals?: QuoteUncheckedUpdateManyWithoutServiceManagerNestedInput
    dgApprovals?: QuoteUncheckedUpdateManyWithoutDgApproverNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    quoteApprovals?: QuoteApprovalUncheckedUpdateManyWithoutApproverNestedInput
    createdExpenses?: ExpenseUncheckedUpdateManyWithoutCreatorNestedInput
    accountingEntries?: AccountingEntryUncheckedUpdateManyWithoutCreatorNestedInput
    createdReminders?: ReminderUncheckedUpdateManyWithoutCreatorNestedInput
    createdRecurringInvoices?: RecurringInvoiceUncheckedUpdateManyWithoutCreatorNestedInput
    employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    leaveApprovals?: LeaveRequestUncheckedUpdateManyWithoutApprovedByNestedInput
    assignedProspects?: ProspectUncheckedUpdateManyWithoutAssignedUserNestedInput
    createdProspects?: ProspectUncheckedUpdateManyWithoutCreatorNestedInput
    createdProspectActivities?: ProspectActivityUncheckedUpdateManyWithoutCreatorNestedInput
    technicien?: TechnicienUncheckedUpdateOneWithoutUtilisateurNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAuditLogsInput = {
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    preferences?: string | null
    permissions?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    service?: ServiceCreateNestedOneWithoutUsersInput
    createdCustomers?: CustomerCreateNestedManyWithoutCreatorInput
    createdQuotes?: QuoteCreateNestedManyWithoutCreatorInput
    createdInvoices?: InvoiceCreateNestedManyWithoutCreatorInput
    createdPayments?: PaymentCreateNestedManyWithoutCreatorInput
    serviceApprovals?: QuoteCreateNestedManyWithoutServiceManagerInput
    dgApprovals?: QuoteCreateNestedManyWithoutDgApproverInput
    quoteApprovals?: QuoteApprovalCreateNestedManyWithoutApproverInput
    createdExpenses?: ExpenseCreateNestedManyWithoutCreatorInput
    accountingEntries?: AccountingEntryCreateNestedManyWithoutCreatorInput
    cashFlowEntries?: CashFlowCreateNestedManyWithoutCreatorInput
    createdReminders?: ReminderCreateNestedManyWithoutCreatorInput
    createdRecurringInvoices?: RecurringInvoiceCreateNestedManyWithoutCreatorInput
    employee?: EmployeeCreateNestedOneWithoutUserInput
    leaveApprovals?: LeaveRequestCreateNestedManyWithoutApprovedByInput
    assignedProspects?: ProspectCreateNestedManyWithoutAssignedUserInput
    createdProspects?: ProspectCreateNestedManyWithoutCreatorInput
    createdProspectActivities?: ProspectActivityCreateNestedManyWithoutCreatorInput
    technicien?: TechnicienCreateNestedOneWithoutUtilisateurInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: number
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    serviceId?: number | null
    isActive?: boolean
    lastLogin?: Date | string | null
    preferences?: string | null
    permissions?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdCustomers?: CustomerUncheckedCreateNestedManyWithoutCreatorInput
    createdQuotes?: QuoteUncheckedCreateNestedManyWithoutCreatorInput
    createdInvoices?: InvoiceUncheckedCreateNestedManyWithoutCreatorInput
    createdPayments?: PaymentUncheckedCreateNestedManyWithoutCreatorInput
    serviceApprovals?: QuoteUncheckedCreateNestedManyWithoutServiceManagerInput
    dgApprovals?: QuoteUncheckedCreateNestedManyWithoutDgApproverInput
    quoteApprovals?: QuoteApprovalUncheckedCreateNestedManyWithoutApproverInput
    createdExpenses?: ExpenseUncheckedCreateNestedManyWithoutCreatorInput
    accountingEntries?: AccountingEntryUncheckedCreateNestedManyWithoutCreatorInput
    cashFlowEntries?: CashFlowUncheckedCreateNestedManyWithoutCreatorInput
    createdReminders?: ReminderUncheckedCreateNestedManyWithoutCreatorInput
    createdRecurringInvoices?: RecurringInvoiceUncheckedCreateNestedManyWithoutCreatorInput
    employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    leaveApprovals?: LeaveRequestUncheckedCreateNestedManyWithoutApprovedByInput
    assignedProspects?: ProspectUncheckedCreateNestedManyWithoutAssignedUserInput
    createdProspects?: ProspectUncheckedCreateNestedManyWithoutCreatorInput
    createdProspectActivities?: ProspectActivityUncheckedCreateNestedManyWithoutCreatorInput
    technicien?: TechnicienUncheckedCreateNestedOneWithoutUtilisateurInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneWithoutUsersNestedInput
    createdCustomers?: CustomerUpdateManyWithoutCreatorNestedInput
    createdQuotes?: QuoteUpdateManyWithoutCreatorNestedInput
    createdInvoices?: InvoiceUpdateManyWithoutCreatorNestedInput
    createdPayments?: PaymentUpdateManyWithoutCreatorNestedInput
    serviceApprovals?: QuoteUpdateManyWithoutServiceManagerNestedInput
    dgApprovals?: QuoteUpdateManyWithoutDgApproverNestedInput
    quoteApprovals?: QuoteApprovalUpdateManyWithoutApproverNestedInput
    createdExpenses?: ExpenseUpdateManyWithoutCreatorNestedInput
    accountingEntries?: AccountingEntryUpdateManyWithoutCreatorNestedInput
    cashFlowEntries?: CashFlowUpdateManyWithoutCreatorNestedInput
    createdReminders?: ReminderUpdateManyWithoutCreatorNestedInput
    createdRecurringInvoices?: RecurringInvoiceUpdateManyWithoutCreatorNestedInput
    employee?: EmployeeUpdateOneWithoutUserNestedInput
    leaveApprovals?: LeaveRequestUpdateManyWithoutApprovedByNestedInput
    assignedProspects?: ProspectUpdateManyWithoutAssignedUserNestedInput
    createdProspects?: ProspectUpdateManyWithoutCreatorNestedInput
    createdProspectActivities?: ProspectActivityUpdateManyWithoutCreatorNestedInput
    technicien?: TechnicienUpdateOneWithoutUtilisateurNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    serviceId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdCustomers?: CustomerUncheckedUpdateManyWithoutCreatorNestedInput
    createdQuotes?: QuoteUncheckedUpdateManyWithoutCreatorNestedInput
    createdInvoices?: InvoiceUncheckedUpdateManyWithoutCreatorNestedInput
    createdPayments?: PaymentUncheckedUpdateManyWithoutCreatorNestedInput
    serviceApprovals?: QuoteUncheckedUpdateManyWithoutServiceManagerNestedInput
    dgApprovals?: QuoteUncheckedUpdateManyWithoutDgApproverNestedInput
    quoteApprovals?: QuoteApprovalUncheckedUpdateManyWithoutApproverNestedInput
    createdExpenses?: ExpenseUncheckedUpdateManyWithoutCreatorNestedInput
    accountingEntries?: AccountingEntryUncheckedUpdateManyWithoutCreatorNestedInput
    cashFlowEntries?: CashFlowUncheckedUpdateManyWithoutCreatorNestedInput
    createdReminders?: ReminderUncheckedUpdateManyWithoutCreatorNestedInput
    createdRecurringInvoices?: RecurringInvoiceUncheckedUpdateManyWithoutCreatorNestedInput
    employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    leaveApprovals?: LeaveRequestUncheckedUpdateManyWithoutApprovedByNestedInput
    assignedProspects?: ProspectUncheckedUpdateManyWithoutAssignedUserNestedInput
    createdProspects?: ProspectUncheckedUpdateManyWithoutCreatorNestedInput
    createdProspectActivities?: ProspectActivityUncheckedUpdateManyWithoutCreatorNestedInput
    technicien?: TechnicienUncheckedUpdateOneWithoutUtilisateurNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ServiceCreateWithoutEmployeesInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutServiceInput
    customers?: CustomerCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutEmployeesInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutServiceInput
    customers?: CustomerUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutEmployeesInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutEmployeesInput, ServiceUncheckedCreateWithoutEmployeesInput>
  }

  export type UserCreateWithoutEmployeeInput = {
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    preferences?: string | null
    permissions?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    service?: ServiceCreateNestedOneWithoutUsersInput
    createdCustomers?: CustomerCreateNestedManyWithoutCreatorInput
    createdQuotes?: QuoteCreateNestedManyWithoutCreatorInput
    createdInvoices?: InvoiceCreateNestedManyWithoutCreatorInput
    createdPayments?: PaymentCreateNestedManyWithoutCreatorInput
    serviceApprovals?: QuoteCreateNestedManyWithoutServiceManagerInput
    dgApprovals?: QuoteCreateNestedManyWithoutDgApproverInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    quoteApprovals?: QuoteApprovalCreateNestedManyWithoutApproverInput
    createdExpenses?: ExpenseCreateNestedManyWithoutCreatorInput
    accountingEntries?: AccountingEntryCreateNestedManyWithoutCreatorInput
    cashFlowEntries?: CashFlowCreateNestedManyWithoutCreatorInput
    createdReminders?: ReminderCreateNestedManyWithoutCreatorInput
    createdRecurringInvoices?: RecurringInvoiceCreateNestedManyWithoutCreatorInput
    leaveApprovals?: LeaveRequestCreateNestedManyWithoutApprovedByInput
    assignedProspects?: ProspectCreateNestedManyWithoutAssignedUserInput
    createdProspects?: ProspectCreateNestedManyWithoutCreatorInput
    createdProspectActivities?: ProspectActivityCreateNestedManyWithoutCreatorInput
    technicien?: TechnicienCreateNestedOneWithoutUtilisateurInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEmployeeInput = {
    id?: number
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    serviceId?: number | null
    isActive?: boolean
    lastLogin?: Date | string | null
    preferences?: string | null
    permissions?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdCustomers?: CustomerUncheckedCreateNestedManyWithoutCreatorInput
    createdQuotes?: QuoteUncheckedCreateNestedManyWithoutCreatorInput
    createdInvoices?: InvoiceUncheckedCreateNestedManyWithoutCreatorInput
    createdPayments?: PaymentUncheckedCreateNestedManyWithoutCreatorInput
    serviceApprovals?: QuoteUncheckedCreateNestedManyWithoutServiceManagerInput
    dgApprovals?: QuoteUncheckedCreateNestedManyWithoutDgApproverInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    quoteApprovals?: QuoteApprovalUncheckedCreateNestedManyWithoutApproverInput
    createdExpenses?: ExpenseUncheckedCreateNestedManyWithoutCreatorInput
    accountingEntries?: AccountingEntryUncheckedCreateNestedManyWithoutCreatorInput
    cashFlowEntries?: CashFlowUncheckedCreateNestedManyWithoutCreatorInput
    createdReminders?: ReminderUncheckedCreateNestedManyWithoutCreatorInput
    createdRecurringInvoices?: RecurringInvoiceUncheckedCreateNestedManyWithoutCreatorInput
    leaveApprovals?: LeaveRequestUncheckedCreateNestedManyWithoutApprovedByInput
    assignedProspects?: ProspectUncheckedCreateNestedManyWithoutAssignedUserInput
    createdProspects?: ProspectUncheckedCreateNestedManyWithoutCreatorInput
    createdProspectActivities?: ProspectActivityUncheckedCreateNestedManyWithoutCreatorInput
    technicien?: TechnicienUncheckedCreateNestedOneWithoutUtilisateurInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEmployeeInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEmployeeInput, UserUncheckedCreateWithoutEmployeeInput>
  }

  export type ContractCreateWithoutEmployeeInput = {
    contractType: $Enums.ContractType
    startDate: Date | string
    endDate?: Date | string | null
    baseSalary: number
    workingHours: number
    benefits?: string | null
    terms?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContractUncheckedCreateWithoutEmployeeInput = {
    id?: number
    contractType: $Enums.ContractType
    startDate: Date | string
    endDate?: Date | string | null
    baseSalary: number
    workingHours: number
    benefits?: string | null
    terms?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContractCreateOrConnectWithoutEmployeeInput = {
    where: ContractWhereUniqueInput
    create: XOR<ContractCreateWithoutEmployeeInput, ContractUncheckedCreateWithoutEmployeeInput>
  }

  export type ContractCreateManyEmployeeInputEnvelope = {
    data: ContractCreateManyEmployeeInput | ContractCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type SalaryCreateWithoutEmployeeInput = {
    paymentDate: Date | string
    workingDays?: number
    baseSalary: number
    overtime?: number
    bonuses?: number
    allowances?: number
    paidLeave?: number
    grossSalary: number
    socialContributions?: number
    cnpsEmployee?: number
    cnamEmployee?: number
    fdfpEmployee?: number
    taxes?: number
    nonTaxableAmount?: number
    otherDeductions?: number
    loanDeductions?: number
    totalDeductions: number
    netSalary: number
    status?: $Enums.SalaryStatus
    paymentMethod?: $Enums.PaymentMethod | null
    reference?: string | null
    notes?: string | null
    createdAt?: Date | string
    loanPayments?: LoanPaymentCreateNestedManyWithoutSalaryInput
  }

  export type SalaryUncheckedCreateWithoutEmployeeInput = {
    id?: number
    paymentDate: Date | string
    workingDays?: number
    baseSalary: number
    overtime?: number
    bonuses?: number
    allowances?: number
    paidLeave?: number
    grossSalary: number
    socialContributions?: number
    cnpsEmployee?: number
    cnamEmployee?: number
    fdfpEmployee?: number
    taxes?: number
    nonTaxableAmount?: number
    otherDeductions?: number
    loanDeductions?: number
    totalDeductions: number
    netSalary: number
    status?: $Enums.SalaryStatus
    paymentMethod?: $Enums.PaymentMethod | null
    reference?: string | null
    notes?: string | null
    createdAt?: Date | string
    loanPayments?: LoanPaymentUncheckedCreateNestedManyWithoutSalaryInput
  }

  export type SalaryCreateOrConnectWithoutEmployeeInput = {
    where: SalaryWhereUniqueInput
    create: XOR<SalaryCreateWithoutEmployeeInput, SalaryUncheckedCreateWithoutEmployeeInput>
  }

  export type SalaryCreateManyEmployeeInputEnvelope = {
    data: SalaryCreateManyEmployeeInput | SalaryCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type LeaveRequestCreateWithoutEmployeeInput = {
    leaveType: $Enums.LeaveType
    startDate: Date | string
    endDate: Date | string
    days: number
    reason: string
    notes?: string | null
    status?: $Enums.LeaveStatus
    approvedAt?: Date | string | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedBy?: UserCreateNestedOneWithoutLeaveApprovalsInput
  }

  export type LeaveRequestUncheckedCreateWithoutEmployeeInput = {
    id?: number
    leaveType: $Enums.LeaveType
    startDate: Date | string
    endDate: Date | string
    days: number
    reason: string
    notes?: string | null
    status?: $Enums.LeaveStatus
    approvedById?: number | null
    approvedAt?: Date | string | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaveRequestCreateOrConnectWithoutEmployeeInput = {
    where: LeaveRequestWhereUniqueInput
    create: XOR<LeaveRequestCreateWithoutEmployeeInput, LeaveRequestUncheckedCreateWithoutEmployeeInput>
  }

  export type LeaveRequestCreateManyEmployeeInputEnvelope = {
    data: LeaveRequestCreateManyEmployeeInput | LeaveRequestCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type LoanCreateWithoutEmployeeInput = {
    loanNumber: string
    amount: number
    interestRate?: number
    monthlyPayment: number
    remainingAmount: number
    startDate: Date | string
    endDate: Date | string
    purpose?: string | null
    status?: $Enums.LoanStatus
    notes?: string | null
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: LoanPaymentCreateNestedManyWithoutLoanInput
  }

  export type LoanUncheckedCreateWithoutEmployeeInput = {
    id?: number
    loanNumber: string
    amount: number
    interestRate?: number
    monthlyPayment: number
    remainingAmount: number
    startDate: Date | string
    endDate: Date | string
    purpose?: string | null
    status?: $Enums.LoanStatus
    notes?: string | null
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: LoanPaymentUncheckedCreateNestedManyWithoutLoanInput
  }

  export type LoanCreateOrConnectWithoutEmployeeInput = {
    where: LoanWhereUniqueInput
    create: XOR<LoanCreateWithoutEmployeeInput, LoanUncheckedCreateWithoutEmployeeInput>
  }

  export type LoanCreateManyEmployeeInputEnvelope = {
    data: LoanCreateManyEmployeeInput | LoanCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type ServiceUpsertWithoutEmployeesInput = {
    update: XOR<ServiceUpdateWithoutEmployeesInput, ServiceUncheckedUpdateWithoutEmployeesInput>
    create: XOR<ServiceCreateWithoutEmployeesInput, ServiceUncheckedCreateWithoutEmployeesInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutEmployeesInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutEmployeesInput, ServiceUncheckedUpdateWithoutEmployeesInput>
  }

  export type ServiceUpdateWithoutEmployeesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutServiceNestedInput
    customers?: CustomerUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutEmployeesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutServiceNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type UserUpsertWithoutEmployeeInput = {
    update: XOR<UserUpdateWithoutEmployeeInput, UserUncheckedUpdateWithoutEmployeeInput>
    create: XOR<UserCreateWithoutEmployeeInput, UserUncheckedCreateWithoutEmployeeInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEmployeeInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEmployeeInput, UserUncheckedUpdateWithoutEmployeeInput>
  }

  export type UserUpdateWithoutEmployeeInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneWithoutUsersNestedInput
    createdCustomers?: CustomerUpdateManyWithoutCreatorNestedInput
    createdQuotes?: QuoteUpdateManyWithoutCreatorNestedInput
    createdInvoices?: InvoiceUpdateManyWithoutCreatorNestedInput
    createdPayments?: PaymentUpdateManyWithoutCreatorNestedInput
    serviceApprovals?: QuoteUpdateManyWithoutServiceManagerNestedInput
    dgApprovals?: QuoteUpdateManyWithoutDgApproverNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    quoteApprovals?: QuoteApprovalUpdateManyWithoutApproverNestedInput
    createdExpenses?: ExpenseUpdateManyWithoutCreatorNestedInput
    accountingEntries?: AccountingEntryUpdateManyWithoutCreatorNestedInput
    cashFlowEntries?: CashFlowUpdateManyWithoutCreatorNestedInput
    createdReminders?: ReminderUpdateManyWithoutCreatorNestedInput
    createdRecurringInvoices?: RecurringInvoiceUpdateManyWithoutCreatorNestedInput
    leaveApprovals?: LeaveRequestUpdateManyWithoutApprovedByNestedInput
    assignedProspects?: ProspectUpdateManyWithoutAssignedUserNestedInput
    createdProspects?: ProspectUpdateManyWithoutCreatorNestedInput
    createdProspectActivities?: ProspectActivityUpdateManyWithoutCreatorNestedInput
    technicien?: TechnicienUpdateOneWithoutUtilisateurNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    serviceId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdCustomers?: CustomerUncheckedUpdateManyWithoutCreatorNestedInput
    createdQuotes?: QuoteUncheckedUpdateManyWithoutCreatorNestedInput
    createdInvoices?: InvoiceUncheckedUpdateManyWithoutCreatorNestedInput
    createdPayments?: PaymentUncheckedUpdateManyWithoutCreatorNestedInput
    serviceApprovals?: QuoteUncheckedUpdateManyWithoutServiceManagerNestedInput
    dgApprovals?: QuoteUncheckedUpdateManyWithoutDgApproverNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    quoteApprovals?: QuoteApprovalUncheckedUpdateManyWithoutApproverNestedInput
    createdExpenses?: ExpenseUncheckedUpdateManyWithoutCreatorNestedInput
    accountingEntries?: AccountingEntryUncheckedUpdateManyWithoutCreatorNestedInput
    cashFlowEntries?: CashFlowUncheckedUpdateManyWithoutCreatorNestedInput
    createdReminders?: ReminderUncheckedUpdateManyWithoutCreatorNestedInput
    createdRecurringInvoices?: RecurringInvoiceUncheckedUpdateManyWithoutCreatorNestedInput
    leaveApprovals?: LeaveRequestUncheckedUpdateManyWithoutApprovedByNestedInput
    assignedProspects?: ProspectUncheckedUpdateManyWithoutAssignedUserNestedInput
    createdProspects?: ProspectUncheckedUpdateManyWithoutCreatorNestedInput
    createdProspectActivities?: ProspectActivityUncheckedUpdateManyWithoutCreatorNestedInput
    technicien?: TechnicienUncheckedUpdateOneWithoutUtilisateurNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ContractUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: ContractWhereUniqueInput
    update: XOR<ContractUpdateWithoutEmployeeInput, ContractUncheckedUpdateWithoutEmployeeInput>
    create: XOR<ContractCreateWithoutEmployeeInput, ContractUncheckedCreateWithoutEmployeeInput>
  }

  export type ContractUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: ContractWhereUniqueInput
    data: XOR<ContractUpdateWithoutEmployeeInput, ContractUncheckedUpdateWithoutEmployeeInput>
  }

  export type ContractUpdateManyWithWhereWithoutEmployeeInput = {
    where: ContractScalarWhereInput
    data: XOR<ContractUpdateManyMutationInput, ContractUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type ContractScalarWhereInput = {
    AND?: ContractScalarWhereInput | ContractScalarWhereInput[]
    OR?: ContractScalarWhereInput[]
    NOT?: ContractScalarWhereInput | ContractScalarWhereInput[]
    id?: IntFilter<"Contract"> | number
    employeeId?: IntFilter<"Contract"> | number
    contractType?: EnumContractTypeFilter<"Contract"> | $Enums.ContractType
    startDate?: DateTimeFilter<"Contract"> | Date | string
    endDate?: DateTimeNullableFilter<"Contract"> | Date | string | null
    baseSalary?: FloatFilter<"Contract"> | number
    workingHours?: FloatFilter<"Contract"> | number
    benefits?: StringNullableFilter<"Contract"> | string | null
    terms?: StringNullableFilter<"Contract"> | string | null
    isActive?: BoolFilter<"Contract"> | boolean
    createdAt?: DateTimeFilter<"Contract"> | Date | string
    updatedAt?: DateTimeFilter<"Contract"> | Date | string
  }

  export type SalaryUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: SalaryWhereUniqueInput
    update: XOR<SalaryUpdateWithoutEmployeeInput, SalaryUncheckedUpdateWithoutEmployeeInput>
    create: XOR<SalaryCreateWithoutEmployeeInput, SalaryUncheckedCreateWithoutEmployeeInput>
  }

  export type SalaryUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: SalaryWhereUniqueInput
    data: XOR<SalaryUpdateWithoutEmployeeInput, SalaryUncheckedUpdateWithoutEmployeeInput>
  }

  export type SalaryUpdateManyWithWhereWithoutEmployeeInput = {
    where: SalaryScalarWhereInput
    data: XOR<SalaryUpdateManyMutationInput, SalaryUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type SalaryScalarWhereInput = {
    AND?: SalaryScalarWhereInput | SalaryScalarWhereInput[]
    OR?: SalaryScalarWhereInput[]
    NOT?: SalaryScalarWhereInput | SalaryScalarWhereInput[]
    id?: IntFilter<"Salary"> | number
    employeeId?: IntFilter<"Salary"> | number
    paymentDate?: DateTimeFilter<"Salary"> | Date | string
    workingDays?: IntFilter<"Salary"> | number
    baseSalary?: FloatFilter<"Salary"> | number
    overtime?: FloatFilter<"Salary"> | number
    bonuses?: FloatFilter<"Salary"> | number
    allowances?: FloatFilter<"Salary"> | number
    paidLeave?: FloatFilter<"Salary"> | number
    grossSalary?: FloatFilter<"Salary"> | number
    socialContributions?: FloatFilter<"Salary"> | number
    cnpsEmployee?: FloatFilter<"Salary"> | number
    cnamEmployee?: FloatFilter<"Salary"> | number
    fdfpEmployee?: FloatFilter<"Salary"> | number
    taxes?: FloatFilter<"Salary"> | number
    nonTaxableAmount?: FloatFilter<"Salary"> | number
    otherDeductions?: FloatFilter<"Salary"> | number
    loanDeductions?: FloatFilter<"Salary"> | number
    totalDeductions?: FloatFilter<"Salary"> | number
    netSalary?: FloatFilter<"Salary"> | number
    status?: EnumSalaryStatusFilter<"Salary"> | $Enums.SalaryStatus
    paymentMethod?: EnumPaymentMethodNullableFilter<"Salary"> | $Enums.PaymentMethod | null
    reference?: StringNullableFilter<"Salary"> | string | null
    notes?: StringNullableFilter<"Salary"> | string | null
    createdAt?: DateTimeFilter<"Salary"> | Date | string
  }

  export type LeaveRequestUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: LeaveRequestWhereUniqueInput
    update: XOR<LeaveRequestUpdateWithoutEmployeeInput, LeaveRequestUncheckedUpdateWithoutEmployeeInput>
    create: XOR<LeaveRequestCreateWithoutEmployeeInput, LeaveRequestUncheckedCreateWithoutEmployeeInput>
  }

  export type LeaveRequestUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: LeaveRequestWhereUniqueInput
    data: XOR<LeaveRequestUpdateWithoutEmployeeInput, LeaveRequestUncheckedUpdateWithoutEmployeeInput>
  }

  export type LeaveRequestUpdateManyWithWhereWithoutEmployeeInput = {
    where: LeaveRequestScalarWhereInput
    data: XOR<LeaveRequestUpdateManyMutationInput, LeaveRequestUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type LoanUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: LoanWhereUniqueInput
    update: XOR<LoanUpdateWithoutEmployeeInput, LoanUncheckedUpdateWithoutEmployeeInput>
    create: XOR<LoanCreateWithoutEmployeeInput, LoanUncheckedCreateWithoutEmployeeInput>
  }

  export type LoanUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: LoanWhereUniqueInput
    data: XOR<LoanUpdateWithoutEmployeeInput, LoanUncheckedUpdateWithoutEmployeeInput>
  }

  export type LoanUpdateManyWithWhereWithoutEmployeeInput = {
    where: LoanScalarWhereInput
    data: XOR<LoanUpdateManyMutationInput, LoanUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type LoanScalarWhereInput = {
    AND?: LoanScalarWhereInput | LoanScalarWhereInput[]
    OR?: LoanScalarWhereInput[]
    NOT?: LoanScalarWhereInput | LoanScalarWhereInput[]
    id?: IntFilter<"Loan"> | number
    loanNumber?: StringFilter<"Loan"> | string
    employeeId?: IntFilter<"Loan"> | number
    amount?: FloatFilter<"Loan"> | number
    interestRate?: FloatFilter<"Loan"> | number
    monthlyPayment?: FloatFilter<"Loan"> | number
    remainingAmount?: FloatFilter<"Loan"> | number
    startDate?: DateTimeFilter<"Loan"> | Date | string
    endDate?: DateTimeFilter<"Loan"> | Date | string
    purpose?: StringNullableFilter<"Loan"> | string | null
    status?: EnumLoanStatusFilter<"Loan"> | $Enums.LoanStatus
    notes?: StringNullableFilter<"Loan"> | string | null
    createdBy?: IntFilter<"Loan"> | number
    createdAt?: DateTimeFilter<"Loan"> | Date | string
    updatedAt?: DateTimeFilter<"Loan"> | Date | string
  }

  export type EmployeeCreateWithoutContractsInput = {
    employeeNumber: string
    registrationNumber?: string | null
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    address?: string | null
    dateOfBirth: Date | string
    placeOfBirth?: string | null
    nationality?: string | null
    socialSecurityNumber?: string | null
    cnpsNumber?: string | null
    cnamNumber?: string | null
    bankAccount?: string | null
    emergencyContact?: string | null
    position: string
    department?: string | null
    category?: string | null
    level?: string | null
    manager?: string | null
    hireDate: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    service?: ServiceCreateNestedOneWithoutEmployeesInput
    user?: UserCreateNestedOneWithoutEmployeeInput
    salaries?: SalaryCreateNestedManyWithoutEmployeeInput
    leaveRequests?: LeaveRequestCreateNestedManyWithoutEmployeeInput
    loans?: LoanCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutContractsInput = {
    id?: number
    employeeNumber: string
    registrationNumber?: string | null
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    address?: string | null
    dateOfBirth: Date | string
    placeOfBirth?: string | null
    nationality?: string | null
    socialSecurityNumber?: string | null
    cnpsNumber?: string | null
    cnamNumber?: string | null
    bankAccount?: string | null
    emergencyContact?: string | null
    serviceId?: number | null
    position: string
    department?: string | null
    category?: string | null
    level?: string | null
    manager?: string | null
    hireDate: Date | string
    isActive?: boolean
    userId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    salaries?: SalaryUncheckedCreateNestedManyWithoutEmployeeInput
    leaveRequests?: LeaveRequestUncheckedCreateNestedManyWithoutEmployeeInput
    loans?: LoanUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutContractsInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutContractsInput, EmployeeUncheckedCreateWithoutContractsInput>
  }

  export type EmployeeUpsertWithoutContractsInput = {
    update: XOR<EmployeeUpdateWithoutContractsInput, EmployeeUncheckedUpdateWithoutContractsInput>
    create: XOR<EmployeeCreateWithoutContractsInput, EmployeeUncheckedCreateWithoutContractsInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutContractsInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutContractsInput, EmployeeUncheckedUpdateWithoutContractsInput>
  }

  export type EmployeeUpdateWithoutContractsInput = {
    employeeNumber?: StringFieldUpdateOperationsInput | string
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    placeOfBirth?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    socialSecurityNumber?: NullableStringFieldUpdateOperationsInput | string | null
    cnpsNumber?: NullableStringFieldUpdateOperationsInput | string | null
    cnamNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    position?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    manager?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneWithoutEmployeesNestedInput
    user?: UserUpdateOneWithoutEmployeeNestedInput
    salaries?: SalaryUpdateManyWithoutEmployeeNestedInput
    leaveRequests?: LeaveRequestUpdateManyWithoutEmployeeNestedInput
    loans?: LoanUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutContractsInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeNumber?: StringFieldUpdateOperationsInput | string
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    placeOfBirth?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    socialSecurityNumber?: NullableStringFieldUpdateOperationsInput | string | null
    cnpsNumber?: NullableStringFieldUpdateOperationsInput | string | null
    cnamNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: NullableIntFieldUpdateOperationsInput | number | null
    position?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    manager?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salaries?: SalaryUncheckedUpdateManyWithoutEmployeeNestedInput
    leaveRequests?: LeaveRequestUncheckedUpdateManyWithoutEmployeeNestedInput
    loans?: LoanUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeCreateWithoutSalariesInput = {
    employeeNumber: string
    registrationNumber?: string | null
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    address?: string | null
    dateOfBirth: Date | string
    placeOfBirth?: string | null
    nationality?: string | null
    socialSecurityNumber?: string | null
    cnpsNumber?: string | null
    cnamNumber?: string | null
    bankAccount?: string | null
    emergencyContact?: string | null
    position: string
    department?: string | null
    category?: string | null
    level?: string | null
    manager?: string | null
    hireDate: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    service?: ServiceCreateNestedOneWithoutEmployeesInput
    user?: UserCreateNestedOneWithoutEmployeeInput
    contracts?: ContractCreateNestedManyWithoutEmployeeInput
    leaveRequests?: LeaveRequestCreateNestedManyWithoutEmployeeInput
    loans?: LoanCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutSalariesInput = {
    id?: number
    employeeNumber: string
    registrationNumber?: string | null
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    address?: string | null
    dateOfBirth: Date | string
    placeOfBirth?: string | null
    nationality?: string | null
    socialSecurityNumber?: string | null
    cnpsNumber?: string | null
    cnamNumber?: string | null
    bankAccount?: string | null
    emergencyContact?: string | null
    serviceId?: number | null
    position: string
    department?: string | null
    category?: string | null
    level?: string | null
    manager?: string | null
    hireDate: Date | string
    isActive?: boolean
    userId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contracts?: ContractUncheckedCreateNestedManyWithoutEmployeeInput
    leaveRequests?: LeaveRequestUncheckedCreateNestedManyWithoutEmployeeInput
    loans?: LoanUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutSalariesInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutSalariesInput, EmployeeUncheckedCreateWithoutSalariesInput>
  }

  export type LoanPaymentCreateWithoutSalaryInput = {
    amount: number
    paymentDate: Date | string
    principal: number
    interest: number
    notes?: string | null
    createdAt?: Date | string
    loan: LoanCreateNestedOneWithoutPaymentsInput
  }

  export type LoanPaymentUncheckedCreateWithoutSalaryInput = {
    id?: number
    loanId: number
    amount: number
    paymentDate: Date | string
    principal: number
    interest: number
    notes?: string | null
    createdAt?: Date | string
  }

  export type LoanPaymentCreateOrConnectWithoutSalaryInput = {
    where: LoanPaymentWhereUniqueInput
    create: XOR<LoanPaymentCreateWithoutSalaryInput, LoanPaymentUncheckedCreateWithoutSalaryInput>
  }

  export type LoanPaymentCreateManySalaryInputEnvelope = {
    data: LoanPaymentCreateManySalaryInput | LoanPaymentCreateManySalaryInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeUpsertWithoutSalariesInput = {
    update: XOR<EmployeeUpdateWithoutSalariesInput, EmployeeUncheckedUpdateWithoutSalariesInput>
    create: XOR<EmployeeCreateWithoutSalariesInput, EmployeeUncheckedCreateWithoutSalariesInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutSalariesInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutSalariesInput, EmployeeUncheckedUpdateWithoutSalariesInput>
  }

  export type EmployeeUpdateWithoutSalariesInput = {
    employeeNumber?: StringFieldUpdateOperationsInput | string
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    placeOfBirth?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    socialSecurityNumber?: NullableStringFieldUpdateOperationsInput | string | null
    cnpsNumber?: NullableStringFieldUpdateOperationsInput | string | null
    cnamNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    position?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    manager?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneWithoutEmployeesNestedInput
    user?: UserUpdateOneWithoutEmployeeNestedInput
    contracts?: ContractUpdateManyWithoutEmployeeNestedInput
    leaveRequests?: LeaveRequestUpdateManyWithoutEmployeeNestedInput
    loans?: LoanUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutSalariesInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeNumber?: StringFieldUpdateOperationsInput | string
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    placeOfBirth?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    socialSecurityNumber?: NullableStringFieldUpdateOperationsInput | string | null
    cnpsNumber?: NullableStringFieldUpdateOperationsInput | string | null
    cnamNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: NullableIntFieldUpdateOperationsInput | number | null
    position?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    manager?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contracts?: ContractUncheckedUpdateManyWithoutEmployeeNestedInput
    leaveRequests?: LeaveRequestUncheckedUpdateManyWithoutEmployeeNestedInput
    loans?: LoanUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type LoanPaymentUpsertWithWhereUniqueWithoutSalaryInput = {
    where: LoanPaymentWhereUniqueInput
    update: XOR<LoanPaymentUpdateWithoutSalaryInput, LoanPaymentUncheckedUpdateWithoutSalaryInput>
    create: XOR<LoanPaymentCreateWithoutSalaryInput, LoanPaymentUncheckedCreateWithoutSalaryInput>
  }

  export type LoanPaymentUpdateWithWhereUniqueWithoutSalaryInput = {
    where: LoanPaymentWhereUniqueInput
    data: XOR<LoanPaymentUpdateWithoutSalaryInput, LoanPaymentUncheckedUpdateWithoutSalaryInput>
  }

  export type LoanPaymentUpdateManyWithWhereWithoutSalaryInput = {
    where: LoanPaymentScalarWhereInput
    data: XOR<LoanPaymentUpdateManyMutationInput, LoanPaymentUncheckedUpdateManyWithoutSalaryInput>
  }

  export type LoanPaymentScalarWhereInput = {
    AND?: LoanPaymentScalarWhereInput | LoanPaymentScalarWhereInput[]
    OR?: LoanPaymentScalarWhereInput[]
    NOT?: LoanPaymentScalarWhereInput | LoanPaymentScalarWhereInput[]
    id?: IntFilter<"LoanPayment"> | number
    loanId?: IntFilter<"LoanPayment"> | number
    salaryId?: IntNullableFilter<"LoanPayment"> | number | null
    amount?: FloatFilter<"LoanPayment"> | number
    paymentDate?: DateTimeFilter<"LoanPayment"> | Date | string
    principal?: FloatFilter<"LoanPayment"> | number
    interest?: FloatFilter<"LoanPayment"> | number
    notes?: StringNullableFilter<"LoanPayment"> | string | null
    createdAt?: DateTimeFilter<"LoanPayment"> | Date | string
  }

  export type LoanCreateWithoutPaymentsInput = {
    loanNumber: string
    amount: number
    interestRate?: number
    monthlyPayment: number
    remainingAmount: number
    startDate: Date | string
    endDate: Date | string
    purpose?: string | null
    status?: $Enums.LoanStatus
    notes?: string | null
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutLoansInput
  }

  export type LoanUncheckedCreateWithoutPaymentsInput = {
    id?: number
    loanNumber: string
    employeeId: number
    amount: number
    interestRate?: number
    monthlyPayment: number
    remainingAmount: number
    startDate: Date | string
    endDate: Date | string
    purpose?: string | null
    status?: $Enums.LoanStatus
    notes?: string | null
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LoanCreateOrConnectWithoutPaymentsInput = {
    where: LoanWhereUniqueInput
    create: XOR<LoanCreateWithoutPaymentsInput, LoanUncheckedCreateWithoutPaymentsInput>
  }

  export type SalaryCreateWithoutLoanPaymentsInput = {
    paymentDate: Date | string
    workingDays?: number
    baseSalary: number
    overtime?: number
    bonuses?: number
    allowances?: number
    paidLeave?: number
    grossSalary: number
    socialContributions?: number
    cnpsEmployee?: number
    cnamEmployee?: number
    fdfpEmployee?: number
    taxes?: number
    nonTaxableAmount?: number
    otherDeductions?: number
    loanDeductions?: number
    totalDeductions: number
    netSalary: number
    status?: $Enums.SalaryStatus
    paymentMethod?: $Enums.PaymentMethod | null
    reference?: string | null
    notes?: string | null
    createdAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutSalariesInput
  }

  export type SalaryUncheckedCreateWithoutLoanPaymentsInput = {
    id?: number
    employeeId: number
    paymentDate: Date | string
    workingDays?: number
    baseSalary: number
    overtime?: number
    bonuses?: number
    allowances?: number
    paidLeave?: number
    grossSalary: number
    socialContributions?: number
    cnpsEmployee?: number
    cnamEmployee?: number
    fdfpEmployee?: number
    taxes?: number
    nonTaxableAmount?: number
    otherDeductions?: number
    loanDeductions?: number
    totalDeductions: number
    netSalary: number
    status?: $Enums.SalaryStatus
    paymentMethod?: $Enums.PaymentMethod | null
    reference?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type SalaryCreateOrConnectWithoutLoanPaymentsInput = {
    where: SalaryWhereUniqueInput
    create: XOR<SalaryCreateWithoutLoanPaymentsInput, SalaryUncheckedCreateWithoutLoanPaymentsInput>
  }

  export type LoanUpsertWithoutPaymentsInput = {
    update: XOR<LoanUpdateWithoutPaymentsInput, LoanUncheckedUpdateWithoutPaymentsInput>
    create: XOR<LoanCreateWithoutPaymentsInput, LoanUncheckedCreateWithoutPaymentsInput>
    where?: LoanWhereInput
  }

  export type LoanUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: LoanWhereInput
    data: XOR<LoanUpdateWithoutPaymentsInput, LoanUncheckedUpdateWithoutPaymentsInput>
  }

  export type LoanUpdateWithoutPaymentsInput = {
    loanNumber?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    interestRate?: FloatFieldUpdateOperationsInput | number
    monthlyPayment?: FloatFieldUpdateOperationsInput | number
    remainingAmount?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLoanStatusFieldUpdateOperationsInput | $Enums.LoanStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutLoansNestedInput
  }

  export type LoanUncheckedUpdateWithoutPaymentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    loanNumber?: StringFieldUpdateOperationsInput | string
    employeeId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    interestRate?: FloatFieldUpdateOperationsInput | number
    monthlyPayment?: FloatFieldUpdateOperationsInput | number
    remainingAmount?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLoanStatusFieldUpdateOperationsInput | $Enums.LoanStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryUpsertWithoutLoanPaymentsInput = {
    update: XOR<SalaryUpdateWithoutLoanPaymentsInput, SalaryUncheckedUpdateWithoutLoanPaymentsInput>
    create: XOR<SalaryCreateWithoutLoanPaymentsInput, SalaryUncheckedCreateWithoutLoanPaymentsInput>
    where?: SalaryWhereInput
  }

  export type SalaryUpdateToOneWithWhereWithoutLoanPaymentsInput = {
    where?: SalaryWhereInput
    data: XOR<SalaryUpdateWithoutLoanPaymentsInput, SalaryUncheckedUpdateWithoutLoanPaymentsInput>
  }

  export type SalaryUpdateWithoutLoanPaymentsInput = {
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    workingDays?: IntFieldUpdateOperationsInput | number
    baseSalary?: FloatFieldUpdateOperationsInput | number
    overtime?: FloatFieldUpdateOperationsInput | number
    bonuses?: FloatFieldUpdateOperationsInput | number
    allowances?: FloatFieldUpdateOperationsInput | number
    paidLeave?: FloatFieldUpdateOperationsInput | number
    grossSalary?: FloatFieldUpdateOperationsInput | number
    socialContributions?: FloatFieldUpdateOperationsInput | number
    cnpsEmployee?: FloatFieldUpdateOperationsInput | number
    cnamEmployee?: FloatFieldUpdateOperationsInput | number
    fdfpEmployee?: FloatFieldUpdateOperationsInput | number
    taxes?: FloatFieldUpdateOperationsInput | number
    nonTaxableAmount?: FloatFieldUpdateOperationsInput | number
    otherDeductions?: FloatFieldUpdateOperationsInput | number
    loanDeductions?: FloatFieldUpdateOperationsInput | number
    totalDeductions?: FloatFieldUpdateOperationsInput | number
    netSalary?: FloatFieldUpdateOperationsInput | number
    status?: EnumSalaryStatusFieldUpdateOperationsInput | $Enums.SalaryStatus
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutSalariesNestedInput
  }

  export type SalaryUncheckedUpdateWithoutLoanPaymentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    workingDays?: IntFieldUpdateOperationsInput | number
    baseSalary?: FloatFieldUpdateOperationsInput | number
    overtime?: FloatFieldUpdateOperationsInput | number
    bonuses?: FloatFieldUpdateOperationsInput | number
    allowances?: FloatFieldUpdateOperationsInput | number
    paidLeave?: FloatFieldUpdateOperationsInput | number
    grossSalary?: FloatFieldUpdateOperationsInput | number
    socialContributions?: FloatFieldUpdateOperationsInput | number
    cnpsEmployee?: FloatFieldUpdateOperationsInput | number
    cnamEmployee?: FloatFieldUpdateOperationsInput | number
    fdfpEmployee?: FloatFieldUpdateOperationsInput | number
    taxes?: FloatFieldUpdateOperationsInput | number
    nonTaxableAmount?: FloatFieldUpdateOperationsInput | number
    otherDeductions?: FloatFieldUpdateOperationsInput | number
    loanDeductions?: FloatFieldUpdateOperationsInput | number
    totalDeductions?: FloatFieldUpdateOperationsInput | number
    netSalary?: FloatFieldUpdateOperationsInput | number
    status?: EnumSalaryStatusFieldUpdateOperationsInput | $Enums.SalaryStatus
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeCreateWithoutLeaveRequestsInput = {
    employeeNumber: string
    registrationNumber?: string | null
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    address?: string | null
    dateOfBirth: Date | string
    placeOfBirth?: string | null
    nationality?: string | null
    socialSecurityNumber?: string | null
    cnpsNumber?: string | null
    cnamNumber?: string | null
    bankAccount?: string | null
    emergencyContact?: string | null
    position: string
    department?: string | null
    category?: string | null
    level?: string | null
    manager?: string | null
    hireDate: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    service?: ServiceCreateNestedOneWithoutEmployeesInput
    user?: UserCreateNestedOneWithoutEmployeeInput
    contracts?: ContractCreateNestedManyWithoutEmployeeInput
    salaries?: SalaryCreateNestedManyWithoutEmployeeInput
    loans?: LoanCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutLeaveRequestsInput = {
    id?: number
    employeeNumber: string
    registrationNumber?: string | null
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    address?: string | null
    dateOfBirth: Date | string
    placeOfBirth?: string | null
    nationality?: string | null
    socialSecurityNumber?: string | null
    cnpsNumber?: string | null
    cnamNumber?: string | null
    bankAccount?: string | null
    emergencyContact?: string | null
    serviceId?: number | null
    position: string
    department?: string | null
    category?: string | null
    level?: string | null
    manager?: string | null
    hireDate: Date | string
    isActive?: boolean
    userId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contracts?: ContractUncheckedCreateNestedManyWithoutEmployeeInput
    salaries?: SalaryUncheckedCreateNestedManyWithoutEmployeeInput
    loans?: LoanUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutLeaveRequestsInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutLeaveRequestsInput, EmployeeUncheckedCreateWithoutLeaveRequestsInput>
  }

  export type UserCreateWithoutLeaveApprovalsInput = {
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    preferences?: string | null
    permissions?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    service?: ServiceCreateNestedOneWithoutUsersInput
    createdCustomers?: CustomerCreateNestedManyWithoutCreatorInput
    createdQuotes?: QuoteCreateNestedManyWithoutCreatorInput
    createdInvoices?: InvoiceCreateNestedManyWithoutCreatorInput
    createdPayments?: PaymentCreateNestedManyWithoutCreatorInput
    serviceApprovals?: QuoteCreateNestedManyWithoutServiceManagerInput
    dgApprovals?: QuoteCreateNestedManyWithoutDgApproverInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    quoteApprovals?: QuoteApprovalCreateNestedManyWithoutApproverInput
    createdExpenses?: ExpenseCreateNestedManyWithoutCreatorInput
    accountingEntries?: AccountingEntryCreateNestedManyWithoutCreatorInput
    cashFlowEntries?: CashFlowCreateNestedManyWithoutCreatorInput
    createdReminders?: ReminderCreateNestedManyWithoutCreatorInput
    createdRecurringInvoices?: RecurringInvoiceCreateNestedManyWithoutCreatorInput
    employee?: EmployeeCreateNestedOneWithoutUserInput
    assignedProspects?: ProspectCreateNestedManyWithoutAssignedUserInput
    createdProspects?: ProspectCreateNestedManyWithoutCreatorInput
    createdProspectActivities?: ProspectActivityCreateNestedManyWithoutCreatorInput
    technicien?: TechnicienCreateNestedOneWithoutUtilisateurInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLeaveApprovalsInput = {
    id?: number
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    serviceId?: number | null
    isActive?: boolean
    lastLogin?: Date | string | null
    preferences?: string | null
    permissions?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdCustomers?: CustomerUncheckedCreateNestedManyWithoutCreatorInput
    createdQuotes?: QuoteUncheckedCreateNestedManyWithoutCreatorInput
    createdInvoices?: InvoiceUncheckedCreateNestedManyWithoutCreatorInput
    createdPayments?: PaymentUncheckedCreateNestedManyWithoutCreatorInput
    serviceApprovals?: QuoteUncheckedCreateNestedManyWithoutServiceManagerInput
    dgApprovals?: QuoteUncheckedCreateNestedManyWithoutDgApproverInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    quoteApprovals?: QuoteApprovalUncheckedCreateNestedManyWithoutApproverInput
    createdExpenses?: ExpenseUncheckedCreateNestedManyWithoutCreatorInput
    accountingEntries?: AccountingEntryUncheckedCreateNestedManyWithoutCreatorInput
    cashFlowEntries?: CashFlowUncheckedCreateNestedManyWithoutCreatorInput
    createdReminders?: ReminderUncheckedCreateNestedManyWithoutCreatorInput
    createdRecurringInvoices?: RecurringInvoiceUncheckedCreateNestedManyWithoutCreatorInput
    employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    assignedProspects?: ProspectUncheckedCreateNestedManyWithoutAssignedUserInput
    createdProspects?: ProspectUncheckedCreateNestedManyWithoutCreatorInput
    createdProspectActivities?: ProspectActivityUncheckedCreateNestedManyWithoutCreatorInput
    technicien?: TechnicienUncheckedCreateNestedOneWithoutUtilisateurInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLeaveApprovalsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLeaveApprovalsInput, UserUncheckedCreateWithoutLeaveApprovalsInput>
  }

  export type EmployeeUpsertWithoutLeaveRequestsInput = {
    update: XOR<EmployeeUpdateWithoutLeaveRequestsInput, EmployeeUncheckedUpdateWithoutLeaveRequestsInput>
    create: XOR<EmployeeCreateWithoutLeaveRequestsInput, EmployeeUncheckedCreateWithoutLeaveRequestsInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutLeaveRequestsInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutLeaveRequestsInput, EmployeeUncheckedUpdateWithoutLeaveRequestsInput>
  }

  export type EmployeeUpdateWithoutLeaveRequestsInput = {
    employeeNumber?: StringFieldUpdateOperationsInput | string
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    placeOfBirth?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    socialSecurityNumber?: NullableStringFieldUpdateOperationsInput | string | null
    cnpsNumber?: NullableStringFieldUpdateOperationsInput | string | null
    cnamNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    position?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    manager?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneWithoutEmployeesNestedInput
    user?: UserUpdateOneWithoutEmployeeNestedInput
    contracts?: ContractUpdateManyWithoutEmployeeNestedInput
    salaries?: SalaryUpdateManyWithoutEmployeeNestedInput
    loans?: LoanUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutLeaveRequestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeNumber?: StringFieldUpdateOperationsInput | string
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    placeOfBirth?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    socialSecurityNumber?: NullableStringFieldUpdateOperationsInput | string | null
    cnpsNumber?: NullableStringFieldUpdateOperationsInput | string | null
    cnamNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: NullableIntFieldUpdateOperationsInput | number | null
    position?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    manager?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contracts?: ContractUncheckedUpdateManyWithoutEmployeeNestedInput
    salaries?: SalaryUncheckedUpdateManyWithoutEmployeeNestedInput
    loans?: LoanUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type UserUpsertWithoutLeaveApprovalsInput = {
    update: XOR<UserUpdateWithoutLeaveApprovalsInput, UserUncheckedUpdateWithoutLeaveApprovalsInput>
    create: XOR<UserCreateWithoutLeaveApprovalsInput, UserUncheckedCreateWithoutLeaveApprovalsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLeaveApprovalsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLeaveApprovalsInput, UserUncheckedUpdateWithoutLeaveApprovalsInput>
  }

  export type UserUpdateWithoutLeaveApprovalsInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneWithoutUsersNestedInput
    createdCustomers?: CustomerUpdateManyWithoutCreatorNestedInput
    createdQuotes?: QuoteUpdateManyWithoutCreatorNestedInput
    createdInvoices?: InvoiceUpdateManyWithoutCreatorNestedInput
    createdPayments?: PaymentUpdateManyWithoutCreatorNestedInput
    serviceApprovals?: QuoteUpdateManyWithoutServiceManagerNestedInput
    dgApprovals?: QuoteUpdateManyWithoutDgApproverNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    quoteApprovals?: QuoteApprovalUpdateManyWithoutApproverNestedInput
    createdExpenses?: ExpenseUpdateManyWithoutCreatorNestedInput
    accountingEntries?: AccountingEntryUpdateManyWithoutCreatorNestedInput
    cashFlowEntries?: CashFlowUpdateManyWithoutCreatorNestedInput
    createdReminders?: ReminderUpdateManyWithoutCreatorNestedInput
    createdRecurringInvoices?: RecurringInvoiceUpdateManyWithoutCreatorNestedInput
    employee?: EmployeeUpdateOneWithoutUserNestedInput
    assignedProspects?: ProspectUpdateManyWithoutAssignedUserNestedInput
    createdProspects?: ProspectUpdateManyWithoutCreatorNestedInput
    createdProspectActivities?: ProspectActivityUpdateManyWithoutCreatorNestedInput
    technicien?: TechnicienUpdateOneWithoutUtilisateurNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLeaveApprovalsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    serviceId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdCustomers?: CustomerUncheckedUpdateManyWithoutCreatorNestedInput
    createdQuotes?: QuoteUncheckedUpdateManyWithoutCreatorNestedInput
    createdInvoices?: InvoiceUncheckedUpdateManyWithoutCreatorNestedInput
    createdPayments?: PaymentUncheckedUpdateManyWithoutCreatorNestedInput
    serviceApprovals?: QuoteUncheckedUpdateManyWithoutServiceManagerNestedInput
    dgApprovals?: QuoteUncheckedUpdateManyWithoutDgApproverNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    quoteApprovals?: QuoteApprovalUncheckedUpdateManyWithoutApproverNestedInput
    createdExpenses?: ExpenseUncheckedUpdateManyWithoutCreatorNestedInput
    accountingEntries?: AccountingEntryUncheckedUpdateManyWithoutCreatorNestedInput
    cashFlowEntries?: CashFlowUncheckedUpdateManyWithoutCreatorNestedInput
    createdReminders?: ReminderUncheckedUpdateManyWithoutCreatorNestedInput
    createdRecurringInvoices?: RecurringInvoiceUncheckedUpdateManyWithoutCreatorNestedInput
    employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    assignedProspects?: ProspectUncheckedUpdateManyWithoutAssignedUserNestedInput
    createdProspects?: ProspectUncheckedUpdateManyWithoutCreatorNestedInput
    createdProspectActivities?: ProspectActivityUncheckedUpdateManyWithoutCreatorNestedInput
    technicien?: TechnicienUncheckedUpdateOneWithoutUtilisateurNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAssignedProspectsInput = {
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    preferences?: string | null
    permissions?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    service?: ServiceCreateNestedOneWithoutUsersInput
    createdCustomers?: CustomerCreateNestedManyWithoutCreatorInput
    createdQuotes?: QuoteCreateNestedManyWithoutCreatorInput
    createdInvoices?: InvoiceCreateNestedManyWithoutCreatorInput
    createdPayments?: PaymentCreateNestedManyWithoutCreatorInput
    serviceApprovals?: QuoteCreateNestedManyWithoutServiceManagerInput
    dgApprovals?: QuoteCreateNestedManyWithoutDgApproverInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    quoteApprovals?: QuoteApprovalCreateNestedManyWithoutApproverInput
    createdExpenses?: ExpenseCreateNestedManyWithoutCreatorInput
    accountingEntries?: AccountingEntryCreateNestedManyWithoutCreatorInput
    cashFlowEntries?: CashFlowCreateNestedManyWithoutCreatorInput
    createdReminders?: ReminderCreateNestedManyWithoutCreatorInput
    createdRecurringInvoices?: RecurringInvoiceCreateNestedManyWithoutCreatorInput
    employee?: EmployeeCreateNestedOneWithoutUserInput
    leaveApprovals?: LeaveRequestCreateNestedManyWithoutApprovedByInput
    createdProspects?: ProspectCreateNestedManyWithoutCreatorInput
    createdProspectActivities?: ProspectActivityCreateNestedManyWithoutCreatorInput
    technicien?: TechnicienCreateNestedOneWithoutUtilisateurInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAssignedProspectsInput = {
    id?: number
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    serviceId?: number | null
    isActive?: boolean
    lastLogin?: Date | string | null
    preferences?: string | null
    permissions?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdCustomers?: CustomerUncheckedCreateNestedManyWithoutCreatorInput
    createdQuotes?: QuoteUncheckedCreateNestedManyWithoutCreatorInput
    createdInvoices?: InvoiceUncheckedCreateNestedManyWithoutCreatorInput
    createdPayments?: PaymentUncheckedCreateNestedManyWithoutCreatorInput
    serviceApprovals?: QuoteUncheckedCreateNestedManyWithoutServiceManagerInput
    dgApprovals?: QuoteUncheckedCreateNestedManyWithoutDgApproverInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    quoteApprovals?: QuoteApprovalUncheckedCreateNestedManyWithoutApproverInput
    createdExpenses?: ExpenseUncheckedCreateNestedManyWithoutCreatorInput
    accountingEntries?: AccountingEntryUncheckedCreateNestedManyWithoutCreatorInput
    cashFlowEntries?: CashFlowUncheckedCreateNestedManyWithoutCreatorInput
    createdReminders?: ReminderUncheckedCreateNestedManyWithoutCreatorInput
    createdRecurringInvoices?: RecurringInvoiceUncheckedCreateNestedManyWithoutCreatorInput
    employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    leaveApprovals?: LeaveRequestUncheckedCreateNestedManyWithoutApprovedByInput
    createdProspects?: ProspectUncheckedCreateNestedManyWithoutCreatorInput
    createdProspectActivities?: ProspectActivityUncheckedCreateNestedManyWithoutCreatorInput
    technicien?: TechnicienUncheckedCreateNestedOneWithoutUtilisateurInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAssignedProspectsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssignedProspectsInput, UserUncheckedCreateWithoutAssignedProspectsInput>
  }

  export type UserCreateWithoutCreatedProspectsInput = {
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    preferences?: string | null
    permissions?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    service?: ServiceCreateNestedOneWithoutUsersInput
    createdCustomers?: CustomerCreateNestedManyWithoutCreatorInput
    createdQuotes?: QuoteCreateNestedManyWithoutCreatorInput
    createdInvoices?: InvoiceCreateNestedManyWithoutCreatorInput
    createdPayments?: PaymentCreateNestedManyWithoutCreatorInput
    serviceApprovals?: QuoteCreateNestedManyWithoutServiceManagerInput
    dgApprovals?: QuoteCreateNestedManyWithoutDgApproverInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    quoteApprovals?: QuoteApprovalCreateNestedManyWithoutApproverInput
    createdExpenses?: ExpenseCreateNestedManyWithoutCreatorInput
    accountingEntries?: AccountingEntryCreateNestedManyWithoutCreatorInput
    cashFlowEntries?: CashFlowCreateNestedManyWithoutCreatorInput
    createdReminders?: ReminderCreateNestedManyWithoutCreatorInput
    createdRecurringInvoices?: RecurringInvoiceCreateNestedManyWithoutCreatorInput
    employee?: EmployeeCreateNestedOneWithoutUserInput
    leaveApprovals?: LeaveRequestCreateNestedManyWithoutApprovedByInput
    assignedProspects?: ProspectCreateNestedManyWithoutAssignedUserInput
    createdProspectActivities?: ProspectActivityCreateNestedManyWithoutCreatorInput
    technicien?: TechnicienCreateNestedOneWithoutUtilisateurInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedProspectsInput = {
    id?: number
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    serviceId?: number | null
    isActive?: boolean
    lastLogin?: Date | string | null
    preferences?: string | null
    permissions?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdCustomers?: CustomerUncheckedCreateNestedManyWithoutCreatorInput
    createdQuotes?: QuoteUncheckedCreateNestedManyWithoutCreatorInput
    createdInvoices?: InvoiceUncheckedCreateNestedManyWithoutCreatorInput
    createdPayments?: PaymentUncheckedCreateNestedManyWithoutCreatorInput
    serviceApprovals?: QuoteUncheckedCreateNestedManyWithoutServiceManagerInput
    dgApprovals?: QuoteUncheckedCreateNestedManyWithoutDgApproverInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    quoteApprovals?: QuoteApprovalUncheckedCreateNestedManyWithoutApproverInput
    createdExpenses?: ExpenseUncheckedCreateNestedManyWithoutCreatorInput
    accountingEntries?: AccountingEntryUncheckedCreateNestedManyWithoutCreatorInput
    cashFlowEntries?: CashFlowUncheckedCreateNestedManyWithoutCreatorInput
    createdReminders?: ReminderUncheckedCreateNestedManyWithoutCreatorInput
    createdRecurringInvoices?: RecurringInvoiceUncheckedCreateNestedManyWithoutCreatorInput
    employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    leaveApprovals?: LeaveRequestUncheckedCreateNestedManyWithoutApprovedByInput
    assignedProspects?: ProspectUncheckedCreateNestedManyWithoutAssignedUserInput
    createdProspectActivities?: ProspectActivityUncheckedCreateNestedManyWithoutCreatorInput
    technicien?: TechnicienUncheckedCreateNestedOneWithoutUtilisateurInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedProspectsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedProspectsInput, UserUncheckedCreateWithoutCreatedProspectsInput>
  }

  export type ProspectActivityCreateWithoutProspectInput = {
    type: string
    subject?: string | null
    description?: string | null
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    outcome?: string | null
    nextAction?: string | null
    createdAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedProspectActivitiesInput
  }

  export type ProspectActivityUncheckedCreateWithoutProspectInput = {
    id?: number
    type: string
    subject?: string | null
    description?: string | null
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    outcome?: string | null
    nextAction?: string | null
    createdBy: number
    createdAt?: Date | string
  }

  export type ProspectActivityCreateOrConnectWithoutProspectInput = {
    where: ProspectActivityWhereUniqueInput
    create: XOR<ProspectActivityCreateWithoutProspectInput, ProspectActivityUncheckedCreateWithoutProspectInput>
  }

  export type ProspectActivityCreateManyProspectInputEnvelope = {
    data: ProspectActivityCreateManyProspectInput | ProspectActivityCreateManyProspectInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutAssignedProspectsInput = {
    update: XOR<UserUpdateWithoutAssignedProspectsInput, UserUncheckedUpdateWithoutAssignedProspectsInput>
    create: XOR<UserCreateWithoutAssignedProspectsInput, UserUncheckedCreateWithoutAssignedProspectsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAssignedProspectsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAssignedProspectsInput, UserUncheckedUpdateWithoutAssignedProspectsInput>
  }

  export type UserUpdateWithoutAssignedProspectsInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneWithoutUsersNestedInput
    createdCustomers?: CustomerUpdateManyWithoutCreatorNestedInput
    createdQuotes?: QuoteUpdateManyWithoutCreatorNestedInput
    createdInvoices?: InvoiceUpdateManyWithoutCreatorNestedInput
    createdPayments?: PaymentUpdateManyWithoutCreatorNestedInput
    serviceApprovals?: QuoteUpdateManyWithoutServiceManagerNestedInput
    dgApprovals?: QuoteUpdateManyWithoutDgApproverNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    quoteApprovals?: QuoteApprovalUpdateManyWithoutApproverNestedInput
    createdExpenses?: ExpenseUpdateManyWithoutCreatorNestedInput
    accountingEntries?: AccountingEntryUpdateManyWithoutCreatorNestedInput
    cashFlowEntries?: CashFlowUpdateManyWithoutCreatorNestedInput
    createdReminders?: ReminderUpdateManyWithoutCreatorNestedInput
    createdRecurringInvoices?: RecurringInvoiceUpdateManyWithoutCreatorNestedInput
    employee?: EmployeeUpdateOneWithoutUserNestedInput
    leaveApprovals?: LeaveRequestUpdateManyWithoutApprovedByNestedInput
    createdProspects?: ProspectUpdateManyWithoutCreatorNestedInput
    createdProspectActivities?: ProspectActivityUpdateManyWithoutCreatorNestedInput
    technicien?: TechnicienUpdateOneWithoutUtilisateurNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAssignedProspectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    serviceId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdCustomers?: CustomerUncheckedUpdateManyWithoutCreatorNestedInput
    createdQuotes?: QuoteUncheckedUpdateManyWithoutCreatorNestedInput
    createdInvoices?: InvoiceUncheckedUpdateManyWithoutCreatorNestedInput
    createdPayments?: PaymentUncheckedUpdateManyWithoutCreatorNestedInput
    serviceApprovals?: QuoteUncheckedUpdateManyWithoutServiceManagerNestedInput
    dgApprovals?: QuoteUncheckedUpdateManyWithoutDgApproverNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    quoteApprovals?: QuoteApprovalUncheckedUpdateManyWithoutApproverNestedInput
    createdExpenses?: ExpenseUncheckedUpdateManyWithoutCreatorNestedInput
    accountingEntries?: AccountingEntryUncheckedUpdateManyWithoutCreatorNestedInput
    cashFlowEntries?: CashFlowUncheckedUpdateManyWithoutCreatorNestedInput
    createdReminders?: ReminderUncheckedUpdateManyWithoutCreatorNestedInput
    createdRecurringInvoices?: RecurringInvoiceUncheckedUpdateManyWithoutCreatorNestedInput
    employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    leaveApprovals?: LeaveRequestUncheckedUpdateManyWithoutApprovedByNestedInput
    createdProspects?: ProspectUncheckedUpdateManyWithoutCreatorNestedInput
    createdProspectActivities?: ProspectActivityUncheckedUpdateManyWithoutCreatorNestedInput
    technicien?: TechnicienUncheckedUpdateOneWithoutUtilisateurNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutCreatedProspectsInput = {
    update: XOR<UserUpdateWithoutCreatedProspectsInput, UserUncheckedUpdateWithoutCreatedProspectsInput>
    create: XOR<UserCreateWithoutCreatedProspectsInput, UserUncheckedCreateWithoutCreatedProspectsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedProspectsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedProspectsInput, UserUncheckedUpdateWithoutCreatedProspectsInput>
  }

  export type UserUpdateWithoutCreatedProspectsInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneWithoutUsersNestedInput
    createdCustomers?: CustomerUpdateManyWithoutCreatorNestedInput
    createdQuotes?: QuoteUpdateManyWithoutCreatorNestedInput
    createdInvoices?: InvoiceUpdateManyWithoutCreatorNestedInput
    createdPayments?: PaymentUpdateManyWithoutCreatorNestedInput
    serviceApprovals?: QuoteUpdateManyWithoutServiceManagerNestedInput
    dgApprovals?: QuoteUpdateManyWithoutDgApproverNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    quoteApprovals?: QuoteApprovalUpdateManyWithoutApproverNestedInput
    createdExpenses?: ExpenseUpdateManyWithoutCreatorNestedInput
    accountingEntries?: AccountingEntryUpdateManyWithoutCreatorNestedInput
    cashFlowEntries?: CashFlowUpdateManyWithoutCreatorNestedInput
    createdReminders?: ReminderUpdateManyWithoutCreatorNestedInput
    createdRecurringInvoices?: RecurringInvoiceUpdateManyWithoutCreatorNestedInput
    employee?: EmployeeUpdateOneWithoutUserNestedInput
    leaveApprovals?: LeaveRequestUpdateManyWithoutApprovedByNestedInput
    assignedProspects?: ProspectUpdateManyWithoutAssignedUserNestedInput
    createdProspectActivities?: ProspectActivityUpdateManyWithoutCreatorNestedInput
    technicien?: TechnicienUpdateOneWithoutUtilisateurNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedProspectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    serviceId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdCustomers?: CustomerUncheckedUpdateManyWithoutCreatorNestedInput
    createdQuotes?: QuoteUncheckedUpdateManyWithoutCreatorNestedInput
    createdInvoices?: InvoiceUncheckedUpdateManyWithoutCreatorNestedInput
    createdPayments?: PaymentUncheckedUpdateManyWithoutCreatorNestedInput
    serviceApprovals?: QuoteUncheckedUpdateManyWithoutServiceManagerNestedInput
    dgApprovals?: QuoteUncheckedUpdateManyWithoutDgApproverNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    quoteApprovals?: QuoteApprovalUncheckedUpdateManyWithoutApproverNestedInput
    createdExpenses?: ExpenseUncheckedUpdateManyWithoutCreatorNestedInput
    accountingEntries?: AccountingEntryUncheckedUpdateManyWithoutCreatorNestedInput
    cashFlowEntries?: CashFlowUncheckedUpdateManyWithoutCreatorNestedInput
    createdReminders?: ReminderUncheckedUpdateManyWithoutCreatorNestedInput
    createdRecurringInvoices?: RecurringInvoiceUncheckedUpdateManyWithoutCreatorNestedInput
    employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    leaveApprovals?: LeaveRequestUncheckedUpdateManyWithoutApprovedByNestedInput
    assignedProspects?: ProspectUncheckedUpdateManyWithoutAssignedUserNestedInput
    createdProspectActivities?: ProspectActivityUncheckedUpdateManyWithoutCreatorNestedInput
    technicien?: TechnicienUncheckedUpdateOneWithoutUtilisateurNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProspectActivityUpsertWithWhereUniqueWithoutProspectInput = {
    where: ProspectActivityWhereUniqueInput
    update: XOR<ProspectActivityUpdateWithoutProspectInput, ProspectActivityUncheckedUpdateWithoutProspectInput>
    create: XOR<ProspectActivityCreateWithoutProspectInput, ProspectActivityUncheckedCreateWithoutProspectInput>
  }

  export type ProspectActivityUpdateWithWhereUniqueWithoutProspectInput = {
    where: ProspectActivityWhereUniqueInput
    data: XOR<ProspectActivityUpdateWithoutProspectInput, ProspectActivityUncheckedUpdateWithoutProspectInput>
  }

  export type ProspectActivityUpdateManyWithWhereWithoutProspectInput = {
    where: ProspectActivityScalarWhereInput
    data: XOR<ProspectActivityUpdateManyMutationInput, ProspectActivityUncheckedUpdateManyWithoutProspectInput>
  }

  export type ProspectCreateWithoutActivitiesInput = {
    companyName: string
    contactName: string
    position?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    website?: string | null
    industry?: string | null
    companySize?: string | null
    estimatedValue?: number | null
    priority?: string
    stage?: string
    source?: string | null
    notes?: string | null
    hasBudget?: boolean
    isDecisionMaker?: boolean
    hasNeed?: boolean
    timeline?: string | null
    lastContact?: Date | string
    nextAction?: string | null
    nextActionDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedUser?: UserCreateNestedOneWithoutAssignedProspectsInput
    creator: UserCreateNestedOneWithoutCreatedProspectsInput
  }

  export type ProspectUncheckedCreateWithoutActivitiesInput = {
    id?: number
    companyName: string
    contactName: string
    position?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    website?: string | null
    industry?: string | null
    companySize?: string | null
    estimatedValue?: number | null
    priority?: string
    stage?: string
    source?: string | null
    notes?: string | null
    hasBudget?: boolean
    isDecisionMaker?: boolean
    hasNeed?: boolean
    timeline?: string | null
    lastContact?: Date | string
    nextAction?: string | null
    nextActionDate?: Date | string | null
    assignedTo?: number | null
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProspectCreateOrConnectWithoutActivitiesInput = {
    where: ProspectWhereUniqueInput
    create: XOR<ProspectCreateWithoutActivitiesInput, ProspectUncheckedCreateWithoutActivitiesInput>
  }

  export type UserCreateWithoutCreatedProspectActivitiesInput = {
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    preferences?: string | null
    permissions?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    service?: ServiceCreateNestedOneWithoutUsersInput
    createdCustomers?: CustomerCreateNestedManyWithoutCreatorInput
    createdQuotes?: QuoteCreateNestedManyWithoutCreatorInput
    createdInvoices?: InvoiceCreateNestedManyWithoutCreatorInput
    createdPayments?: PaymentCreateNestedManyWithoutCreatorInput
    serviceApprovals?: QuoteCreateNestedManyWithoutServiceManagerInput
    dgApprovals?: QuoteCreateNestedManyWithoutDgApproverInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    quoteApprovals?: QuoteApprovalCreateNestedManyWithoutApproverInput
    createdExpenses?: ExpenseCreateNestedManyWithoutCreatorInput
    accountingEntries?: AccountingEntryCreateNestedManyWithoutCreatorInput
    cashFlowEntries?: CashFlowCreateNestedManyWithoutCreatorInput
    createdReminders?: ReminderCreateNestedManyWithoutCreatorInput
    createdRecurringInvoices?: RecurringInvoiceCreateNestedManyWithoutCreatorInput
    employee?: EmployeeCreateNestedOneWithoutUserInput
    leaveApprovals?: LeaveRequestCreateNestedManyWithoutApprovedByInput
    assignedProspects?: ProspectCreateNestedManyWithoutAssignedUserInput
    createdProspects?: ProspectCreateNestedManyWithoutCreatorInput
    technicien?: TechnicienCreateNestedOneWithoutUtilisateurInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedProspectActivitiesInput = {
    id?: number
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    serviceId?: number | null
    isActive?: boolean
    lastLogin?: Date | string | null
    preferences?: string | null
    permissions?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdCustomers?: CustomerUncheckedCreateNestedManyWithoutCreatorInput
    createdQuotes?: QuoteUncheckedCreateNestedManyWithoutCreatorInput
    createdInvoices?: InvoiceUncheckedCreateNestedManyWithoutCreatorInput
    createdPayments?: PaymentUncheckedCreateNestedManyWithoutCreatorInput
    serviceApprovals?: QuoteUncheckedCreateNestedManyWithoutServiceManagerInput
    dgApprovals?: QuoteUncheckedCreateNestedManyWithoutDgApproverInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    quoteApprovals?: QuoteApprovalUncheckedCreateNestedManyWithoutApproverInput
    createdExpenses?: ExpenseUncheckedCreateNestedManyWithoutCreatorInput
    accountingEntries?: AccountingEntryUncheckedCreateNestedManyWithoutCreatorInput
    cashFlowEntries?: CashFlowUncheckedCreateNestedManyWithoutCreatorInput
    createdReminders?: ReminderUncheckedCreateNestedManyWithoutCreatorInput
    createdRecurringInvoices?: RecurringInvoiceUncheckedCreateNestedManyWithoutCreatorInput
    employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    leaveApprovals?: LeaveRequestUncheckedCreateNestedManyWithoutApprovedByInput
    assignedProspects?: ProspectUncheckedCreateNestedManyWithoutAssignedUserInput
    createdProspects?: ProspectUncheckedCreateNestedManyWithoutCreatorInput
    technicien?: TechnicienUncheckedCreateNestedOneWithoutUtilisateurInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedProspectActivitiesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedProspectActivitiesInput, UserUncheckedCreateWithoutCreatedProspectActivitiesInput>
  }

  export type ProspectUpsertWithoutActivitiesInput = {
    update: XOR<ProspectUpdateWithoutActivitiesInput, ProspectUncheckedUpdateWithoutActivitiesInput>
    create: XOR<ProspectCreateWithoutActivitiesInput, ProspectUncheckedCreateWithoutActivitiesInput>
    where?: ProspectWhereInput
  }

  export type ProspectUpdateToOneWithWhereWithoutActivitiesInput = {
    where?: ProspectWhereInput
    data: XOR<ProspectUpdateWithoutActivitiesInput, ProspectUncheckedUpdateWithoutActivitiesInput>
  }

  export type ProspectUpdateWithoutActivitiesInput = {
    companyName?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedValue?: NullableFloatFieldUpdateOperationsInput | number | null
    priority?: StringFieldUpdateOperationsInput | string
    stage?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    hasBudget?: BoolFieldUpdateOperationsInput | boolean
    isDecisionMaker?: BoolFieldUpdateOperationsInput | boolean
    hasNeed?: BoolFieldUpdateOperationsInput | boolean
    timeline?: NullableStringFieldUpdateOperationsInput | string | null
    lastContact?: DateTimeFieldUpdateOperationsInput | Date | string
    nextAction?: NullableStringFieldUpdateOperationsInput | string | null
    nextActionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedUser?: UserUpdateOneWithoutAssignedProspectsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedProspectsNestedInput
  }

  export type ProspectUncheckedUpdateWithoutActivitiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyName?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedValue?: NullableFloatFieldUpdateOperationsInput | number | null
    priority?: StringFieldUpdateOperationsInput | string
    stage?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    hasBudget?: BoolFieldUpdateOperationsInput | boolean
    isDecisionMaker?: BoolFieldUpdateOperationsInput | boolean
    hasNeed?: BoolFieldUpdateOperationsInput | boolean
    timeline?: NullableStringFieldUpdateOperationsInput | string | null
    lastContact?: DateTimeFieldUpdateOperationsInput | Date | string
    nextAction?: NullableStringFieldUpdateOperationsInput | string | null
    nextActionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: NullableIntFieldUpdateOperationsInput | number | null
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutCreatedProspectActivitiesInput = {
    update: XOR<UserUpdateWithoutCreatedProspectActivitiesInput, UserUncheckedUpdateWithoutCreatedProspectActivitiesInput>
    create: XOR<UserCreateWithoutCreatedProspectActivitiesInput, UserUncheckedCreateWithoutCreatedProspectActivitiesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedProspectActivitiesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedProspectActivitiesInput, UserUncheckedUpdateWithoutCreatedProspectActivitiesInput>
  }

  export type UserUpdateWithoutCreatedProspectActivitiesInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneWithoutUsersNestedInput
    createdCustomers?: CustomerUpdateManyWithoutCreatorNestedInput
    createdQuotes?: QuoteUpdateManyWithoutCreatorNestedInput
    createdInvoices?: InvoiceUpdateManyWithoutCreatorNestedInput
    createdPayments?: PaymentUpdateManyWithoutCreatorNestedInput
    serviceApprovals?: QuoteUpdateManyWithoutServiceManagerNestedInput
    dgApprovals?: QuoteUpdateManyWithoutDgApproverNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    quoteApprovals?: QuoteApprovalUpdateManyWithoutApproverNestedInput
    createdExpenses?: ExpenseUpdateManyWithoutCreatorNestedInput
    accountingEntries?: AccountingEntryUpdateManyWithoutCreatorNestedInput
    cashFlowEntries?: CashFlowUpdateManyWithoutCreatorNestedInput
    createdReminders?: ReminderUpdateManyWithoutCreatorNestedInput
    createdRecurringInvoices?: RecurringInvoiceUpdateManyWithoutCreatorNestedInput
    employee?: EmployeeUpdateOneWithoutUserNestedInput
    leaveApprovals?: LeaveRequestUpdateManyWithoutApprovedByNestedInput
    assignedProspects?: ProspectUpdateManyWithoutAssignedUserNestedInput
    createdProspects?: ProspectUpdateManyWithoutCreatorNestedInput
    technicien?: TechnicienUpdateOneWithoutUtilisateurNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedProspectActivitiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    serviceId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdCustomers?: CustomerUncheckedUpdateManyWithoutCreatorNestedInput
    createdQuotes?: QuoteUncheckedUpdateManyWithoutCreatorNestedInput
    createdInvoices?: InvoiceUncheckedUpdateManyWithoutCreatorNestedInput
    createdPayments?: PaymentUncheckedUpdateManyWithoutCreatorNestedInput
    serviceApprovals?: QuoteUncheckedUpdateManyWithoutServiceManagerNestedInput
    dgApprovals?: QuoteUncheckedUpdateManyWithoutDgApproverNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    quoteApprovals?: QuoteApprovalUncheckedUpdateManyWithoutApproverNestedInput
    createdExpenses?: ExpenseUncheckedUpdateManyWithoutCreatorNestedInput
    accountingEntries?: AccountingEntryUncheckedUpdateManyWithoutCreatorNestedInput
    cashFlowEntries?: CashFlowUncheckedUpdateManyWithoutCreatorNestedInput
    createdReminders?: ReminderUncheckedUpdateManyWithoutCreatorNestedInput
    createdRecurringInvoices?: RecurringInvoiceUncheckedUpdateManyWithoutCreatorNestedInput
    employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    leaveApprovals?: LeaveRequestUncheckedUpdateManyWithoutApprovedByNestedInput
    assignedProspects?: ProspectUncheckedUpdateManyWithoutAssignedUserNestedInput
    createdProspects?: ProspectUncheckedUpdateManyWithoutCreatorNestedInput
    technicien?: TechnicienUncheckedUpdateOneWithoutUtilisateurNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type EmployeeCreateWithoutLoansInput = {
    employeeNumber: string
    registrationNumber?: string | null
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    address?: string | null
    dateOfBirth: Date | string
    placeOfBirth?: string | null
    nationality?: string | null
    socialSecurityNumber?: string | null
    cnpsNumber?: string | null
    cnamNumber?: string | null
    bankAccount?: string | null
    emergencyContact?: string | null
    position: string
    department?: string | null
    category?: string | null
    level?: string | null
    manager?: string | null
    hireDate: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    service?: ServiceCreateNestedOneWithoutEmployeesInput
    user?: UserCreateNestedOneWithoutEmployeeInput
    contracts?: ContractCreateNestedManyWithoutEmployeeInput
    salaries?: SalaryCreateNestedManyWithoutEmployeeInput
    leaveRequests?: LeaveRequestCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutLoansInput = {
    id?: number
    employeeNumber: string
    registrationNumber?: string | null
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    address?: string | null
    dateOfBirth: Date | string
    placeOfBirth?: string | null
    nationality?: string | null
    socialSecurityNumber?: string | null
    cnpsNumber?: string | null
    cnamNumber?: string | null
    bankAccount?: string | null
    emergencyContact?: string | null
    serviceId?: number | null
    position: string
    department?: string | null
    category?: string | null
    level?: string | null
    manager?: string | null
    hireDate: Date | string
    isActive?: boolean
    userId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contracts?: ContractUncheckedCreateNestedManyWithoutEmployeeInput
    salaries?: SalaryUncheckedCreateNestedManyWithoutEmployeeInput
    leaveRequests?: LeaveRequestUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutLoansInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutLoansInput, EmployeeUncheckedCreateWithoutLoansInput>
  }

  export type LoanPaymentCreateWithoutLoanInput = {
    amount: number
    paymentDate: Date | string
    principal: number
    interest: number
    notes?: string | null
    createdAt?: Date | string
    salary?: SalaryCreateNestedOneWithoutLoanPaymentsInput
  }

  export type LoanPaymentUncheckedCreateWithoutLoanInput = {
    id?: number
    salaryId?: number | null
    amount: number
    paymentDate: Date | string
    principal: number
    interest: number
    notes?: string | null
    createdAt?: Date | string
  }

  export type LoanPaymentCreateOrConnectWithoutLoanInput = {
    where: LoanPaymentWhereUniqueInput
    create: XOR<LoanPaymentCreateWithoutLoanInput, LoanPaymentUncheckedCreateWithoutLoanInput>
  }

  export type LoanPaymentCreateManyLoanInputEnvelope = {
    data: LoanPaymentCreateManyLoanInput | LoanPaymentCreateManyLoanInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeUpsertWithoutLoansInput = {
    update: XOR<EmployeeUpdateWithoutLoansInput, EmployeeUncheckedUpdateWithoutLoansInput>
    create: XOR<EmployeeCreateWithoutLoansInput, EmployeeUncheckedCreateWithoutLoansInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutLoansInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutLoansInput, EmployeeUncheckedUpdateWithoutLoansInput>
  }

  export type EmployeeUpdateWithoutLoansInput = {
    employeeNumber?: StringFieldUpdateOperationsInput | string
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    placeOfBirth?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    socialSecurityNumber?: NullableStringFieldUpdateOperationsInput | string | null
    cnpsNumber?: NullableStringFieldUpdateOperationsInput | string | null
    cnamNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    position?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    manager?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneWithoutEmployeesNestedInput
    user?: UserUpdateOneWithoutEmployeeNestedInput
    contracts?: ContractUpdateManyWithoutEmployeeNestedInput
    salaries?: SalaryUpdateManyWithoutEmployeeNestedInput
    leaveRequests?: LeaveRequestUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutLoansInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeNumber?: StringFieldUpdateOperationsInput | string
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    placeOfBirth?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    socialSecurityNumber?: NullableStringFieldUpdateOperationsInput | string | null
    cnpsNumber?: NullableStringFieldUpdateOperationsInput | string | null
    cnamNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: NullableIntFieldUpdateOperationsInput | number | null
    position?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    manager?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contracts?: ContractUncheckedUpdateManyWithoutEmployeeNestedInput
    salaries?: SalaryUncheckedUpdateManyWithoutEmployeeNestedInput
    leaveRequests?: LeaveRequestUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type LoanPaymentUpsertWithWhereUniqueWithoutLoanInput = {
    where: LoanPaymentWhereUniqueInput
    update: XOR<LoanPaymentUpdateWithoutLoanInput, LoanPaymentUncheckedUpdateWithoutLoanInput>
    create: XOR<LoanPaymentCreateWithoutLoanInput, LoanPaymentUncheckedCreateWithoutLoanInput>
  }

  export type LoanPaymentUpdateWithWhereUniqueWithoutLoanInput = {
    where: LoanPaymentWhereUniqueInput
    data: XOR<LoanPaymentUpdateWithoutLoanInput, LoanPaymentUncheckedUpdateWithoutLoanInput>
  }

  export type LoanPaymentUpdateManyWithWhereWithoutLoanInput = {
    where: LoanPaymentScalarWhereInput
    data: XOR<LoanPaymentUpdateManyMutationInput, LoanPaymentUncheckedUpdateManyWithoutLoanInput>
  }

  export type TechnicienCreateWithoutSpecialiteInput = {
    nom: string
    prenom: string
    contact: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    utilisateur?: UserCreateNestedOneWithoutTechnicienInput
    interventions?: TechnicienInterventionCreateNestedManyWithoutTechnicienInput
    rapports?: RapportMissionCreateNestedManyWithoutTechnicienInput
    sortiesMateriels?: SortieMaterielCreateNestedManyWithoutTechnicienInput
  }

  export type TechnicienUncheckedCreateWithoutSpecialiteInput = {
    id?: number
    nom: string
    prenom: string
    contact: string
    utilisateurId?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    interventions?: TechnicienInterventionUncheckedCreateNestedManyWithoutTechnicienInput
    rapports?: RapportMissionUncheckedCreateNestedManyWithoutTechnicienInput
    sortiesMateriels?: SortieMaterielUncheckedCreateNestedManyWithoutTechnicienInput
  }

  export type TechnicienCreateOrConnectWithoutSpecialiteInput = {
    where: TechnicienWhereUniqueInput
    create: XOR<TechnicienCreateWithoutSpecialiteInput, TechnicienUncheckedCreateWithoutSpecialiteInput>
  }

  export type TechnicienCreateManySpecialiteInputEnvelope = {
    data: TechnicienCreateManySpecialiteInput | TechnicienCreateManySpecialiteInput[]
    skipDuplicates?: boolean
  }

  export type TechnicienUpsertWithWhereUniqueWithoutSpecialiteInput = {
    where: TechnicienWhereUniqueInput
    update: XOR<TechnicienUpdateWithoutSpecialiteInput, TechnicienUncheckedUpdateWithoutSpecialiteInput>
    create: XOR<TechnicienCreateWithoutSpecialiteInput, TechnicienUncheckedCreateWithoutSpecialiteInput>
  }

  export type TechnicienUpdateWithWhereUniqueWithoutSpecialiteInput = {
    where: TechnicienWhereUniqueInput
    data: XOR<TechnicienUpdateWithoutSpecialiteInput, TechnicienUncheckedUpdateWithoutSpecialiteInput>
  }

  export type TechnicienUpdateManyWithWhereWithoutSpecialiteInput = {
    where: TechnicienScalarWhereInput
    data: XOR<TechnicienUpdateManyMutationInput, TechnicienUncheckedUpdateManyWithoutSpecialiteInput>
  }

  export type TechnicienScalarWhereInput = {
    AND?: TechnicienScalarWhereInput | TechnicienScalarWhereInput[]
    OR?: TechnicienScalarWhereInput[]
    NOT?: TechnicienScalarWhereInput | TechnicienScalarWhereInput[]
    id?: IntFilter<"Technicien"> | number
    nom?: StringFilter<"Technicien"> | string
    prenom?: StringFilter<"Technicien"> | string
    contact?: StringFilter<"Technicien"> | string
    specialiteId?: IntFilter<"Technicien"> | number
    utilisateurId?: IntNullableFilter<"Technicien"> | number | null
    isActive?: BoolFilter<"Technicien"> | boolean
    createdAt?: DateTimeFilter<"Technicien"> | Date | string
    updatedAt?: DateTimeFilter<"Technicien"> | Date | string
  }

  export type SpecialiteCreateWithoutTechniciensInput = {
    libelle: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SpecialiteUncheckedCreateWithoutTechniciensInput = {
    id?: number
    libelle: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SpecialiteCreateOrConnectWithoutTechniciensInput = {
    where: SpecialiteWhereUniqueInput
    create: XOR<SpecialiteCreateWithoutTechniciensInput, SpecialiteUncheckedCreateWithoutTechniciensInput>
  }

  export type UserCreateWithoutTechnicienInput = {
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    preferences?: string | null
    permissions?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    service?: ServiceCreateNestedOneWithoutUsersInput
    createdCustomers?: CustomerCreateNestedManyWithoutCreatorInput
    createdQuotes?: QuoteCreateNestedManyWithoutCreatorInput
    createdInvoices?: InvoiceCreateNestedManyWithoutCreatorInput
    createdPayments?: PaymentCreateNestedManyWithoutCreatorInput
    serviceApprovals?: QuoteCreateNestedManyWithoutServiceManagerInput
    dgApprovals?: QuoteCreateNestedManyWithoutDgApproverInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    quoteApprovals?: QuoteApprovalCreateNestedManyWithoutApproverInput
    createdExpenses?: ExpenseCreateNestedManyWithoutCreatorInput
    accountingEntries?: AccountingEntryCreateNestedManyWithoutCreatorInput
    cashFlowEntries?: CashFlowCreateNestedManyWithoutCreatorInput
    createdReminders?: ReminderCreateNestedManyWithoutCreatorInput
    createdRecurringInvoices?: RecurringInvoiceCreateNestedManyWithoutCreatorInput
    employee?: EmployeeCreateNestedOneWithoutUserInput
    leaveApprovals?: LeaveRequestCreateNestedManyWithoutApprovedByInput
    assignedProspects?: ProspectCreateNestedManyWithoutAssignedUserInput
    createdProspects?: ProspectCreateNestedManyWithoutCreatorInput
    createdProspectActivities?: ProspectActivityCreateNestedManyWithoutCreatorInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTechnicienInput = {
    id?: number
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    serviceId?: number | null
    isActive?: boolean
    lastLogin?: Date | string | null
    preferences?: string | null
    permissions?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdCustomers?: CustomerUncheckedCreateNestedManyWithoutCreatorInput
    createdQuotes?: QuoteUncheckedCreateNestedManyWithoutCreatorInput
    createdInvoices?: InvoiceUncheckedCreateNestedManyWithoutCreatorInput
    createdPayments?: PaymentUncheckedCreateNestedManyWithoutCreatorInput
    serviceApprovals?: QuoteUncheckedCreateNestedManyWithoutServiceManagerInput
    dgApprovals?: QuoteUncheckedCreateNestedManyWithoutDgApproverInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    quoteApprovals?: QuoteApprovalUncheckedCreateNestedManyWithoutApproverInput
    createdExpenses?: ExpenseUncheckedCreateNestedManyWithoutCreatorInput
    accountingEntries?: AccountingEntryUncheckedCreateNestedManyWithoutCreatorInput
    cashFlowEntries?: CashFlowUncheckedCreateNestedManyWithoutCreatorInput
    createdReminders?: ReminderUncheckedCreateNestedManyWithoutCreatorInput
    createdRecurringInvoices?: RecurringInvoiceUncheckedCreateNestedManyWithoutCreatorInput
    employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    leaveApprovals?: LeaveRequestUncheckedCreateNestedManyWithoutApprovedByInput
    assignedProspects?: ProspectUncheckedCreateNestedManyWithoutAssignedUserInput
    createdProspects?: ProspectUncheckedCreateNestedManyWithoutCreatorInput
    createdProspectActivities?: ProspectActivityUncheckedCreateNestedManyWithoutCreatorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTechnicienInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTechnicienInput, UserUncheckedCreateWithoutTechnicienInput>
  }

  export type TechnicienInterventionCreateWithoutTechnicienInput = {
    role?: string
    commentaire?: string | null
    createdAt?: Date | string
    intervention: InterventionCreateNestedOneWithoutTechniciensInput
  }

  export type TechnicienInterventionUncheckedCreateWithoutTechnicienInput = {
    id?: number
    interventionId: number
    role?: string
    commentaire?: string | null
    createdAt?: Date | string
  }

  export type TechnicienInterventionCreateOrConnectWithoutTechnicienInput = {
    where: TechnicienInterventionWhereUniqueInput
    create: XOR<TechnicienInterventionCreateWithoutTechnicienInput, TechnicienInterventionUncheckedCreateWithoutTechnicienInput>
  }

  export type TechnicienInterventionCreateManyTechnicienInputEnvelope = {
    data: TechnicienInterventionCreateManyTechnicienInput | TechnicienInterventionCreateManyTechnicienInput[]
    skipDuplicates?: boolean
  }

  export type RapportMissionCreateWithoutTechnicienInput = {
    titre: string
    contenu: string
    createdById?: number | null
    statut?: string
    dateValidation?: Date | string | null
    commentaire?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    intervention?: InterventionCreateNestedOneWithoutRapportsInput
    mission: MissionCreateNestedOneWithoutRapportsInput
    images?: RapportImageCreateNestedManyWithoutRapportInput
  }

  export type RapportMissionUncheckedCreateWithoutTechnicienInput = {
    id?: number
    titre: string
    contenu: string
    interventionId?: number | null
    missionId: string
    createdById?: number | null
    statut?: string
    dateValidation?: Date | string | null
    commentaire?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: RapportImageUncheckedCreateNestedManyWithoutRapportInput
  }

  export type RapportMissionCreateOrConnectWithoutTechnicienInput = {
    where: RapportMissionWhereUniqueInput
    create: XOR<RapportMissionCreateWithoutTechnicienInput, RapportMissionUncheckedCreateWithoutTechnicienInput>
  }

  export type RapportMissionCreateManyTechnicienInputEnvelope = {
    data: RapportMissionCreateManyTechnicienInput | RapportMissionCreateManyTechnicienInput[]
    skipDuplicates?: boolean
  }

  export type SortieMaterielCreateWithoutTechnicienInput = {
    quantite: number
    dateSortie?: Date | string
    motif?: string | null
    retourne?: boolean
    dateRetour?: Date | string | null
    quantiteRetour?: number | null
    commentaire?: string | null
    createdAt?: Date | string
    materiel: MaterielCreateNestedOneWithoutSortiesInput
    intervention: InterventionCreateNestedOneWithoutSortiesMaterielsInput
  }

  export type SortieMaterielUncheckedCreateWithoutTechnicienInput = {
    id?: number
    materielId: number
    interventionId: number
    quantite: number
    dateSortie?: Date | string
    motif?: string | null
    retourne?: boolean
    dateRetour?: Date | string | null
    quantiteRetour?: number | null
    commentaire?: string | null
    createdAt?: Date | string
  }

  export type SortieMaterielCreateOrConnectWithoutTechnicienInput = {
    where: SortieMaterielWhereUniqueInput
    create: XOR<SortieMaterielCreateWithoutTechnicienInput, SortieMaterielUncheckedCreateWithoutTechnicienInput>
  }

  export type SortieMaterielCreateManyTechnicienInputEnvelope = {
    data: SortieMaterielCreateManyTechnicienInput | SortieMaterielCreateManyTechnicienInput[]
    skipDuplicates?: boolean
  }

  export type SpecialiteUpsertWithoutTechniciensInput = {
    update: XOR<SpecialiteUpdateWithoutTechniciensInput, SpecialiteUncheckedUpdateWithoutTechniciensInput>
    create: XOR<SpecialiteCreateWithoutTechniciensInput, SpecialiteUncheckedCreateWithoutTechniciensInput>
    where?: SpecialiteWhereInput
  }

  export type SpecialiteUpdateToOneWithWhereWithoutTechniciensInput = {
    where?: SpecialiteWhereInput
    data: XOR<SpecialiteUpdateWithoutTechniciensInput, SpecialiteUncheckedUpdateWithoutTechniciensInput>
  }

  export type SpecialiteUpdateWithoutTechniciensInput = {
    libelle?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpecialiteUncheckedUpdateWithoutTechniciensInput = {
    id?: IntFieldUpdateOperationsInput | number
    libelle?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutTechnicienInput = {
    update: XOR<UserUpdateWithoutTechnicienInput, UserUncheckedUpdateWithoutTechnicienInput>
    create: XOR<UserCreateWithoutTechnicienInput, UserUncheckedCreateWithoutTechnicienInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTechnicienInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTechnicienInput, UserUncheckedUpdateWithoutTechnicienInput>
  }

  export type UserUpdateWithoutTechnicienInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneWithoutUsersNestedInput
    createdCustomers?: CustomerUpdateManyWithoutCreatorNestedInput
    createdQuotes?: QuoteUpdateManyWithoutCreatorNestedInput
    createdInvoices?: InvoiceUpdateManyWithoutCreatorNestedInput
    createdPayments?: PaymentUpdateManyWithoutCreatorNestedInput
    serviceApprovals?: QuoteUpdateManyWithoutServiceManagerNestedInput
    dgApprovals?: QuoteUpdateManyWithoutDgApproverNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    quoteApprovals?: QuoteApprovalUpdateManyWithoutApproverNestedInput
    createdExpenses?: ExpenseUpdateManyWithoutCreatorNestedInput
    accountingEntries?: AccountingEntryUpdateManyWithoutCreatorNestedInput
    cashFlowEntries?: CashFlowUpdateManyWithoutCreatorNestedInput
    createdReminders?: ReminderUpdateManyWithoutCreatorNestedInput
    createdRecurringInvoices?: RecurringInvoiceUpdateManyWithoutCreatorNestedInput
    employee?: EmployeeUpdateOneWithoutUserNestedInput
    leaveApprovals?: LeaveRequestUpdateManyWithoutApprovedByNestedInput
    assignedProspects?: ProspectUpdateManyWithoutAssignedUserNestedInput
    createdProspects?: ProspectUpdateManyWithoutCreatorNestedInput
    createdProspectActivities?: ProspectActivityUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTechnicienInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    serviceId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdCustomers?: CustomerUncheckedUpdateManyWithoutCreatorNestedInput
    createdQuotes?: QuoteUncheckedUpdateManyWithoutCreatorNestedInput
    createdInvoices?: InvoiceUncheckedUpdateManyWithoutCreatorNestedInput
    createdPayments?: PaymentUncheckedUpdateManyWithoutCreatorNestedInput
    serviceApprovals?: QuoteUncheckedUpdateManyWithoutServiceManagerNestedInput
    dgApprovals?: QuoteUncheckedUpdateManyWithoutDgApproverNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    quoteApprovals?: QuoteApprovalUncheckedUpdateManyWithoutApproverNestedInput
    createdExpenses?: ExpenseUncheckedUpdateManyWithoutCreatorNestedInput
    accountingEntries?: AccountingEntryUncheckedUpdateManyWithoutCreatorNestedInput
    cashFlowEntries?: CashFlowUncheckedUpdateManyWithoutCreatorNestedInput
    createdReminders?: ReminderUncheckedUpdateManyWithoutCreatorNestedInput
    createdRecurringInvoices?: RecurringInvoiceUncheckedUpdateManyWithoutCreatorNestedInput
    employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    leaveApprovals?: LeaveRequestUncheckedUpdateManyWithoutApprovedByNestedInput
    assignedProspects?: ProspectUncheckedUpdateManyWithoutAssignedUserNestedInput
    createdProspects?: ProspectUncheckedUpdateManyWithoutCreatorNestedInput
    createdProspectActivities?: ProspectActivityUncheckedUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TechnicienInterventionUpsertWithWhereUniqueWithoutTechnicienInput = {
    where: TechnicienInterventionWhereUniqueInput
    update: XOR<TechnicienInterventionUpdateWithoutTechnicienInput, TechnicienInterventionUncheckedUpdateWithoutTechnicienInput>
    create: XOR<TechnicienInterventionCreateWithoutTechnicienInput, TechnicienInterventionUncheckedCreateWithoutTechnicienInput>
  }

  export type TechnicienInterventionUpdateWithWhereUniqueWithoutTechnicienInput = {
    where: TechnicienInterventionWhereUniqueInput
    data: XOR<TechnicienInterventionUpdateWithoutTechnicienInput, TechnicienInterventionUncheckedUpdateWithoutTechnicienInput>
  }

  export type TechnicienInterventionUpdateManyWithWhereWithoutTechnicienInput = {
    where: TechnicienInterventionScalarWhereInput
    data: XOR<TechnicienInterventionUpdateManyMutationInput, TechnicienInterventionUncheckedUpdateManyWithoutTechnicienInput>
  }

  export type TechnicienInterventionScalarWhereInput = {
    AND?: TechnicienInterventionScalarWhereInput | TechnicienInterventionScalarWhereInput[]
    OR?: TechnicienInterventionScalarWhereInput[]
    NOT?: TechnicienInterventionScalarWhereInput | TechnicienInterventionScalarWhereInput[]
    id?: IntFilter<"TechnicienIntervention"> | number
    technicienId?: IntFilter<"TechnicienIntervention"> | number
    interventionId?: IntFilter<"TechnicienIntervention"> | number
    role?: StringFilter<"TechnicienIntervention"> | string
    commentaire?: StringNullableFilter<"TechnicienIntervention"> | string | null
    createdAt?: DateTimeFilter<"TechnicienIntervention"> | Date | string
  }

  export type RapportMissionUpsertWithWhereUniqueWithoutTechnicienInput = {
    where: RapportMissionWhereUniqueInput
    update: XOR<RapportMissionUpdateWithoutTechnicienInput, RapportMissionUncheckedUpdateWithoutTechnicienInput>
    create: XOR<RapportMissionCreateWithoutTechnicienInput, RapportMissionUncheckedCreateWithoutTechnicienInput>
  }

  export type RapportMissionUpdateWithWhereUniqueWithoutTechnicienInput = {
    where: RapportMissionWhereUniqueInput
    data: XOR<RapportMissionUpdateWithoutTechnicienInput, RapportMissionUncheckedUpdateWithoutTechnicienInput>
  }

  export type RapportMissionUpdateManyWithWhereWithoutTechnicienInput = {
    where: RapportMissionScalarWhereInput
    data: XOR<RapportMissionUpdateManyMutationInput, RapportMissionUncheckedUpdateManyWithoutTechnicienInput>
  }

  export type RapportMissionScalarWhereInput = {
    AND?: RapportMissionScalarWhereInput | RapportMissionScalarWhereInput[]
    OR?: RapportMissionScalarWhereInput[]
    NOT?: RapportMissionScalarWhereInput | RapportMissionScalarWhereInput[]
    id?: IntFilter<"RapportMission"> | number
    titre?: StringFilter<"RapportMission"> | string
    contenu?: StringFilter<"RapportMission"> | string
    interventionId?: IntNullableFilter<"RapportMission"> | number | null
    technicienId?: IntFilter<"RapportMission"> | number
    missionId?: StringFilter<"RapportMission"> | string
    createdById?: IntNullableFilter<"RapportMission"> | number | null
    statut?: StringFilter<"RapportMission"> | string
    dateValidation?: DateTimeNullableFilter<"RapportMission"> | Date | string | null
    commentaire?: StringNullableFilter<"RapportMission"> | string | null
    createdAt?: DateTimeFilter<"RapportMission"> | Date | string
    updatedAt?: DateTimeFilter<"RapportMission"> | Date | string
  }

  export type SortieMaterielUpsertWithWhereUniqueWithoutTechnicienInput = {
    where: SortieMaterielWhereUniqueInput
    update: XOR<SortieMaterielUpdateWithoutTechnicienInput, SortieMaterielUncheckedUpdateWithoutTechnicienInput>
    create: XOR<SortieMaterielCreateWithoutTechnicienInput, SortieMaterielUncheckedCreateWithoutTechnicienInput>
  }

  export type SortieMaterielUpdateWithWhereUniqueWithoutTechnicienInput = {
    where: SortieMaterielWhereUniqueInput
    data: XOR<SortieMaterielUpdateWithoutTechnicienInput, SortieMaterielUncheckedUpdateWithoutTechnicienInput>
  }

  export type SortieMaterielUpdateManyWithWhereWithoutTechnicienInput = {
    where: SortieMaterielScalarWhereInput
    data: XOR<SortieMaterielUpdateManyMutationInput, SortieMaterielUncheckedUpdateManyWithoutTechnicienInput>
  }

  export type SortieMaterielScalarWhereInput = {
    AND?: SortieMaterielScalarWhereInput | SortieMaterielScalarWhereInput[]
    OR?: SortieMaterielScalarWhereInput[]
    NOT?: SortieMaterielScalarWhereInput | SortieMaterielScalarWhereInput[]
    id?: IntFilter<"SortieMateriel"> | number
    materielId?: IntFilter<"SortieMateriel"> | number
    interventionId?: IntFilter<"SortieMateriel"> | number
    technicienId?: IntFilter<"SortieMateriel"> | number
    quantite?: IntFilter<"SortieMateriel"> | number
    dateSortie?: DateTimeFilter<"SortieMateriel"> | Date | string
    motif?: StringNullableFilter<"SortieMateriel"> | string | null
    retourne?: BoolFilter<"SortieMateriel"> | boolean
    dateRetour?: DateTimeNullableFilter<"SortieMateriel"> | Date | string | null
    quantiteRetour?: IntNullableFilter<"SortieMateriel"> | number | null
    commentaire?: StringNullableFilter<"SortieMateriel"> | string | null
    createdAt?: DateTimeFilter<"SortieMateriel"> | Date | string
  }

  export type CustomerCreateWithoutMissionsInput = {
    customerNumber: string
    type?: $Enums.CustomerType
    name: string
    legalName?: string | null
    siret?: string | null
    vatNumber?: string | null
    email?: string | null
    phone?: string | null
    mobile?: string | null
    website?: string | null
    paymentTerms?: number
    paymentMethod?: $Enums.PaymentMethod
    creditLimit?: number
    discountRate?: number
    category?: string | null
    tags?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    service?: ServiceCreateNestedOneWithoutCustomersInput
    creator: UserCreateNestedOneWithoutCreatedCustomersInput
    addresses?: CustomerAddressCreateNestedManyWithoutCustomerInput
    quotes?: QuoteCreateNestedManyWithoutCustomerInput
    invoices?: InvoiceCreateNestedManyWithoutCustomerInput
    payments?: PaymentCreateNestedManyWithoutCustomerInput
    recurringInvoices?: RecurringInvoiceCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutMissionsInput = {
    id?: number
    customerNumber: string
    type?: $Enums.CustomerType
    name: string
    legalName?: string | null
    siret?: string | null
    vatNumber?: string | null
    email?: string | null
    phone?: string | null
    mobile?: string | null
    website?: string | null
    paymentTerms?: number
    paymentMethod?: $Enums.PaymentMethod
    creditLimit?: number
    discountRate?: number
    category?: string | null
    tags?: string | null
    notes?: string | null
    isActive?: boolean
    serviceId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: number
    addresses?: CustomerAddressUncheckedCreateNestedManyWithoutCustomerInput
    quotes?: QuoteUncheckedCreateNestedManyWithoutCustomerInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCustomerInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCustomerInput
    recurringInvoices?: RecurringInvoiceUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutMissionsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutMissionsInput, CustomerUncheckedCreateWithoutMissionsInput>
  }

  export type InterventionCreateWithoutMissionInput = {
    dateHeureDebut: Date | string
    dateHeureFin?: Date | string | null
    duree?: number | null
    statut?: string
    commentaire?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    techniciens?: TechnicienInterventionCreateNestedManyWithoutInterventionInput
    rapports?: RapportMissionCreateNestedManyWithoutInterventionInput
    sortiesMateriels?: SortieMaterielCreateNestedManyWithoutInterventionInput
  }

  export type InterventionUncheckedCreateWithoutMissionInput = {
    id?: number
    dateHeureDebut: Date | string
    dateHeureFin?: Date | string | null
    duree?: number | null
    statut?: string
    commentaire?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    techniciens?: TechnicienInterventionUncheckedCreateNestedManyWithoutInterventionInput
    rapports?: RapportMissionUncheckedCreateNestedManyWithoutInterventionInput
    sortiesMateriels?: SortieMaterielUncheckedCreateNestedManyWithoutInterventionInput
  }

  export type InterventionCreateOrConnectWithoutMissionInput = {
    where: InterventionWhereUniqueInput
    create: XOR<InterventionCreateWithoutMissionInput, InterventionUncheckedCreateWithoutMissionInput>
  }

  export type InterventionCreateManyMissionInputEnvelope = {
    data: InterventionCreateManyMissionInput | InterventionCreateManyMissionInput[]
    skipDuplicates?: boolean
  }

  export type RapportMissionCreateWithoutMissionInput = {
    titre: string
    contenu: string
    createdById?: number | null
    statut?: string
    dateValidation?: Date | string | null
    commentaire?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    intervention?: InterventionCreateNestedOneWithoutRapportsInput
    technicien: TechnicienCreateNestedOneWithoutRapportsInput
    images?: RapportImageCreateNestedManyWithoutRapportInput
  }

  export type RapportMissionUncheckedCreateWithoutMissionInput = {
    id?: number
    titre: string
    contenu: string
    interventionId?: number | null
    technicienId: number
    createdById?: number | null
    statut?: string
    dateValidation?: Date | string | null
    commentaire?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: RapportImageUncheckedCreateNestedManyWithoutRapportInput
  }

  export type RapportMissionCreateOrConnectWithoutMissionInput = {
    where: RapportMissionWhereUniqueInput
    create: XOR<RapportMissionCreateWithoutMissionInput, RapportMissionUncheckedCreateWithoutMissionInput>
  }

  export type RapportMissionCreateManyMissionInputEnvelope = {
    data: RapportMissionCreateManyMissionInput | RapportMissionCreateManyMissionInput[]
    skipDuplicates?: boolean
  }

  export type QuoteCreateWithoutMissionsInput = {
    quoteNumber: string
    status?: $Enums.QuoteStatus
    quoteDate: Date | string
    validUntil: Date | string
    subtotalHt?: number
    discountAmount?: number
    totalVat?: number
    totalTtc?: number
    terms?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt?: Date | string | null
    submittedForServiceApprovalAt?: Date | string | null
    serviceManagerApprovalDate?: Date | string | null
    serviceManagerComments?: string | null
    dgApprovalDate?: Date | string | null
    dgComments?: string | null
    acceptedAt?: Date | string | null
    customer: CustomerCreateNestedOneWithoutQuotesInput
    customerAddress?: CustomerAddressCreateNestedOneWithoutQuotesInput
    creator: UserCreateNestedOneWithoutCreatedQuotesInput
    serviceManager?: UserCreateNestedOneWithoutServiceApprovalsInput
    dgApprover?: UserCreateNestedOneWithoutDgApprovalsInput
    items?: QuoteItemCreateNestedManyWithoutQuoteInput
    invoices?: InvoiceCreateNestedManyWithoutQuoteInput
    approvals?: QuoteApprovalCreateNestedManyWithoutQuoteInput
  }

  export type QuoteUncheckedCreateWithoutMissionsInput = {
    id?: number
    quoteNumber: string
    customerId: number
    customerAddressId?: number | null
    status?: $Enums.QuoteStatus
    quoteDate: Date | string
    validUntil: Date | string
    subtotalHt?: number
    discountAmount?: number
    totalVat?: number
    totalTtc?: number
    terms?: string | null
    notes?: string | null
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt?: Date | string | null
    submittedForServiceApprovalAt?: Date | string | null
    serviceManagerApprovedBy?: number | null
    serviceManagerApprovalDate?: Date | string | null
    serviceManagerComments?: string | null
    dgApprovedBy?: number | null
    dgApprovalDate?: Date | string | null
    dgComments?: string | null
    acceptedAt?: Date | string | null
    items?: QuoteItemUncheckedCreateNestedManyWithoutQuoteInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutQuoteInput
    approvals?: QuoteApprovalUncheckedCreateNestedManyWithoutQuoteInput
  }

  export type QuoteCreateOrConnectWithoutMissionsInput = {
    where: QuoteWhereUniqueInput
    create: XOR<QuoteCreateWithoutMissionsInput, QuoteUncheckedCreateWithoutMissionsInput>
  }

  export type CustomerUpsertWithoutMissionsInput = {
    update: XOR<CustomerUpdateWithoutMissionsInput, CustomerUncheckedUpdateWithoutMissionsInput>
    create: XOR<CustomerCreateWithoutMissionsInput, CustomerUncheckedCreateWithoutMissionsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutMissionsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutMissionsInput, CustomerUncheckedUpdateWithoutMissionsInput>
  }

  export type CustomerUpdateWithoutMissionsInput = {
    customerNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    siret?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: IntFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    creditLimit?: FloatFieldUpdateOperationsInput | number
    discountRate?: FloatFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneWithoutCustomersNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedCustomersNestedInput
    addresses?: CustomerAddressUpdateManyWithoutCustomerNestedInput
    quotes?: QuoteUpdateManyWithoutCustomerNestedInput
    invoices?: InvoiceUpdateManyWithoutCustomerNestedInput
    payments?: PaymentUpdateManyWithoutCustomerNestedInput
    recurringInvoices?: RecurringInvoiceUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutMissionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    siret?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: IntFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    creditLimit?: FloatFieldUpdateOperationsInput | number
    discountRate?: FloatFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    serviceId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    addresses?: CustomerAddressUncheckedUpdateManyWithoutCustomerNestedInput
    quotes?: QuoteUncheckedUpdateManyWithoutCustomerNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCustomerNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCustomerNestedInput
    recurringInvoices?: RecurringInvoiceUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type InterventionUpsertWithWhereUniqueWithoutMissionInput = {
    where: InterventionWhereUniqueInput
    update: XOR<InterventionUpdateWithoutMissionInput, InterventionUncheckedUpdateWithoutMissionInput>
    create: XOR<InterventionCreateWithoutMissionInput, InterventionUncheckedCreateWithoutMissionInput>
  }

  export type InterventionUpdateWithWhereUniqueWithoutMissionInput = {
    where: InterventionWhereUniqueInput
    data: XOR<InterventionUpdateWithoutMissionInput, InterventionUncheckedUpdateWithoutMissionInput>
  }

  export type InterventionUpdateManyWithWhereWithoutMissionInput = {
    where: InterventionScalarWhereInput
    data: XOR<InterventionUpdateManyMutationInput, InterventionUncheckedUpdateManyWithoutMissionInput>
  }

  export type InterventionScalarWhereInput = {
    AND?: InterventionScalarWhereInput | InterventionScalarWhereInput[]
    OR?: InterventionScalarWhereInput[]
    NOT?: InterventionScalarWhereInput | InterventionScalarWhereInput[]
    id?: IntFilter<"Intervention"> | number
    dateHeureDebut?: DateTimeFilter<"Intervention"> | Date | string
    dateHeureFin?: DateTimeNullableFilter<"Intervention"> | Date | string | null
    duree?: IntNullableFilter<"Intervention"> | number | null
    missionId?: StringFilter<"Intervention"> | string
    statut?: StringFilter<"Intervention"> | string
    commentaire?: StringNullableFilter<"Intervention"> | string | null
    createdAt?: DateTimeFilter<"Intervention"> | Date | string
    updatedAt?: DateTimeFilter<"Intervention"> | Date | string
  }

  export type RapportMissionUpsertWithWhereUniqueWithoutMissionInput = {
    where: RapportMissionWhereUniqueInput
    update: XOR<RapportMissionUpdateWithoutMissionInput, RapportMissionUncheckedUpdateWithoutMissionInput>
    create: XOR<RapportMissionCreateWithoutMissionInput, RapportMissionUncheckedCreateWithoutMissionInput>
  }

  export type RapportMissionUpdateWithWhereUniqueWithoutMissionInput = {
    where: RapportMissionWhereUniqueInput
    data: XOR<RapportMissionUpdateWithoutMissionInput, RapportMissionUncheckedUpdateWithoutMissionInput>
  }

  export type RapportMissionUpdateManyWithWhereWithoutMissionInput = {
    where: RapportMissionScalarWhereInput
    data: XOR<RapportMissionUpdateManyMutationInput, RapportMissionUncheckedUpdateManyWithoutMissionInput>
  }

  export type QuoteUpsertWithWhereUniqueWithoutMissionsInput = {
    where: QuoteWhereUniqueInput
    update: XOR<QuoteUpdateWithoutMissionsInput, QuoteUncheckedUpdateWithoutMissionsInput>
    create: XOR<QuoteCreateWithoutMissionsInput, QuoteUncheckedCreateWithoutMissionsInput>
  }

  export type QuoteUpdateWithWhereUniqueWithoutMissionsInput = {
    where: QuoteWhereUniqueInput
    data: XOR<QuoteUpdateWithoutMissionsInput, QuoteUncheckedUpdateWithoutMissionsInput>
  }

  export type QuoteUpdateManyWithWhereWithoutMissionsInput = {
    where: QuoteScalarWhereInput
    data: XOR<QuoteUpdateManyMutationInput, QuoteUncheckedUpdateManyWithoutMissionsInput>
  }

  export type MissionCreateWithoutInterventionsInput = {
    numIntervention: string
    natureIntervention: string
    objectifDuContrat: string
    description?: string | null
    priorite?: string | null
    statut?: string | null
    dateSortieFicheIntervention: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    client: CustomerCreateNestedOneWithoutMissionsInput
    rapports?: RapportMissionCreateNestedManyWithoutMissionInput
    devis?: QuoteCreateNestedManyWithoutMissionsInput
  }

  export type MissionUncheckedCreateWithoutInterventionsInput = {
    numIntervention: string
    natureIntervention: string
    objectifDuContrat: string
    description?: string | null
    priorite?: string | null
    statut?: string | null
    dateSortieFicheIntervention: Date | string
    clientId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    rapports?: RapportMissionUncheckedCreateNestedManyWithoutMissionInput
    devis?: QuoteUncheckedCreateNestedManyWithoutMissionsInput
  }

  export type MissionCreateOrConnectWithoutInterventionsInput = {
    where: MissionWhereUniqueInput
    create: XOR<MissionCreateWithoutInterventionsInput, MissionUncheckedCreateWithoutInterventionsInput>
  }

  export type TechnicienInterventionCreateWithoutInterventionInput = {
    role?: string
    commentaire?: string | null
    createdAt?: Date | string
    technicien: TechnicienCreateNestedOneWithoutInterventionsInput
  }

  export type TechnicienInterventionUncheckedCreateWithoutInterventionInput = {
    id?: number
    technicienId: number
    role?: string
    commentaire?: string | null
    createdAt?: Date | string
  }

  export type TechnicienInterventionCreateOrConnectWithoutInterventionInput = {
    where: TechnicienInterventionWhereUniqueInput
    create: XOR<TechnicienInterventionCreateWithoutInterventionInput, TechnicienInterventionUncheckedCreateWithoutInterventionInput>
  }

  export type TechnicienInterventionCreateManyInterventionInputEnvelope = {
    data: TechnicienInterventionCreateManyInterventionInput | TechnicienInterventionCreateManyInterventionInput[]
    skipDuplicates?: boolean
  }

  export type RapportMissionCreateWithoutInterventionInput = {
    titre: string
    contenu: string
    createdById?: number | null
    statut?: string
    dateValidation?: Date | string | null
    commentaire?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    technicien: TechnicienCreateNestedOneWithoutRapportsInput
    mission: MissionCreateNestedOneWithoutRapportsInput
    images?: RapportImageCreateNestedManyWithoutRapportInput
  }

  export type RapportMissionUncheckedCreateWithoutInterventionInput = {
    id?: number
    titre: string
    contenu: string
    technicienId: number
    missionId: string
    createdById?: number | null
    statut?: string
    dateValidation?: Date | string | null
    commentaire?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: RapportImageUncheckedCreateNestedManyWithoutRapportInput
  }

  export type RapportMissionCreateOrConnectWithoutInterventionInput = {
    where: RapportMissionWhereUniqueInput
    create: XOR<RapportMissionCreateWithoutInterventionInput, RapportMissionUncheckedCreateWithoutInterventionInput>
  }

  export type RapportMissionCreateManyInterventionInputEnvelope = {
    data: RapportMissionCreateManyInterventionInput | RapportMissionCreateManyInterventionInput[]
    skipDuplicates?: boolean
  }

  export type SortieMaterielCreateWithoutInterventionInput = {
    quantite: number
    dateSortie?: Date | string
    motif?: string | null
    retourne?: boolean
    dateRetour?: Date | string | null
    quantiteRetour?: number | null
    commentaire?: string | null
    createdAt?: Date | string
    materiel: MaterielCreateNestedOneWithoutSortiesInput
    technicien: TechnicienCreateNestedOneWithoutSortiesMaterielsInput
  }

  export type SortieMaterielUncheckedCreateWithoutInterventionInput = {
    id?: number
    materielId: number
    technicienId: number
    quantite: number
    dateSortie?: Date | string
    motif?: string | null
    retourne?: boolean
    dateRetour?: Date | string | null
    quantiteRetour?: number | null
    commentaire?: string | null
    createdAt?: Date | string
  }

  export type SortieMaterielCreateOrConnectWithoutInterventionInput = {
    where: SortieMaterielWhereUniqueInput
    create: XOR<SortieMaterielCreateWithoutInterventionInput, SortieMaterielUncheckedCreateWithoutInterventionInput>
  }

  export type SortieMaterielCreateManyInterventionInputEnvelope = {
    data: SortieMaterielCreateManyInterventionInput | SortieMaterielCreateManyInterventionInput[]
    skipDuplicates?: boolean
  }

  export type MissionUpsertWithoutInterventionsInput = {
    update: XOR<MissionUpdateWithoutInterventionsInput, MissionUncheckedUpdateWithoutInterventionsInput>
    create: XOR<MissionCreateWithoutInterventionsInput, MissionUncheckedCreateWithoutInterventionsInput>
    where?: MissionWhereInput
  }

  export type MissionUpdateToOneWithWhereWithoutInterventionsInput = {
    where?: MissionWhereInput
    data: XOR<MissionUpdateWithoutInterventionsInput, MissionUncheckedUpdateWithoutInterventionsInput>
  }

  export type MissionUpdateWithoutInterventionsInput = {
    numIntervention?: StringFieldUpdateOperationsInput | string
    natureIntervention?: StringFieldUpdateOperationsInput | string
    objectifDuContrat?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priorite?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: NullableStringFieldUpdateOperationsInput | string | null
    dateSortieFicheIntervention?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: CustomerUpdateOneRequiredWithoutMissionsNestedInput
    rapports?: RapportMissionUpdateManyWithoutMissionNestedInput
    devis?: QuoteUpdateManyWithoutMissionsNestedInput
  }

  export type MissionUncheckedUpdateWithoutInterventionsInput = {
    numIntervention?: StringFieldUpdateOperationsInput | string
    natureIntervention?: StringFieldUpdateOperationsInput | string
    objectifDuContrat?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priorite?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: NullableStringFieldUpdateOperationsInput | string | null
    dateSortieFicheIntervention?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rapports?: RapportMissionUncheckedUpdateManyWithoutMissionNestedInput
    devis?: QuoteUncheckedUpdateManyWithoutMissionsNestedInput
  }

  export type TechnicienInterventionUpsertWithWhereUniqueWithoutInterventionInput = {
    where: TechnicienInterventionWhereUniqueInput
    update: XOR<TechnicienInterventionUpdateWithoutInterventionInput, TechnicienInterventionUncheckedUpdateWithoutInterventionInput>
    create: XOR<TechnicienInterventionCreateWithoutInterventionInput, TechnicienInterventionUncheckedCreateWithoutInterventionInput>
  }

  export type TechnicienInterventionUpdateWithWhereUniqueWithoutInterventionInput = {
    where: TechnicienInterventionWhereUniqueInput
    data: XOR<TechnicienInterventionUpdateWithoutInterventionInput, TechnicienInterventionUncheckedUpdateWithoutInterventionInput>
  }

  export type TechnicienInterventionUpdateManyWithWhereWithoutInterventionInput = {
    where: TechnicienInterventionScalarWhereInput
    data: XOR<TechnicienInterventionUpdateManyMutationInput, TechnicienInterventionUncheckedUpdateManyWithoutInterventionInput>
  }

  export type RapportMissionUpsertWithWhereUniqueWithoutInterventionInput = {
    where: RapportMissionWhereUniqueInput
    update: XOR<RapportMissionUpdateWithoutInterventionInput, RapportMissionUncheckedUpdateWithoutInterventionInput>
    create: XOR<RapportMissionCreateWithoutInterventionInput, RapportMissionUncheckedCreateWithoutInterventionInput>
  }

  export type RapportMissionUpdateWithWhereUniqueWithoutInterventionInput = {
    where: RapportMissionWhereUniqueInput
    data: XOR<RapportMissionUpdateWithoutInterventionInput, RapportMissionUncheckedUpdateWithoutInterventionInput>
  }

  export type RapportMissionUpdateManyWithWhereWithoutInterventionInput = {
    where: RapportMissionScalarWhereInput
    data: XOR<RapportMissionUpdateManyMutationInput, RapportMissionUncheckedUpdateManyWithoutInterventionInput>
  }

  export type SortieMaterielUpsertWithWhereUniqueWithoutInterventionInput = {
    where: SortieMaterielWhereUniqueInput
    update: XOR<SortieMaterielUpdateWithoutInterventionInput, SortieMaterielUncheckedUpdateWithoutInterventionInput>
    create: XOR<SortieMaterielCreateWithoutInterventionInput, SortieMaterielUncheckedCreateWithoutInterventionInput>
  }

  export type SortieMaterielUpdateWithWhereUniqueWithoutInterventionInput = {
    where: SortieMaterielWhereUniqueInput
    data: XOR<SortieMaterielUpdateWithoutInterventionInput, SortieMaterielUncheckedUpdateWithoutInterventionInput>
  }

  export type SortieMaterielUpdateManyWithWhereWithoutInterventionInput = {
    where: SortieMaterielScalarWhereInput
    data: XOR<SortieMaterielUpdateManyMutationInput, SortieMaterielUncheckedUpdateManyWithoutInterventionInput>
  }

  export type TechnicienCreateWithoutInterventionsInput = {
    nom: string
    prenom: string
    contact: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    specialite: SpecialiteCreateNestedOneWithoutTechniciensInput
    utilisateur?: UserCreateNestedOneWithoutTechnicienInput
    rapports?: RapportMissionCreateNestedManyWithoutTechnicienInput
    sortiesMateriels?: SortieMaterielCreateNestedManyWithoutTechnicienInput
  }

  export type TechnicienUncheckedCreateWithoutInterventionsInput = {
    id?: number
    nom: string
    prenom: string
    contact: string
    specialiteId: number
    utilisateurId?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    rapports?: RapportMissionUncheckedCreateNestedManyWithoutTechnicienInput
    sortiesMateriels?: SortieMaterielUncheckedCreateNestedManyWithoutTechnicienInput
  }

  export type TechnicienCreateOrConnectWithoutInterventionsInput = {
    where: TechnicienWhereUniqueInput
    create: XOR<TechnicienCreateWithoutInterventionsInput, TechnicienUncheckedCreateWithoutInterventionsInput>
  }

  export type InterventionCreateWithoutTechniciensInput = {
    dateHeureDebut: Date | string
    dateHeureFin?: Date | string | null
    duree?: number | null
    statut?: string
    commentaire?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    mission: MissionCreateNestedOneWithoutInterventionsInput
    rapports?: RapportMissionCreateNestedManyWithoutInterventionInput
    sortiesMateriels?: SortieMaterielCreateNestedManyWithoutInterventionInput
  }

  export type InterventionUncheckedCreateWithoutTechniciensInput = {
    id?: number
    dateHeureDebut: Date | string
    dateHeureFin?: Date | string | null
    duree?: number | null
    missionId: string
    statut?: string
    commentaire?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rapports?: RapportMissionUncheckedCreateNestedManyWithoutInterventionInput
    sortiesMateriels?: SortieMaterielUncheckedCreateNestedManyWithoutInterventionInput
  }

  export type InterventionCreateOrConnectWithoutTechniciensInput = {
    where: InterventionWhereUniqueInput
    create: XOR<InterventionCreateWithoutTechniciensInput, InterventionUncheckedCreateWithoutTechniciensInput>
  }

  export type TechnicienUpsertWithoutInterventionsInput = {
    update: XOR<TechnicienUpdateWithoutInterventionsInput, TechnicienUncheckedUpdateWithoutInterventionsInput>
    create: XOR<TechnicienCreateWithoutInterventionsInput, TechnicienUncheckedCreateWithoutInterventionsInput>
    where?: TechnicienWhereInput
  }

  export type TechnicienUpdateToOneWithWhereWithoutInterventionsInput = {
    where?: TechnicienWhereInput
    data: XOR<TechnicienUpdateWithoutInterventionsInput, TechnicienUncheckedUpdateWithoutInterventionsInput>
  }

  export type TechnicienUpdateWithoutInterventionsInput = {
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    specialite?: SpecialiteUpdateOneRequiredWithoutTechniciensNestedInput
    utilisateur?: UserUpdateOneWithoutTechnicienNestedInput
    rapports?: RapportMissionUpdateManyWithoutTechnicienNestedInput
    sortiesMateriels?: SortieMaterielUpdateManyWithoutTechnicienNestedInput
  }

  export type TechnicienUncheckedUpdateWithoutInterventionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    specialiteId?: IntFieldUpdateOperationsInput | number
    utilisateurId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rapports?: RapportMissionUncheckedUpdateManyWithoutTechnicienNestedInput
    sortiesMateriels?: SortieMaterielUncheckedUpdateManyWithoutTechnicienNestedInput
  }

  export type InterventionUpsertWithoutTechniciensInput = {
    update: XOR<InterventionUpdateWithoutTechniciensInput, InterventionUncheckedUpdateWithoutTechniciensInput>
    create: XOR<InterventionCreateWithoutTechniciensInput, InterventionUncheckedCreateWithoutTechniciensInput>
    where?: InterventionWhereInput
  }

  export type InterventionUpdateToOneWithWhereWithoutTechniciensInput = {
    where?: InterventionWhereInput
    data: XOR<InterventionUpdateWithoutTechniciensInput, InterventionUncheckedUpdateWithoutTechniciensInput>
  }

  export type InterventionUpdateWithoutTechniciensInput = {
    dateHeureDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateHeureFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duree?: NullableIntFieldUpdateOperationsInput | number | null
    statut?: StringFieldUpdateOperationsInput | string
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mission?: MissionUpdateOneRequiredWithoutInterventionsNestedInput
    rapports?: RapportMissionUpdateManyWithoutInterventionNestedInput
    sortiesMateriels?: SortieMaterielUpdateManyWithoutInterventionNestedInput
  }

  export type InterventionUncheckedUpdateWithoutTechniciensInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateHeureDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateHeureFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duree?: NullableIntFieldUpdateOperationsInput | number | null
    missionId?: StringFieldUpdateOperationsInput | string
    statut?: StringFieldUpdateOperationsInput | string
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rapports?: RapportMissionUncheckedUpdateManyWithoutInterventionNestedInput
    sortiesMateriels?: SortieMaterielUncheckedUpdateManyWithoutInterventionNestedInput
  }

  export type InterventionCreateWithoutRapportsInput = {
    dateHeureDebut: Date | string
    dateHeureFin?: Date | string | null
    duree?: number | null
    statut?: string
    commentaire?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    mission: MissionCreateNestedOneWithoutInterventionsInput
    techniciens?: TechnicienInterventionCreateNestedManyWithoutInterventionInput
    sortiesMateriels?: SortieMaterielCreateNestedManyWithoutInterventionInput
  }

  export type InterventionUncheckedCreateWithoutRapportsInput = {
    id?: number
    dateHeureDebut: Date | string
    dateHeureFin?: Date | string | null
    duree?: number | null
    missionId: string
    statut?: string
    commentaire?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    techniciens?: TechnicienInterventionUncheckedCreateNestedManyWithoutInterventionInput
    sortiesMateriels?: SortieMaterielUncheckedCreateNestedManyWithoutInterventionInput
  }

  export type InterventionCreateOrConnectWithoutRapportsInput = {
    where: InterventionWhereUniqueInput
    create: XOR<InterventionCreateWithoutRapportsInput, InterventionUncheckedCreateWithoutRapportsInput>
  }

  export type TechnicienCreateWithoutRapportsInput = {
    nom: string
    prenom: string
    contact: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    specialite: SpecialiteCreateNestedOneWithoutTechniciensInput
    utilisateur?: UserCreateNestedOneWithoutTechnicienInput
    interventions?: TechnicienInterventionCreateNestedManyWithoutTechnicienInput
    sortiesMateriels?: SortieMaterielCreateNestedManyWithoutTechnicienInput
  }

  export type TechnicienUncheckedCreateWithoutRapportsInput = {
    id?: number
    nom: string
    prenom: string
    contact: string
    specialiteId: number
    utilisateurId?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    interventions?: TechnicienInterventionUncheckedCreateNestedManyWithoutTechnicienInput
    sortiesMateriels?: SortieMaterielUncheckedCreateNestedManyWithoutTechnicienInput
  }

  export type TechnicienCreateOrConnectWithoutRapportsInput = {
    where: TechnicienWhereUniqueInput
    create: XOR<TechnicienCreateWithoutRapportsInput, TechnicienUncheckedCreateWithoutRapportsInput>
  }

  export type MissionCreateWithoutRapportsInput = {
    numIntervention: string
    natureIntervention: string
    objectifDuContrat: string
    description?: string | null
    priorite?: string | null
    statut?: string | null
    dateSortieFicheIntervention: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    client: CustomerCreateNestedOneWithoutMissionsInput
    interventions?: InterventionCreateNestedManyWithoutMissionInput
    devis?: QuoteCreateNestedManyWithoutMissionsInput
  }

  export type MissionUncheckedCreateWithoutRapportsInput = {
    numIntervention: string
    natureIntervention: string
    objectifDuContrat: string
    description?: string | null
    priorite?: string | null
    statut?: string | null
    dateSortieFicheIntervention: Date | string
    clientId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    interventions?: InterventionUncheckedCreateNestedManyWithoutMissionInput
    devis?: QuoteUncheckedCreateNestedManyWithoutMissionsInput
  }

  export type MissionCreateOrConnectWithoutRapportsInput = {
    where: MissionWhereUniqueInput
    create: XOR<MissionCreateWithoutRapportsInput, MissionUncheckedCreateWithoutRapportsInput>
  }

  export type RapportImageCreateWithoutRapportInput = {
    url: string
    description?: string | null
    ordre: number
    createdAt?: Date | string
  }

  export type RapportImageUncheckedCreateWithoutRapportInput = {
    id?: number
    url: string
    description?: string | null
    ordre: number
    createdAt?: Date | string
  }

  export type RapportImageCreateOrConnectWithoutRapportInput = {
    where: RapportImageWhereUniqueInput
    create: XOR<RapportImageCreateWithoutRapportInput, RapportImageUncheckedCreateWithoutRapportInput>
  }

  export type RapportImageCreateManyRapportInputEnvelope = {
    data: RapportImageCreateManyRapportInput | RapportImageCreateManyRapportInput[]
    skipDuplicates?: boolean
  }

  export type InterventionUpsertWithoutRapportsInput = {
    update: XOR<InterventionUpdateWithoutRapportsInput, InterventionUncheckedUpdateWithoutRapportsInput>
    create: XOR<InterventionCreateWithoutRapportsInput, InterventionUncheckedCreateWithoutRapportsInput>
    where?: InterventionWhereInput
  }

  export type InterventionUpdateToOneWithWhereWithoutRapportsInput = {
    where?: InterventionWhereInput
    data: XOR<InterventionUpdateWithoutRapportsInput, InterventionUncheckedUpdateWithoutRapportsInput>
  }

  export type InterventionUpdateWithoutRapportsInput = {
    dateHeureDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateHeureFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duree?: NullableIntFieldUpdateOperationsInput | number | null
    statut?: StringFieldUpdateOperationsInput | string
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mission?: MissionUpdateOneRequiredWithoutInterventionsNestedInput
    techniciens?: TechnicienInterventionUpdateManyWithoutInterventionNestedInput
    sortiesMateriels?: SortieMaterielUpdateManyWithoutInterventionNestedInput
  }

  export type InterventionUncheckedUpdateWithoutRapportsInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateHeureDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateHeureFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duree?: NullableIntFieldUpdateOperationsInput | number | null
    missionId?: StringFieldUpdateOperationsInput | string
    statut?: StringFieldUpdateOperationsInput | string
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    techniciens?: TechnicienInterventionUncheckedUpdateManyWithoutInterventionNestedInput
    sortiesMateriels?: SortieMaterielUncheckedUpdateManyWithoutInterventionNestedInput
  }

  export type TechnicienUpsertWithoutRapportsInput = {
    update: XOR<TechnicienUpdateWithoutRapportsInput, TechnicienUncheckedUpdateWithoutRapportsInput>
    create: XOR<TechnicienCreateWithoutRapportsInput, TechnicienUncheckedCreateWithoutRapportsInput>
    where?: TechnicienWhereInput
  }

  export type TechnicienUpdateToOneWithWhereWithoutRapportsInput = {
    where?: TechnicienWhereInput
    data: XOR<TechnicienUpdateWithoutRapportsInput, TechnicienUncheckedUpdateWithoutRapportsInput>
  }

  export type TechnicienUpdateWithoutRapportsInput = {
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    specialite?: SpecialiteUpdateOneRequiredWithoutTechniciensNestedInput
    utilisateur?: UserUpdateOneWithoutTechnicienNestedInput
    interventions?: TechnicienInterventionUpdateManyWithoutTechnicienNestedInput
    sortiesMateriels?: SortieMaterielUpdateManyWithoutTechnicienNestedInput
  }

  export type TechnicienUncheckedUpdateWithoutRapportsInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    specialiteId?: IntFieldUpdateOperationsInput | number
    utilisateurId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interventions?: TechnicienInterventionUncheckedUpdateManyWithoutTechnicienNestedInput
    sortiesMateriels?: SortieMaterielUncheckedUpdateManyWithoutTechnicienNestedInput
  }

  export type MissionUpsertWithoutRapportsInput = {
    update: XOR<MissionUpdateWithoutRapportsInput, MissionUncheckedUpdateWithoutRapportsInput>
    create: XOR<MissionCreateWithoutRapportsInput, MissionUncheckedCreateWithoutRapportsInput>
    where?: MissionWhereInput
  }

  export type MissionUpdateToOneWithWhereWithoutRapportsInput = {
    where?: MissionWhereInput
    data: XOR<MissionUpdateWithoutRapportsInput, MissionUncheckedUpdateWithoutRapportsInput>
  }

  export type MissionUpdateWithoutRapportsInput = {
    numIntervention?: StringFieldUpdateOperationsInput | string
    natureIntervention?: StringFieldUpdateOperationsInput | string
    objectifDuContrat?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priorite?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: NullableStringFieldUpdateOperationsInput | string | null
    dateSortieFicheIntervention?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: CustomerUpdateOneRequiredWithoutMissionsNestedInput
    interventions?: InterventionUpdateManyWithoutMissionNestedInput
    devis?: QuoteUpdateManyWithoutMissionsNestedInput
  }

  export type MissionUncheckedUpdateWithoutRapportsInput = {
    numIntervention?: StringFieldUpdateOperationsInput | string
    natureIntervention?: StringFieldUpdateOperationsInput | string
    objectifDuContrat?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priorite?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: NullableStringFieldUpdateOperationsInput | string | null
    dateSortieFicheIntervention?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interventions?: InterventionUncheckedUpdateManyWithoutMissionNestedInput
    devis?: QuoteUncheckedUpdateManyWithoutMissionsNestedInput
  }

  export type RapportImageUpsertWithWhereUniqueWithoutRapportInput = {
    where: RapportImageWhereUniqueInput
    update: XOR<RapportImageUpdateWithoutRapportInput, RapportImageUncheckedUpdateWithoutRapportInput>
    create: XOR<RapportImageCreateWithoutRapportInput, RapportImageUncheckedCreateWithoutRapportInput>
  }

  export type RapportImageUpdateWithWhereUniqueWithoutRapportInput = {
    where: RapportImageWhereUniqueInput
    data: XOR<RapportImageUpdateWithoutRapportInput, RapportImageUncheckedUpdateWithoutRapportInput>
  }

  export type RapportImageUpdateManyWithWhereWithoutRapportInput = {
    where: RapportImageScalarWhereInput
    data: XOR<RapportImageUpdateManyMutationInput, RapportImageUncheckedUpdateManyWithoutRapportInput>
  }

  export type RapportImageScalarWhereInput = {
    AND?: RapportImageScalarWhereInput | RapportImageScalarWhereInput[]
    OR?: RapportImageScalarWhereInput[]
    NOT?: RapportImageScalarWhereInput | RapportImageScalarWhereInput[]
    id?: IntFilter<"RapportImage"> | number
    rapportId?: IntFilter<"RapportImage"> | number
    url?: StringFilter<"RapportImage"> | string
    description?: StringNullableFilter<"RapportImage"> | string | null
    ordre?: IntFilter<"RapportImage"> | number
    createdAt?: DateTimeFilter<"RapportImage"> | Date | string
  }

  export type RapportMissionCreateWithoutImagesInput = {
    titre: string
    contenu: string
    createdById?: number | null
    statut?: string
    dateValidation?: Date | string | null
    commentaire?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    intervention?: InterventionCreateNestedOneWithoutRapportsInput
    technicien: TechnicienCreateNestedOneWithoutRapportsInput
    mission: MissionCreateNestedOneWithoutRapportsInput
  }

  export type RapportMissionUncheckedCreateWithoutImagesInput = {
    id?: number
    titre: string
    contenu: string
    interventionId?: number | null
    technicienId: number
    missionId: string
    createdById?: number | null
    statut?: string
    dateValidation?: Date | string | null
    commentaire?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RapportMissionCreateOrConnectWithoutImagesInput = {
    where: RapportMissionWhereUniqueInput
    create: XOR<RapportMissionCreateWithoutImagesInput, RapportMissionUncheckedCreateWithoutImagesInput>
  }

  export type RapportMissionUpsertWithoutImagesInput = {
    update: XOR<RapportMissionUpdateWithoutImagesInput, RapportMissionUncheckedUpdateWithoutImagesInput>
    create: XOR<RapportMissionCreateWithoutImagesInput, RapportMissionUncheckedCreateWithoutImagesInput>
    where?: RapportMissionWhereInput
  }

  export type RapportMissionUpdateToOneWithWhereWithoutImagesInput = {
    where?: RapportMissionWhereInput
    data: XOR<RapportMissionUpdateWithoutImagesInput, RapportMissionUncheckedUpdateWithoutImagesInput>
  }

  export type RapportMissionUpdateWithoutImagesInput = {
    titre?: StringFieldUpdateOperationsInput | string
    contenu?: StringFieldUpdateOperationsInput | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    statut?: StringFieldUpdateOperationsInput | string
    dateValidation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intervention?: InterventionUpdateOneWithoutRapportsNestedInput
    technicien?: TechnicienUpdateOneRequiredWithoutRapportsNestedInput
    mission?: MissionUpdateOneRequiredWithoutRapportsNestedInput
  }

  export type RapportMissionUncheckedUpdateWithoutImagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    titre?: StringFieldUpdateOperationsInput | string
    contenu?: StringFieldUpdateOperationsInput | string
    interventionId?: NullableIntFieldUpdateOperationsInput | number | null
    technicienId?: IntFieldUpdateOperationsInput | number
    missionId?: StringFieldUpdateOperationsInput | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    statut?: StringFieldUpdateOperationsInput | string
    dateValidation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SortieMaterielCreateWithoutMaterielInput = {
    quantite: number
    dateSortie?: Date | string
    motif?: string | null
    retourne?: boolean
    dateRetour?: Date | string | null
    quantiteRetour?: number | null
    commentaire?: string | null
    createdAt?: Date | string
    intervention: InterventionCreateNestedOneWithoutSortiesMaterielsInput
    technicien: TechnicienCreateNestedOneWithoutSortiesMaterielsInput
  }

  export type SortieMaterielUncheckedCreateWithoutMaterielInput = {
    id?: number
    interventionId: number
    technicienId: number
    quantite: number
    dateSortie?: Date | string
    motif?: string | null
    retourne?: boolean
    dateRetour?: Date | string | null
    quantiteRetour?: number | null
    commentaire?: string | null
    createdAt?: Date | string
  }

  export type SortieMaterielCreateOrConnectWithoutMaterielInput = {
    where: SortieMaterielWhereUniqueInput
    create: XOR<SortieMaterielCreateWithoutMaterielInput, SortieMaterielUncheckedCreateWithoutMaterielInput>
  }

  export type SortieMaterielCreateManyMaterielInputEnvelope = {
    data: SortieMaterielCreateManyMaterielInput | SortieMaterielCreateManyMaterielInput[]
    skipDuplicates?: boolean
  }

  export type EntreeMaterielCreateWithoutMaterielInput = {
    quantite: number
    dateEntree?: Date | string
    source?: string
    prixTotal?: number | null
    fournisseur?: string | null
    facture?: string | null
    commentaire?: string | null
    createdAt?: Date | string
  }

  export type EntreeMaterielUncheckedCreateWithoutMaterielInput = {
    id?: number
    quantite: number
    dateEntree?: Date | string
    source?: string
    prixTotal?: number | null
    fournisseur?: string | null
    facture?: string | null
    commentaire?: string | null
    createdAt?: Date | string
  }

  export type EntreeMaterielCreateOrConnectWithoutMaterielInput = {
    where: EntreeMaterielWhereUniqueInput
    create: XOR<EntreeMaterielCreateWithoutMaterielInput, EntreeMaterielUncheckedCreateWithoutMaterielInput>
  }

  export type EntreeMaterielCreateManyMaterielInputEnvelope = {
    data: EntreeMaterielCreateManyMaterielInput | EntreeMaterielCreateManyMaterielInput[]
    skipDuplicates?: boolean
  }

  export type SortieMaterielUpsertWithWhereUniqueWithoutMaterielInput = {
    where: SortieMaterielWhereUniqueInput
    update: XOR<SortieMaterielUpdateWithoutMaterielInput, SortieMaterielUncheckedUpdateWithoutMaterielInput>
    create: XOR<SortieMaterielCreateWithoutMaterielInput, SortieMaterielUncheckedCreateWithoutMaterielInput>
  }

  export type SortieMaterielUpdateWithWhereUniqueWithoutMaterielInput = {
    where: SortieMaterielWhereUniqueInput
    data: XOR<SortieMaterielUpdateWithoutMaterielInput, SortieMaterielUncheckedUpdateWithoutMaterielInput>
  }

  export type SortieMaterielUpdateManyWithWhereWithoutMaterielInput = {
    where: SortieMaterielScalarWhereInput
    data: XOR<SortieMaterielUpdateManyMutationInput, SortieMaterielUncheckedUpdateManyWithoutMaterielInput>
  }

  export type EntreeMaterielUpsertWithWhereUniqueWithoutMaterielInput = {
    where: EntreeMaterielWhereUniqueInput
    update: XOR<EntreeMaterielUpdateWithoutMaterielInput, EntreeMaterielUncheckedUpdateWithoutMaterielInput>
    create: XOR<EntreeMaterielCreateWithoutMaterielInput, EntreeMaterielUncheckedCreateWithoutMaterielInput>
  }

  export type EntreeMaterielUpdateWithWhereUniqueWithoutMaterielInput = {
    where: EntreeMaterielWhereUniqueInput
    data: XOR<EntreeMaterielUpdateWithoutMaterielInput, EntreeMaterielUncheckedUpdateWithoutMaterielInput>
  }

  export type EntreeMaterielUpdateManyWithWhereWithoutMaterielInput = {
    where: EntreeMaterielScalarWhereInput
    data: XOR<EntreeMaterielUpdateManyMutationInput, EntreeMaterielUncheckedUpdateManyWithoutMaterielInput>
  }

  export type EntreeMaterielScalarWhereInput = {
    AND?: EntreeMaterielScalarWhereInput | EntreeMaterielScalarWhereInput[]
    OR?: EntreeMaterielScalarWhereInput[]
    NOT?: EntreeMaterielScalarWhereInput | EntreeMaterielScalarWhereInput[]
    id?: IntFilter<"EntreeMateriel"> | number
    materielId?: IntFilter<"EntreeMateriel"> | number
    quantite?: IntFilter<"EntreeMateriel"> | number
    dateEntree?: DateTimeFilter<"EntreeMateriel"> | Date | string
    source?: StringFilter<"EntreeMateriel"> | string
    prixTotal?: FloatNullableFilter<"EntreeMateriel"> | number | null
    fournisseur?: StringNullableFilter<"EntreeMateriel"> | string | null
    facture?: StringNullableFilter<"EntreeMateriel"> | string | null
    commentaire?: StringNullableFilter<"EntreeMateriel"> | string | null
    createdAt?: DateTimeFilter<"EntreeMateriel"> | Date | string
  }

  export type MaterielCreateWithoutSortiesInput = {
    reference: string
    designation: string
    description?: string | null
    quantiteTotale?: number
    quantiteDisponible?: number
    seuilAlerte?: number
    emplacement?: string | null
    categorie?: string
    prixUnitaire?: number | null
    fournisseur?: string | null
    dateAchat?: Date | string | null
    garantie?: string | null
    statut?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    entrees?: EntreeMaterielCreateNestedManyWithoutMaterielInput
  }

  export type MaterielUncheckedCreateWithoutSortiesInput = {
    id?: number
    reference: string
    designation: string
    description?: string | null
    quantiteTotale?: number
    quantiteDisponible?: number
    seuilAlerte?: number
    emplacement?: string | null
    categorie?: string
    prixUnitaire?: number | null
    fournisseur?: string | null
    dateAchat?: Date | string | null
    garantie?: string | null
    statut?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    entrees?: EntreeMaterielUncheckedCreateNestedManyWithoutMaterielInput
  }

  export type MaterielCreateOrConnectWithoutSortiesInput = {
    where: MaterielWhereUniqueInput
    create: XOR<MaterielCreateWithoutSortiesInput, MaterielUncheckedCreateWithoutSortiesInput>
  }

  export type InterventionCreateWithoutSortiesMaterielsInput = {
    dateHeureDebut: Date | string
    dateHeureFin?: Date | string | null
    duree?: number | null
    statut?: string
    commentaire?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    mission: MissionCreateNestedOneWithoutInterventionsInput
    techniciens?: TechnicienInterventionCreateNestedManyWithoutInterventionInput
    rapports?: RapportMissionCreateNestedManyWithoutInterventionInput
  }

  export type InterventionUncheckedCreateWithoutSortiesMaterielsInput = {
    id?: number
    dateHeureDebut: Date | string
    dateHeureFin?: Date | string | null
    duree?: number | null
    missionId: string
    statut?: string
    commentaire?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    techniciens?: TechnicienInterventionUncheckedCreateNestedManyWithoutInterventionInput
    rapports?: RapportMissionUncheckedCreateNestedManyWithoutInterventionInput
  }

  export type InterventionCreateOrConnectWithoutSortiesMaterielsInput = {
    where: InterventionWhereUniqueInput
    create: XOR<InterventionCreateWithoutSortiesMaterielsInput, InterventionUncheckedCreateWithoutSortiesMaterielsInput>
  }

  export type TechnicienCreateWithoutSortiesMaterielsInput = {
    nom: string
    prenom: string
    contact: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    specialite: SpecialiteCreateNestedOneWithoutTechniciensInput
    utilisateur?: UserCreateNestedOneWithoutTechnicienInput
    interventions?: TechnicienInterventionCreateNestedManyWithoutTechnicienInput
    rapports?: RapportMissionCreateNestedManyWithoutTechnicienInput
  }

  export type TechnicienUncheckedCreateWithoutSortiesMaterielsInput = {
    id?: number
    nom: string
    prenom: string
    contact: string
    specialiteId: number
    utilisateurId?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    interventions?: TechnicienInterventionUncheckedCreateNestedManyWithoutTechnicienInput
    rapports?: RapportMissionUncheckedCreateNestedManyWithoutTechnicienInput
  }

  export type TechnicienCreateOrConnectWithoutSortiesMaterielsInput = {
    where: TechnicienWhereUniqueInput
    create: XOR<TechnicienCreateWithoutSortiesMaterielsInput, TechnicienUncheckedCreateWithoutSortiesMaterielsInput>
  }

  export type MaterielUpsertWithoutSortiesInput = {
    update: XOR<MaterielUpdateWithoutSortiesInput, MaterielUncheckedUpdateWithoutSortiesInput>
    create: XOR<MaterielCreateWithoutSortiesInput, MaterielUncheckedCreateWithoutSortiesInput>
    where?: MaterielWhereInput
  }

  export type MaterielUpdateToOneWithWhereWithoutSortiesInput = {
    where?: MaterielWhereInput
    data: XOR<MaterielUpdateWithoutSortiesInput, MaterielUncheckedUpdateWithoutSortiesInput>
  }

  export type MaterielUpdateWithoutSortiesInput = {
    reference?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantiteTotale?: IntFieldUpdateOperationsInput | number
    quantiteDisponible?: IntFieldUpdateOperationsInput | number
    seuilAlerte?: IntFieldUpdateOperationsInput | number
    emplacement?: NullableStringFieldUpdateOperationsInput | string | null
    categorie?: StringFieldUpdateOperationsInput | string
    prixUnitaire?: NullableFloatFieldUpdateOperationsInput | number | null
    fournisseur?: NullableStringFieldUpdateOperationsInput | string | null
    dateAchat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garantie?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entrees?: EntreeMaterielUpdateManyWithoutMaterielNestedInput
  }

  export type MaterielUncheckedUpdateWithoutSortiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    reference?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantiteTotale?: IntFieldUpdateOperationsInput | number
    quantiteDisponible?: IntFieldUpdateOperationsInput | number
    seuilAlerte?: IntFieldUpdateOperationsInput | number
    emplacement?: NullableStringFieldUpdateOperationsInput | string | null
    categorie?: StringFieldUpdateOperationsInput | string
    prixUnitaire?: NullableFloatFieldUpdateOperationsInput | number | null
    fournisseur?: NullableStringFieldUpdateOperationsInput | string | null
    dateAchat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garantie?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entrees?: EntreeMaterielUncheckedUpdateManyWithoutMaterielNestedInput
  }

  export type InterventionUpsertWithoutSortiesMaterielsInput = {
    update: XOR<InterventionUpdateWithoutSortiesMaterielsInput, InterventionUncheckedUpdateWithoutSortiesMaterielsInput>
    create: XOR<InterventionCreateWithoutSortiesMaterielsInput, InterventionUncheckedCreateWithoutSortiesMaterielsInput>
    where?: InterventionWhereInput
  }

  export type InterventionUpdateToOneWithWhereWithoutSortiesMaterielsInput = {
    where?: InterventionWhereInput
    data: XOR<InterventionUpdateWithoutSortiesMaterielsInput, InterventionUncheckedUpdateWithoutSortiesMaterielsInput>
  }

  export type InterventionUpdateWithoutSortiesMaterielsInput = {
    dateHeureDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateHeureFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duree?: NullableIntFieldUpdateOperationsInput | number | null
    statut?: StringFieldUpdateOperationsInput | string
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mission?: MissionUpdateOneRequiredWithoutInterventionsNestedInput
    techniciens?: TechnicienInterventionUpdateManyWithoutInterventionNestedInput
    rapports?: RapportMissionUpdateManyWithoutInterventionNestedInput
  }

  export type InterventionUncheckedUpdateWithoutSortiesMaterielsInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateHeureDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateHeureFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duree?: NullableIntFieldUpdateOperationsInput | number | null
    missionId?: StringFieldUpdateOperationsInput | string
    statut?: StringFieldUpdateOperationsInput | string
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    techniciens?: TechnicienInterventionUncheckedUpdateManyWithoutInterventionNestedInput
    rapports?: RapportMissionUncheckedUpdateManyWithoutInterventionNestedInput
  }

  export type TechnicienUpsertWithoutSortiesMaterielsInput = {
    update: XOR<TechnicienUpdateWithoutSortiesMaterielsInput, TechnicienUncheckedUpdateWithoutSortiesMaterielsInput>
    create: XOR<TechnicienCreateWithoutSortiesMaterielsInput, TechnicienUncheckedCreateWithoutSortiesMaterielsInput>
    where?: TechnicienWhereInput
  }

  export type TechnicienUpdateToOneWithWhereWithoutSortiesMaterielsInput = {
    where?: TechnicienWhereInput
    data: XOR<TechnicienUpdateWithoutSortiesMaterielsInput, TechnicienUncheckedUpdateWithoutSortiesMaterielsInput>
  }

  export type TechnicienUpdateWithoutSortiesMaterielsInput = {
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    specialite?: SpecialiteUpdateOneRequiredWithoutTechniciensNestedInput
    utilisateur?: UserUpdateOneWithoutTechnicienNestedInput
    interventions?: TechnicienInterventionUpdateManyWithoutTechnicienNestedInput
    rapports?: RapportMissionUpdateManyWithoutTechnicienNestedInput
  }

  export type TechnicienUncheckedUpdateWithoutSortiesMaterielsInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    specialiteId?: IntFieldUpdateOperationsInput | number
    utilisateurId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interventions?: TechnicienInterventionUncheckedUpdateManyWithoutTechnicienNestedInput
    rapports?: RapportMissionUncheckedUpdateManyWithoutTechnicienNestedInput
  }

  export type MaterielCreateWithoutEntreesInput = {
    reference: string
    designation: string
    description?: string | null
    quantiteTotale?: number
    quantiteDisponible?: number
    seuilAlerte?: number
    emplacement?: string | null
    categorie?: string
    prixUnitaire?: number | null
    fournisseur?: string | null
    dateAchat?: Date | string | null
    garantie?: string | null
    statut?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sorties?: SortieMaterielCreateNestedManyWithoutMaterielInput
  }

  export type MaterielUncheckedCreateWithoutEntreesInput = {
    id?: number
    reference: string
    designation: string
    description?: string | null
    quantiteTotale?: number
    quantiteDisponible?: number
    seuilAlerte?: number
    emplacement?: string | null
    categorie?: string
    prixUnitaire?: number | null
    fournisseur?: string | null
    dateAchat?: Date | string | null
    garantie?: string | null
    statut?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sorties?: SortieMaterielUncheckedCreateNestedManyWithoutMaterielInput
  }

  export type MaterielCreateOrConnectWithoutEntreesInput = {
    where: MaterielWhereUniqueInput
    create: XOR<MaterielCreateWithoutEntreesInput, MaterielUncheckedCreateWithoutEntreesInput>
  }

  export type MaterielUpsertWithoutEntreesInput = {
    update: XOR<MaterielUpdateWithoutEntreesInput, MaterielUncheckedUpdateWithoutEntreesInput>
    create: XOR<MaterielCreateWithoutEntreesInput, MaterielUncheckedCreateWithoutEntreesInput>
    where?: MaterielWhereInput
  }

  export type MaterielUpdateToOneWithWhereWithoutEntreesInput = {
    where?: MaterielWhereInput
    data: XOR<MaterielUpdateWithoutEntreesInput, MaterielUncheckedUpdateWithoutEntreesInput>
  }

  export type MaterielUpdateWithoutEntreesInput = {
    reference?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantiteTotale?: IntFieldUpdateOperationsInput | number
    quantiteDisponible?: IntFieldUpdateOperationsInput | number
    seuilAlerte?: IntFieldUpdateOperationsInput | number
    emplacement?: NullableStringFieldUpdateOperationsInput | string | null
    categorie?: StringFieldUpdateOperationsInput | string
    prixUnitaire?: NullableFloatFieldUpdateOperationsInput | number | null
    fournisseur?: NullableStringFieldUpdateOperationsInput | string | null
    dateAchat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garantie?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sorties?: SortieMaterielUpdateManyWithoutMaterielNestedInput
  }

  export type MaterielUncheckedUpdateWithoutEntreesInput = {
    id?: IntFieldUpdateOperationsInput | number
    reference?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantiteTotale?: IntFieldUpdateOperationsInput | number
    quantiteDisponible?: IntFieldUpdateOperationsInput | number
    seuilAlerte?: IntFieldUpdateOperationsInput | number
    emplacement?: NullableStringFieldUpdateOperationsInput | string | null
    categorie?: StringFieldUpdateOperationsInput | string
    prixUnitaire?: NullableFloatFieldUpdateOperationsInput | number | null
    fournisseur?: NullableStringFieldUpdateOperationsInput | string | null
    dateAchat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garantie?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sorties?: SortieMaterielUncheckedUpdateManyWithoutMaterielNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    preferences?: string | null
    permissions?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    service?: ServiceCreateNestedOneWithoutUsersInput
    createdCustomers?: CustomerCreateNestedManyWithoutCreatorInput
    createdQuotes?: QuoteCreateNestedManyWithoutCreatorInput
    createdInvoices?: InvoiceCreateNestedManyWithoutCreatorInput
    createdPayments?: PaymentCreateNestedManyWithoutCreatorInput
    serviceApprovals?: QuoteCreateNestedManyWithoutServiceManagerInput
    dgApprovals?: QuoteCreateNestedManyWithoutDgApproverInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    quoteApprovals?: QuoteApprovalCreateNestedManyWithoutApproverInput
    createdExpenses?: ExpenseCreateNestedManyWithoutCreatorInput
    accountingEntries?: AccountingEntryCreateNestedManyWithoutCreatorInput
    cashFlowEntries?: CashFlowCreateNestedManyWithoutCreatorInput
    createdReminders?: ReminderCreateNestedManyWithoutCreatorInput
    createdRecurringInvoices?: RecurringInvoiceCreateNestedManyWithoutCreatorInput
    employee?: EmployeeCreateNestedOneWithoutUserInput
    leaveApprovals?: LeaveRequestCreateNestedManyWithoutApprovedByInput
    assignedProspects?: ProspectCreateNestedManyWithoutAssignedUserInput
    createdProspects?: ProspectCreateNestedManyWithoutCreatorInput
    createdProspectActivities?: ProspectActivityCreateNestedManyWithoutCreatorInput
    technicien?: TechnicienCreateNestedOneWithoutUtilisateurInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: number
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    serviceId?: number | null
    isActive?: boolean
    lastLogin?: Date | string | null
    preferences?: string | null
    permissions?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdCustomers?: CustomerUncheckedCreateNestedManyWithoutCreatorInput
    createdQuotes?: QuoteUncheckedCreateNestedManyWithoutCreatorInput
    createdInvoices?: InvoiceUncheckedCreateNestedManyWithoutCreatorInput
    createdPayments?: PaymentUncheckedCreateNestedManyWithoutCreatorInput
    serviceApprovals?: QuoteUncheckedCreateNestedManyWithoutServiceManagerInput
    dgApprovals?: QuoteUncheckedCreateNestedManyWithoutDgApproverInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    quoteApprovals?: QuoteApprovalUncheckedCreateNestedManyWithoutApproverInput
    createdExpenses?: ExpenseUncheckedCreateNestedManyWithoutCreatorInput
    accountingEntries?: AccountingEntryUncheckedCreateNestedManyWithoutCreatorInput
    cashFlowEntries?: CashFlowUncheckedCreateNestedManyWithoutCreatorInput
    createdReminders?: ReminderUncheckedCreateNestedManyWithoutCreatorInput
    createdRecurringInvoices?: RecurringInvoiceUncheckedCreateNestedManyWithoutCreatorInput
    employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    leaveApprovals?: LeaveRequestUncheckedCreateNestedManyWithoutApprovedByInput
    assignedProspects?: ProspectUncheckedCreateNestedManyWithoutAssignedUserInput
    createdProspects?: ProspectUncheckedCreateNestedManyWithoutCreatorInput
    createdProspectActivities?: ProspectActivityUncheckedCreateNestedManyWithoutCreatorInput
    technicien?: TechnicienUncheckedCreateNestedOneWithoutUtilisateurInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneWithoutUsersNestedInput
    createdCustomers?: CustomerUpdateManyWithoutCreatorNestedInput
    createdQuotes?: QuoteUpdateManyWithoutCreatorNestedInput
    createdInvoices?: InvoiceUpdateManyWithoutCreatorNestedInput
    createdPayments?: PaymentUpdateManyWithoutCreatorNestedInput
    serviceApprovals?: QuoteUpdateManyWithoutServiceManagerNestedInput
    dgApprovals?: QuoteUpdateManyWithoutDgApproverNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    quoteApprovals?: QuoteApprovalUpdateManyWithoutApproverNestedInput
    createdExpenses?: ExpenseUpdateManyWithoutCreatorNestedInput
    accountingEntries?: AccountingEntryUpdateManyWithoutCreatorNestedInput
    cashFlowEntries?: CashFlowUpdateManyWithoutCreatorNestedInput
    createdReminders?: ReminderUpdateManyWithoutCreatorNestedInput
    createdRecurringInvoices?: RecurringInvoiceUpdateManyWithoutCreatorNestedInput
    employee?: EmployeeUpdateOneWithoutUserNestedInput
    leaveApprovals?: LeaveRequestUpdateManyWithoutApprovedByNestedInput
    assignedProspects?: ProspectUpdateManyWithoutAssignedUserNestedInput
    createdProspects?: ProspectUpdateManyWithoutCreatorNestedInput
    createdProspectActivities?: ProspectActivityUpdateManyWithoutCreatorNestedInput
    technicien?: TechnicienUpdateOneWithoutUtilisateurNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    serviceId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdCustomers?: CustomerUncheckedUpdateManyWithoutCreatorNestedInput
    createdQuotes?: QuoteUncheckedUpdateManyWithoutCreatorNestedInput
    createdInvoices?: InvoiceUncheckedUpdateManyWithoutCreatorNestedInput
    createdPayments?: PaymentUncheckedUpdateManyWithoutCreatorNestedInput
    serviceApprovals?: QuoteUncheckedUpdateManyWithoutServiceManagerNestedInput
    dgApprovals?: QuoteUncheckedUpdateManyWithoutDgApproverNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    quoteApprovals?: QuoteApprovalUncheckedUpdateManyWithoutApproverNestedInput
    createdExpenses?: ExpenseUncheckedUpdateManyWithoutCreatorNestedInput
    accountingEntries?: AccountingEntryUncheckedUpdateManyWithoutCreatorNestedInput
    cashFlowEntries?: CashFlowUncheckedUpdateManyWithoutCreatorNestedInput
    createdReminders?: ReminderUncheckedUpdateManyWithoutCreatorNestedInput
    createdRecurringInvoices?: RecurringInvoiceUncheckedUpdateManyWithoutCreatorNestedInput
    employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    leaveApprovals?: LeaveRequestUncheckedUpdateManyWithoutApprovedByNestedInput
    assignedProspects?: ProspectUncheckedUpdateManyWithoutAssignedUserNestedInput
    createdProspects?: ProspectUncheckedUpdateManyWithoutCreatorNestedInput
    createdProspectActivities?: ProspectActivityUncheckedUpdateManyWithoutCreatorNestedInput
    technicien?: TechnicienUncheckedUpdateOneWithoutUtilisateurNestedInput
  }

  export type UserCreateManyServiceInput = {
    id?: number
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    preferences?: string | null
    permissions?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerCreateManyServiceInput = {
    id?: number
    customerNumber: string
    type?: $Enums.CustomerType
    name: string
    legalName?: string | null
    siret?: string | null
    vatNumber?: string | null
    email?: string | null
    phone?: string | null
    mobile?: string | null
    website?: string | null
    paymentTerms?: number
    paymentMethod?: $Enums.PaymentMethod
    creditLimit?: number
    discountRate?: number
    category?: string | null
    tags?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: number
  }

  export type EmployeeCreateManyServiceInput = {
    id?: number
    employeeNumber: string
    registrationNumber?: string | null
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    address?: string | null
    dateOfBirth: Date | string
    placeOfBirth?: string | null
    nationality?: string | null
    socialSecurityNumber?: string | null
    cnpsNumber?: string | null
    cnamNumber?: string | null
    bankAccount?: string | null
    emergencyContact?: string | null
    position: string
    department?: string | null
    category?: string | null
    level?: string | null
    manager?: string | null
    hireDate: Date | string
    isActive?: boolean
    userId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateWithoutServiceInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdCustomers?: CustomerUpdateManyWithoutCreatorNestedInput
    createdQuotes?: QuoteUpdateManyWithoutCreatorNestedInput
    createdInvoices?: InvoiceUpdateManyWithoutCreatorNestedInput
    createdPayments?: PaymentUpdateManyWithoutCreatorNestedInput
    serviceApprovals?: QuoteUpdateManyWithoutServiceManagerNestedInput
    dgApprovals?: QuoteUpdateManyWithoutDgApproverNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    quoteApprovals?: QuoteApprovalUpdateManyWithoutApproverNestedInput
    createdExpenses?: ExpenseUpdateManyWithoutCreatorNestedInput
    accountingEntries?: AccountingEntryUpdateManyWithoutCreatorNestedInput
    cashFlowEntries?: CashFlowUpdateManyWithoutCreatorNestedInput
    createdReminders?: ReminderUpdateManyWithoutCreatorNestedInput
    createdRecurringInvoices?: RecurringInvoiceUpdateManyWithoutCreatorNestedInput
    employee?: EmployeeUpdateOneWithoutUserNestedInput
    leaveApprovals?: LeaveRequestUpdateManyWithoutApprovedByNestedInput
    assignedProspects?: ProspectUpdateManyWithoutAssignedUserNestedInput
    createdProspects?: ProspectUpdateManyWithoutCreatorNestedInput
    createdProspectActivities?: ProspectActivityUpdateManyWithoutCreatorNestedInput
    technicien?: TechnicienUpdateOneWithoutUtilisateurNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutServiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdCustomers?: CustomerUncheckedUpdateManyWithoutCreatorNestedInput
    createdQuotes?: QuoteUncheckedUpdateManyWithoutCreatorNestedInput
    createdInvoices?: InvoiceUncheckedUpdateManyWithoutCreatorNestedInput
    createdPayments?: PaymentUncheckedUpdateManyWithoutCreatorNestedInput
    serviceApprovals?: QuoteUncheckedUpdateManyWithoutServiceManagerNestedInput
    dgApprovals?: QuoteUncheckedUpdateManyWithoutDgApproverNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    quoteApprovals?: QuoteApprovalUncheckedUpdateManyWithoutApproverNestedInput
    createdExpenses?: ExpenseUncheckedUpdateManyWithoutCreatorNestedInput
    accountingEntries?: AccountingEntryUncheckedUpdateManyWithoutCreatorNestedInput
    cashFlowEntries?: CashFlowUncheckedUpdateManyWithoutCreatorNestedInput
    createdReminders?: ReminderUncheckedUpdateManyWithoutCreatorNestedInput
    createdRecurringInvoices?: RecurringInvoiceUncheckedUpdateManyWithoutCreatorNestedInput
    employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    leaveApprovals?: LeaveRequestUncheckedUpdateManyWithoutApprovedByNestedInput
    assignedProspects?: ProspectUncheckedUpdateManyWithoutAssignedUserNestedInput
    createdProspects?: ProspectUncheckedUpdateManyWithoutCreatorNestedInput
    createdProspectActivities?: ProspectActivityUncheckedUpdateManyWithoutCreatorNestedInput
    technicien?: TechnicienUncheckedUpdateOneWithoutUtilisateurNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutServiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerUpdateWithoutServiceInput = {
    customerNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    siret?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: IntFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    creditLimit?: FloatFieldUpdateOperationsInput | number
    discountRate?: FloatFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedCustomersNestedInput
    addresses?: CustomerAddressUpdateManyWithoutCustomerNestedInput
    quotes?: QuoteUpdateManyWithoutCustomerNestedInput
    invoices?: InvoiceUpdateManyWithoutCustomerNestedInput
    payments?: PaymentUpdateManyWithoutCustomerNestedInput
    recurringInvoices?: RecurringInvoiceUpdateManyWithoutCustomerNestedInput
    missions?: MissionUpdateManyWithoutClientNestedInput
  }

  export type CustomerUncheckedUpdateWithoutServiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    siret?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: IntFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    creditLimit?: FloatFieldUpdateOperationsInput | number
    discountRate?: FloatFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    addresses?: CustomerAddressUncheckedUpdateManyWithoutCustomerNestedInput
    quotes?: QuoteUncheckedUpdateManyWithoutCustomerNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCustomerNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCustomerNestedInput
    recurringInvoices?: RecurringInvoiceUncheckedUpdateManyWithoutCustomerNestedInput
    missions?: MissionUncheckedUpdateManyWithoutClientNestedInput
  }

  export type CustomerUncheckedUpdateManyWithoutServiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    siret?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: IntFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    creditLimit?: FloatFieldUpdateOperationsInput | number
    discountRate?: FloatFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
  }

  export type EmployeeUpdateWithoutServiceInput = {
    employeeNumber?: StringFieldUpdateOperationsInput | string
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    placeOfBirth?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    socialSecurityNumber?: NullableStringFieldUpdateOperationsInput | string | null
    cnpsNumber?: NullableStringFieldUpdateOperationsInput | string | null
    cnamNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    position?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    manager?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutEmployeeNestedInput
    contracts?: ContractUpdateManyWithoutEmployeeNestedInput
    salaries?: SalaryUpdateManyWithoutEmployeeNestedInput
    leaveRequests?: LeaveRequestUpdateManyWithoutEmployeeNestedInput
    loans?: LoanUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutServiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeNumber?: StringFieldUpdateOperationsInput | string
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    placeOfBirth?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    socialSecurityNumber?: NullableStringFieldUpdateOperationsInput | string | null
    cnpsNumber?: NullableStringFieldUpdateOperationsInput | string | null
    cnamNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    position?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    manager?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contracts?: ContractUncheckedUpdateManyWithoutEmployeeNestedInput
    salaries?: SalaryUncheckedUpdateManyWithoutEmployeeNestedInput
    leaveRequests?: LeaveRequestUncheckedUpdateManyWithoutEmployeeNestedInput
    loans?: LoanUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateManyWithoutServiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeNumber?: StringFieldUpdateOperationsInput | string
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    placeOfBirth?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    socialSecurityNumber?: NullableStringFieldUpdateOperationsInput | string | null
    cnpsNumber?: NullableStringFieldUpdateOperationsInput | string | null
    cnamNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    position?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    manager?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerCreateManyCreatorInput = {
    id?: number
    customerNumber: string
    type?: $Enums.CustomerType
    name: string
    legalName?: string | null
    siret?: string | null
    vatNumber?: string | null
    email?: string | null
    phone?: string | null
    mobile?: string | null
    website?: string | null
    paymentTerms?: number
    paymentMethod?: $Enums.PaymentMethod
    creditLimit?: number
    discountRate?: number
    category?: string | null
    tags?: string | null
    notes?: string | null
    isActive?: boolean
    serviceId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuoteCreateManyCreatorInput = {
    id?: number
    quoteNumber: string
    customerId: number
    customerAddressId?: number | null
    status?: $Enums.QuoteStatus
    quoteDate: Date | string
    validUntil: Date | string
    subtotalHt?: number
    discountAmount?: number
    totalVat?: number
    totalTtc?: number
    terms?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt?: Date | string | null
    submittedForServiceApprovalAt?: Date | string | null
    serviceManagerApprovedBy?: number | null
    serviceManagerApprovalDate?: Date | string | null
    serviceManagerComments?: string | null
    dgApprovedBy?: number | null
    dgApprovalDate?: Date | string | null
    dgComments?: string | null
    acceptedAt?: Date | string | null
  }

  export type InvoiceCreateManyCreatorInput = {
    id?: number
    invoiceNumber: string
    customerId: number
    customerAddressId?: number | null
    quoteId?: number | null
    type?: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    invoiceDate: Date | string
    dueDate: Date | string
    subtotalHt?: number
    discountAmount?: number
    totalVat?: number
    totalTtc?: number
    paidAmount?: number
    balanceDue?: number
    paymentTerms?: number
    lateFeeRate?: number
    terms?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt?: Date | string | null
  }

  export type PaymentCreateManyCreatorInput = {
    id?: number
    paymentNumber: string
    customerId: number
    amount: number
    paymentDate: Date | string
    paymentMethod: $Enums.PaymentMethod
    reference?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type QuoteCreateManyServiceManagerInput = {
    id?: number
    quoteNumber: string
    customerId: number
    customerAddressId?: number | null
    status?: $Enums.QuoteStatus
    quoteDate: Date | string
    validUntil: Date | string
    subtotalHt?: number
    discountAmount?: number
    totalVat?: number
    totalTtc?: number
    terms?: string | null
    notes?: string | null
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt?: Date | string | null
    submittedForServiceApprovalAt?: Date | string | null
    serviceManagerApprovalDate?: Date | string | null
    serviceManagerComments?: string | null
    dgApprovedBy?: number | null
    dgApprovalDate?: Date | string | null
    dgComments?: string | null
    acceptedAt?: Date | string | null
  }

  export type QuoteCreateManyDgApproverInput = {
    id?: number
    quoteNumber: string
    customerId: number
    customerAddressId?: number | null
    status?: $Enums.QuoteStatus
    quoteDate: Date | string
    validUntil: Date | string
    subtotalHt?: number
    discountAmount?: number
    totalVat?: number
    totalTtc?: number
    terms?: string | null
    notes?: string | null
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt?: Date | string | null
    submittedForServiceApprovalAt?: Date | string | null
    serviceManagerApprovedBy?: number | null
    serviceManagerApprovalDate?: Date | string | null
    serviceManagerComments?: string | null
    dgApprovalDate?: Date | string | null
    dgComments?: string | null
    acceptedAt?: Date | string | null
  }

  export type AuditLogCreateManyUserInput = {
    id?: number
    action: string
    details?: string | null
    createdAt?: Date | string
  }

  export type QuoteApprovalCreateManyApproverInput = {
    id?: number
    quoteId: number
    approvalLevel: $Enums.ApprovalLevel
    status?: $Enums.ApprovalStatus
    approvalDate?: Date | string | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseCreateManyCreatorInput = {
    id?: number
    expenseNumber: string
    supplierId?: number | null
    category: string
    description?: string | null
    amountHt: number
    vatAmount?: number
    totalTtc: number
    expenseDate: Date | string
    paymentDate?: Date | string | null
    paymentMethod?: $Enums.PaymentMethod
    status?: $Enums.ExpenseStatus
    receiptUrl?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountingEntryCreateManyCreatorInput = {
    id?: number
    entryDate: Date | string
    accountNumber: string
    debit?: number
    credit?: number
    description?: string | null
    sourceDocumentType: $Enums.SourceDocumentType
    sourceDocumentId: number
    createdAt?: Date | string
  }

  export type CashFlowCreateManyCreatorInput = {
    id?: number
    transactionDate: Date | string
    type: $Enums.CashFlowType
    amount: number
    description?: string | null
    category?: string | null
    sourceDocumentType: $Enums.SourceDocumentType
    sourceDocumentId: number
    createdAt?: Date | string
  }

  export type ReminderCreateManyCreatorInput = {
    id?: number
    invoiceId: number
    type: $Enums.ReminderType
    sentDate: Date | string
    dueDate?: Date | string | null
    amountDue: number
    lateFees?: number
    status?: $Enums.ReminderStatus
    emailSubject?: string | null
    emailBody?: string | null
    createdAt?: Date | string
  }

  export type RecurringInvoiceCreateManyCreatorInput = {
    id?: number
    customerId: number
    templateName: string
    frequency: $Enums.RecurringFrequency
    startDate: Date | string
    endDate?: Date | string | null
    nextInvoiceDate: Date | string
    isActive?: boolean
    subtotalHt?: number
    totalVat?: number
    totalTtc?: number
    terms?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaveRequestCreateManyApprovedByInput = {
    id?: number
    employeeId: number
    leaveType: $Enums.LeaveType
    startDate: Date | string
    endDate: Date | string
    days: number
    reason: string
    notes?: string | null
    status?: $Enums.LeaveStatus
    approvedAt?: Date | string | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProspectCreateManyAssignedUserInput = {
    id?: number
    companyName: string
    contactName: string
    position?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    website?: string | null
    industry?: string | null
    companySize?: string | null
    estimatedValue?: number | null
    priority?: string
    stage?: string
    source?: string | null
    notes?: string | null
    hasBudget?: boolean
    isDecisionMaker?: boolean
    hasNeed?: boolean
    timeline?: string | null
    lastContact?: Date | string
    nextAction?: string | null
    nextActionDate?: Date | string | null
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProspectCreateManyCreatorInput = {
    id?: number
    companyName: string
    contactName: string
    position?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    website?: string | null
    industry?: string | null
    companySize?: string | null
    estimatedValue?: number | null
    priority?: string
    stage?: string
    source?: string | null
    notes?: string | null
    hasBudget?: boolean
    isDecisionMaker?: boolean
    hasNeed?: boolean
    timeline?: string | null
    lastContact?: Date | string
    nextAction?: string | null
    nextActionDate?: Date | string | null
    assignedTo?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProspectActivityCreateManyCreatorInput = {
    id?: number
    prospectId: number
    type: string
    subject?: string | null
    description?: string | null
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    outcome?: string | null
    nextAction?: string | null
    createdAt?: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: number
    type: string
    message: string
    data?: string | null
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type CustomerUpdateWithoutCreatorInput = {
    customerNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    siret?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: IntFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    creditLimit?: FloatFieldUpdateOperationsInput | number
    discountRate?: FloatFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneWithoutCustomersNestedInput
    addresses?: CustomerAddressUpdateManyWithoutCustomerNestedInput
    quotes?: QuoteUpdateManyWithoutCustomerNestedInput
    invoices?: InvoiceUpdateManyWithoutCustomerNestedInput
    payments?: PaymentUpdateManyWithoutCustomerNestedInput
    recurringInvoices?: RecurringInvoiceUpdateManyWithoutCustomerNestedInput
    missions?: MissionUpdateManyWithoutClientNestedInput
  }

  export type CustomerUncheckedUpdateWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    siret?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: IntFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    creditLimit?: FloatFieldUpdateOperationsInput | number
    discountRate?: FloatFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    serviceId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addresses?: CustomerAddressUncheckedUpdateManyWithoutCustomerNestedInput
    quotes?: QuoteUncheckedUpdateManyWithoutCustomerNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCustomerNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCustomerNestedInput
    recurringInvoices?: RecurringInvoiceUncheckedUpdateManyWithoutCustomerNestedInput
    missions?: MissionUncheckedUpdateManyWithoutClientNestedInput
  }

  export type CustomerUncheckedUpdateManyWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    siret?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: IntFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    creditLimit?: FloatFieldUpdateOperationsInput | number
    discountRate?: FloatFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    serviceId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuoteUpdateWithoutCreatorInput = {
    quoteNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    quoteDate?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotalHt?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalVat?: FloatFieldUpdateOperationsInput | number
    totalTtc?: FloatFieldUpdateOperationsInput | number
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedForServiceApprovalAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceManagerApprovalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceManagerComments?: NullableStringFieldUpdateOperationsInput | string | null
    dgApprovalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dgComments?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customer?: CustomerUpdateOneRequiredWithoutQuotesNestedInput
    customerAddress?: CustomerAddressUpdateOneWithoutQuotesNestedInput
    serviceManager?: UserUpdateOneWithoutServiceApprovalsNestedInput
    dgApprover?: UserUpdateOneWithoutDgApprovalsNestedInput
    items?: QuoteItemUpdateManyWithoutQuoteNestedInput
    invoices?: InvoiceUpdateManyWithoutQuoteNestedInput
    approvals?: QuoteApprovalUpdateManyWithoutQuoteNestedInput
    missions?: MissionUpdateManyWithoutDevisNestedInput
  }

  export type QuoteUncheckedUpdateWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    quoteNumber?: StringFieldUpdateOperationsInput | string
    customerId?: IntFieldUpdateOperationsInput | number
    customerAddressId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    quoteDate?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotalHt?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalVat?: FloatFieldUpdateOperationsInput | number
    totalTtc?: FloatFieldUpdateOperationsInput | number
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedForServiceApprovalAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceManagerApprovedBy?: NullableIntFieldUpdateOperationsInput | number | null
    serviceManagerApprovalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceManagerComments?: NullableStringFieldUpdateOperationsInput | string | null
    dgApprovedBy?: NullableIntFieldUpdateOperationsInput | number | null
    dgApprovalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dgComments?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: QuoteItemUncheckedUpdateManyWithoutQuoteNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutQuoteNestedInput
    approvals?: QuoteApprovalUncheckedUpdateManyWithoutQuoteNestedInput
    missions?: MissionUncheckedUpdateManyWithoutDevisNestedInput
  }

  export type QuoteUncheckedUpdateManyWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    quoteNumber?: StringFieldUpdateOperationsInput | string
    customerId?: IntFieldUpdateOperationsInput | number
    customerAddressId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    quoteDate?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotalHt?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalVat?: FloatFieldUpdateOperationsInput | number
    totalTtc?: FloatFieldUpdateOperationsInput | number
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedForServiceApprovalAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceManagerApprovedBy?: NullableIntFieldUpdateOperationsInput | number | null
    serviceManagerApprovalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceManagerComments?: NullableStringFieldUpdateOperationsInput | string | null
    dgApprovedBy?: NullableIntFieldUpdateOperationsInput | number | null
    dgApprovalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dgComments?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InvoiceUpdateWithoutCreatorInput = {
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotalHt?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalVat?: FloatFieldUpdateOperationsInput | number
    totalTtc?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    balanceDue?: FloatFieldUpdateOperationsInput | number
    paymentTerms?: IntFieldUpdateOperationsInput | number
    lateFeeRate?: FloatFieldUpdateOperationsInput | number
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customer?: CustomerUpdateOneRequiredWithoutInvoicesNestedInput
    customerAddress?: CustomerAddressUpdateOneWithoutInvoicesNestedInput
    quote?: QuoteUpdateOneWithoutInvoicesNestedInput
    items?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
    paymentAllocations?: PaymentAllocationUpdateManyWithoutInvoiceNestedInput
    reminders?: ReminderUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    customerId?: IntFieldUpdateOperationsInput | number
    customerAddressId?: NullableIntFieldUpdateOperationsInput | number | null
    quoteId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotalHt?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalVat?: FloatFieldUpdateOperationsInput | number
    totalTtc?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    balanceDue?: FloatFieldUpdateOperationsInput | number
    paymentTerms?: IntFieldUpdateOperationsInput | number
    lateFeeRate?: FloatFieldUpdateOperationsInput | number
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
    paymentAllocations?: PaymentAllocationUncheckedUpdateManyWithoutInvoiceNestedInput
    reminders?: ReminderUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    customerId?: IntFieldUpdateOperationsInput | number
    customerAddressId?: NullableIntFieldUpdateOperationsInput | number | null
    quoteId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotalHt?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalVat?: FloatFieldUpdateOperationsInput | number
    totalTtc?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    balanceDue?: FloatFieldUpdateOperationsInput | number
    paymentTerms?: IntFieldUpdateOperationsInput | number
    lateFeeRate?: FloatFieldUpdateOperationsInput | number
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PaymentUpdateWithoutCreatorInput = {
    paymentNumber?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutPaymentsNestedInput
    allocations?: PaymentAllocationUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    paymentNumber?: StringFieldUpdateOperationsInput | string
    customerId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    allocations?: PaymentAllocationUncheckedUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateManyWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    paymentNumber?: StringFieldUpdateOperationsInput | string
    customerId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuoteUpdateWithoutServiceManagerInput = {
    quoteNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    quoteDate?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotalHt?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalVat?: FloatFieldUpdateOperationsInput | number
    totalTtc?: FloatFieldUpdateOperationsInput | number
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedForServiceApprovalAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceManagerApprovalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceManagerComments?: NullableStringFieldUpdateOperationsInput | string | null
    dgApprovalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dgComments?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customer?: CustomerUpdateOneRequiredWithoutQuotesNestedInput
    customerAddress?: CustomerAddressUpdateOneWithoutQuotesNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedQuotesNestedInput
    dgApprover?: UserUpdateOneWithoutDgApprovalsNestedInput
    items?: QuoteItemUpdateManyWithoutQuoteNestedInput
    invoices?: InvoiceUpdateManyWithoutQuoteNestedInput
    approvals?: QuoteApprovalUpdateManyWithoutQuoteNestedInput
    missions?: MissionUpdateManyWithoutDevisNestedInput
  }

  export type QuoteUncheckedUpdateWithoutServiceManagerInput = {
    id?: IntFieldUpdateOperationsInput | number
    quoteNumber?: StringFieldUpdateOperationsInput | string
    customerId?: IntFieldUpdateOperationsInput | number
    customerAddressId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    quoteDate?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotalHt?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalVat?: FloatFieldUpdateOperationsInput | number
    totalTtc?: FloatFieldUpdateOperationsInput | number
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedForServiceApprovalAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceManagerApprovalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceManagerComments?: NullableStringFieldUpdateOperationsInput | string | null
    dgApprovedBy?: NullableIntFieldUpdateOperationsInput | number | null
    dgApprovalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dgComments?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: QuoteItemUncheckedUpdateManyWithoutQuoteNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutQuoteNestedInput
    approvals?: QuoteApprovalUncheckedUpdateManyWithoutQuoteNestedInput
    missions?: MissionUncheckedUpdateManyWithoutDevisNestedInput
  }

  export type QuoteUncheckedUpdateManyWithoutServiceManagerInput = {
    id?: IntFieldUpdateOperationsInput | number
    quoteNumber?: StringFieldUpdateOperationsInput | string
    customerId?: IntFieldUpdateOperationsInput | number
    customerAddressId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    quoteDate?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotalHt?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalVat?: FloatFieldUpdateOperationsInput | number
    totalTtc?: FloatFieldUpdateOperationsInput | number
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedForServiceApprovalAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceManagerApprovalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceManagerComments?: NullableStringFieldUpdateOperationsInput | string | null
    dgApprovedBy?: NullableIntFieldUpdateOperationsInput | number | null
    dgApprovalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dgComments?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuoteUpdateWithoutDgApproverInput = {
    quoteNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    quoteDate?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotalHt?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalVat?: FloatFieldUpdateOperationsInput | number
    totalTtc?: FloatFieldUpdateOperationsInput | number
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedForServiceApprovalAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceManagerApprovalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceManagerComments?: NullableStringFieldUpdateOperationsInput | string | null
    dgApprovalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dgComments?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customer?: CustomerUpdateOneRequiredWithoutQuotesNestedInput
    customerAddress?: CustomerAddressUpdateOneWithoutQuotesNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedQuotesNestedInput
    serviceManager?: UserUpdateOneWithoutServiceApprovalsNestedInput
    items?: QuoteItemUpdateManyWithoutQuoteNestedInput
    invoices?: InvoiceUpdateManyWithoutQuoteNestedInput
    approvals?: QuoteApprovalUpdateManyWithoutQuoteNestedInput
    missions?: MissionUpdateManyWithoutDevisNestedInput
  }

  export type QuoteUncheckedUpdateWithoutDgApproverInput = {
    id?: IntFieldUpdateOperationsInput | number
    quoteNumber?: StringFieldUpdateOperationsInput | string
    customerId?: IntFieldUpdateOperationsInput | number
    customerAddressId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    quoteDate?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotalHt?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalVat?: FloatFieldUpdateOperationsInput | number
    totalTtc?: FloatFieldUpdateOperationsInput | number
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedForServiceApprovalAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceManagerApprovedBy?: NullableIntFieldUpdateOperationsInput | number | null
    serviceManagerApprovalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceManagerComments?: NullableStringFieldUpdateOperationsInput | string | null
    dgApprovalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dgComments?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: QuoteItemUncheckedUpdateManyWithoutQuoteNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutQuoteNestedInput
    approvals?: QuoteApprovalUncheckedUpdateManyWithoutQuoteNestedInput
    missions?: MissionUncheckedUpdateManyWithoutDevisNestedInput
  }

  export type QuoteUncheckedUpdateManyWithoutDgApproverInput = {
    id?: IntFieldUpdateOperationsInput | number
    quoteNumber?: StringFieldUpdateOperationsInput | string
    customerId?: IntFieldUpdateOperationsInput | number
    customerAddressId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    quoteDate?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotalHt?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalVat?: FloatFieldUpdateOperationsInput | number
    totalTtc?: FloatFieldUpdateOperationsInput | number
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedForServiceApprovalAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceManagerApprovedBy?: NullableIntFieldUpdateOperationsInput | number | null
    serviceManagerApprovalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceManagerComments?: NullableStringFieldUpdateOperationsInput | string | null
    dgApprovalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dgComments?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AuditLogUpdateWithoutUserInput = {
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuoteApprovalUpdateWithoutApproverInput = {
    approvalLevel?: EnumApprovalLevelFieldUpdateOperationsInput | $Enums.ApprovalLevel
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approvalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quote?: QuoteUpdateOneRequiredWithoutApprovalsNestedInput
  }

  export type QuoteApprovalUncheckedUpdateWithoutApproverInput = {
    id?: IntFieldUpdateOperationsInput | number
    quoteId?: IntFieldUpdateOperationsInput | number
    approvalLevel?: EnumApprovalLevelFieldUpdateOperationsInput | $Enums.ApprovalLevel
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approvalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuoteApprovalUncheckedUpdateManyWithoutApproverInput = {
    id?: IntFieldUpdateOperationsInput | number
    quoteId?: IntFieldUpdateOperationsInput | number
    approvalLevel?: EnumApprovalLevelFieldUpdateOperationsInput | $Enums.ApprovalLevel
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approvalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseUpdateWithoutCreatorInput = {
    expenseNumber?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amountHt?: FloatFieldUpdateOperationsInput | number
    vatAmount?: FloatFieldUpdateOperationsInput | number
    totalTtc?: FloatFieldUpdateOperationsInput | number
    expenseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumExpenseStatusFieldUpdateOperationsInput | $Enums.ExpenseStatus
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: SupplierUpdateOneWithoutExpensesNestedInput
  }

  export type ExpenseUncheckedUpdateWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    expenseNumber?: StringFieldUpdateOperationsInput | string
    supplierId?: NullableIntFieldUpdateOperationsInput | number | null
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amountHt?: FloatFieldUpdateOperationsInput | number
    vatAmount?: FloatFieldUpdateOperationsInput | number
    totalTtc?: FloatFieldUpdateOperationsInput | number
    expenseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumExpenseStatusFieldUpdateOperationsInput | $Enums.ExpenseStatus
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseUncheckedUpdateManyWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    expenseNumber?: StringFieldUpdateOperationsInput | string
    supplierId?: NullableIntFieldUpdateOperationsInput | number | null
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amountHt?: FloatFieldUpdateOperationsInput | number
    vatAmount?: FloatFieldUpdateOperationsInput | number
    totalTtc?: FloatFieldUpdateOperationsInput | number
    expenseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumExpenseStatusFieldUpdateOperationsInput | $Enums.ExpenseStatus
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountingEntryUpdateWithoutCreatorInput = {
    entryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    debit?: FloatFieldUpdateOperationsInput | number
    credit?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sourceDocumentType?: EnumSourceDocumentTypeFieldUpdateOperationsInput | $Enums.SourceDocumentType
    sourceDocumentId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountingEntryUncheckedUpdateWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    entryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    debit?: FloatFieldUpdateOperationsInput | number
    credit?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sourceDocumentType?: EnumSourceDocumentTypeFieldUpdateOperationsInput | $Enums.SourceDocumentType
    sourceDocumentId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountingEntryUncheckedUpdateManyWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    entryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    debit?: FloatFieldUpdateOperationsInput | number
    credit?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sourceDocumentType?: EnumSourceDocumentTypeFieldUpdateOperationsInput | $Enums.SourceDocumentType
    sourceDocumentId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashFlowUpdateWithoutCreatorInput = {
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumCashFlowTypeFieldUpdateOperationsInput | $Enums.CashFlowType
    amount?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    sourceDocumentType?: EnumSourceDocumentTypeFieldUpdateOperationsInput | $Enums.SourceDocumentType
    sourceDocumentId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashFlowUncheckedUpdateWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumCashFlowTypeFieldUpdateOperationsInput | $Enums.CashFlowType
    amount?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    sourceDocumentType?: EnumSourceDocumentTypeFieldUpdateOperationsInput | $Enums.SourceDocumentType
    sourceDocumentId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashFlowUncheckedUpdateManyWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumCashFlowTypeFieldUpdateOperationsInput | $Enums.CashFlowType
    amount?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    sourceDocumentType?: EnumSourceDocumentTypeFieldUpdateOperationsInput | $Enums.SourceDocumentType
    sourceDocumentId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReminderUpdateWithoutCreatorInput = {
    type?: EnumReminderTypeFieldUpdateOperationsInput | $Enums.ReminderType
    sentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amountDue?: FloatFieldUpdateOperationsInput | number
    lateFees?: FloatFieldUpdateOperationsInput | number
    status?: EnumReminderStatusFieldUpdateOperationsInput | $Enums.ReminderStatus
    emailSubject?: NullableStringFieldUpdateOperationsInput | string | null
    emailBody?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneRequiredWithoutRemindersNestedInput
  }

  export type ReminderUncheckedUpdateWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    type?: EnumReminderTypeFieldUpdateOperationsInput | $Enums.ReminderType
    sentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amountDue?: FloatFieldUpdateOperationsInput | number
    lateFees?: FloatFieldUpdateOperationsInput | number
    status?: EnumReminderStatusFieldUpdateOperationsInput | $Enums.ReminderStatus
    emailSubject?: NullableStringFieldUpdateOperationsInput | string | null
    emailBody?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReminderUncheckedUpdateManyWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    type?: EnumReminderTypeFieldUpdateOperationsInput | $Enums.ReminderType
    sentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amountDue?: FloatFieldUpdateOperationsInput | number
    lateFees?: FloatFieldUpdateOperationsInput | number
    status?: EnumReminderStatusFieldUpdateOperationsInput | $Enums.ReminderStatus
    emailSubject?: NullableStringFieldUpdateOperationsInput | string | null
    emailBody?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecurringInvoiceUpdateWithoutCreatorInput = {
    templateName?: StringFieldUpdateOperationsInput | string
    frequency?: EnumRecurringFrequencyFieldUpdateOperationsInput | $Enums.RecurringFrequency
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextInvoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subtotalHt?: FloatFieldUpdateOperationsInput | number
    totalVat?: FloatFieldUpdateOperationsInput | number
    totalTtc?: FloatFieldUpdateOperationsInput | number
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutRecurringInvoicesNestedInput
    items?: RecurringInvoiceItemUpdateManyWithoutRecurringInvoiceNestedInput
  }

  export type RecurringInvoiceUncheckedUpdateWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    templateName?: StringFieldUpdateOperationsInput | string
    frequency?: EnumRecurringFrequencyFieldUpdateOperationsInput | $Enums.RecurringFrequency
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextInvoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subtotalHt?: FloatFieldUpdateOperationsInput | number
    totalVat?: FloatFieldUpdateOperationsInput | number
    totalTtc?: FloatFieldUpdateOperationsInput | number
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: RecurringInvoiceItemUncheckedUpdateManyWithoutRecurringInvoiceNestedInput
  }

  export type RecurringInvoiceUncheckedUpdateManyWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    templateName?: StringFieldUpdateOperationsInput | string
    frequency?: EnumRecurringFrequencyFieldUpdateOperationsInput | $Enums.RecurringFrequency
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextInvoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subtotalHt?: FloatFieldUpdateOperationsInput | number
    totalVat?: FloatFieldUpdateOperationsInput | number
    totalTtc?: FloatFieldUpdateOperationsInput | number
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveRequestUpdateWithoutApprovedByInput = {
    leaveType?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    days?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutLeaveRequestsNestedInput
  }

  export type LeaveRequestUncheckedUpdateWithoutApprovedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    leaveType?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    days?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveRequestUncheckedUpdateManyWithoutApprovedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    leaveType?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    days?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProspectUpdateWithoutAssignedUserInput = {
    companyName?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedValue?: NullableFloatFieldUpdateOperationsInput | number | null
    priority?: StringFieldUpdateOperationsInput | string
    stage?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    hasBudget?: BoolFieldUpdateOperationsInput | boolean
    isDecisionMaker?: BoolFieldUpdateOperationsInput | boolean
    hasNeed?: BoolFieldUpdateOperationsInput | boolean
    timeline?: NullableStringFieldUpdateOperationsInput | string | null
    lastContact?: DateTimeFieldUpdateOperationsInput | Date | string
    nextAction?: NullableStringFieldUpdateOperationsInput | string | null
    nextActionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedProspectsNestedInput
    activities?: ProspectActivityUpdateManyWithoutProspectNestedInput
  }

  export type ProspectUncheckedUpdateWithoutAssignedUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyName?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedValue?: NullableFloatFieldUpdateOperationsInput | number | null
    priority?: StringFieldUpdateOperationsInput | string
    stage?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    hasBudget?: BoolFieldUpdateOperationsInput | boolean
    isDecisionMaker?: BoolFieldUpdateOperationsInput | boolean
    hasNeed?: BoolFieldUpdateOperationsInput | boolean
    timeline?: NullableStringFieldUpdateOperationsInput | string | null
    lastContact?: DateTimeFieldUpdateOperationsInput | Date | string
    nextAction?: NullableStringFieldUpdateOperationsInput | string | null
    nextActionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ProspectActivityUncheckedUpdateManyWithoutProspectNestedInput
  }

  export type ProspectUncheckedUpdateManyWithoutAssignedUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyName?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedValue?: NullableFloatFieldUpdateOperationsInput | number | null
    priority?: StringFieldUpdateOperationsInput | string
    stage?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    hasBudget?: BoolFieldUpdateOperationsInput | boolean
    isDecisionMaker?: BoolFieldUpdateOperationsInput | boolean
    hasNeed?: BoolFieldUpdateOperationsInput | boolean
    timeline?: NullableStringFieldUpdateOperationsInput | string | null
    lastContact?: DateTimeFieldUpdateOperationsInput | Date | string
    nextAction?: NullableStringFieldUpdateOperationsInput | string | null
    nextActionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProspectUpdateWithoutCreatorInput = {
    companyName?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedValue?: NullableFloatFieldUpdateOperationsInput | number | null
    priority?: StringFieldUpdateOperationsInput | string
    stage?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    hasBudget?: BoolFieldUpdateOperationsInput | boolean
    isDecisionMaker?: BoolFieldUpdateOperationsInput | boolean
    hasNeed?: BoolFieldUpdateOperationsInput | boolean
    timeline?: NullableStringFieldUpdateOperationsInput | string | null
    lastContact?: DateTimeFieldUpdateOperationsInput | Date | string
    nextAction?: NullableStringFieldUpdateOperationsInput | string | null
    nextActionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedUser?: UserUpdateOneWithoutAssignedProspectsNestedInput
    activities?: ProspectActivityUpdateManyWithoutProspectNestedInput
  }

  export type ProspectUncheckedUpdateWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyName?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedValue?: NullableFloatFieldUpdateOperationsInput | number | null
    priority?: StringFieldUpdateOperationsInput | string
    stage?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    hasBudget?: BoolFieldUpdateOperationsInput | boolean
    isDecisionMaker?: BoolFieldUpdateOperationsInput | boolean
    hasNeed?: BoolFieldUpdateOperationsInput | boolean
    timeline?: NullableStringFieldUpdateOperationsInput | string | null
    lastContact?: DateTimeFieldUpdateOperationsInput | Date | string
    nextAction?: NullableStringFieldUpdateOperationsInput | string | null
    nextActionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ProspectActivityUncheckedUpdateManyWithoutProspectNestedInput
  }

  export type ProspectUncheckedUpdateManyWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyName?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedValue?: NullableFloatFieldUpdateOperationsInput | number | null
    priority?: StringFieldUpdateOperationsInput | string
    stage?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    hasBudget?: BoolFieldUpdateOperationsInput | boolean
    isDecisionMaker?: BoolFieldUpdateOperationsInput | boolean
    hasNeed?: BoolFieldUpdateOperationsInput | boolean
    timeline?: NullableStringFieldUpdateOperationsInput | string | null
    lastContact?: DateTimeFieldUpdateOperationsInput | Date | string
    nextAction?: NullableStringFieldUpdateOperationsInput | string | null
    nextActionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProspectActivityUpdateWithoutCreatorInput = {
    type?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    nextAction?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prospect?: ProspectUpdateOneRequiredWithoutActivitiesNestedInput
  }

  export type ProspectActivityUncheckedUpdateWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    prospectId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    nextAction?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProspectActivityUncheckedUpdateManyWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    prospectId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    nextAction?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerAddressCreateManyCustomerInput = {
    id?: number
    type: $Enums.AddressType
    name?: string | null
    addressLine1: string
    addressLine2?: string | null
    postalCode: string
    city: string
    country?: string
    isDefault?: boolean
    createdAt?: Date | string
  }

  export type QuoteCreateManyCustomerInput = {
    id?: number
    quoteNumber: string
    customerAddressId?: number | null
    status?: $Enums.QuoteStatus
    quoteDate: Date | string
    validUntil: Date | string
    subtotalHt?: number
    discountAmount?: number
    totalVat?: number
    totalTtc?: number
    terms?: string | null
    notes?: string | null
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt?: Date | string | null
    submittedForServiceApprovalAt?: Date | string | null
    serviceManagerApprovedBy?: number | null
    serviceManagerApprovalDate?: Date | string | null
    serviceManagerComments?: string | null
    dgApprovedBy?: number | null
    dgApprovalDate?: Date | string | null
    dgComments?: string | null
    acceptedAt?: Date | string | null
  }

  export type InvoiceCreateManyCustomerInput = {
    id?: number
    invoiceNumber: string
    customerAddressId?: number | null
    quoteId?: number | null
    type?: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    invoiceDate: Date | string
    dueDate: Date | string
    subtotalHt?: number
    discountAmount?: number
    totalVat?: number
    totalTtc?: number
    paidAmount?: number
    balanceDue?: number
    paymentTerms?: number
    lateFeeRate?: number
    terms?: string | null
    notes?: string | null
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt?: Date | string | null
  }

  export type PaymentCreateManyCustomerInput = {
    id?: number
    paymentNumber: string
    amount: number
    paymentDate: Date | string
    paymentMethod: $Enums.PaymentMethod
    reference?: string | null
    notes?: string | null
    createdBy: number
    createdAt?: Date | string
  }

  export type RecurringInvoiceCreateManyCustomerInput = {
    id?: number
    templateName: string
    frequency: $Enums.RecurringFrequency
    startDate: Date | string
    endDate?: Date | string | null
    nextInvoiceDate: Date | string
    isActive?: boolean
    subtotalHt?: number
    totalVat?: number
    totalTtc?: number
    terms?: string | null
    notes?: string | null
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MissionCreateManyClientInput = {
    numIntervention: string
    natureIntervention: string
    objectifDuContrat: string
    description?: string | null
    priorite?: string | null
    statut?: string | null
    dateSortieFicheIntervention: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerAddressUpdateWithoutCustomerInput = {
    type?: EnumAddressTypeFieldUpdateOperationsInput | $Enums.AddressType
    name?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotes?: QuoteUpdateManyWithoutCustomerAddressNestedInput
    invoices?: InvoiceUpdateManyWithoutCustomerAddressNestedInput
  }

  export type CustomerAddressUncheckedUpdateWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumAddressTypeFieldUpdateOperationsInput | $Enums.AddressType
    name?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotes?: QuoteUncheckedUpdateManyWithoutCustomerAddressNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCustomerAddressNestedInput
  }

  export type CustomerAddressUncheckedUpdateManyWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumAddressTypeFieldUpdateOperationsInput | $Enums.AddressType
    name?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuoteUpdateWithoutCustomerInput = {
    quoteNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    quoteDate?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotalHt?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalVat?: FloatFieldUpdateOperationsInput | number
    totalTtc?: FloatFieldUpdateOperationsInput | number
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedForServiceApprovalAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceManagerApprovalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceManagerComments?: NullableStringFieldUpdateOperationsInput | string | null
    dgApprovalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dgComments?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerAddress?: CustomerAddressUpdateOneWithoutQuotesNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedQuotesNestedInput
    serviceManager?: UserUpdateOneWithoutServiceApprovalsNestedInput
    dgApprover?: UserUpdateOneWithoutDgApprovalsNestedInput
    items?: QuoteItemUpdateManyWithoutQuoteNestedInput
    invoices?: InvoiceUpdateManyWithoutQuoteNestedInput
    approvals?: QuoteApprovalUpdateManyWithoutQuoteNestedInput
    missions?: MissionUpdateManyWithoutDevisNestedInput
  }

  export type QuoteUncheckedUpdateWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    quoteNumber?: StringFieldUpdateOperationsInput | string
    customerAddressId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    quoteDate?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotalHt?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalVat?: FloatFieldUpdateOperationsInput | number
    totalTtc?: FloatFieldUpdateOperationsInput | number
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedForServiceApprovalAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceManagerApprovedBy?: NullableIntFieldUpdateOperationsInput | number | null
    serviceManagerApprovalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceManagerComments?: NullableStringFieldUpdateOperationsInput | string | null
    dgApprovedBy?: NullableIntFieldUpdateOperationsInput | number | null
    dgApprovalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dgComments?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: QuoteItemUncheckedUpdateManyWithoutQuoteNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutQuoteNestedInput
    approvals?: QuoteApprovalUncheckedUpdateManyWithoutQuoteNestedInput
    missions?: MissionUncheckedUpdateManyWithoutDevisNestedInput
  }

  export type QuoteUncheckedUpdateManyWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    quoteNumber?: StringFieldUpdateOperationsInput | string
    customerAddressId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    quoteDate?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotalHt?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalVat?: FloatFieldUpdateOperationsInput | number
    totalTtc?: FloatFieldUpdateOperationsInput | number
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedForServiceApprovalAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceManagerApprovedBy?: NullableIntFieldUpdateOperationsInput | number | null
    serviceManagerApprovalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceManagerComments?: NullableStringFieldUpdateOperationsInput | string | null
    dgApprovedBy?: NullableIntFieldUpdateOperationsInput | number | null
    dgApprovalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dgComments?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InvoiceUpdateWithoutCustomerInput = {
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotalHt?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalVat?: FloatFieldUpdateOperationsInput | number
    totalTtc?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    balanceDue?: FloatFieldUpdateOperationsInput | number
    paymentTerms?: IntFieldUpdateOperationsInput | number
    lateFeeRate?: FloatFieldUpdateOperationsInput | number
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerAddress?: CustomerAddressUpdateOneWithoutInvoicesNestedInput
    quote?: QuoteUpdateOneWithoutInvoicesNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedInvoicesNestedInput
    items?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
    paymentAllocations?: PaymentAllocationUpdateManyWithoutInvoiceNestedInput
    reminders?: ReminderUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    customerAddressId?: NullableIntFieldUpdateOperationsInput | number | null
    quoteId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotalHt?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalVat?: FloatFieldUpdateOperationsInput | number
    totalTtc?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    balanceDue?: FloatFieldUpdateOperationsInput | number
    paymentTerms?: IntFieldUpdateOperationsInput | number
    lateFeeRate?: FloatFieldUpdateOperationsInput | number
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
    paymentAllocations?: PaymentAllocationUncheckedUpdateManyWithoutInvoiceNestedInput
    reminders?: ReminderUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    customerAddressId?: NullableIntFieldUpdateOperationsInput | number | null
    quoteId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotalHt?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalVat?: FloatFieldUpdateOperationsInput | number
    totalTtc?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    balanceDue?: FloatFieldUpdateOperationsInput | number
    paymentTerms?: IntFieldUpdateOperationsInput | number
    lateFeeRate?: FloatFieldUpdateOperationsInput | number
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PaymentUpdateWithoutCustomerInput = {
    paymentNumber?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedPaymentsNestedInput
    allocations?: PaymentAllocationUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    paymentNumber?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    allocations?: PaymentAllocationUncheckedUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateManyWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    paymentNumber?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecurringInvoiceUpdateWithoutCustomerInput = {
    templateName?: StringFieldUpdateOperationsInput | string
    frequency?: EnumRecurringFrequencyFieldUpdateOperationsInput | $Enums.RecurringFrequency
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextInvoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subtotalHt?: FloatFieldUpdateOperationsInput | number
    totalVat?: FloatFieldUpdateOperationsInput | number
    totalTtc?: FloatFieldUpdateOperationsInput | number
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedRecurringInvoicesNestedInput
    items?: RecurringInvoiceItemUpdateManyWithoutRecurringInvoiceNestedInput
  }

  export type RecurringInvoiceUncheckedUpdateWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    templateName?: StringFieldUpdateOperationsInput | string
    frequency?: EnumRecurringFrequencyFieldUpdateOperationsInput | $Enums.RecurringFrequency
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextInvoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subtotalHt?: FloatFieldUpdateOperationsInput | number
    totalVat?: FloatFieldUpdateOperationsInput | number
    totalTtc?: FloatFieldUpdateOperationsInput | number
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: RecurringInvoiceItemUncheckedUpdateManyWithoutRecurringInvoiceNestedInput
  }

  export type RecurringInvoiceUncheckedUpdateManyWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    templateName?: StringFieldUpdateOperationsInput | string
    frequency?: EnumRecurringFrequencyFieldUpdateOperationsInput | $Enums.RecurringFrequency
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextInvoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subtotalHt?: FloatFieldUpdateOperationsInput | number
    totalVat?: FloatFieldUpdateOperationsInput | number
    totalTtc?: FloatFieldUpdateOperationsInput | number
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MissionUpdateWithoutClientInput = {
    numIntervention?: StringFieldUpdateOperationsInput | string
    natureIntervention?: StringFieldUpdateOperationsInput | string
    objectifDuContrat?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priorite?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: NullableStringFieldUpdateOperationsInput | string | null
    dateSortieFicheIntervention?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interventions?: InterventionUpdateManyWithoutMissionNestedInput
    rapports?: RapportMissionUpdateManyWithoutMissionNestedInput
    devis?: QuoteUpdateManyWithoutMissionsNestedInput
  }

  export type MissionUncheckedUpdateWithoutClientInput = {
    numIntervention?: StringFieldUpdateOperationsInput | string
    natureIntervention?: StringFieldUpdateOperationsInput | string
    objectifDuContrat?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priorite?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: NullableStringFieldUpdateOperationsInput | string | null
    dateSortieFicheIntervention?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interventions?: InterventionUncheckedUpdateManyWithoutMissionNestedInput
    rapports?: RapportMissionUncheckedUpdateManyWithoutMissionNestedInput
    devis?: QuoteUncheckedUpdateManyWithoutMissionsNestedInput
  }

  export type MissionUncheckedUpdateManyWithoutClientInput = {
    numIntervention?: StringFieldUpdateOperationsInput | string
    natureIntervention?: StringFieldUpdateOperationsInput | string
    objectifDuContrat?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priorite?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: NullableStringFieldUpdateOperationsInput | string | null
    dateSortieFicheIntervention?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuoteCreateManyCustomerAddressInput = {
    id?: number
    quoteNumber: string
    customerId: number
    status?: $Enums.QuoteStatus
    quoteDate: Date | string
    validUntil: Date | string
    subtotalHt?: number
    discountAmount?: number
    totalVat?: number
    totalTtc?: number
    terms?: string | null
    notes?: string | null
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt?: Date | string | null
    submittedForServiceApprovalAt?: Date | string | null
    serviceManagerApprovedBy?: number | null
    serviceManagerApprovalDate?: Date | string | null
    serviceManagerComments?: string | null
    dgApprovedBy?: number | null
    dgApprovalDate?: Date | string | null
    dgComments?: string | null
    acceptedAt?: Date | string | null
  }

  export type InvoiceCreateManyCustomerAddressInput = {
    id?: number
    invoiceNumber: string
    customerId: number
    quoteId?: number | null
    type?: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    invoiceDate: Date | string
    dueDate: Date | string
    subtotalHt?: number
    discountAmount?: number
    totalVat?: number
    totalTtc?: number
    paidAmount?: number
    balanceDue?: number
    paymentTerms?: number
    lateFeeRate?: number
    terms?: string | null
    notes?: string | null
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt?: Date | string | null
  }

  export type QuoteUpdateWithoutCustomerAddressInput = {
    quoteNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    quoteDate?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotalHt?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalVat?: FloatFieldUpdateOperationsInput | number
    totalTtc?: FloatFieldUpdateOperationsInput | number
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedForServiceApprovalAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceManagerApprovalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceManagerComments?: NullableStringFieldUpdateOperationsInput | string | null
    dgApprovalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dgComments?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customer?: CustomerUpdateOneRequiredWithoutQuotesNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedQuotesNestedInput
    serviceManager?: UserUpdateOneWithoutServiceApprovalsNestedInput
    dgApprover?: UserUpdateOneWithoutDgApprovalsNestedInput
    items?: QuoteItemUpdateManyWithoutQuoteNestedInput
    invoices?: InvoiceUpdateManyWithoutQuoteNestedInput
    approvals?: QuoteApprovalUpdateManyWithoutQuoteNestedInput
    missions?: MissionUpdateManyWithoutDevisNestedInput
  }

  export type QuoteUncheckedUpdateWithoutCustomerAddressInput = {
    id?: IntFieldUpdateOperationsInput | number
    quoteNumber?: StringFieldUpdateOperationsInput | string
    customerId?: IntFieldUpdateOperationsInput | number
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    quoteDate?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotalHt?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalVat?: FloatFieldUpdateOperationsInput | number
    totalTtc?: FloatFieldUpdateOperationsInput | number
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedForServiceApprovalAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceManagerApprovedBy?: NullableIntFieldUpdateOperationsInput | number | null
    serviceManagerApprovalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceManagerComments?: NullableStringFieldUpdateOperationsInput | string | null
    dgApprovedBy?: NullableIntFieldUpdateOperationsInput | number | null
    dgApprovalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dgComments?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: QuoteItemUncheckedUpdateManyWithoutQuoteNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutQuoteNestedInput
    approvals?: QuoteApprovalUncheckedUpdateManyWithoutQuoteNestedInput
    missions?: MissionUncheckedUpdateManyWithoutDevisNestedInput
  }

  export type QuoteUncheckedUpdateManyWithoutCustomerAddressInput = {
    id?: IntFieldUpdateOperationsInput | number
    quoteNumber?: StringFieldUpdateOperationsInput | string
    customerId?: IntFieldUpdateOperationsInput | number
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    quoteDate?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotalHt?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalVat?: FloatFieldUpdateOperationsInput | number
    totalTtc?: FloatFieldUpdateOperationsInput | number
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedForServiceApprovalAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceManagerApprovedBy?: NullableIntFieldUpdateOperationsInput | number | null
    serviceManagerApprovalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceManagerComments?: NullableStringFieldUpdateOperationsInput | string | null
    dgApprovedBy?: NullableIntFieldUpdateOperationsInput | number | null
    dgApprovalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dgComments?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InvoiceUpdateWithoutCustomerAddressInput = {
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotalHt?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalVat?: FloatFieldUpdateOperationsInput | number
    totalTtc?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    balanceDue?: FloatFieldUpdateOperationsInput | number
    paymentTerms?: IntFieldUpdateOperationsInput | number
    lateFeeRate?: FloatFieldUpdateOperationsInput | number
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customer?: CustomerUpdateOneRequiredWithoutInvoicesNestedInput
    quote?: QuoteUpdateOneWithoutInvoicesNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedInvoicesNestedInput
    items?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
    paymentAllocations?: PaymentAllocationUpdateManyWithoutInvoiceNestedInput
    reminders?: ReminderUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutCustomerAddressInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    customerId?: IntFieldUpdateOperationsInput | number
    quoteId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotalHt?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalVat?: FloatFieldUpdateOperationsInput | number
    totalTtc?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    balanceDue?: FloatFieldUpdateOperationsInput | number
    paymentTerms?: IntFieldUpdateOperationsInput | number
    lateFeeRate?: FloatFieldUpdateOperationsInput | number
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
    paymentAllocations?: PaymentAllocationUncheckedUpdateManyWithoutInvoiceNestedInput
    reminders?: ReminderUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutCustomerAddressInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    customerId?: IntFieldUpdateOperationsInput | number
    quoteId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotalHt?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalVat?: FloatFieldUpdateOperationsInput | number
    totalTtc?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    balanceDue?: FloatFieldUpdateOperationsInput | number
    paymentTerms?: IntFieldUpdateOperationsInput | number
    lateFeeRate?: FloatFieldUpdateOperationsInput | number
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductPriceCreateManyProductInput = {
    id?: number
    customerCategory?: string | null
    minQuantity?: number
    priceHt: number
    validFrom?: Date | string | null
    validUntil?: Date | string | null
    createdAt?: Date | string
  }

  export type QuoteItemCreateManyProductInput = {
    id?: number
    quoteId: number
    description: string
    quantity: number
    unitPriceHt: number
    discountRate?: number
    vatRate: number
    totalHt: number
    sortOrder?: number
  }

  export type InvoiceItemCreateManyProductInput = {
    id?: number
    invoiceId: number
    description: string
    quantity: number
    unitPriceHt: number
    discountRate?: number
    vatRate: number
    totalHt: number
    sortOrder?: number
  }

  export type RecurringInvoiceItemCreateManyProductInput = {
    id?: number
    recurringInvoiceId: number
    description: string
    quantity: number
    unitPriceHt: number
    vatRate: number
    totalHt: number
    sortOrder?: number
  }

  export type ProductPriceUpdateWithoutProductInput = {
    customerCategory?: NullableStringFieldUpdateOperationsInput | string | null
    minQuantity?: IntFieldUpdateOperationsInput | number
    priceHt?: FloatFieldUpdateOperationsInput | number
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductPriceUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerCategory?: NullableStringFieldUpdateOperationsInput | string | null
    minQuantity?: IntFieldUpdateOperationsInput | number
    priceHt?: FloatFieldUpdateOperationsInput | number
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductPriceUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerCategory?: NullableStringFieldUpdateOperationsInput | string | null
    minQuantity?: IntFieldUpdateOperationsInput | number
    priceHt?: FloatFieldUpdateOperationsInput | number
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuoteItemUpdateWithoutProductInput = {
    description?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPriceHt?: FloatFieldUpdateOperationsInput | number
    discountRate?: FloatFieldUpdateOperationsInput | number
    vatRate?: FloatFieldUpdateOperationsInput | number
    totalHt?: FloatFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
    quote?: QuoteUpdateOneRequiredWithoutItemsNestedInput
  }

  export type QuoteItemUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    quoteId?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPriceHt?: FloatFieldUpdateOperationsInput | number
    discountRate?: FloatFieldUpdateOperationsInput | number
    vatRate?: FloatFieldUpdateOperationsInput | number
    totalHt?: FloatFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
  }

  export type QuoteItemUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    quoteId?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPriceHt?: FloatFieldUpdateOperationsInput | number
    discountRate?: FloatFieldUpdateOperationsInput | number
    vatRate?: FloatFieldUpdateOperationsInput | number
    totalHt?: FloatFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
  }

  export type InvoiceItemUpdateWithoutProductInput = {
    description?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPriceHt?: FloatFieldUpdateOperationsInput | number
    discountRate?: FloatFieldUpdateOperationsInput | number
    vatRate?: FloatFieldUpdateOperationsInput | number
    totalHt?: FloatFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
    invoice?: InvoiceUpdateOneRequiredWithoutItemsNestedInput
  }

  export type InvoiceItemUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPriceHt?: FloatFieldUpdateOperationsInput | number
    discountRate?: FloatFieldUpdateOperationsInput | number
    vatRate?: FloatFieldUpdateOperationsInput | number
    totalHt?: FloatFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
  }

  export type InvoiceItemUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPriceHt?: FloatFieldUpdateOperationsInput | number
    discountRate?: FloatFieldUpdateOperationsInput | number
    vatRate?: FloatFieldUpdateOperationsInput | number
    totalHt?: FloatFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
  }

  export type RecurringInvoiceItemUpdateWithoutProductInput = {
    description?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPriceHt?: FloatFieldUpdateOperationsInput | number
    vatRate?: FloatFieldUpdateOperationsInput | number
    totalHt?: FloatFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
    recurringInvoice?: RecurringInvoiceUpdateOneRequiredWithoutItemsNestedInput
  }

  export type RecurringInvoiceItemUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    recurringInvoiceId?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPriceHt?: FloatFieldUpdateOperationsInput | number
    vatRate?: FloatFieldUpdateOperationsInput | number
    totalHt?: FloatFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
  }

  export type RecurringInvoiceItemUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    recurringInvoiceId?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPriceHt?: FloatFieldUpdateOperationsInput | number
    vatRate?: FloatFieldUpdateOperationsInput | number
    totalHt?: FloatFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
  }

  export type QuoteItemCreateManyQuoteInput = {
    id?: number
    productId?: number | null
    description: string
    quantity: number
    unitPriceHt: number
    discountRate?: number
    vatRate: number
    totalHt: number
    sortOrder?: number
  }

  export type InvoiceCreateManyQuoteInput = {
    id?: number
    invoiceNumber: string
    customerId: number
    customerAddressId?: number | null
    type?: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    invoiceDate: Date | string
    dueDate: Date | string
    subtotalHt?: number
    discountAmount?: number
    totalVat?: number
    totalTtc?: number
    paidAmount?: number
    balanceDue?: number
    paymentTerms?: number
    lateFeeRate?: number
    terms?: string | null
    notes?: string | null
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt?: Date | string | null
  }

  export type QuoteApprovalCreateManyQuoteInput = {
    id?: number
    approverId: number
    approvalLevel: $Enums.ApprovalLevel
    status?: $Enums.ApprovalStatus
    approvalDate?: Date | string | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuoteItemUpdateWithoutQuoteInput = {
    description?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPriceHt?: FloatFieldUpdateOperationsInput | number
    discountRate?: FloatFieldUpdateOperationsInput | number
    vatRate?: FloatFieldUpdateOperationsInput | number
    totalHt?: FloatFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
    product?: ProductUpdateOneWithoutQuoteItemsNestedInput
  }

  export type QuoteItemUncheckedUpdateWithoutQuoteInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPriceHt?: FloatFieldUpdateOperationsInput | number
    discountRate?: FloatFieldUpdateOperationsInput | number
    vatRate?: FloatFieldUpdateOperationsInput | number
    totalHt?: FloatFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
  }

  export type QuoteItemUncheckedUpdateManyWithoutQuoteInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPriceHt?: FloatFieldUpdateOperationsInput | number
    discountRate?: FloatFieldUpdateOperationsInput | number
    vatRate?: FloatFieldUpdateOperationsInput | number
    totalHt?: FloatFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
  }

  export type InvoiceUpdateWithoutQuoteInput = {
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotalHt?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalVat?: FloatFieldUpdateOperationsInput | number
    totalTtc?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    balanceDue?: FloatFieldUpdateOperationsInput | number
    paymentTerms?: IntFieldUpdateOperationsInput | number
    lateFeeRate?: FloatFieldUpdateOperationsInput | number
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customer?: CustomerUpdateOneRequiredWithoutInvoicesNestedInput
    customerAddress?: CustomerAddressUpdateOneWithoutInvoicesNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedInvoicesNestedInput
    items?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
    paymentAllocations?: PaymentAllocationUpdateManyWithoutInvoiceNestedInput
    reminders?: ReminderUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutQuoteInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    customerId?: IntFieldUpdateOperationsInput | number
    customerAddressId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotalHt?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalVat?: FloatFieldUpdateOperationsInput | number
    totalTtc?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    balanceDue?: FloatFieldUpdateOperationsInput | number
    paymentTerms?: IntFieldUpdateOperationsInput | number
    lateFeeRate?: FloatFieldUpdateOperationsInput | number
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
    paymentAllocations?: PaymentAllocationUncheckedUpdateManyWithoutInvoiceNestedInput
    reminders?: ReminderUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutQuoteInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    customerId?: IntFieldUpdateOperationsInput | number
    customerAddressId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotalHt?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalVat?: FloatFieldUpdateOperationsInput | number
    totalTtc?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    balanceDue?: FloatFieldUpdateOperationsInput | number
    paymentTerms?: IntFieldUpdateOperationsInput | number
    lateFeeRate?: FloatFieldUpdateOperationsInput | number
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuoteApprovalUpdateWithoutQuoteInput = {
    approvalLevel?: EnumApprovalLevelFieldUpdateOperationsInput | $Enums.ApprovalLevel
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approvalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approver?: UserUpdateOneRequiredWithoutQuoteApprovalsNestedInput
  }

  export type QuoteApprovalUncheckedUpdateWithoutQuoteInput = {
    id?: IntFieldUpdateOperationsInput | number
    approverId?: IntFieldUpdateOperationsInput | number
    approvalLevel?: EnumApprovalLevelFieldUpdateOperationsInput | $Enums.ApprovalLevel
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approvalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuoteApprovalUncheckedUpdateManyWithoutQuoteInput = {
    id?: IntFieldUpdateOperationsInput | number
    approverId?: IntFieldUpdateOperationsInput | number
    approvalLevel?: EnumApprovalLevelFieldUpdateOperationsInput | $Enums.ApprovalLevel
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approvalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MissionUpdateWithoutDevisInput = {
    numIntervention?: StringFieldUpdateOperationsInput | string
    natureIntervention?: StringFieldUpdateOperationsInput | string
    objectifDuContrat?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priorite?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: NullableStringFieldUpdateOperationsInput | string | null
    dateSortieFicheIntervention?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: CustomerUpdateOneRequiredWithoutMissionsNestedInput
    interventions?: InterventionUpdateManyWithoutMissionNestedInput
    rapports?: RapportMissionUpdateManyWithoutMissionNestedInput
  }

  export type MissionUncheckedUpdateWithoutDevisInput = {
    numIntervention?: StringFieldUpdateOperationsInput | string
    natureIntervention?: StringFieldUpdateOperationsInput | string
    objectifDuContrat?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priorite?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: NullableStringFieldUpdateOperationsInput | string | null
    dateSortieFicheIntervention?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interventions?: InterventionUncheckedUpdateManyWithoutMissionNestedInput
    rapports?: RapportMissionUncheckedUpdateManyWithoutMissionNestedInput
  }

  export type MissionUncheckedUpdateManyWithoutDevisInput = {
    numIntervention?: StringFieldUpdateOperationsInput | string
    natureIntervention?: StringFieldUpdateOperationsInput | string
    objectifDuContrat?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priorite?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: NullableStringFieldUpdateOperationsInput | string | null
    dateSortieFicheIntervention?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceItemCreateManyInvoiceInput = {
    id?: number
    productId?: number | null
    description: string
    quantity: number
    unitPriceHt: number
    discountRate?: number
    vatRate: number
    totalHt: number
    sortOrder?: number
  }

  export type PaymentAllocationCreateManyInvoiceInput = {
    id?: number
    paymentId: number
    amount: number
    createdAt?: Date | string
  }

  export type ReminderCreateManyInvoiceInput = {
    id?: number
    type: $Enums.ReminderType
    sentDate: Date | string
    dueDate?: Date | string | null
    amountDue: number
    lateFees?: number
    status?: $Enums.ReminderStatus
    emailSubject?: string | null
    emailBody?: string | null
    createdBy: number
    createdAt?: Date | string
  }

  export type InvoiceItemUpdateWithoutInvoiceInput = {
    description?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPriceHt?: FloatFieldUpdateOperationsInput | number
    discountRate?: FloatFieldUpdateOperationsInput | number
    vatRate?: FloatFieldUpdateOperationsInput | number
    totalHt?: FloatFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
    product?: ProductUpdateOneWithoutInvoiceItemsNestedInput
  }

  export type InvoiceItemUncheckedUpdateWithoutInvoiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPriceHt?: FloatFieldUpdateOperationsInput | number
    discountRate?: FloatFieldUpdateOperationsInput | number
    vatRate?: FloatFieldUpdateOperationsInput | number
    totalHt?: FloatFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
  }

  export type InvoiceItemUncheckedUpdateManyWithoutInvoiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPriceHt?: FloatFieldUpdateOperationsInput | number
    discountRate?: FloatFieldUpdateOperationsInput | number
    vatRate?: FloatFieldUpdateOperationsInput | number
    totalHt?: FloatFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
  }

  export type PaymentAllocationUpdateWithoutInvoiceInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payment?: PaymentUpdateOneRequiredWithoutAllocationsNestedInput
  }

  export type PaymentAllocationUncheckedUpdateWithoutInvoiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    paymentId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentAllocationUncheckedUpdateManyWithoutInvoiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    paymentId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReminderUpdateWithoutInvoiceInput = {
    type?: EnumReminderTypeFieldUpdateOperationsInput | $Enums.ReminderType
    sentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amountDue?: FloatFieldUpdateOperationsInput | number
    lateFees?: FloatFieldUpdateOperationsInput | number
    status?: EnumReminderStatusFieldUpdateOperationsInput | $Enums.ReminderStatus
    emailSubject?: NullableStringFieldUpdateOperationsInput | string | null
    emailBody?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedRemindersNestedInput
  }

  export type ReminderUncheckedUpdateWithoutInvoiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumReminderTypeFieldUpdateOperationsInput | $Enums.ReminderType
    sentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amountDue?: FloatFieldUpdateOperationsInput | number
    lateFees?: FloatFieldUpdateOperationsInput | number
    status?: EnumReminderStatusFieldUpdateOperationsInput | $Enums.ReminderStatus
    emailSubject?: NullableStringFieldUpdateOperationsInput | string | null
    emailBody?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReminderUncheckedUpdateManyWithoutInvoiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumReminderTypeFieldUpdateOperationsInput | $Enums.ReminderType
    sentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amountDue?: FloatFieldUpdateOperationsInput | number
    lateFees?: FloatFieldUpdateOperationsInput | number
    status?: EnumReminderStatusFieldUpdateOperationsInput | $Enums.ReminderStatus
    emailSubject?: NullableStringFieldUpdateOperationsInput | string | null
    emailBody?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentAllocationCreateManyPaymentInput = {
    id?: number
    invoiceId: number
    amount: number
    createdAt?: Date | string
  }

  export type PaymentAllocationUpdateWithoutPaymentInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneRequiredWithoutPaymentAllocationsNestedInput
  }

  export type PaymentAllocationUncheckedUpdateWithoutPaymentInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentAllocationUncheckedUpdateManyWithoutPaymentInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecurringInvoiceItemCreateManyRecurringInvoiceInput = {
    id?: number
    productId?: number | null
    description: string
    quantity: number
    unitPriceHt: number
    vatRate: number
    totalHt: number
    sortOrder?: number
  }

  export type RecurringInvoiceItemUpdateWithoutRecurringInvoiceInput = {
    description?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPriceHt?: FloatFieldUpdateOperationsInput | number
    vatRate?: FloatFieldUpdateOperationsInput | number
    totalHt?: FloatFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
    product?: ProductUpdateOneWithoutRecurringInvoiceItemsNestedInput
  }

  export type RecurringInvoiceItemUncheckedUpdateWithoutRecurringInvoiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPriceHt?: FloatFieldUpdateOperationsInput | number
    vatRate?: FloatFieldUpdateOperationsInput | number
    totalHt?: FloatFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
  }

  export type RecurringInvoiceItemUncheckedUpdateManyWithoutRecurringInvoiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPriceHt?: FloatFieldUpdateOperationsInput | number
    vatRate?: FloatFieldUpdateOperationsInput | number
    totalHt?: FloatFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
  }

  export type ExpenseCreateManySupplierInput = {
    id?: number
    expenseNumber: string
    category: string
    description?: string | null
    amountHt: number
    vatAmount?: number
    totalTtc: number
    expenseDate: Date | string
    paymentDate?: Date | string | null
    paymentMethod?: $Enums.PaymentMethod
    status?: $Enums.ExpenseStatus
    receiptUrl?: string | null
    notes?: string | null
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseUpdateWithoutSupplierInput = {
    expenseNumber?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amountHt?: FloatFieldUpdateOperationsInput | number
    vatAmount?: FloatFieldUpdateOperationsInput | number
    totalTtc?: FloatFieldUpdateOperationsInput | number
    expenseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumExpenseStatusFieldUpdateOperationsInput | $Enums.ExpenseStatus
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedExpensesNestedInput
  }

  export type ExpenseUncheckedUpdateWithoutSupplierInput = {
    id?: IntFieldUpdateOperationsInput | number
    expenseNumber?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amountHt?: FloatFieldUpdateOperationsInput | number
    vatAmount?: FloatFieldUpdateOperationsInput | number
    totalTtc?: FloatFieldUpdateOperationsInput | number
    expenseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumExpenseStatusFieldUpdateOperationsInput | $Enums.ExpenseStatus
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseUncheckedUpdateManyWithoutSupplierInput = {
    id?: IntFieldUpdateOperationsInput | number
    expenseNumber?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amountHt?: FloatFieldUpdateOperationsInput | number
    vatAmount?: FloatFieldUpdateOperationsInput | number
    totalTtc?: FloatFieldUpdateOperationsInput | number
    expenseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumExpenseStatusFieldUpdateOperationsInput | $Enums.ExpenseStatus
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractCreateManyEmployeeInput = {
    id?: number
    contractType: $Enums.ContractType
    startDate: Date | string
    endDate?: Date | string | null
    baseSalary: number
    workingHours: number
    benefits?: string | null
    terms?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalaryCreateManyEmployeeInput = {
    id?: number
    paymentDate: Date | string
    workingDays?: number
    baseSalary: number
    overtime?: number
    bonuses?: number
    allowances?: number
    paidLeave?: number
    grossSalary: number
    socialContributions?: number
    cnpsEmployee?: number
    cnamEmployee?: number
    fdfpEmployee?: number
    taxes?: number
    nonTaxableAmount?: number
    otherDeductions?: number
    loanDeductions?: number
    totalDeductions: number
    netSalary: number
    status?: $Enums.SalaryStatus
    paymentMethod?: $Enums.PaymentMethod | null
    reference?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type LeaveRequestCreateManyEmployeeInput = {
    id?: number
    leaveType: $Enums.LeaveType
    startDate: Date | string
    endDate: Date | string
    days: number
    reason: string
    notes?: string | null
    status?: $Enums.LeaveStatus
    approvedById?: number | null
    approvedAt?: Date | string | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LoanCreateManyEmployeeInput = {
    id?: number
    loanNumber: string
    amount: number
    interestRate?: number
    monthlyPayment: number
    remainingAmount: number
    startDate: Date | string
    endDate: Date | string
    purpose?: string | null
    status?: $Enums.LoanStatus
    notes?: string | null
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContractUpdateWithoutEmployeeInput = {
    contractType?: EnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    baseSalary?: FloatFieldUpdateOperationsInput | number
    workingHours?: FloatFieldUpdateOperationsInput | number
    benefits?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractUncheckedUpdateWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    contractType?: EnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    baseSalary?: FloatFieldUpdateOperationsInput | number
    workingHours?: FloatFieldUpdateOperationsInput | number
    benefits?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractUncheckedUpdateManyWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    contractType?: EnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    baseSalary?: FloatFieldUpdateOperationsInput | number
    workingHours?: FloatFieldUpdateOperationsInput | number
    benefits?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryUpdateWithoutEmployeeInput = {
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    workingDays?: IntFieldUpdateOperationsInput | number
    baseSalary?: FloatFieldUpdateOperationsInput | number
    overtime?: FloatFieldUpdateOperationsInput | number
    bonuses?: FloatFieldUpdateOperationsInput | number
    allowances?: FloatFieldUpdateOperationsInput | number
    paidLeave?: FloatFieldUpdateOperationsInput | number
    grossSalary?: FloatFieldUpdateOperationsInput | number
    socialContributions?: FloatFieldUpdateOperationsInput | number
    cnpsEmployee?: FloatFieldUpdateOperationsInput | number
    cnamEmployee?: FloatFieldUpdateOperationsInput | number
    fdfpEmployee?: FloatFieldUpdateOperationsInput | number
    taxes?: FloatFieldUpdateOperationsInput | number
    nonTaxableAmount?: FloatFieldUpdateOperationsInput | number
    otherDeductions?: FloatFieldUpdateOperationsInput | number
    loanDeductions?: FloatFieldUpdateOperationsInput | number
    totalDeductions?: FloatFieldUpdateOperationsInput | number
    netSalary?: FloatFieldUpdateOperationsInput | number
    status?: EnumSalaryStatusFieldUpdateOperationsInput | $Enums.SalaryStatus
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loanPayments?: LoanPaymentUpdateManyWithoutSalaryNestedInput
  }

  export type SalaryUncheckedUpdateWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    workingDays?: IntFieldUpdateOperationsInput | number
    baseSalary?: FloatFieldUpdateOperationsInput | number
    overtime?: FloatFieldUpdateOperationsInput | number
    bonuses?: FloatFieldUpdateOperationsInput | number
    allowances?: FloatFieldUpdateOperationsInput | number
    paidLeave?: FloatFieldUpdateOperationsInput | number
    grossSalary?: FloatFieldUpdateOperationsInput | number
    socialContributions?: FloatFieldUpdateOperationsInput | number
    cnpsEmployee?: FloatFieldUpdateOperationsInput | number
    cnamEmployee?: FloatFieldUpdateOperationsInput | number
    fdfpEmployee?: FloatFieldUpdateOperationsInput | number
    taxes?: FloatFieldUpdateOperationsInput | number
    nonTaxableAmount?: FloatFieldUpdateOperationsInput | number
    otherDeductions?: FloatFieldUpdateOperationsInput | number
    loanDeductions?: FloatFieldUpdateOperationsInput | number
    totalDeductions?: FloatFieldUpdateOperationsInput | number
    netSalary?: FloatFieldUpdateOperationsInput | number
    status?: EnumSalaryStatusFieldUpdateOperationsInput | $Enums.SalaryStatus
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loanPayments?: LoanPaymentUncheckedUpdateManyWithoutSalaryNestedInput
  }

  export type SalaryUncheckedUpdateManyWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    workingDays?: IntFieldUpdateOperationsInput | number
    baseSalary?: FloatFieldUpdateOperationsInput | number
    overtime?: FloatFieldUpdateOperationsInput | number
    bonuses?: FloatFieldUpdateOperationsInput | number
    allowances?: FloatFieldUpdateOperationsInput | number
    paidLeave?: FloatFieldUpdateOperationsInput | number
    grossSalary?: FloatFieldUpdateOperationsInput | number
    socialContributions?: FloatFieldUpdateOperationsInput | number
    cnpsEmployee?: FloatFieldUpdateOperationsInput | number
    cnamEmployee?: FloatFieldUpdateOperationsInput | number
    fdfpEmployee?: FloatFieldUpdateOperationsInput | number
    taxes?: FloatFieldUpdateOperationsInput | number
    nonTaxableAmount?: FloatFieldUpdateOperationsInput | number
    otherDeductions?: FloatFieldUpdateOperationsInput | number
    loanDeductions?: FloatFieldUpdateOperationsInput | number
    totalDeductions?: FloatFieldUpdateOperationsInput | number
    netSalary?: FloatFieldUpdateOperationsInput | number
    status?: EnumSalaryStatusFieldUpdateOperationsInput | $Enums.SalaryStatus
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveRequestUpdateWithoutEmployeeInput = {
    leaveType?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    days?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedBy?: UserUpdateOneWithoutLeaveApprovalsNestedInput
  }

  export type LeaveRequestUncheckedUpdateWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    leaveType?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    days?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveRequestUncheckedUpdateManyWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    leaveType?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    days?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoanUpdateWithoutEmployeeInput = {
    loanNumber?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    interestRate?: FloatFieldUpdateOperationsInput | number
    monthlyPayment?: FloatFieldUpdateOperationsInput | number
    remainingAmount?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLoanStatusFieldUpdateOperationsInput | $Enums.LoanStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: LoanPaymentUpdateManyWithoutLoanNestedInput
  }

  export type LoanUncheckedUpdateWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    loanNumber?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    interestRate?: FloatFieldUpdateOperationsInput | number
    monthlyPayment?: FloatFieldUpdateOperationsInput | number
    remainingAmount?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLoanStatusFieldUpdateOperationsInput | $Enums.LoanStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: LoanPaymentUncheckedUpdateManyWithoutLoanNestedInput
  }

  export type LoanUncheckedUpdateManyWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    loanNumber?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    interestRate?: FloatFieldUpdateOperationsInput | number
    monthlyPayment?: FloatFieldUpdateOperationsInput | number
    remainingAmount?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLoanStatusFieldUpdateOperationsInput | $Enums.LoanStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoanPaymentCreateManySalaryInput = {
    id?: number
    loanId: number
    amount: number
    paymentDate: Date | string
    principal: number
    interest: number
    notes?: string | null
    createdAt?: Date | string
  }

  export type LoanPaymentUpdateWithoutSalaryInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    principal?: FloatFieldUpdateOperationsInput | number
    interest?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loan?: LoanUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type LoanPaymentUncheckedUpdateWithoutSalaryInput = {
    id?: IntFieldUpdateOperationsInput | number
    loanId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    principal?: FloatFieldUpdateOperationsInput | number
    interest?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoanPaymentUncheckedUpdateManyWithoutSalaryInput = {
    id?: IntFieldUpdateOperationsInput | number
    loanId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    principal?: FloatFieldUpdateOperationsInput | number
    interest?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProspectActivityCreateManyProspectInput = {
    id?: number
    type: string
    subject?: string | null
    description?: string | null
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    outcome?: string | null
    nextAction?: string | null
    createdBy: number
    createdAt?: Date | string
  }

  export type ProspectActivityUpdateWithoutProspectInput = {
    type?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    nextAction?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedProspectActivitiesNestedInput
  }

  export type ProspectActivityUncheckedUpdateWithoutProspectInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    nextAction?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProspectActivityUncheckedUpdateManyWithoutProspectInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    nextAction?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoanPaymentCreateManyLoanInput = {
    id?: number
    salaryId?: number | null
    amount: number
    paymentDate: Date | string
    principal: number
    interest: number
    notes?: string | null
    createdAt?: Date | string
  }

  export type LoanPaymentUpdateWithoutLoanInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    principal?: FloatFieldUpdateOperationsInput | number
    interest?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salary?: SalaryUpdateOneWithoutLoanPaymentsNestedInput
  }

  export type LoanPaymentUncheckedUpdateWithoutLoanInput = {
    id?: IntFieldUpdateOperationsInput | number
    salaryId?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    principal?: FloatFieldUpdateOperationsInput | number
    interest?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoanPaymentUncheckedUpdateManyWithoutLoanInput = {
    id?: IntFieldUpdateOperationsInput | number
    salaryId?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    principal?: FloatFieldUpdateOperationsInput | number
    interest?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TechnicienCreateManySpecialiteInput = {
    id?: number
    nom: string
    prenom: string
    contact: string
    utilisateurId?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TechnicienUpdateWithoutSpecialiteInput = {
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    utilisateur?: UserUpdateOneWithoutTechnicienNestedInput
    interventions?: TechnicienInterventionUpdateManyWithoutTechnicienNestedInput
    rapports?: RapportMissionUpdateManyWithoutTechnicienNestedInput
    sortiesMateriels?: SortieMaterielUpdateManyWithoutTechnicienNestedInput
  }

  export type TechnicienUncheckedUpdateWithoutSpecialiteInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    utilisateurId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interventions?: TechnicienInterventionUncheckedUpdateManyWithoutTechnicienNestedInput
    rapports?: RapportMissionUncheckedUpdateManyWithoutTechnicienNestedInput
    sortiesMateriels?: SortieMaterielUncheckedUpdateManyWithoutTechnicienNestedInput
  }

  export type TechnicienUncheckedUpdateManyWithoutSpecialiteInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    utilisateurId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TechnicienInterventionCreateManyTechnicienInput = {
    id?: number
    interventionId: number
    role?: string
    commentaire?: string | null
    createdAt?: Date | string
  }

  export type RapportMissionCreateManyTechnicienInput = {
    id?: number
    titre: string
    contenu: string
    interventionId?: number | null
    missionId: string
    createdById?: number | null
    statut?: string
    dateValidation?: Date | string | null
    commentaire?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SortieMaterielCreateManyTechnicienInput = {
    id?: number
    materielId: number
    interventionId: number
    quantite: number
    dateSortie?: Date | string
    motif?: string | null
    retourne?: boolean
    dateRetour?: Date | string | null
    quantiteRetour?: number | null
    commentaire?: string | null
    createdAt?: Date | string
  }

  export type TechnicienInterventionUpdateWithoutTechnicienInput = {
    role?: StringFieldUpdateOperationsInput | string
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intervention?: InterventionUpdateOneRequiredWithoutTechniciensNestedInput
  }

  export type TechnicienInterventionUncheckedUpdateWithoutTechnicienInput = {
    id?: IntFieldUpdateOperationsInput | number
    interventionId?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TechnicienInterventionUncheckedUpdateManyWithoutTechnicienInput = {
    id?: IntFieldUpdateOperationsInput | number
    interventionId?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RapportMissionUpdateWithoutTechnicienInput = {
    titre?: StringFieldUpdateOperationsInput | string
    contenu?: StringFieldUpdateOperationsInput | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    statut?: StringFieldUpdateOperationsInput | string
    dateValidation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intervention?: InterventionUpdateOneWithoutRapportsNestedInput
    mission?: MissionUpdateOneRequiredWithoutRapportsNestedInput
    images?: RapportImageUpdateManyWithoutRapportNestedInput
  }

  export type RapportMissionUncheckedUpdateWithoutTechnicienInput = {
    id?: IntFieldUpdateOperationsInput | number
    titre?: StringFieldUpdateOperationsInput | string
    contenu?: StringFieldUpdateOperationsInput | string
    interventionId?: NullableIntFieldUpdateOperationsInput | number | null
    missionId?: StringFieldUpdateOperationsInput | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    statut?: StringFieldUpdateOperationsInput | string
    dateValidation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: RapportImageUncheckedUpdateManyWithoutRapportNestedInput
  }

  export type RapportMissionUncheckedUpdateManyWithoutTechnicienInput = {
    id?: IntFieldUpdateOperationsInput | number
    titre?: StringFieldUpdateOperationsInput | string
    contenu?: StringFieldUpdateOperationsInput | string
    interventionId?: NullableIntFieldUpdateOperationsInput | number | null
    missionId?: StringFieldUpdateOperationsInput | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    statut?: StringFieldUpdateOperationsInput | string
    dateValidation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SortieMaterielUpdateWithoutTechnicienInput = {
    quantite?: IntFieldUpdateOperationsInput | number
    dateSortie?: DateTimeFieldUpdateOperationsInput | Date | string
    motif?: NullableStringFieldUpdateOperationsInput | string | null
    retourne?: BoolFieldUpdateOperationsInput | boolean
    dateRetour?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantiteRetour?: NullableIntFieldUpdateOperationsInput | number | null
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    materiel?: MaterielUpdateOneRequiredWithoutSortiesNestedInput
    intervention?: InterventionUpdateOneRequiredWithoutSortiesMaterielsNestedInput
  }

  export type SortieMaterielUncheckedUpdateWithoutTechnicienInput = {
    id?: IntFieldUpdateOperationsInput | number
    materielId?: IntFieldUpdateOperationsInput | number
    interventionId?: IntFieldUpdateOperationsInput | number
    quantite?: IntFieldUpdateOperationsInput | number
    dateSortie?: DateTimeFieldUpdateOperationsInput | Date | string
    motif?: NullableStringFieldUpdateOperationsInput | string | null
    retourne?: BoolFieldUpdateOperationsInput | boolean
    dateRetour?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantiteRetour?: NullableIntFieldUpdateOperationsInput | number | null
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SortieMaterielUncheckedUpdateManyWithoutTechnicienInput = {
    id?: IntFieldUpdateOperationsInput | number
    materielId?: IntFieldUpdateOperationsInput | number
    interventionId?: IntFieldUpdateOperationsInput | number
    quantite?: IntFieldUpdateOperationsInput | number
    dateSortie?: DateTimeFieldUpdateOperationsInput | Date | string
    motif?: NullableStringFieldUpdateOperationsInput | string | null
    retourne?: BoolFieldUpdateOperationsInput | boolean
    dateRetour?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantiteRetour?: NullableIntFieldUpdateOperationsInput | number | null
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterventionCreateManyMissionInput = {
    id?: number
    dateHeureDebut: Date | string
    dateHeureFin?: Date | string | null
    duree?: number | null
    statut?: string
    commentaire?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RapportMissionCreateManyMissionInput = {
    id?: number
    titre: string
    contenu: string
    interventionId?: number | null
    technicienId: number
    createdById?: number | null
    statut?: string
    dateValidation?: Date | string | null
    commentaire?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InterventionUpdateWithoutMissionInput = {
    dateHeureDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateHeureFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duree?: NullableIntFieldUpdateOperationsInput | number | null
    statut?: StringFieldUpdateOperationsInput | string
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    techniciens?: TechnicienInterventionUpdateManyWithoutInterventionNestedInput
    rapports?: RapportMissionUpdateManyWithoutInterventionNestedInput
    sortiesMateriels?: SortieMaterielUpdateManyWithoutInterventionNestedInput
  }

  export type InterventionUncheckedUpdateWithoutMissionInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateHeureDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateHeureFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duree?: NullableIntFieldUpdateOperationsInput | number | null
    statut?: StringFieldUpdateOperationsInput | string
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    techniciens?: TechnicienInterventionUncheckedUpdateManyWithoutInterventionNestedInput
    rapports?: RapportMissionUncheckedUpdateManyWithoutInterventionNestedInput
    sortiesMateriels?: SortieMaterielUncheckedUpdateManyWithoutInterventionNestedInput
  }

  export type InterventionUncheckedUpdateManyWithoutMissionInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateHeureDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateHeureFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duree?: NullableIntFieldUpdateOperationsInput | number | null
    statut?: StringFieldUpdateOperationsInput | string
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RapportMissionUpdateWithoutMissionInput = {
    titre?: StringFieldUpdateOperationsInput | string
    contenu?: StringFieldUpdateOperationsInput | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    statut?: StringFieldUpdateOperationsInput | string
    dateValidation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intervention?: InterventionUpdateOneWithoutRapportsNestedInput
    technicien?: TechnicienUpdateOneRequiredWithoutRapportsNestedInput
    images?: RapportImageUpdateManyWithoutRapportNestedInput
  }

  export type RapportMissionUncheckedUpdateWithoutMissionInput = {
    id?: IntFieldUpdateOperationsInput | number
    titre?: StringFieldUpdateOperationsInput | string
    contenu?: StringFieldUpdateOperationsInput | string
    interventionId?: NullableIntFieldUpdateOperationsInput | number | null
    technicienId?: IntFieldUpdateOperationsInput | number
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    statut?: StringFieldUpdateOperationsInput | string
    dateValidation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: RapportImageUncheckedUpdateManyWithoutRapportNestedInput
  }

  export type RapportMissionUncheckedUpdateManyWithoutMissionInput = {
    id?: IntFieldUpdateOperationsInput | number
    titre?: StringFieldUpdateOperationsInput | string
    contenu?: StringFieldUpdateOperationsInput | string
    interventionId?: NullableIntFieldUpdateOperationsInput | number | null
    technicienId?: IntFieldUpdateOperationsInput | number
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    statut?: StringFieldUpdateOperationsInput | string
    dateValidation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuoteUpdateWithoutMissionsInput = {
    quoteNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    quoteDate?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotalHt?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalVat?: FloatFieldUpdateOperationsInput | number
    totalTtc?: FloatFieldUpdateOperationsInput | number
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedForServiceApprovalAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceManagerApprovalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceManagerComments?: NullableStringFieldUpdateOperationsInput | string | null
    dgApprovalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dgComments?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customer?: CustomerUpdateOneRequiredWithoutQuotesNestedInput
    customerAddress?: CustomerAddressUpdateOneWithoutQuotesNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedQuotesNestedInput
    serviceManager?: UserUpdateOneWithoutServiceApprovalsNestedInput
    dgApprover?: UserUpdateOneWithoutDgApprovalsNestedInput
    items?: QuoteItemUpdateManyWithoutQuoteNestedInput
    invoices?: InvoiceUpdateManyWithoutQuoteNestedInput
    approvals?: QuoteApprovalUpdateManyWithoutQuoteNestedInput
  }

  export type QuoteUncheckedUpdateWithoutMissionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    quoteNumber?: StringFieldUpdateOperationsInput | string
    customerId?: IntFieldUpdateOperationsInput | number
    customerAddressId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    quoteDate?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotalHt?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalVat?: FloatFieldUpdateOperationsInput | number
    totalTtc?: FloatFieldUpdateOperationsInput | number
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedForServiceApprovalAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceManagerApprovedBy?: NullableIntFieldUpdateOperationsInput | number | null
    serviceManagerApprovalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceManagerComments?: NullableStringFieldUpdateOperationsInput | string | null
    dgApprovedBy?: NullableIntFieldUpdateOperationsInput | number | null
    dgApprovalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dgComments?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: QuoteItemUncheckedUpdateManyWithoutQuoteNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutQuoteNestedInput
    approvals?: QuoteApprovalUncheckedUpdateManyWithoutQuoteNestedInput
  }

  export type QuoteUncheckedUpdateManyWithoutMissionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    quoteNumber?: StringFieldUpdateOperationsInput | string
    customerId?: IntFieldUpdateOperationsInput | number
    customerAddressId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    quoteDate?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotalHt?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalVat?: FloatFieldUpdateOperationsInput | number
    totalTtc?: FloatFieldUpdateOperationsInput | number
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedForServiceApprovalAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceManagerApprovedBy?: NullableIntFieldUpdateOperationsInput | number | null
    serviceManagerApprovalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceManagerComments?: NullableStringFieldUpdateOperationsInput | string | null
    dgApprovedBy?: NullableIntFieldUpdateOperationsInput | number | null
    dgApprovalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dgComments?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TechnicienInterventionCreateManyInterventionInput = {
    id?: number
    technicienId: number
    role?: string
    commentaire?: string | null
    createdAt?: Date | string
  }

  export type RapportMissionCreateManyInterventionInput = {
    id?: number
    titre: string
    contenu: string
    technicienId: number
    missionId: string
    createdById?: number | null
    statut?: string
    dateValidation?: Date | string | null
    commentaire?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SortieMaterielCreateManyInterventionInput = {
    id?: number
    materielId: number
    technicienId: number
    quantite: number
    dateSortie?: Date | string
    motif?: string | null
    retourne?: boolean
    dateRetour?: Date | string | null
    quantiteRetour?: number | null
    commentaire?: string | null
    createdAt?: Date | string
  }

  export type TechnicienInterventionUpdateWithoutInterventionInput = {
    role?: StringFieldUpdateOperationsInput | string
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    technicien?: TechnicienUpdateOneRequiredWithoutInterventionsNestedInput
  }

  export type TechnicienInterventionUncheckedUpdateWithoutInterventionInput = {
    id?: IntFieldUpdateOperationsInput | number
    technicienId?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TechnicienInterventionUncheckedUpdateManyWithoutInterventionInput = {
    id?: IntFieldUpdateOperationsInput | number
    technicienId?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RapportMissionUpdateWithoutInterventionInput = {
    titre?: StringFieldUpdateOperationsInput | string
    contenu?: StringFieldUpdateOperationsInput | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    statut?: StringFieldUpdateOperationsInput | string
    dateValidation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    technicien?: TechnicienUpdateOneRequiredWithoutRapportsNestedInput
    mission?: MissionUpdateOneRequiredWithoutRapportsNestedInput
    images?: RapportImageUpdateManyWithoutRapportNestedInput
  }

  export type RapportMissionUncheckedUpdateWithoutInterventionInput = {
    id?: IntFieldUpdateOperationsInput | number
    titre?: StringFieldUpdateOperationsInput | string
    contenu?: StringFieldUpdateOperationsInput | string
    technicienId?: IntFieldUpdateOperationsInput | number
    missionId?: StringFieldUpdateOperationsInput | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    statut?: StringFieldUpdateOperationsInput | string
    dateValidation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: RapportImageUncheckedUpdateManyWithoutRapportNestedInput
  }

  export type RapportMissionUncheckedUpdateManyWithoutInterventionInput = {
    id?: IntFieldUpdateOperationsInput | number
    titre?: StringFieldUpdateOperationsInput | string
    contenu?: StringFieldUpdateOperationsInput | string
    technicienId?: IntFieldUpdateOperationsInput | number
    missionId?: StringFieldUpdateOperationsInput | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    statut?: StringFieldUpdateOperationsInput | string
    dateValidation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SortieMaterielUpdateWithoutInterventionInput = {
    quantite?: IntFieldUpdateOperationsInput | number
    dateSortie?: DateTimeFieldUpdateOperationsInput | Date | string
    motif?: NullableStringFieldUpdateOperationsInput | string | null
    retourne?: BoolFieldUpdateOperationsInput | boolean
    dateRetour?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantiteRetour?: NullableIntFieldUpdateOperationsInput | number | null
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    materiel?: MaterielUpdateOneRequiredWithoutSortiesNestedInput
    technicien?: TechnicienUpdateOneRequiredWithoutSortiesMaterielsNestedInput
  }

  export type SortieMaterielUncheckedUpdateWithoutInterventionInput = {
    id?: IntFieldUpdateOperationsInput | number
    materielId?: IntFieldUpdateOperationsInput | number
    technicienId?: IntFieldUpdateOperationsInput | number
    quantite?: IntFieldUpdateOperationsInput | number
    dateSortie?: DateTimeFieldUpdateOperationsInput | Date | string
    motif?: NullableStringFieldUpdateOperationsInput | string | null
    retourne?: BoolFieldUpdateOperationsInput | boolean
    dateRetour?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantiteRetour?: NullableIntFieldUpdateOperationsInput | number | null
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SortieMaterielUncheckedUpdateManyWithoutInterventionInput = {
    id?: IntFieldUpdateOperationsInput | number
    materielId?: IntFieldUpdateOperationsInput | number
    technicienId?: IntFieldUpdateOperationsInput | number
    quantite?: IntFieldUpdateOperationsInput | number
    dateSortie?: DateTimeFieldUpdateOperationsInput | Date | string
    motif?: NullableStringFieldUpdateOperationsInput | string | null
    retourne?: BoolFieldUpdateOperationsInput | boolean
    dateRetour?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantiteRetour?: NullableIntFieldUpdateOperationsInput | number | null
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RapportImageCreateManyRapportInput = {
    id?: number
    url: string
    description?: string | null
    ordre: number
    createdAt?: Date | string
  }

  export type RapportImageUpdateWithoutRapportInput = {
    url?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ordre?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RapportImageUncheckedUpdateWithoutRapportInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ordre?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RapportImageUncheckedUpdateManyWithoutRapportInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ordre?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SortieMaterielCreateManyMaterielInput = {
    id?: number
    interventionId: number
    technicienId: number
    quantite: number
    dateSortie?: Date | string
    motif?: string | null
    retourne?: boolean
    dateRetour?: Date | string | null
    quantiteRetour?: number | null
    commentaire?: string | null
    createdAt?: Date | string
  }

  export type EntreeMaterielCreateManyMaterielInput = {
    id?: number
    quantite: number
    dateEntree?: Date | string
    source?: string
    prixTotal?: number | null
    fournisseur?: string | null
    facture?: string | null
    commentaire?: string | null
    createdAt?: Date | string
  }

  export type SortieMaterielUpdateWithoutMaterielInput = {
    quantite?: IntFieldUpdateOperationsInput | number
    dateSortie?: DateTimeFieldUpdateOperationsInput | Date | string
    motif?: NullableStringFieldUpdateOperationsInput | string | null
    retourne?: BoolFieldUpdateOperationsInput | boolean
    dateRetour?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantiteRetour?: NullableIntFieldUpdateOperationsInput | number | null
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intervention?: InterventionUpdateOneRequiredWithoutSortiesMaterielsNestedInput
    technicien?: TechnicienUpdateOneRequiredWithoutSortiesMaterielsNestedInput
  }

  export type SortieMaterielUncheckedUpdateWithoutMaterielInput = {
    id?: IntFieldUpdateOperationsInput | number
    interventionId?: IntFieldUpdateOperationsInput | number
    technicienId?: IntFieldUpdateOperationsInput | number
    quantite?: IntFieldUpdateOperationsInput | number
    dateSortie?: DateTimeFieldUpdateOperationsInput | Date | string
    motif?: NullableStringFieldUpdateOperationsInput | string | null
    retourne?: BoolFieldUpdateOperationsInput | boolean
    dateRetour?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantiteRetour?: NullableIntFieldUpdateOperationsInput | number | null
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SortieMaterielUncheckedUpdateManyWithoutMaterielInput = {
    id?: IntFieldUpdateOperationsInput | number
    interventionId?: IntFieldUpdateOperationsInput | number
    technicienId?: IntFieldUpdateOperationsInput | number
    quantite?: IntFieldUpdateOperationsInput | number
    dateSortie?: DateTimeFieldUpdateOperationsInput | Date | string
    motif?: NullableStringFieldUpdateOperationsInput | string | null
    retourne?: BoolFieldUpdateOperationsInput | boolean
    dateRetour?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantiteRetour?: NullableIntFieldUpdateOperationsInput | number | null
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EntreeMaterielUpdateWithoutMaterielInput = {
    quantite?: IntFieldUpdateOperationsInput | number
    dateEntree?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: StringFieldUpdateOperationsInput | string
    prixTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    fournisseur?: NullableStringFieldUpdateOperationsInput | string | null
    facture?: NullableStringFieldUpdateOperationsInput | string | null
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EntreeMaterielUncheckedUpdateWithoutMaterielInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantite?: IntFieldUpdateOperationsInput | number
    dateEntree?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: StringFieldUpdateOperationsInput | string
    prixTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    fournisseur?: NullableStringFieldUpdateOperationsInput | string | null
    facture?: NullableStringFieldUpdateOperationsInput | string | null
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EntreeMaterielUncheckedUpdateManyWithoutMaterielInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantite?: IntFieldUpdateOperationsInput | number
    dateEntree?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: StringFieldUpdateOperationsInput | string
    prixTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    fournisseur?: NullableStringFieldUpdateOperationsInput | string | null
    facture?: NullableStringFieldUpdateOperationsInput | string | null
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use ServiceCountOutputTypeDefaultArgs instead
     */
    export type ServiceCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServiceCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CustomerCountOutputTypeDefaultArgs instead
     */
    export type CustomerCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CustomerCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CustomerAddressCountOutputTypeDefaultArgs instead
     */
    export type CustomerAddressCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CustomerAddressCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductCountOutputTypeDefaultArgs instead
     */
    export type ProductCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QuoteCountOutputTypeDefaultArgs instead
     */
    export type QuoteCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QuoteCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InvoiceCountOutputTypeDefaultArgs instead
     */
    export type InvoiceCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InvoiceCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PaymentCountOutputTypeDefaultArgs instead
     */
    export type PaymentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PaymentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RecurringInvoiceCountOutputTypeDefaultArgs instead
     */
    export type RecurringInvoiceCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RecurringInvoiceCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SupplierCountOutputTypeDefaultArgs instead
     */
    export type SupplierCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SupplierCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmployeeCountOutputTypeDefaultArgs instead
     */
    export type EmployeeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmployeeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SalaryCountOutputTypeDefaultArgs instead
     */
    export type SalaryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SalaryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProspectCountOutputTypeDefaultArgs instead
     */
    export type ProspectCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProspectCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LoanCountOutputTypeDefaultArgs instead
     */
    export type LoanCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LoanCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SpecialiteCountOutputTypeDefaultArgs instead
     */
    export type SpecialiteCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SpecialiteCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TechnicienCountOutputTypeDefaultArgs instead
     */
    export type TechnicienCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TechnicienCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MissionCountOutputTypeDefaultArgs instead
     */
    export type MissionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MissionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InterventionCountOutputTypeDefaultArgs instead
     */
    export type InterventionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InterventionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RapportMissionCountOutputTypeDefaultArgs instead
     */
    export type RapportMissionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RapportMissionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MaterielCountOutputTypeDefaultArgs instead
     */
    export type MaterielCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MaterielCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServiceDefaultArgs instead
     */
    export type ServiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServiceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CustomerDefaultArgs instead
     */
    export type CustomerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CustomerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CustomerAddressDefaultArgs instead
     */
    export type CustomerAddressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CustomerAddressDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductDefaultArgs instead
     */
    export type ProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductPriceDefaultArgs instead
     */
    export type ProductPriceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductPriceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QuoteDefaultArgs instead
     */
    export type QuoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QuoteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QuoteItemDefaultArgs instead
     */
    export type QuoteItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QuoteItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QuoteApprovalDefaultArgs instead
     */
    export type QuoteApprovalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QuoteApprovalDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InvoiceDefaultArgs instead
     */
    export type InvoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InvoiceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InvoiceItemDefaultArgs instead
     */
    export type InvoiceItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InvoiceItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PaymentDefaultArgs instead
     */
    export type PaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PaymentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PaymentAllocationDefaultArgs instead
     */
    export type PaymentAllocationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PaymentAllocationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RecurringInvoiceDefaultArgs instead
     */
    export type RecurringInvoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RecurringInvoiceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RecurringInvoiceItemDefaultArgs instead
     */
    export type RecurringInvoiceItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RecurringInvoiceItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReminderDefaultArgs instead
     */
    export type ReminderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReminderDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DocumentDefaultArgs instead
     */
    export type DocumentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DocumentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExpenseDefaultArgs instead
     */
    export type ExpenseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExpenseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SupplierDefaultArgs instead
     */
    export type SupplierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SupplierDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AccountingEntryDefaultArgs instead
     */
    export type AccountingEntryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AccountingEntryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CashFlowDefaultArgs instead
     */
    export type CashFlowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CashFlowDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuditLogDefaultArgs instead
     */
    export type AuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuditLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmployeeDefaultArgs instead
     */
    export type EmployeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmployeeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContractDefaultArgs instead
     */
    export type ContractArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContractDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SalaryDefaultArgs instead
     */
    export type SalaryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SalaryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LoanPaymentDefaultArgs instead
     */
    export type LoanPaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LoanPaymentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LeaveRequestDefaultArgs instead
     */
    export type LeaveRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LeaveRequestDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProspectDefaultArgs instead
     */
    export type ProspectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProspectDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProspectActivityDefaultArgs instead
     */
    export type ProspectActivityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProspectActivityDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LoanDefaultArgs instead
     */
    export type LoanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LoanDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SpecialiteDefaultArgs instead
     */
    export type SpecialiteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SpecialiteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TechnicienDefaultArgs instead
     */
    export type TechnicienArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TechnicienDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MissionDefaultArgs instead
     */
    export type MissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MissionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InterventionDefaultArgs instead
     */
    export type InterventionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InterventionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TechnicienInterventionDefaultArgs instead
     */
    export type TechnicienInterventionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TechnicienInterventionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RapportMissionDefaultArgs instead
     */
    export type RapportMissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RapportMissionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RapportImageDefaultArgs instead
     */
    export type RapportImageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RapportImageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MaterielDefaultArgs instead
     */
    export type MaterielArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MaterielDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SortieMaterielDefaultArgs instead
     */
    export type SortieMaterielArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SortieMaterielDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EntreeMaterielDefaultArgs instead
     */
    export type EntreeMaterielArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EntreeMaterielDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationDefaultArgs instead
     */
    export type NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}